{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MzI5MTIw", "number": 4466, "title": "Refactor Atomix", "bodyText": "Description\nIn order to fix an BUG (#4439) and test it properly we had to migrate our ZeebeStateMachine to atomix.\nThis bring a bunch of other problems and issues, which resulted in a bigger refactoring which was already due. Sorry to the reviewers.\nThis PR does the following:\n\nMigrates  the ZeebeStateMachine to atomix, which means the old is replaced, which was only used in RaftTests\nMoves everything what is snapshot related to atomix and some parts to the broker. This merging makes it now easier to merge the snapshot replication stuff (#4424) and removes the parts from the LogStream. The engine doesn't know anymore about snapshoting, since it doesn't need to.\nRemoves everything primitive and session related. This was a big dead part of the code base, which made the code much complexer as it needed to be.\nIterate over the RaftTests.\n\nAdds new tests which relies on the actual log and replication. The test verifies that entries are commited and written to the log. The Ordering of the entries is also taken into account. Not all tests are migrated, but at least adjusted that they no longer rely on sessions.\nRemove some tests which doesn't make sense anymore or need to be rewritten.\nMigrate one test testNodeCatchUpAfterCompaction, which is currently on ignore because it seem to fail. We need to investigate that #4467\nRemove snapshot tests from the Raft module, which where not easy to migrate. It was for now easier to just remove them. We need to investigate if it makes sense to write new in the raft module or maybe in other modules like IT or Broker. Maybe we already have enough, this needs to be investigated. #4468\n\n\n\n\nRelated issues\n\ncloses #4388\ncloses #4432\ncloses #4344\ncloses #4258\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-05-06T20:54:28Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4466", "merged": true, "mergeCommit": {"oid": "04f658899d24394aa6850cf051ea8a21fab1360d"}, "closed": true, "closedAt": "2020-05-14T14:02:56Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce26wuABqjMzMTEzMzg3NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchNF6-gBqjMzMzY0OTE2Nzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64feaf0f6cc504826214002c105bd076bdb750d9", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/64feaf0f6cc504826214002c105bd076bdb750d9", "committedDate": "2020-05-06T20:40:20Z", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue."}, "afterCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e920effc9dc7aef5836da9347a22bc7daca5e46f", "committedDate": "2020-05-07T05:54:32Z", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDUwMTU3", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-409050157", "createdAt": "2020-05-11T10:28:25Z", "commit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMDoyODoyNVrOGTWWSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMzo0MDozNVrOGTcvQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MjI4MA==", "bodyText": "RaftStateMachineFactory could be simplified to only take one parameter", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422942280", "createdAt": "2020-05-11T10:28:25Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -584,13 +571,11 @@ default boolean isLeader() {\n     protected RaftStorage storage;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n-    protected Duration sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n-    protected PrimitiveTypeRegistry primitiveTypes;\n     protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n     protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n     protected ThreadContextFactory threadContextFactory;\n-    protected RaftStateMachineFactory stateMachineFactory = RaftServiceManager::new;\n-    protected LoadMonitorFactory loadMonitorFactory = LoadMonitor::new;\n+    protected RaftStateMachineFactory stateMachineFactory =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1NzczNA==", "bodyText": "I think the builder should use the SnapshotStoreFactory of the RaftStorageConfig by default, and not hardcode a snapshot store. This would mean that either the factory of the config need to be passed to the builder on construction.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422957734", "createdAt": "2020-05-11T10:57:43Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java", "diffHunk": "@@ -698,7 +698,8 @@ public Builder withSnapshotStore(final SnapshotStore snapshotStore) {\n     @Override\n     public RaftStorage build() {\n       if (snapshotStore == null) {\n-        snapshotStore = new DefaultSnapshotStore(directory.toPath(), prefix);\n+        snapshotStore =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MTE3Mw==", "bodyText": "Looks like a verbatim copy of io.zeebe.engine.util.StreamProcessingComposite Maybe it was a rename and the commit was incomplete?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422961173", "createdAt": "2020-05-11T11:04:13Z", "author": {"login": "pihme"}, "path": "broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTcwMQ==", "bodyText": "Maybe unit tests here?\n\nsame file should always get the same checksum\ntwo different files get different checksums\nsame files in same order get same checksum\nsame files, but different order gets different checksums", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422965701", "createdAt": "2020-05-11T11:13:22Z", "author": {"login": "pihme"}, "path": "util/src/main/java/io/zeebe/util/ChecksumUtil.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+\n+public final class ChecksumUtil {\n+\n+  private ChecksumUtil() {}\n+\n+  /** computes a checksum for the files, in the order they're presented */\n+  public static long createCombinedChecksum(final List<Path> paths) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzczOA==", "bodyText": "CLOSED_SESSION is never used and can probably be removed.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422977738", "createdAt": "2020-05-11T11:37:27Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -188,7 +188,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.ClosedSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MTE4OA==", "bodyText": "UNKNOWN_SESSIONis still being used in LeaderRole\nI think it is worth investigating, how the removal of sessions impacts the implementation of LeaderRole. Ideally, LeaderRole wouldn't need this enum value anymore, so that it can be removed", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422981188", "createdAt": "2020-05-11T11:44:30Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -162,7 +162,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.UnknownSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTYzNg==", "bodyText": "??? What does this even mean?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422985636", "createdAt": "2020-05-11T11:53:52Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -60,10 +54,8 @@\n  *\n  * <h2>State machines</h2>\n  *\n- * Underlying each server is a {@link PrimitiveService}. The state machine is responsible for\n- * maintaining the state with relation to {@link OperationType#COMMAND}s and {@link\n- * OperationType#QUERY}s submitted to the server by a client. State machines are provided in a\n- * factory to allow servers to transition between stateful and stateless states.\n+ * State machines are provided in a factory to allow servers to transition between stateful and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzgwNQ==", "bodyText": "Maybe at least log the exception?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422987805", "createdAt": "2020-05-11T11:58:19Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(\n-      final PartitionMetadata metadata, final PartitionManagementService managementService) {\n-    if (server == null\n-        && metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      initServer(managementService);\n-      return server.join(metadata.members());\n-    } else if (server != null\n-        && !metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      return server.leave().thenRun(() -> server = null);\n-    }\n-    return CompletableFuture.completedFuture(null);\n-  }\n-\n   /** Closes the partition. */\n   CompletableFuture<Void> close() {\n-    return closeClient()\n-        .exceptionally(v -> null)\n-        .thenCompose(v -> closeServer())\n-        .exceptionally(v -> null);\n-  }\n-\n-  private CompletableFuture<Void> closeClient() {\n-    if (client != null) {\n-      return client.stop();\n-    }\n-    return CompletableFuture.completedFuture(null);\n+    return closeServer().exceptionally(v -> null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MTIwOQ==", "bodyText": "could perhaps lead to NPE in ZeebePartition#onRoleChange Not sure whether the lifecycle guarantees that a server is set when onRoleChange() is called", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422991209", "createdAt": "2020-05-11T12:05:03Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -262,25 +213,6 @@ public long term() {\n     return partitionMetadata != null ? partitionMetadata.members() : Collections.emptyList();\n   }\n \n-  @Override\n-  public MemberId primary() {\n-    return client != null ? client.leader() : null;\n-  }\n-\n-  @Override\n-  public Collection<MemberId> backups() {\n-    final MemberId leader = primary();\n-    if (leader == null) {\n-      return members();\n-    }\n-    return members().stream().filter(m -> !m.equals(leader)).collect(Collectors.toSet());\n-  }\n-\n-  @Override\n-  public RaftPartitionClient getClient() {\n-    return client;\n-  }\n-\n   public Role getRole() {\n     return server != null ? server.getRole() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MzAxMQ==", "bodyText": "Please add the old types as line comments for the new void lines. Otherwise, this is just way too confusing.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422993011", "createdAt": "2020-05-11T12:08:51Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java", "diffHunk": "@@ -117,57 +73,45 @@\n           .register(VoteResponse.class)\n           .register(AppendRequest.class)\n           .register(AppendResponse.class)\n-          .register(PublishRequest.class)\n-          .register(ResetRequest.class)\n           .register(RaftResponse.Status.class)\n           .register(RaftError.class)\n           .register(RaftError.Type.class)\n-          .register(ReadConsistency.class)\n-          .register(SessionMetadata.class)\n-          .register(CloseSessionEntry.class)\n-          .register(CommandEntry.class)\n           .register(ConfigurationEntry.class)\n           .register(InitializeEntry.class)\n-          .register(KeepAliveEntry.class)\n-          .register(MetadataEntry.class)\n-          .register(OpenSessionEntry.class)\n-          .register(QueryEntry.class)\n-          .register(PrimitiveOperation.class)\n-          .register(PrimitiveEvent.class)\n-          .register(DefaultEventType.class)\n-          .register(DefaultOperationId.class)\n-          .register(OperationType.class)\n-          .register(ReadConsistency.class)\n           .register(ArrayList.class)\n           .register(LinkedList.class)\n           .register(Collections.emptyList().getClass())\n           .register(HashSet.class)\n           .register(DefaultRaftMember.class)\n           .register(MemberId.class)\n-          .register(SessionId.class)\n           .register(RaftMember.Type.class)\n           .register(Instant.class)\n           .register(Configuration.class)\n           .register(ZeebeEntry.class)\n           .build(\"RaftProtocol\");\n \n-  /** Raft storage namespace. */\n+  /**\n+   * Raft storage namespace.\n+   *\n+   * <p>*Be aware* we use the Void type for replaced/removed types to keep the id's of used types,\n+   * otherwise we break compatibility.\n+   */\n   public static final Namespace RAFT_STORAGE =\n       Namespace.builder()\n           .register(Namespaces.BASIC)\n           .nextId(Namespaces.BEGIN_USER_CUSTOM_ID + 100)\n-          .register(CloseSessionEntry.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDczMw==", "bodyText": "Optional: personally I would expect these lines as part of the when section:\nWhen I append an entry and wait for the commit and log, then ..", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423010733", "createdAt": "2020-05-11T12:42:15Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzk2OA==", "bodyText": "you could use assertThat(firstMemberEntries).describedAs(\"Enty comparison 1 v \" + member.getId() to give the error message more context", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423013968", "createdAt": "2020-05-11T12:47:55Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).withFailMessage(memberLog.toString()).isEqualTo(2);\n+\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldAppendEntriesOnAllNodes() throws Throwable {\n+    // given\n+    final var entryCount = 128;\n+\n+    // when\n+    raftRule.awaitAppendEntries(entryCount);\n+\n+    // then\n+    raftRule.awaitCommit(entryCount + 1);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(entryCount + 1);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n+    final var firstMemberEntries = memberLog.get(\"1\");\n+    final var members = memberLog.keySet();\n+    for (final var member : members) {\n+      if (!member.equals(\"1\")) {\n+        final var otherEntries = memberLog.get(member);\n+\n+        assertThat(firstMemberEntries).containsExactly(otherEntries.toArray(new Indexed[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyNTgwOQ==", "bodyText": "Will throw IAE as per line 83. Not sure what this method is for", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423025809", "createdAt": "2020-05-11T13:08:31Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyODM0Nw==", "bodyText": "Not sure why there is a timeout. The exception will be ignored anyway. And if this runs sequentially, then each server could take up to 30 seconds. Maybe better collect the futures and wait for all of them. Or just call shutdown without waiting", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423028347", "createdAt": "2020-05-11T13:12:40Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMDQyMQ==", "bodyText": "directory is not reset", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423030421", "createdAt": "2020-05-11T13:15:52Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjAzOQ==", "bodyText": "When can this happen? Lines 166 look they always create active members", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032039", "createdAt": "2020-05-11T13:18:30Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjQ3MA==", "bodyText": "Why wait longer for more nodes?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032470", "createdAt": "2020-05-11T13:19:06Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMzg2Ng==", "bodyText": "This method behaves strange, if members already has entries. Then new members would be added at the end, but the first entries would be used to create the servers.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423033866", "createdAt": "2020-05-11T13:21:17Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNjMxOA==", "bodyText": "Maybe call next method to avoid code dpulication", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423036318", "createdAt": "2020-05-11T13:24:59Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNzU2Ng==", "bodyText": "getMemberLog->getMemberLogs()", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423037566", "createdAt": "2020-05-11T13:26:47Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzOTQwMw==", "bodyText": "Function<Builder, Builder> -> UnaryOperator<Builder>", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423039403", "createdAt": "2020-05-11T13:29:33Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NjAzNA==", "bodyText": "Don't understand this class at all. Has nothing to do with commits. It's just an index comparator. Might make more sense if this class were a RaftCommitListener itself\nEven then the implementation won't work, if the index I am waiting for has already bean reached when the class is constructed, and there are no more commits which trigger the commit listener, and the reachedCommit()method.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046034", "createdAt": "2020-05-11T13:39:09Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Njk3Nw==", "bodyText": "rename to reachedCommit(final long currentIndex) The way it is now it is confusing", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046977", "createdAt": "2020-05-11T13:40:35Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {\n+\n+    private final long awaitedIndex;\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    public CommitAwaiter(final long index) {\n+      this.awaitedIndex = index;\n+    }\n+\n+    public boolean reachedCommit(final long index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 482}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTAxMjA0", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-408901204", "createdAt": "2020-05-11T06:49:56Z", "commit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNjo0OTo1NlrOGTOxgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzo0MDoxOVrOGT59Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgxODE3OA==", "bodyText": "We probably don't need this anymore. It was used by the clients, right?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422818178", "createdAt": "2020-05-11T06:49:56Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java", "diffHunk": "@@ -18,19 +18,8 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import io.atomix.primitive.PrimitiveType;\n-import io.atomix.primitive.partition.PartitionGroup;\n-import io.atomix.primitive.partition.PartitionService;\n import io.atomix.primitive.protocol.PrimitiveProtocol;\n import io.atomix.primitive.protocol.ProxyProtocol;\n-import io.atomix.primitive.proxy.ProxyClient;\n-import io.atomix.primitive.proxy.impl.DefaultProxyClient;\n-import io.atomix.primitive.service.ServiceConfig;\n-import io.atomix.primitive.session.SessionClient;\n-import io.atomix.raft.partition.RaftPartition;\n-import io.atomix.utils.config.ConfigurationException;\n-import java.util.Collection;\n-import java.util.stream.Collectors;\n \n /** Multi-Raft protocol. */\n public class MultiRaftProtocol implements ProxyProtocol {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NjkzNg==", "bodyText": "Can be removed.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423496936", "createdAt": "2020-05-12T06:43:57Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -94,20 +83,16 @@\n   private static final int HIGH_LOAD_THRESHOLD = 500;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Ng==", "bodyText": "This is required if we want dynamic reconfiguration \ud83d\ude00", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423500156", "createdAt": "2020-05-12T06:51:02Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNTIwMA==", "bodyText": "Is it safe to compact without a snapshot? Depending on what we want to test, this might not work.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423515200", "createdAt": "2020-05-12T07:21:09Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjAxMg==", "bodyText": "Name doesn't match \ud83d\ude42", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423516012", "createdAt": "2020-05-12T07:22:38Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzA2Ng==", "bodyText": "We can get the index from appendEntry and use that to await commit, instead of estimating the commit index.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517066", "createdAt": "2020-05-12T07:24:45Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzc1NQ==", "bodyText": "Same as above. We cannot guarantee there are only 2 initial entries.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517755", "createdAt": "2020-05-12T07:25:57Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry\n+    final var expectedEntryCount = entryCount * 2 + 1;\n+    raftRule.awaitCommit(expectedEntryCount);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(expectedEntryCount);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownLeader();\n+\n+    // when\n+    raftRule.awaitNewLeader();\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 2 initial entries\n+    final var expectedEntryCount = entryCount * 2 + 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA==", "bodyText": "Is it difficult to use RaftRule for this also?", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423524328", "createdAt": "2020-05-12T07:37:53Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -108,21 +75,18 @@\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.mockito.Mockito;\n-import org.slf4j.LoggerFactory;\n \n /** Raft test. */\n public class RaftTest extends ConcurrentTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY1OQ==", "bodyText": "Did you move this test to some where else? This is important to test.", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423525659", "createdAt": "2020-05-12T07:40:19Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -1178,444 +485,24 @@ public void testThreeNodesSequentiallyStart() throws Throwable {\n     await(2000 * 3, 3);\n   }\n \n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodesManyEventsAfterLeaderShutdown() throws Throwable {\n-    testManyEventsAfterLeaderShutdown(5);\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testThreeNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(3);\n-  }\n-\n-  /** Tests submitting a sequential event that publishes to all sessions. */\n-  private void testEventsAfterFollowerKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer follower =\n-        servers.stream().filter(s -> s.getRole() == RaftServer.Role.FOLLOWER).findFirst().get();\n-    follower.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000, 2);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testFiveNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(5);\n-  }\n-\n-  /** Tests submitting events. */\n-  @Test\n-  public void testFiveNodesEventsAfterLeaderKill() throws Throwable {\n-    testEventsAfterLeaderKill(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testEventsAfterLeaderKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer leader = getLeader(servers).get();\n-    leader.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodeManySessionsManyEvents() throws Throwable {\n-    testManySessionsManyEvents(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testManySessionsManyEvents(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(false).thenRun(this::resume);\n-      await(10000, 4);\n-    }\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testOneNodeExpireEvent() throws Throwable {\n-    testSessionExpire(1);\n-  }\n-\n-  /** Tests a session expiring. */\n-  private void testSessionExpire(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    createSession(client2);\n-    primitive1.onExpire(event -> resume()).thenRun(this::resume);\n-    client2.close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testThreeNodeExpireEvent() throws Throwable {\n-    testSessionExpire(3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testFiveNodeExpireEvent() throws Throwable {\n-    testSessionExpire(5);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testOneNodeCloseEvent() throws Throwable {\n-    testSessionClose(1);\n-  }\n-\n-  /** Tests a session closing. */\n-  private void testSessionClose(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    primitive1.onClose(event -> resume()).thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 1);\n-    createSession(client2).close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 2);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testThreeNodeCloseEvent() throws Throwable {\n-    testSessionClose(3);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testFiveNodeCloseEvent() throws Throwable {\n-    testSessionClose(5);\n-  }\n-\n   @Test\n   public void testThreeNodeManyEventsDoNotMissHeartbeats() throws Throwable {\n     // given\n     createServers(3);\n+    final var leader = getLeader(servers).orElseThrow();\n \n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        message -> {\n-          threadAssertNotNull(message);\n-          resume();\n-        });\n+    appendEntry(leader);\n \n     final double startMissedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n \n     // when\n-    for (int i = 0; i < 1_000; i++) {\n-      primitive.sendEvent(true);\n-    }\n-    await(10000, 1_000);\n+    appendEntries(leader, 1000);\n \n     // then\n     final double missedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n     assertThat(0.0, is(missedHeartBeats - startMissedHeartBeats));\n   }\n \n-  @Test\n-  public void testSnapshotSentOnDataLoss() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f"}, "originalPosition": 1154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNTY3NTQ4", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-411567548", "createdAt": "2020-05-14T08:16:56Z", "commit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNTcwMzE3", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-411570317", "createdAt": "2020-05-14T08:20:32Z", "commit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMDozMlrOGVRLNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMDozMlrOGVRLNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDY3Ng==", "bodyText": "Nit: I'd be fine collapsing this and the interface type, or at least renaming to something more descriptive than Zeebe \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424954676", "createdAt": "2020-05-14T08:20:32Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -22,20 +22,14 @@\n \n import io.atomix.cluster.ClusterMembershipService;\n import io.atomix.cluster.MemberId;\n-import io.atomix.primitive.PrimitiveTypeRegistry;\n-import io.atomix.primitive.operation.OperationType;\n-import io.atomix.primitive.service.PrimitiveService;\n import io.atomix.raft.cluster.RaftCluster;\n import io.atomix.raft.cluster.RaftMember;\n import io.atomix.raft.impl.DefaultRaftServer;\n import io.atomix.raft.impl.RaftContext;\n-import io.atomix.raft.impl.RaftServiceManager;\n+import io.atomix.raft.impl.zeebe.ZeebeRaftStateMachine;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNjkwNjAw", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-411690600", "createdAt": "2020-05-14T10:56:22Z", "commit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNjk4ODUw", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#pullrequestreview-411698850", "createdAt": "2020-05-14T11:08:55Z", "commit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "committedDate": "2020-05-14T12:25:15Z", "message": "chore(atomix): migrate zeebe state machine to atomix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "committedDate": "2020-05-14T12:26:09Z", "message": "chore(atomix): move snapshotting and statemachine to atomix\n\n We add some implementations which are only used in atomix and for there tests, but have been replaced on broker side.\n This means we haven't tested our code completely with the other tests and had duplicate logic. We still have for replicate\n but this migration makes it now easier to move and merge the related classes.\n\n The engine doesn't know anymore about snapshoting, since it doesnt need to."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d34a70ac0ead5ff927ea939d695576da626412a0", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/d34a70ac0ead5ff927ea939d695576da626412a0", "committedDate": "2020-05-14T12:26:48Z", "message": "chore(atomix): remove sessions and primitives\n\nWe no longer need everything session related nor primitives."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eeb0980056cf4880562d356b0f637edf5c32d895", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/eeb0980056cf4880562d356b0f637edf5c32d895", "committedDate": "2020-05-14T12:26:48Z", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f425fa37685cc34221c6a265f9c23341ad16afac", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f425fa37685cc34221c6a265f9c23341ad16afac", "committedDate": "2020-05-14T12:26:48Z", "message": "chore(atomix): rename annotated parameters method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "committedDate": "2020-05-14T12:26:48Z", "message": "chore(atomix): log errors on closing server"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e58ce0574d49cd8b689c47a15d019b6c434cc037", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e58ce0574d49cd8b689c47a15d019b6c434cc037", "committedDate": "2020-05-13T14:01:45Z", "message": "chore(atomix): log errors on closing server"}, "afterCommit": {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "committedDate": "2020-05-14T12:26:48Z", "message": "chore(atomix): log errors on closing server"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2891, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}