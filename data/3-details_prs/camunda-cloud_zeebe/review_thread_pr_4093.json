{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNTIxNDMy", "number": 4093, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1ODo1OFrODqTqCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyNTowNlrODqUOag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njg4ODQxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1ODo1OFrOF5-KKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1ODo1OFrOF5-KKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTU2MQ==", "bodyText": "Nit: can we keep the same wording as we usually do for error messages?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331561", "createdAt": "2020-03-23T09:58:58Z", "author": {"login": "npepinpe"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -79,6 +79,10 @@\n       \"Processor finished reprocessing at event position {}\";\n   private static final String LOG_STMT_FAILED_ON_PROCESSING =\n       \"Event {} failed on processing last time, will call #onError to update workflow instance blacklist.\";\n+\n+  private static final String ERROR_INCONSISTENT_LOG =\n+      \"Inconsistent log detected! Last position was '%d' and current position is '%d'.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njg5MDQ4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1OToyOFrOF5-LbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1OToyOFrOF5-LbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTg4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // ERROR", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331885", "createdAt": "2020-03-23T09:59:28Z", "author": {"login": "npepinpe"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -146,9 +150,19 @@ private long scanLog(final long snapshotPosition) {\n \n     if (logStreamReader.hasNext()) {\n       lastSourceEventPosition = snapshotPosition;\n+\n+      long lastPosition = snapshotPosition;\n       while (logStreamReader.hasNext()) {\n         final LoggedEvent newEvent = logStreamReader.next();\n \n+        final var currentPosition = newEvent.getPosition();\n+        if (lastPosition >= currentPosition) {\n+          // ERROR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njk2MTQ5OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoxOToyNFrOF5-4JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDozNjo0MlrOF5_gjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MzMzMg==", "bodyText": "Since on recovery we switch the processor phase to Phase.PROCESSING, would comparing phases only not be enough? What additional guarantees does the latch provide?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396343332", "createdAt": "2020-03-23T10:19:24Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1MzY3OA==", "bodyText": "It is more a remaining because I checked before whether I call this method. I kept that to verify that after we failed we haven't called it, but probably not necessary.", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353678", "createdAt": "2020-03-23T10:36:42Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MzMzMg=="}, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njk2NzMzOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyMTowNlrOF5-73w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDozNjo1MlrOF5_hAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDI4Nw==", "bodyText": "Shouldn't it be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        new RecordStream(testStreams.events(getLogName(2)))\n          \n          \n            \n                        new RecordStream(testStreams.events(getLogName(1)))", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396344287", "createdAt": "2020-03-23T10:21:06Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Mzc5Mg==", "bodyText": "copy paste error", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353792", "createdAt": "2020-03-23T10:36:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDI4Nw=="}, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njk3NDA5OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyMjo1OVrOF5_AGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDo0MDo0OVrOF5_qOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ==", "bodyText": "Is it enough to only test the first processor composite?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396345369", "createdAt": "2020-03-23T10:22:59Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final TypedRecordProcessor typedRecordProcessor = mock(TypedRecordProcessor.class);\n+    final var streamProcessor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Mzg5Ng==", "bodyText": "yes why not?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396353896", "createdAt": "2020-03-23T10:37:04Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final TypedRecordProcessor typedRecordProcessor = mock(TypedRecordProcessor.class);\n+    final var streamProcessor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ=="}, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1NjE1NA==", "bodyText": "Don't we want to ensure that inconsistencies would be detected in both? I guess they're both too close to detect different cases that this test would fail. It's probably fine as is \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396356154", "createdAt": "2020-03-23T10:40:49Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final TypedRecordProcessor typedRecordProcessor = mock(TypedRecordProcessor.class);\n+    final var streamProcessor =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ=="}, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njk4MTU0OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyNTowNlrOF5_E8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyNTowNlrOF5_E8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NjYwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // things provisioned by this rule", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396346609", "createdAt": "2020-03-23T10:25:06Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.util;\n+\n+import static io.zeebe.engine.util.Records.workflowInstance;\n+\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.engine.processor.ReadonlyProcessingContext;\n+import io.zeebe.engine.processor.StreamProcessor;\n+import io.zeebe.engine.processor.TypedRecordProcessorFactory;\n+import io.zeebe.engine.processor.TypedRecordProcessors;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.logstreams.log.LogStreamRecordWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+\n+public class StreamProcessingComposite {\n+\n+  // things provisioned by this rule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4938, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}