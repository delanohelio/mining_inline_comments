{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MDkwMjAw", "number": 5348, "title": "chore(engine): update last processed position after reprocessing", "bodyText": "Description\nWhen the broker is out of disk space, stream processor is paused immediately after reprocessing. Then the last processed position was not updated. As a result, no snapshots are taken because AsyncSnapshotDirector assumes there is nothing processed, even though new snapshots can be taken because exporter position has changed. So the logs are not compacted and the brokers cannot recover from out of disk space.\nIn this PR, we initialize streamprocessor's lastProcessedPosition to the last reprocessed position. Then we can take new snapshots even if nothing new has been processed.\nRelated issues\ncloses #5329\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-09-15T07:14:45Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5348", "merged": true, "mergeCommit": {"oid": "b342502106ab15d03bf3605f41604ad0021afdab"}, "closed": true, "closedAt": "2020-09-17T12:56:16Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJXFMzgFqTQ4OTMwMjcxMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJvP3IgBqjM3Nzc0NjExMTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MzAyNzEx", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#pullrequestreview-489302711", "createdAt": "2020-09-16T06:13:05Z", "commit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjoxMzowNVrOHShmOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzowMDowNFrOHSi1YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4Njg3NQ==", "bodyText": "It looks a bit odd to set the last processed position from outside.\nIf it is important to update the metrics with the position then I recommend creating a new method for starting the processing that takes the position as an argument. This makes it more clear that the position should be set only when the processing is started.\nOtherwise, we could implement this logic also in StreamProcessor.getLastProcessedPositionAsync().\nWhat do you think?", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489186875", "createdAt": "2020-09-16T06:13:05Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/processing/streamprocessor/ProcessingStateMachine.java", "diffHunk": "@@ -443,4 +443,11 @@ public long getLastWrittenEventPosition() {\n   public boolean isMakingProgress() {\n     return !onErrorHandlingLoop;\n   }\n+\n+  public void initLastProcessedPosition(final long lastReprocessedPosition) {\n+    if (lastSuccessfulProcessedEventPosition == StreamProcessor.UNSET_POSITION) {\n+      lastSuccessfulProcessedEventPosition = lastReprocessedPosition;\n+      metrics.setLastProcessedPosition(lastSuccessfulProcessedEventPosition);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4NzAyOQ==", "bodyText": "It seems that the event handlers are not required for the test. Can we remove them?", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489187029", "createdAt": "2020-09-16T06:13:30Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODUwMg==", "bodyText": "It seems that the event handler is not required for the test. Can we remove it?", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489188502", "createdAt": "2020-09-16T06:17:32Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            recoveredLatch.countDown();\n+                          }\n+                        }));\n+\n+    // then\n+    recoveredLatch.await();\n+\n+    assertThat(streamProcessor.getLastProcessedPositionAsync().get()).isEqualTo(firstPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedEventWhenSnapshot() throws Exception {\n+    // given\n+    final CountDownLatch onProcessedListenerLatch = new CountDownLatch(2);\n+    streamProcessorRule.startTypedStreamProcessor(\n+        (processors, context) ->\n+            processors.onEvent(\n+                ValueType.WORKFLOW_INSTANCE,\n+                ELEMENT_ACTIVATING,\n+                new TypedRecordProcessor<UnifiedRecordValue>() {\n+                  @Override\n+                  public void processRecord(\n+                      final long position,\n+                      final TypedRecord<UnifiedRecordValue> record,\n+                      final TypedResponseWriter responseWriter,\n+                      final TypedStreamWriter streamWriter,\n+                      final Consumer<SideEffectProducer> sideEffect) {}\n+                }),\n+        (t) -> onProcessedListenerLatch.countDown());\n+\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var snapshotPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(\n+            ELEMENT_ACTIVATING); // should be processed and included in the snapshot\n+    onProcessedListenerLatch.await();\n+    streamProcessorRule.snapshot();\n+    streamProcessorRule.closeStreamProcessor();\n+\n+    // when\n+    // The processor restarts with a snapshot that was the state of the processor before it\n+    // was closed.\n+    final var recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODk1Nw==", "bodyText": "These tests verify the fix but not the actual problem behind it. Can we write a test to verify that we can take a snapshot after reprocessing if no new record was processed?", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489188957", "createdAt": "2020-09-16T06:18:42Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNzEzNg==", "bodyText": "This part of the test is a bit hard to read. Please try to improve it. For example, by adding a new line :)", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489207136", "createdAt": "2020-09-16T07:00:04Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            recoveredLatch.countDown();\n+                          }\n+                        }));\n+\n+    // then\n+    recoveredLatch.await();\n+\n+    assertThat(streamProcessor.getLastProcessedPositionAsync().get()).isEqualTo(firstPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedEventWhenSnapshot() throws Exception {\n+    // given\n+    final CountDownLatch onProcessedListenerLatch = new CountDownLatch(2);\n+    streamProcessorRule.startTypedStreamProcessor(\n+        (processors, context) ->\n+            processors.onEvent(\n+                ValueType.WORKFLOW_INSTANCE,\n+                ELEMENT_ACTIVATING,\n+                new TypedRecordProcessor<UnifiedRecordValue>() {\n+                  @Override\n+                  public void processRecord(\n+                      final long position,\n+                      final TypedRecord<UnifiedRecordValue> record,\n+                      final TypedResponseWriter responseWriter,\n+                      final TypedStreamWriter streamWriter,\n+                      final Consumer<SideEffectProducer> sideEffect) {}\n+                }),\n+        (t) -> onProcessedListenerLatch.countDown());\n+\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var snapshotPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(\n+            ELEMENT_ACTIVATING); // should be processed and included in the snapshot\n+    onProcessedListenerLatch.await();\n+    streamProcessorRule.snapshot();\n+    streamProcessorRule.closeStreamProcessor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8415ebfe5362292297b6a9404f31219d8d3e900"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNDkxMTYz", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#pullrequestreview-490491163", "createdAt": "2020-09-17T11:22:12Z", "commit": {"oid": "8ba18594a87bdee51fd50202b8a12702e277a744"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24f774f46dc637bdeadb45b35372744a6eb760db", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/24f774f46dc637bdeadb45b35372744a6eb760db", "committedDate": "2020-09-17T11:24:53Z", "message": "chore(engine): update last processed position after reprocessing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ba18594a87bdee51fd50202b8a12702e277a744", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/8ba18594a87bdee51fd50202b8a12702e277a744", "committedDate": "2020-09-17T09:46:41Z", "message": "chore(engine): cleanup test and rename method"}, "afterCommit": {"oid": "24f774f46dc637bdeadb45b35372744a6eb760db", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/24f774f46dc637bdeadb45b35372744a6eb760db", "committedDate": "2020-09-17T11:24:53Z", "message": "chore(engine): update last processed position after reprocessing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2505, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}