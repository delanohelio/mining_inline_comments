{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1OTM1MDkx", "number": 5622, "title": "Add randomized property tests for raft", "bodyText": "Description\nTesting a distributed or concurrent program is difficult. There are so many combinations of concurrent operations possible. It is not possible to test all cases. Hence we introduce a randomized test for the raft protocol implementation. For each run of this test, it runs a fixed number of tries. Each try generates a random sequence of operations that can be applied to the raft replicas. While running these operations, the tests verifies some properties that should be guaranteed by the raft. The scheduling and message delivery is controlled via these operations. The properties that we verify are:\n\nThere is only one leader at a term\nThe committed entries are same on all replicas\n\nIn one run, it only tests a few sequences. This test will be run with each build and PR. So overtime, the tests will be run with many different sequences of operations. Thus overtime, any existing bugs will be revealed, or confidence in the raft implementation will increase. We have already found and fixed two bugs with this approach - #5360 and #5356\nFor the randomized test we use a property based testing framework - jqwik.\nCurrent limitations:\n\nDue to some unknown non-determinism within the raft implementation, test failures may not be reproducible by reusing the seed.\n\nGeneral limitations:\n\nThese tests cannot be used for testing liveness (eg:- join process completes, leader election completes with in a specific duration etc.)\nA passing test does not mean there are no bugs. So if you make changes to raft, also add tests to verify your specific changes.\n\nDepends on #5588\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-10-19T12:37:50Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5622", "merged": true, "mergeCommit": {"oid": "000989b78f288ada1247e4e1783ec5a93f64c682"}, "closed": true, "closedAt": "2020-10-23T15:27:24Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdU8VQ3gBqjM5MDczNzUyOTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVWfhNgBqjM5MTM5MTgzNzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b", "committedDate": "2020-10-19T12:18:51Z", "message": "chore(broker): add raft property tests"}, "afterCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/cf729ba4194edfbd54351a0aea3ba9bdfb022538", "committedDate": "2020-10-22T06:53:00Z", "message": "chore(broker): add raft property tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzkzOTQx", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#pullrequestreview-514393941", "createdAt": "2020-10-22T06:26:11Z", "commit": {"oid": "9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNjoyNjoxMVrOHmST7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzozOToxOVrOHmUhfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkwNzk0OQ==", "bodyText": "Why was this necessary?", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509907949", "createdAt": "2020-10-22T06:26:11Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/pom.xml", "diffHunk": "@@ -201,6 +229,7 @@\n           <usedDependencies>\n             <!-- dependency used but plugin seems to report a false positive here -->\n             <dependency>uk.co.real-logic:sbe-tool</dependency>\n+            <dependency>net.jqwik:jqwik</dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkxNjI1MQ==", "bodyText": "Didn't I reviewed that before? \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509916251", "createdAt": "2020-10-22T06:45:55Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -552,20 +551,16 @@ default boolean isLeader() {\n \n     private static final Duration DEFAULT_ELECTION_TIMEOUT = Duration.ofMillis(750);\n     private static final Duration DEFAULT_HEARTBEAT_INTERVAL = Duration.ofMillis(250);\n-    private static final ThreadModel DEFAULT_THREAD_MODEL = ThreadModel.SHARED_THREAD_POOL;\n-    private static final int DEFAULT_THREAD_POOL_SIZE =\n-        Math.max(Math.min(Runtime.getRuntime().availableProcessors() * 2, 8), 4);\n \n     protected String name;\n     protected MemberId localMemberId;\n     protected ClusterMembershipService membershipService;\n     protected RaftServerProtocol protocol;\n     protected RaftStorage storage;\n+    protected RaftThreadContextFactory threadContextFactory;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n-    protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n-    protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    protected ThreadContextFactory threadContextFactory;\n+    protected Supplier<Random> randomFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c8d7afa4c6bfed61dc7a5f000c774dbc38c803b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyMDgxMQ==", "bodyText": "Could we create a follow up issue to fix this non determinism? Like introducing a clock?", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509920811", "createdAt": "2020-10-22T06:55:21Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyNDQyMQ==", "bodyText": "Couldn't we introduce in our normal code that node one for partition one does immediately a poll? Last time we had the direct transition, which was not really safe.", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509924421", "createdAt": "2020-10-22T07:02:36Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution\n+ * of raft threads. Note:- Currently there is some non-determinism hidden in the raft. Hence the\n+ * resulting execution is not fully deterministic.\n+ */\n+public class ControllableRaftContexts {\n+\n+  private final Map<MemberId, ControllableRaftServerProtocol> serverProtocols = new HashMap<>();\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue =\n+      new HashMap<>();\n+  private final Map<MemberId, DeterministicSingleThreadContext> deterministicExecutors =\n+      new HashMap<>();\n+\n+  private Path directory;\n+\n+  private final int nodeCount;\n+  private final Map<MemberId, RaftContext> raftServers = new HashMap<>();\n+  private Duration electionTimeout;\n+  private Duration hearbeatTimeout;\n+  private int nextEntry = 0;\n+\n+  // Used only for verification. Map[term -> leader]\n+  private final Map<Long, MemberId> leadersAtTerms = new HashMap<>();\n+\n+  public ControllableRaftContexts(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public Map<MemberId, RaftContext> getRaftServers() {\n+    return raftServers;\n+  }\n+\n+  public RaftContext getRaftContext(final int memberId) {\n+    return raftServers.get(MemberId.from(String.valueOf(memberId)));\n+  }\n+\n+  public RaftContext getRaftContext(final MemberId memberId) {\n+    return raftServers.get(memberId);\n+  }\n+\n+  public void setup(final Path directory, final Random random) throws Exception {\n+    this.directory = directory;\n+    if (nodeCount > 0) {\n+      createRaftContexts(nodeCount, random);\n+    }\n+    joinRaftServers();\n+    electionTimeout = getRaftContext(0).getElectionTimeout();\n+    hearbeatTimeout = getRaftContext(0).getHeartbeatInterval();\n+\n+    // expecting 0 to be the leader\n+    tickHeartbeatTimeout(0);\n+  }\n+\n+  public void shudown() throws IOException {\n+    raftServers.forEach((m, c) -> c.close());\n+    raftServers.clear();\n+    serverProtocols.clear();\n+    deterministicExecutors.forEach((m, e) -> e.close());\n+    deterministicExecutors.clear();\n+    messageQueue.clear();\n+    leadersAtTerms.clear();\n+    directory = null;\n+  }\n+\n+  private void joinRaftServers() throws InterruptedException, ExecutionException, TimeoutException {\n+    final Set<CompletableFuture<Void>> futures = new HashSet<>();\n+    final var servers = getRaftServers();\n+    final var serverIds = new ArrayList<>(servers.keySet());\n+    final long electionTimeout =\n+        servers.get(MemberId.from(String.valueOf(0))).getElectionTimeout().toMillis();\n+    Collections.sort(serverIds);\n+    servers.forEach(\n+        (memberId, raftContext) -> futures.add(raftContext.getCluster().bootstrap(serverIds)));\n+\n+    runUntilDone(0);\n+    // trigger election on 0 so that 0 is initially the leader\n+    getDeterministicScheduler(MemberId.from(String.valueOf(0)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyODIzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ControllableRaftContexts {\n          \n          \n            \n            public final class ControllableRaftContexts {", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509928234", "createdAt": "2020-10-22T07:10:32Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/ControllableRaftContexts.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.impl.RaftContext;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.protocol.ControllableRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.snapshot.TestSnapshotStore;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.zeebe.NoopEntryValidator;\n+import io.atomix.raft.zeebe.ZeebeLogAppender.AppendListener;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.JournalReader;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.zeebe.util.collection.Tuple;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Uses a DeterministicScheduler and controllable messaging layer to get a deterministic execution\n+ * of raft threads. Note:- Currently there is some non-determinism hidden in the raft. Hence the\n+ * resulting execution is not fully deterministic.\n+ */\n+public class ControllableRaftContexts {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkyODM0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class DeterministicSingleThreadContext implements ThreadContext {\n          \n          \n            \n            public final class DeterministicSingleThreadContext implements ThreadContext {", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509928343", "createdAt": "2020-10-22T07:10:43Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMDg2Ng==", "bodyText": "is not used", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509930866", "createdAt": "2020-10-22T07:15:27Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMDk2Nw==", "bodyText": "factory is not used", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509930967", "createdAt": "2020-10-22T07:15:37Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMTMzMA==", "bodyText": "Normally if you have a static factory method I would expect you make the ctor private.", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509931330", "createdAt": "2020-10-22T07:16:16Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjM2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } catch (final Throwable e) {\n          \n          \n            \n                  } catch (final Exception e) {", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932362", "createdAt": "2020-10-22T07:18:22Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {\n+    return new DeterministicSingleThreadContext(\n+        new DeterministicScheduler(), unCaughtExceptionHandler);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final long delay, final TimeUnit timeUnit, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(new WrappedRunnable(command), delay, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final Duration delay, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(\n+            new WrappedRunnable(command), delay.toMillis(), TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final long initialDelay,\n+      final long interval,\n+      final TimeUnit timeUnit,\n+      final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command), initialDelay, interval, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final Duration initialDelay, final Duration interval, final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command),\n+            initialDelay.toMillis(),\n+            interval.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public void execute(final Runnable command) {\n+    deterministicScheduler.execute(new WrappedRunnable(command));\n+  }\n+\n+  @Override\n+  public boolean isCurrentContext() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void checkThread() {\n+    // always assume running on the right context\n+  }\n+\n+  @Override\n+  public boolean isBlocked() {\n+    return false;\n+  }\n+\n+  @Override\n+  public void block() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void unblock() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void close() {\n+    // do nothing\n+  }\n+\n+  class WrappedRunnable implements Runnable {\n+\n+    private final Runnable command;\n+\n+    WrappedRunnable(final Runnable command) {\n+      this.command = command;\n+    }\n+\n+    @Override\n+    public void run() {\n+      try {\n+        command.run();\n+      } catch (final Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjUwOQ==", "bodyText": "static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              class WrappedRunnable implements Runnable {\n          \n          \n            \n            static final class WrappedRunnable implements Runnable {", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932509", "createdAt": "2020-10-22T07:18:38Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/DeterministicSingleThreadContext.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.fail;\n+\n+import io.atomix.utils.concurrent.Scheduled;\n+import io.atomix.utils.concurrent.ScheduledFutureImpl;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+\n+public class DeterministicSingleThreadContext implements ThreadContext {\n+\n+  private final DeterministicScheduler deterministicScheduler;\n+  private final Consumer<Throwable> uncaughtExceptionObserver;\n+\n+  public DeterministicSingleThreadContext(\n+      final DeterministicScheduler executor, final Consumer<Throwable> uncaughtExceptionObserver) {\n+    deterministicScheduler = executor;\n+    this.uncaughtExceptionObserver = uncaughtExceptionObserver;\n+  }\n+\n+  public DeterministicScheduler getDeterministicScheduler() {\n+    return deterministicScheduler;\n+  }\n+\n+  public static ThreadContext createContext(\n+      final ThreadFactory factory, final Consumer<Throwable> unCaughtExceptionHandler) {\n+    return new DeterministicSingleThreadContext(\n+        new DeterministicScheduler(), unCaughtExceptionHandler);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final long delay, final TimeUnit timeUnit, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(new WrappedRunnable(command), delay, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(final Duration delay, final Runnable command) {\n+    final var future =\n+        deterministicScheduler.schedule(\n+            new WrappedRunnable(command), delay.toMillis(), TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final long initialDelay,\n+      final long interval,\n+      final TimeUnit timeUnit,\n+      final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command), initialDelay, interval, timeUnit);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public Scheduled schedule(\n+      final Duration initialDelay, final Duration interval, final Runnable command) {\n+    final ScheduledFuture<?> future =\n+        deterministicScheduler.scheduleAtFixedRate(\n+            new WrappedRunnable(command),\n+            initialDelay.toMillis(),\n+            interval.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+    return new ScheduledFutureImpl<>(future);\n+  }\n+\n+  @Override\n+  public void execute(final Runnable command) {\n+    deterministicScheduler.execute(new WrappedRunnable(command));\n+  }\n+\n+  @Override\n+  public boolean isCurrentContext() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void checkThread() {\n+    // always assume running on the right context\n+  }\n+\n+  @Override\n+  public boolean isBlocked() {\n+    return false;\n+  }\n+\n+  @Override\n+  public void block() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void unblock() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void close() {\n+    // do nothing\n+  }\n+\n+  class WrappedRunnable implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjgzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              final BiConsumer<ControllableRaftContexts, MemberId> operation;\n          \n          \n            \n              private final BiConsumer<ControllableRaftContexts, MemberId> operation;", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932835", "createdAt": "2020-10-22T07:19:15Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftOperation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import io.atomix.cluster.MemberId;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+/** An operation that can be executed on a raft member */\n+public class RaftOperation {\n+\n+  final BiConsumer<ControllableRaftContexts, MemberId> operation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzMjk5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {\n          \n          \n            \n              private RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509932990", "createdAt": "2020-10-22T07:19:32Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftOperation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import io.atomix.cluster.MemberId;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+/** An operation that can be executed on a raft member */\n+public class RaftOperation {\n+\n+  final BiConsumer<ControllableRaftContexts, MemberId> operation;\n+  private final String name;\n+\n+  RaftOperation(final String name, final BiConsumer<ControllableRaftContexts, MemberId> operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDM1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              List<RaftOperation> operations;\n          \n          \n            \n              List<MemberId> raftMembers;\n          \n          \n            \n              File raftDataDirectory;\n          \n          \n            \n              private List<RaftOperation> operations;\n          \n          \n            \n              private List<MemberId> raftMembers;\n          \n          \n            \n              private File raftDataDirectory;", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509934358", "createdAt": "2020-10-22T07:21:58Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNDc1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public ControllableRaftContexts raftContexts;\n          \n          \n            \n              private ControllableRaftContexts raftContexts;", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509934751", "createdAt": "2020-10-22T07:22:38Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzNTM5NA==", "bodyText": "why we need to copy this here?", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509935394", "createdAt": "2020-10-22T07:23:49Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;\n+\n+  @BeforeProperty\n+  public void initOperations() {\n+    // Need members ids to generate pair operations\n+    final var servers =\n+        IntStream.range(0, 3)\n+            .mapToObj(String::valueOf)\n+            .map(MemberId::from)\n+            .collect(Collectors.toList());\n+    operations = RaftOperation.getDefaultRaftOperations();\n+    raftMembers = List.copyOf(servers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODAwNA==", "bodyText": "With Java 11 you can use the build in Files.createTempDirectory(null); method", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938004", "createdAt": "2020-10-22T07:28:38Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;\n+\n+  @BeforeProperty\n+  public void initOperations() {\n+    // Need members ids to generate pair operations\n+    final var servers =\n+        IntStream.range(0, 3)\n+            .mapToObj(String::valueOf)\n+            .map(MemberId::from)\n+            .collect(Collectors.toList());\n+    operations = RaftOperation.getDefaultRaftOperations();\n+    raftMembers = List.copyOf(servers);\n+  }\n+\n+  @AfterTry\n+  public void shutDownRaftNodes() throws IOException {\n+    raftContexts.shudown();\n+    FileUtil.deleteFolder(raftDataDirectory.toPath());\n+    raftDataDirectory = null;\n+  }\n+\n+  @Property(tries = 10, shrinking = ShrinkingMode.OFF, edgeCases = EdgeCasesMode.NONE)\n+  void raftProperty(\n+      @ForAll(\"raftOperations\") final List<RaftOperation> raftOperations,\n+      @ForAll(\"raftMembers\") final List<MemberId> raftMembers,\n+      @ForAll(\"seeds\") final long seed)\n+      throws Exception {\n+\n+    setUpRaftNodes(new Random(seed));\n+\n+    int step = 0;\n+    final var memberIter = raftMembers.iterator();\n+    for (final RaftOperation operation : raftOperations) {\n+      step++;\n+\n+      final MemberId member = memberIter.next();\n+      LOG.info(\"{} on {}\", operation, member);\n+      operation.run(raftContexts, member);\n+      raftContexts.assertOnlyOneLeader();\n+\n+      if (step % 100 == 0) { // reading logs after every operation can be too slow\n+        raftContexts.assertAllLogsEqual();\n+        step = 0;\n+      }\n+    }\n+\n+    raftContexts.assertAllLogsEqual();\n+  }\n+\n+  @Provide\n+  Arbitrary<List<RaftOperation>> raftOperations() {\n+    final var operation = Arbitraries.of(operations);\n+    return operation.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<List<MemberId>> raftMembers() {\n+    final var members = Arbitraries.of(raftMembers);\n+    return members.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<Long> seeds() {\n+    return Arbitraries.longs();\n+  }\n+\n+  private void setUpRaftNodes(final Random random) throws Exception {\n+    // Couldnot make @TempDir annotation work\n+    raftDataDirectory = Files.createTempDir();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODE1Ng==", "bodyText": "Currently you use google Files class", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938156", "createdAt": "2020-10-22T07:28:54Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RandomizedRaftTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import com.google.common.io.Files;\n+import io.atomix.cluster.MemberId;\n+import io.zeebe.util.FileUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import net.jqwik.api.Arbitraries;\n+import net.jqwik.api.Arbitrary;\n+import net.jqwik.api.EdgeCasesMode;\n+import net.jqwik.api.ForAll;\n+import net.jqwik.api.Property;\n+import net.jqwik.api.Provide;\n+import net.jqwik.api.ShrinkingMode;\n+import net.jqwik.api.lifecycle.AfterTry;\n+import net.jqwik.api.lifecycle.BeforeProperty;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RandomizedRaftTest {\n+\n+  private static final int OPERATION_SIZE = 10000;\n+  private static final Logger LOG = LoggerFactory.getLogger(RandomizedRaftTest.class);\n+  public ControllableRaftContexts raftContexts;\n+  List<RaftOperation> operations;\n+  List<MemberId> raftMembers;\n+  File raftDataDirectory;\n+\n+  @BeforeProperty\n+  public void initOperations() {\n+    // Need members ids to generate pair operations\n+    final var servers =\n+        IntStream.range(0, 3)\n+            .mapToObj(String::valueOf)\n+            .map(MemberId::from)\n+            .collect(Collectors.toList());\n+    operations = RaftOperation.getDefaultRaftOperations();\n+    raftMembers = List.copyOf(servers);\n+  }\n+\n+  @AfterTry\n+  public void shutDownRaftNodes() throws IOException {\n+    raftContexts.shudown();\n+    FileUtil.deleteFolder(raftDataDirectory.toPath());\n+    raftDataDirectory = null;\n+  }\n+\n+  @Property(tries = 10, shrinking = ShrinkingMode.OFF, edgeCases = EdgeCasesMode.NONE)\n+  void raftProperty(\n+      @ForAll(\"raftOperations\") final List<RaftOperation> raftOperations,\n+      @ForAll(\"raftMembers\") final List<MemberId> raftMembers,\n+      @ForAll(\"seeds\") final long seed)\n+      throws Exception {\n+\n+    setUpRaftNodes(new Random(seed));\n+\n+    int step = 0;\n+    final var memberIter = raftMembers.iterator();\n+    for (final RaftOperation operation : raftOperations) {\n+      step++;\n+\n+      final MemberId member = memberIter.next();\n+      LOG.info(\"{} on {}\", operation, member);\n+      operation.run(raftContexts, member);\n+      raftContexts.assertOnlyOneLeader();\n+\n+      if (step % 100 == 0) { // reading logs after every operation can be too slow\n+        raftContexts.assertAllLogsEqual();\n+        step = 0;\n+      }\n+    }\n+\n+    raftContexts.assertAllLogsEqual();\n+  }\n+\n+  @Provide\n+  Arbitrary<List<RaftOperation>> raftOperations() {\n+    final var operation = Arbitraries.of(operations);\n+    return operation.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<List<MemberId>> raftMembers() {\n+    final var members = Arbitraries.of(raftMembers);\n+    return members.list().ofSize(OPERATION_SIZE);\n+  }\n+\n+  @Provide\n+  Arbitrary<Long> seeds() {\n+    return Arbitraries.longs();\n+  }\n+\n+  private void setUpRaftNodes(final Random random) throws Exception {\n+    // Couldnot make @TempDir annotation work\n+    raftDataDirectory = Files.createTempDir();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODAwNA=="}, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODk3NA==", "bodyText": "this set has no content", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509938974", "createdAt": "2020-10-22T07:30:07Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MTA1Mw==", "bodyText": "If we just drop the message we should also receive at some point an timeout right? Is it worth to test this?", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509941053", "createdAt": "2020-10-22T07:33:55Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();\n+  private final Map<MemberId, ControllableRaftServerProtocol> servers;\n+  // Incoming messages to each member\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue;\n+  private final MemberId localMemberId;\n+\n+  public ControllableRaftServerProtocol(\n+      final MemberId memberId,\n+      final Map<MemberId, ControllableRaftServerProtocol> servers,\n+      final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue) {\n+    this.servers = servers;\n+    this.messageQueue = messageQueue;\n+    localMemberId = memberId;\n+    messageQueue.put(memberId, new LinkedList<>());\n+    servers.put(memberId, this);\n+  }\n+\n+  public void receiveNextMessage() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    if (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  public void receiveAll() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    while (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  // drop next message from the incoming queue\n+  public void dropNextMessage() {\n+    final var nextMessage =\n+        messageQueue.computeIfAbsent(localMemberId, t -> new LinkedList<>()).poll();\n+    if (nextMessage != null) {\n+      Optional.ofNullable(nextMessage.getRight())\n+          .ifPresent(\n+              f -> {\n+                LoggerFactory.getLogger(\"TEST:\")\n+                    .info(\"Dropped a message to {}\", localMemberId.id());\n+                // RaftServers excepts exceptions from the messaging layer to detect timeouts\n+                f.completeExceptionally(new TimeoutException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ==", "bodyText": "Do you think it is problematic that we have re-implemented the network stuff?", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509943301", "createdAt": "2020-10-22T07:37:49Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();\n+  private final Map<MemberId, ControllableRaftServerProtocol> servers;\n+  // Incoming messages to each member\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue;\n+  private final MemberId localMemberId;\n+\n+  public ControllableRaftServerProtocol(\n+      final MemberId memberId,\n+      final Map<MemberId, ControllableRaftServerProtocol> servers,\n+      final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue) {\n+    this.servers = servers;\n+    this.messageQueue = messageQueue;\n+    localMemberId = memberId;\n+    messageQueue.put(memberId, new LinkedList<>());\n+    servers.put(memberId, this);\n+  }\n+\n+  public void receiveNextMessage() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    if (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  public void receiveAll() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    while (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  // drop next message from the incoming queue\n+  public void dropNextMessage() {\n+    final var nextMessage =\n+        messageQueue.computeIfAbsent(localMemberId, t -> new LinkedList<>()).poll();\n+    if (nextMessage != null) {\n+      Optional.ofNullable(nextMessage.getRight())\n+          .ifPresent(\n+              f -> {\n+                LoggerFactory.getLogger(\"TEST:\")\n+                    .info(\"Dropped a message to {}\", localMemberId.id());\n+                // RaftServers excepts exceptions from the messaging layer to detect timeouts\n+                f.completeExceptionally(new TimeoutException());\n+              });\n+    }\n+  }\n+\n+  ControllableRaftServerProtocol server(final MemberId memberId) {\n+    if (partitions.contains(memberId)) {\n+      return null;\n+    }\n+    return servers.get(memberId);\n+  }\n+\n+  // Add a message to the outgoing queue\n+  private void send(\n+      final MemberId memberId,\n+      final Runnable requestHandler,\n+      final CompletableFuture responseFuture) {\n+    final var message = new Tuple<>(requestHandler, responseFuture);\n+    messageQueue.computeIfAbsent(memberId, m -> new LinkedList<>()).add(message);\n+  }\n+\n+  @Override\n+  public CompletableFuture<JoinResponse> join(final MemberId memberId, final JoinRequest request) {\n+    final var responseFuture = new CompletableFuture<JoinResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.join(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<LeaveResponse> leave(\n+      final MemberId memberId, final LeaveRequest request) {\n+    final var responseFuture = new CompletableFuture<LeaveResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.leave(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ConfigureResponse> configure(\n+      final MemberId memberId, final ConfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ConfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.configure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ReconfigureResponse> reconfigure(\n+      final MemberId memberId, final ReconfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ReconfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.reconfigure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<InstallResponse> install(\n+      final MemberId memberId, final InstallRequest request) {\n+    final var responseFuture = new CompletableFuture<InstallResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.install(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0Mzk1OA==", "bodyText": "I have the feeling we need unit tests for that \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509943958", "createdAt": "2020-10-22T07:38:56Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/protocol/ControllableRaftServerProtocol.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.protocol;\n+\n+import com.google.common.collect.Sets;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.utils.concurrent.Futures;\n+import io.zeebe.util.collection.Tuple;\n+import java.net.ConnectException;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Controllable raft server protocol. The messages are delivered only when explicitly instructed and\n+ * messages can be dropped.\n+ */\n+public class ControllableRaftServerProtocol implements RaftServerProtocol {\n+\n+  private Function<JoinRequest, CompletableFuture<JoinResponse>> joinHandler;\n+  private Function<LeaveRequest, CompletableFuture<LeaveResponse>> leaveHandler;\n+  private Function<ConfigureRequest, CompletableFuture<ConfigureResponse>> configureHandler;\n+  private Function<ReconfigureRequest, CompletableFuture<ReconfigureResponse>> reconfigureHandler;\n+  private Function<InstallRequest, CompletableFuture<InstallResponse>> installHandler;\n+  private Function<TransferRequest, CompletableFuture<TransferResponse>> transferHandler;\n+  private Function<PollRequest, CompletableFuture<PollResponse>> pollHandler;\n+  private Function<VoteRequest, CompletableFuture<VoteResponse>> voteHandler;\n+  private Function<AppendRequest, CompletableFuture<AppendResponse>> appendHandler;\n+  private final Set<MemberId> partitions = Sets.newCopyOnWriteArraySet();\n+  private final Map<MemberId, ControllableRaftServerProtocol> servers;\n+  // Incoming messages to each member\n+  private final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue;\n+  private final MemberId localMemberId;\n+\n+  public ControllableRaftServerProtocol(\n+      final MemberId memberId,\n+      final Map<MemberId, ControllableRaftServerProtocol> servers,\n+      final Map<MemberId, Queue<Tuple<Runnable, CompletableFuture>>> messageQueue) {\n+    this.servers = servers;\n+    this.messageQueue = messageQueue;\n+    localMemberId = memberId;\n+    messageQueue.put(memberId, new LinkedList<>());\n+    servers.put(memberId, this);\n+  }\n+\n+  public void receiveNextMessage() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    if (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  public void receiveAll() {\n+    final var rcvQueue = messageQueue.get(localMemberId);\n+    while (!rcvQueue.isEmpty()) {\n+      rcvQueue.poll().getLeft().run();\n+    }\n+  }\n+\n+  // drop next message from the incoming queue\n+  public void dropNextMessage() {\n+    final var nextMessage =\n+        messageQueue.computeIfAbsent(localMemberId, t -> new LinkedList<>()).poll();\n+    if (nextMessage != null) {\n+      Optional.ofNullable(nextMessage.getRight())\n+          .ifPresent(\n+              f -> {\n+                LoggerFactory.getLogger(\"TEST:\")\n+                    .info(\"Dropped a message to {}\", localMemberId.id());\n+                // RaftServers excepts exceptions from the messaging layer to detect timeouts\n+                f.completeExceptionally(new TimeoutException());\n+              });\n+    }\n+  }\n+\n+  ControllableRaftServerProtocol server(final MemberId memberId) {\n+    if (partitions.contains(memberId)) {\n+      return null;\n+    }\n+    return servers.get(memberId);\n+  }\n+\n+  // Add a message to the outgoing queue\n+  private void send(\n+      final MemberId memberId,\n+      final Runnable requestHandler,\n+      final CompletableFuture responseFuture) {\n+    final var message = new Tuple<>(requestHandler, responseFuture);\n+    messageQueue.computeIfAbsent(memberId, m -> new LinkedList<>()).add(message);\n+  }\n+\n+  @Override\n+  public CompletableFuture<JoinResponse> join(final MemberId memberId, final JoinRequest request) {\n+    final var responseFuture = new CompletableFuture<JoinResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.join(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<LeaveResponse> leave(\n+      final MemberId memberId, final LeaveRequest request) {\n+    final var responseFuture = new CompletableFuture<LeaveResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.leave(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ConfigureResponse> configure(\n+      final MemberId memberId, final ConfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ConfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.configure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<ReconfigureResponse> reconfigure(\n+      final MemberId memberId, final ReconfigureRequest request) {\n+    final var responseFuture = new CompletableFuture<ReconfigureResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.reconfigure(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+\n+  @Override\n+  public CompletableFuture<InstallResponse> install(\n+      final MemberId memberId, final InstallRequest request) {\n+    final var responseFuture = new CompletableFuture<InstallResponse>();\n+    send(\n+        memberId,\n+        () ->\n+            getServer(memberId)\n+                .thenCompose(listener -> listener.install(request))\n+                .thenAccept(\n+                    response -> send(localMemberId, () -> responseFuture.complete(response), null)),\n+        responseFuture);\n+    return responseFuture;\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0MzMwMQ=="}, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk0NDE5MA==", "bodyText": "Ok. why \ud83d\ude06", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#discussion_r509944190", "createdAt": "2020-10-22T07:39:19Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/TestSnapshotStore.java", "diffHunk": "@@ -71,7 +71,7 @@ public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n   @Override\n   public long getCurrentSnapshotIndex() {\n     if (currentPersistedSnapshot.get() == null) {\n-      return -1;\n+      return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf729ba4194edfbd54351a0aea3ba9bdfb022538"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NjU3NDAy", "url": "https://github.com/camunda-cloud/zeebe/pull/5622#pullrequestreview-515657402", "createdAt": "2020-10-23T13:18:02Z", "commit": {"oid": "0bdb0efe7822cf1ba69f703119b758185dc5ff12"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e7526ac51955ca68703593154bbbc8da306147", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/56e7526ac51955ca68703593154bbbc8da306147", "committedDate": "2020-10-23T13:21:27Z", "message": "chore(broker): add raft property tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0bdb0efe7822cf1ba69f703119b758185dc5ff12", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/0bdb0efe7822cf1ba69f703119b758185dc5ff12", "committedDate": "2020-10-22T13:40:04Z", "message": "chore(atomix): review comments"}, "afterCommit": {"oid": "56e7526ac51955ca68703593154bbbc8da306147", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/56e7526ac51955ca68703593154bbbc8da306147", "committedDate": "2020-10-23T13:21:27Z", "message": "chore(broker): add raft property tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2459, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}