{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTA1OTc5", "number": 4944, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyMDo1MVrOEOlDkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1Njo1MlrOEOl58A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzIyNjQwOnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyMDo1MVrOGxzfLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTozMDoyNVrOGx573w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njk3NQ==", "bodyText": "In this case, the request was never send to a broker. Do we want to include them in the metrics?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454876975", "createdAt": "2020-07-15T08:20:51Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxOTQ0OA==", "bodyText": "Why not? My reasoning was that it's still a failure on the gateway's part so it'd be useful to include it. But we can be more strict with what we consider a failure, if that allows us to extract more value from the graph. What's your opinion?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454919448", "createdAt": "2020-07-15T09:31:15Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njk3NQ=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3OTcwNQ==", "bodyText": "That makes sense. May be, as I mentioned in another comment, we can add the reasons for failures to the metrics. So when we want to get more detailed insight, we can filter out irrelevant failures.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454979705", "createdAt": "2020-07-15T11:24:26Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njk3NQ=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk4MjYyMw==", "bodyText": "I agree, I'll add that and post some screen shots of how it looks", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454982623", "createdAt": "2020-07-15T11:30:25Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njk3NQ=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzI0Mzc0OnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyNToxOVrOGxzpyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyNToxOVrOGxzpyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3OTY4OQ==", "bodyText": "Considering \"RESOURCE_EXHAUSTED\" as successful responses can skew the elapsedtime metrics as it is usually much smaller than a successfully processed requests.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454879689", "createdAt": "2020-07-15T08:25:19Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzI4MTcyOnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODozNTozNlrOGx0BTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMToxNToxMlrOGx5fkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NTcwOA==", "bodyText": "I'm not sure if this should be considered as successful.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454885708", "createdAt": "2020-07-15T08:35:36Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {\n+                final long elapsedTime = System.currentTimeMillis() - startTime;\n+                GatewayMetrics.registerSuccessfulRequest(\n+                    request.getPartitionId(), request.getType(), elapsedTime);\n+                return;\n+              }\n             } else {\n               returnFuture.completeExceptionally(error);\n             }\n           } catch (final RuntimeException e) {\n             returnFuture.completeExceptionally(new ClientResponseException(e));\n           }\n+\n+          GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n         });\n   }\n \n-  private <T> void handleResponse(\n+  /**\n+   * Returns true if the request was successfully processed or false, it it wasn't. Rejections and\n+   * RESOURCE_EXCEEDED errors are considered successful requests.\n+   */\n+  private <T> boolean handleResponse(\n       final BrokerResponse<T> response, final CompletableFuture<BrokerResponse<T>> responseFuture) {\n     try {\n       if (response.isResponse()) {\n         responseFuture.complete(response);\n+        return true;\n       } else if (response.isRejection()) {\n         responseFuture.completeExceptionally(new BrokerRejectionException(response.getRejection()));\n+        return true;\n       } else if (response.isError()) {\n         responseFuture.completeExceptionally(new BrokerErrorException(response.getError()));\n+\n+        if (response.getError().getCode() == ErrorCode.RESOURCE_EXHAUSTED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMDM2OA==", "bodyText": "Nicolas asked for it specifically. IIRC, the idea was that marking these as failed would show an increase in failures when a client sends too many requests, which isn't necessarily indicative of a problem in Zeebe. In this sense, including it would reduce the usefulness of have this metric. But @npepinpe, correct me if I'm wrong or misremembering", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454920368", "createdAt": "2020-07-15T09:32:52Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {\n+                final long elapsedTime = System.currentTimeMillis() - startTime;\n+                GatewayMetrics.registerSuccessfulRequest(\n+                    request.getPartitionId(), request.getType(), elapsedTime);\n+                return;\n+              }\n             } else {\n               returnFuture.completeExceptionally(error);\n             }\n           } catch (final RuntimeException e) {\n             returnFuture.completeExceptionally(new ClientResponseException(e));\n           }\n+\n+          GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n         });\n   }\n \n-  private <T> void handleResponse(\n+  /**\n+   * Returns true if the request was successfully processed or false, it it wasn't. Rejections and\n+   * RESOURCE_EXCEEDED errors are considered successful requests.\n+   */\n+  private <T> boolean handleResponse(\n       final BrokerResponse<T> response, final CompletableFuture<BrokerResponse<T>> responseFuture) {\n     try {\n       if (response.isResponse()) {\n         responseFuture.complete(response);\n+        return true;\n       } else if (response.isRejection()) {\n         responseFuture.completeExceptionally(new BrokerRejectionException(response.getRejection()));\n+        return true;\n       } else if (response.isError()) {\n         responseFuture.completeExceptionally(new BrokerErrorException(response.getError()));\n+\n+        if (response.getError().getCode() == ErrorCode.RESOURCE_EXHAUSTED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NTcwOA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODEyMg==", "bodyText": "The idea was that if we want to track the error rate, when stress testing RESOURCE_EXHAUSTED would show a system which is failing when it's behaving as expected.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454928122", "createdAt": "2020-07-15T09:46:06Z", "author": {"login": "npepinpe"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {\n+                final long elapsedTime = System.currentTimeMillis() - startTime;\n+                GatewayMetrics.registerSuccessfulRequest(\n+                    request.getPartitionId(), request.getType(), elapsedTime);\n+                return;\n+              }\n             } else {\n               returnFuture.completeExceptionally(error);\n             }\n           } catch (final RuntimeException e) {\n             returnFuture.completeExceptionally(new ClientResponseException(e));\n           }\n+\n+          GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n         });\n   }\n \n-  private <T> void handleResponse(\n+  /**\n+   * Returns true if the request was successfully processed or false, it it wasn't. Rejections and\n+   * RESOURCE_EXCEEDED errors are considered successful requests.\n+   */\n+  private <T> boolean handleResponse(\n       final BrokerResponse<T> response, final CompletableFuture<BrokerResponse<T>> responseFuture) {\n     try {\n       if (response.isResponse()) {\n         responseFuture.complete(response);\n+        return true;\n       } else if (response.isRejection()) {\n         responseFuture.completeExceptionally(new BrokerRejectionException(response.getRejection()));\n+        return true;\n       } else if (response.isError()) {\n         responseFuture.completeExceptionally(new BrokerErrorException(response.getError()));\n+\n+        if (response.getError().getCode() == ErrorCode.RESOURCE_EXHAUSTED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NTcwOA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3Mjc4Mg==", "bodyText": "My main concern is that if there are too many resource exhausted errors during a stress test, we highly underestimate average latency because resource exhausted responses will have comparatively much lower latency.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454972782", "createdAt": "2020-07-15T11:09:53Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {\n+                final long elapsedTime = System.currentTimeMillis() - startTime;\n+                GatewayMetrics.registerSuccessfulRequest(\n+                    request.getPartitionId(), request.getType(), elapsedTime);\n+                return;\n+              }\n             } else {\n               returnFuture.completeExceptionally(error);\n             }\n           } catch (final RuntimeException e) {\n             returnFuture.completeExceptionally(new ClientResponseException(e));\n           }\n+\n+          GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n         });\n   }\n \n-  private <T> void handleResponse(\n+  /**\n+   * Returns true if the request was successfully processed or false, it it wasn't. Rejections and\n+   * RESOURCE_EXCEEDED errors are considered successful requests.\n+   */\n+  private <T> boolean handleResponse(\n       final BrokerResponse<T> response, final CompletableFuture<BrokerResponse<T>> responseFuture) {\n     try {\n       if (response.isResponse()) {\n         responseFuture.complete(response);\n+        return true;\n       } else if (response.isRejection()) {\n         responseFuture.completeExceptionally(new BrokerRejectionException(response.getRejection()));\n+        return true;\n       } else if (response.isError()) {\n         responseFuture.completeExceptionally(new BrokerErrorException(response.getError()));\n+\n+        if (response.getError().getCode() == ErrorCode.RESOURCE_EXHAUSTED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NTcwOA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3NTM3Ng==", "bodyText": "We can solve both problems by ignoring them altogether. We don't count them as failures and we also don't register their latencies.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454975376", "createdAt": "2020-07-15T11:15:12Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/BrokerRequestManager.java", "diffHunk": "@@ -115,37 +116,57 @@ private static boolean responseValidation(final DirectBuffer responseContent) {\n       nodeIdProvider = determineBrokerNodeIdProvider(request);\n     } catch (final PartitionNotFoundException e) {\n       returnFuture.completeExceptionally(e);\n+      GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n       return;\n     }\n \n     final ActorFuture<DirectBuffer> responseFuture =\n         sender.send(clientTransport, nodeIdProvider, request, requestTimeout);\n+    final long startTime = System.currentTimeMillis();\n \n     actor.runOnCompletion(\n         responseFuture,\n         (clientResponse, error) -> {\n           try {\n             if (error == null) {\n               final BrokerResponse<T> response = request.getResponse(clientResponse);\n-              handleResponse(response, returnFuture);\n+\n+              if (handleResponse(response, returnFuture)) {\n+                final long elapsedTime = System.currentTimeMillis() - startTime;\n+                GatewayMetrics.registerSuccessfulRequest(\n+                    request.getPartitionId(), request.getType(), elapsedTime);\n+                return;\n+              }\n             } else {\n               returnFuture.completeExceptionally(error);\n             }\n           } catch (final RuntimeException e) {\n             returnFuture.completeExceptionally(new ClientResponseException(e));\n           }\n+\n+          GatewayMetrics.registerFailedRequest(request.getPartitionId(), request.getType());\n         });\n   }\n \n-  private <T> void handleResponse(\n+  /**\n+   * Returns true if the request was successfully processed or false, it it wasn't. Rejections and\n+   * RESOURCE_EXCEEDED errors are considered successful requests.\n+   */\n+  private <T> boolean handleResponse(\n       final BrokerResponse<T> response, final CompletableFuture<BrokerResponse<T>> responseFuture) {\n     try {\n       if (response.isResponse()) {\n         responseFuture.complete(response);\n+        return true;\n       } else if (response.isRejection()) {\n         responseFuture.completeExceptionally(new BrokerRejectionException(response.getRejection()));\n+        return true;\n       } else if (response.isError()) {\n         responseFuture.completeExceptionally(new BrokerErrorException(response.getError()));\n+\n+        if (response.getError().getCode() == ErrorCode.RESOURCE_EXHAUSTED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NTcwOA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzI4NjI5OnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODozNjo0OFrOGx0EOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo0OTo1MlrOGzM0Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NjQ1OA==", "bodyText": "TOTAL_REQUESTS should be updated when the request is send, not when the response is received. Isn't it?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454886458", "createdAt": "2020-07-15T08:36:48Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.metrics;\n+\n+import io.prometheus.client.Counter;\n+import io.prometheus.client.Histogram;\n+\n+public final class GatewayMetrics {\n+\n+  private static final Histogram REQUEST_LATENCY =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_request_latency\")\n+          .help(\"Latency of round-trip from gateway to broker\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter FAILED_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_failed_requests\")\n+          .help(\"Number of failed requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter TOTAL_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_total_requests\")\n+          .help(\"Number of requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private GatewayMetrics() {}\n+\n+  public static void registerSuccessfulRequest(\n+      final long partition, final String requestType, final long latencyMs) {\n+    REQUEST_LATENCY.labels(Long.toString(partition), requestType).observe(latencyMs / 1000f);\n+    TOTAL_REQUESTS.labels(Long.toString(partition), requestType).inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMzQ4OA==", "bodyText": "@MiguelPires What's your opinion on this?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r456303488", "createdAt": "2020-07-17T08:38:40Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.metrics;\n+\n+import io.prometheus.client.Counter;\n+import io.prometheus.client.Histogram;\n+\n+public final class GatewayMetrics {\n+\n+  private static final Histogram REQUEST_LATENCY =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_request_latency\")\n+          .help(\"Latency of round-trip from gateway to broker\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter FAILED_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_failed_requests\")\n+          .help(\"Number of failed requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter TOTAL_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_total_requests\")\n+          .help(\"Number of requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private GatewayMetrics() {}\n+\n+  public static void registerSuccessfulRequest(\n+      final long partition, final String requestType, final long latencyMs) {\n+    REQUEST_LATENCY.labels(Long.toString(partition), requestType).observe(latencyMs / 1000f);\n+    TOTAL_REQUESTS.labels(Long.toString(partition), requestType).inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NjQ1OA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMzNjI3Ng==", "bodyText": "Sorry, missed this comment before. Hm, I wouldn't expect a big difference if the rate at which incoming requests come remains steady. But it seems more useful to consider TOTAL_REQUESTS as \"all requests that were completed\" rather than \"all requests that were made including unfinished ones\". If you have a lot of requests that haven't completed then I don't think we should take them into account when calculating the failure rate, since it could heavily skew the results", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r456336276", "createdAt": "2020-07-17T09:41:41Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.metrics;\n+\n+import io.prometheus.client.Counter;\n+import io.prometheus.client.Histogram;\n+\n+public final class GatewayMetrics {\n+\n+  private static final Histogram REQUEST_LATENCY =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_request_latency\")\n+          .help(\"Latency of round-trip from gateway to broker\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter FAILED_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_failed_requests\")\n+          .help(\"Number of failed requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter TOTAL_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_total_requests\")\n+          .help(\"Number of requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private GatewayMetrics() {}\n+\n+  public static void registerSuccessfulRequest(\n+      final long partition, final String requestType, final long latencyMs) {\n+    REQUEST_LATENCY.labels(Long.toString(partition), requestType).observe(latencyMs / 1000f);\n+    TOTAL_REQUESTS.labels(Long.toString(partition), requestType).inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NjQ1OA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MDQ5NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r456340495", "createdAt": "2020-07-17T09:49:52Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.metrics;\n+\n+import io.prometheus.client.Counter;\n+import io.prometheus.client.Histogram;\n+\n+public final class GatewayMetrics {\n+\n+  private static final Histogram REQUEST_LATENCY =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_request_latency\")\n+          .help(\"Latency of round-trip from gateway to broker\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter FAILED_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_failed_requests\")\n+          .help(\"Number of failed requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter TOTAL_REQUESTS =\n+      Counter.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_total_requests\")\n+          .help(\"Number of requests\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private GatewayMetrics() {}\n+\n+  public static void registerSuccessfulRequest(\n+      final long partition, final String requestType, final long latencyMs) {\n+    REQUEST_LATENCY.labels(Long.toString(partition), requestType).observe(latencyMs / 1000f);\n+    TOTAL_REQUESTS.labels(Long.toString(partition), requestType).inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4NjQ1OA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzMzMzg3OnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/request/BrokerRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo0ODo1N1rOGx0hoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMToxMToyN1rOGx5YcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5Mzk4NA==", "bodyText": "Can we use the valueType and intent to build the request type instead of parsing the class name?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454893984", "createdAt": "2020-07-15T08:48:57Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/request/BrokerRequest.java", "diffHunk": "@@ -63,6 +65,10 @@ public void serializeValue() {\n \n   protected abstract T toResponseDto(DirectBuffer buffer);\n \n+  public String getType() {\n+    return COMMON_WORDS.matcher(this.getClass().getSimpleName()).replaceAll(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMjAxMA==", "bodyText": "The BrokerRequest doesn't have access to the valueType and intent. This was a hack around it. It's not pretty but it works for all the request types since they all follow the same format", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454922010", "createdAt": "2020-07-15T09:35:43Z", "author": {"login": "MiguelPires"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/request/BrokerRequest.java", "diffHunk": "@@ -63,6 +65,10 @@ public void serializeValue() {\n \n   protected abstract T toResponseDto(DirectBuffer buffer);\n \n+  public String getType() {\n+    return COMMON_WORDS.matcher(this.getClass().getSimpleName()).replaceAll(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5Mzk4NA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3MzU1Mg==", "bodyText": "Why not add it in BrokerExecuteCommand? All requests extends it, right? Anyway, it is just a suggestion.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454973552", "createdAt": "2020-07-15T11:11:27Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/request/BrokerRequest.java", "diffHunk": "@@ -63,6 +65,10 @@ public void serializeValue() {\n \n   protected abstract T toResponseDto(DirectBuffer buffer);\n \n+  public String getType() {\n+    return COMMON_WORDS.matcher(this.getClass().getSimpleName()).replaceAll(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5Mzk4NA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzM0NTE2OnYy", "diffSide": "RIGHT", "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1MTo1NlrOGx0orA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1MTo1NlrOGx0orA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NTc4OA==", "bodyText": "May be we can add the reasons for failure to the labels. We can then distinguish timeouts vs other failures.", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454895788", "createdAt": "2020-07-15T08:51:56Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/metrics/GatewayMetrics.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.metrics;\n+\n+import io.prometheus.client.Counter;\n+import io.prometheus.client.Histogram;\n+\n+public final class GatewayMetrics {\n+\n+  private static final Histogram REQUEST_LATENCY =\n+      Histogram.build()\n+          .namespace(\"zeebe\")\n+          .name(\"gateway_request_latency\")\n+          .help(\"Latency of round-trip from gateway to broker\")\n+          .labelNames(\"partition\", \"requestType\")\n+          .register();\n+\n+  private static final Counter FAILED_REQUESTS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzM2NTYwOnYy", "diffSide": "RIGHT", "path": "monitor/grafana/zeebe.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1Njo1MlrOGx01Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoyMDo0NlrOGx3y8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5ODk1MA==", "bodyText": "Is it necessary?", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454898950", "createdAt": "2020-07-15T08:56:52Z", "author": {"login": "deepthidevaki"}, "path": "monitor/grafana/zeebe.json", "diffHunk": "@@ -48,8 +48,8 @@\n     },\n     {\n       \"type\": \"panel\",\n-      \"id\": \"table\",\n-      \"name\": \"Table\",\n+      \"id\": \"table-old\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NzU2OA==", "bodyText": "I don't know what that is but I didn't change it by hand. I exported the dashboard in the way described in the README", "url": "https://github.com/camunda-cloud/zeebe/pull/4944#discussion_r454947568", "createdAt": "2020-07-15T10:20:46Z", "author": {"login": "MiguelPires"}, "path": "monitor/grafana/zeebe.json", "diffHunk": "@@ -48,8 +48,8 @@\n     },\n     {\n       \"type\": \"panel\",\n-      \"id\": \"table\",\n-      \"name\": \"Table\",\n+      \"id\": \"table-old\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5ODk1MA=="}, "originalCommit": {"oid": "94ae4f864ea704e9ad3756a407f4f2139fd08ab2"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 440, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}