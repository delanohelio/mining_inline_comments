{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNjI5MjI3", "number": 4713, "title": "fix(engine): check element instance before trigger timer", "bodyText": "Description\n\ntrigger timer only if the related element instance is still activated\nremove element instance on terminated\nreplace old stream processor test with new record batch style\n\nRelated issues\ncloses #4663\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-06-12T11:35:41Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4713", "merged": true, "mergeCommit": {"oid": "bccac13312eaef403e378ffd98bd68fdfaa76910"}, "closed": true, "closedAt": "2020-06-15T09:47:31Z", "author": {"login": "saig0"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqjOIkgFqTQyOTc1MTI4OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrc3TBABqjM0NDMzNjU5MjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NzUxMjg5", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#pullrequestreview-429751289", "createdAt": "2020-06-12T13:44:06Z", "commit": {"oid": "3be4d0dca9a63899495db56fb1a2099f16475c53"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo0NDowNlrOGjEdrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo1MTo1MFrOGjEvpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNjQ3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldTriggerCommandIfTimerIsTriggered() {\n          \n          \n            \n              public void shouldRejectTriggerCommandIfTimerIsTriggered() {", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r439426479", "createdAt": "2020-06-12T13:44:06Z", "author": {"login": "korthout"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/ConcurrentTimerEventTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.timer;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.engine.util.RecordToWrite;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.Assertions;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.TimerRecordValue;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.record.RecordingExporterTestWatcher;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class ConcurrentTimerEventTest {\n+\n+  @ClassRule public static final EngineRule ENGINE = EngineRule.singlePartition();\n+\n+  @Rule\n+  public final RecordingExporterTestWatcher recordingExporterTestWatcher =\n+      new RecordingExporterTestWatcher();\n+\n+  private long workflowInstanceKey;\n+  private Record<TimerRecordValue> timerCreated;\n+\n+  @Before\n+  public void setup() {\n+    ENGINE\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(\"process\")\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT10S\"))\n+                .done())\n+        .deploy();\n+\n+    workflowInstanceKey = ENGINE.workflowInstance().ofBpmnProcessId(\"process\").create();\n+\n+    timerCreated =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    ENGINE.stop();\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfTimerIsCanceled() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldTriggerCommandIfTimerIsTriggered() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3be4d0dca9a63899495db56fb1a2099f16475c53"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTA3OQ==", "bodyText": "I'm not sure I like this test. It looks like the test binds too much to the implementation. Instead of writing commands and events, I feel it would be better to only write commands and wait for something to have occurred before writing another command. For example, send the cancel command for the process, that in turn terminates the process incl the timer intermediate catch event. We wait for that to happen and then send a trigger timer command.", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r439431079", "createdAt": "2020-06-12T13:51:50Z", "author": {"login": "korthout"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/ConcurrentTimerEventTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.timer;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.engine.util.RecordToWrite;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.Assertions;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.TimerRecordValue;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.record.RecordingExporterTestWatcher;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class ConcurrentTimerEventTest {\n+\n+  @ClassRule public static final EngineRule ENGINE = EngineRule.singlePartition();\n+\n+  @Rule\n+  public final RecordingExporterTestWatcher recordingExporterTestWatcher =\n+      new RecordingExporterTestWatcher();\n+\n+  private long workflowInstanceKey;\n+  private Record<TimerRecordValue> timerCreated;\n+\n+  @Before\n+  public void setup() {\n+    ENGINE\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(\"process\")\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT10S\"))\n+                .done())\n+        .deploy();\n+\n+    workflowInstanceKey = ENGINE.workflowInstance().ofBpmnProcessId(\"process\").create();\n+\n+    timerCreated =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    ENGINE.stop();\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfTimerIsCanceled() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldTriggerCommandIfTimerIsTriggered() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldRejectCancelCommandIfTimerIsTriggered() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.CANCEL)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfElementInstanceIsLeft() {\n+    // given\n+    final var processActivated =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATED)\n+            .withElementType(BpmnElementType.PROCESS)\n+            .getFirst();\n+\n+    final var eventActivated =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATED)\n+            .withElementType(BpmnElementType.INTERMEDIATE_CATCH_EVENT)\n+            .getFirst();\n+\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .workflowInstance(WorkflowInstanceIntent.CANCEL, processActivated.getValue())\n+            .key(processActivated.getKey()),\n+        RecordToWrite.event()\n+            .workflowInstance(\n+                WorkflowInstanceIntent.ELEMENT_TERMINATING, processActivated.getValue())\n+            .key(processActivated.getKey())\n+            .causedBy(0),\n+        RecordToWrite.event()\n+            .workflowInstance(WorkflowInstanceIntent.ELEMENT_TERMINATING, eventActivated.getValue())\n+            .key(eventActivated.getKey())\n+            .causedBy(1),\n+        RecordToWrite.event()\n+            .workflowInstance(WorkflowInstanceIntent.ELEMENT_TERMINATED, eventActivated.getValue())\n+            .key(eventActivated.getKey())\n+            .causedBy(2),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3be4d0dca9a63899495db56fb1a2099f16475c53"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNDIyMjc1", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#pullrequestreview-430422275", "createdAt": "2020-06-15T08:22:49Z", "commit": {"oid": "a6175388a6b22c61a3c03cb96d9655622505d1a4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "committedDate": "2020-06-15T09:02:21Z", "message": "fix(engine): check element instance before trigger timer\n\n* trigger timer only if the related element instance is still activated\n* remove element instance on terminated\n* replace old stream processor test with new record batch style\n\nCo-authored-by: Nico Korthout <korthout@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6175388a6b22c61a3c03cb96d9655622505d1a4", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/a6175388a6b22c61a3c03cb96d9655622505d1a4", "committedDate": "2020-06-15T05:20:18Z", "message": "chore(engine): apply review suggestion\n\nCo-authored-by: Nico Korthout <korthout@users.noreply.github.com>"}, "afterCommit": {"oid": "449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "committedDate": "2020-06-15T09:02:21Z", "message": "fix(engine): check element instance before trigger timer\n\n* trigger timer only if the related element instance is still activated\n* remove element instance on terminated\n* replace old stream processor test with new record batch style\n\nCo-authored-by: Nico Korthout <korthout@users.noreply.github.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2763, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}