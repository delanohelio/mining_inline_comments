{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNDAyMzMw", "number": 4070, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNTo1ODoyOVrODpYOBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODo0OFrODp3wLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzE1MDE1OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNTo1ODoyOVrOF4hCAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzowMzoyNVrOF4tZVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNTc2MA==", "bodyText": "Hmm not sure if this is sufficient, since exceptions in the nextStep already catched. So say we have an error on write. You call onError, then try again onWrite this fails again. This will again call onError. But you will not get this in the onError method.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394805760", "createdAt": "2020-03-19T05:58:29Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java", "diffHunk": "@@ -298,12 +299,24 @@ private void onError(final Throwable processingException, final Runnable nextSte\n \n             onErrorHandling = true;\n             nextStep.run();\n+\n+            if (onErrorHandlingLoop) {\n+              onErrorHandlingLoop = false;\n+            }\n           } catch (final Exception ex) {\n+            errorHandlingFailed(ex);\n             onError(ex, nextStep);\n           }\n         });\n   }\n \n+  private void errorHandlingFailed(final Exception ex) {\n+    if (!onErrorHandlingLoop) {\n+      LOG.error(\"Encountered an exception during processing. Retrying.\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwODM0Mg==", "bodyText": "Thanks @Zelldon for this pointer.  I think I fixed it now. I have also added more test cases for this.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395008342", "createdAt": "2020-03-19T13:03:25Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java", "diffHunk": "@@ -298,12 +299,24 @@ private void onError(final Throwable processingException, final Runnable nextSte\n \n             onErrorHandling = true;\n             nextStep.run();\n+\n+            if (onErrorHandlingLoop) {\n+              onErrorHandlingLoop = false;\n+            }\n           } catch (final Exception ex) {\n+            errorHandlingFailed(ex);\n             onError(ex, nextStep);\n           }\n         });\n   }\n \n+  private void errorHandlingFailed(final Exception ex) {\n+    if (!onErrorHandlingLoop) {\n+      LOG.error(\"Encountered an exception during processing. Retrying.\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNTc2MA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzE1MzA0OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNTo1OTo1MlrOF4hDmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDoyMDoyOVrOF4wnNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA==", "bodyText": "We should probably also close the other resources right? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394806168", "createdAt": "2020-03-19T05:59:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwODU3NA==", "bodyText": "Which other resources?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395008574", "createdAt": "2020-03-19T13:03:49Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA0NDgyOQ==", "bodyText": "Idk things like this:\n  @Override\n  protected void onActorClosing() {\n    processingContext.getLogStreamReader().close();\n\n    if (onCommitPositionUpdatedCondition != null) {\n      logStream.removeOnCommitPositionUpdatedCondition(onCommitPositionUpdatedCondition);\n      onCommitPositionUpdatedCondition = null;\n    }\n  }\n\n  @Override\n  protected void onActorClosed() {\n    closeFuture.complete(null);\n    LOG.debug(\"Closed stream processor controller {}.\", getName());\n  }\n\n  @Override\n  protected void onActorCloseRequested() {\n    if (!isFailed()) {\n      lifecycleAwareListeners.forEach(StreamProcessorLifecycleAware::onClose);\n    }\n  }\n\nAlso should we introduce a new listener methods for the lifecycle listeners?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395044829", "createdAt": "2020-03-19T13:58:15Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MDk5Ng==", "bodyText": "\ud83d\ude48 my bad. Doing cleanup onActorFailed is always same as the steps in normal close. Let me see if we can do it any better here to avoid such mistakes in future.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395050996", "createdAt": "2020-03-19T14:06:54Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MTg4Ng==", "bodyText": "Also should we introduce a new listener methods for the lifecycle listeners?\n\nMay be. But is it useful? We can treat \"FAILED\" phase similar to closed, as we are doing now.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395051886", "createdAt": "2020-03-19T14:08:07Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2MTA0Ng==", "bodyText": "Ya. It would make sense to add a new listener method, or atleast make sure that onClose listener is invoked when failed. But adding a new listener method would be meaningful.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395061046", "createdAt": "2020-03-19T14:20:29Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NzE2NzQ0OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNjowNzozMlrOF4hL3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzowNTo1NVrOF4tfGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwODI4NQ==", "bodyText": "This is actually the reason why your test works with the onError loop but this doesn't reflect the real production setting. A this will never fail normally b as I wrote above your logic doesn't detect real loops between write and error or processing and error etc.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394808285", "createdAt": "2020-03-19T06:07:32Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private ZeebeState mockedZeebeState;\n+  private StreamProcessor streamProcessor;\n+  private final AtomicBoolean shouldThrowException = new AtomicBoolean(true);\n+  private final AtomicInteger invocation = new AtomicInteger();\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldThrowException.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenInErrorLoop() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              mockedZeebeState = spy(processingContext.getZeebeState());\n+              processingContext.zeebeState(mockedZeebeState);\n+              return processors(mockedZeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldThrowException.get()) {\n+                            throw new RuntimeException(\"expected\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    Mockito.doAnswer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwOTgxNw==", "bodyText": "Yes. I have now added test to cause exception in writeEvent. I couldn't find an easy way to mock failures in updateState though which can also cause an error loop.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395009817", "createdAt": "2020-03-19T13:05:55Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private ZeebeState mockedZeebeState;\n+  private StreamProcessor streamProcessor;\n+  private final AtomicBoolean shouldThrowException = new AtomicBoolean(true);\n+  private final AtomicInteger invocation = new AtomicInteger();\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldThrowException.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenInErrorLoop() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              mockedZeebeState = spy(processingContext.getZeebeState());\n+              processingContext.zeebeState(mockedZeebeState);\n+              return processors(mockedZeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldThrowException.get()) {\n+                            throw new RuntimeException(\"expected\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    Mockito.doAnswer(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwODI4NQ=="}, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODQ1MTYyOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoxNzo1MlrOF4t7OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzozNTowM1rOF4umtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzAxNw==", "bodyText": "Is there a reason why in this method it is done before calling the write in the method above after calling?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017017", "createdAt": "2020-03-19T13:17:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    shouldFlushThrowException.set(true);\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              final ZeebeState zeebeState = processingContext.getZeebeState();\n+              mockedLogStreamWriter =\n+                  new WrappedStreamWriter(processingContext.getLogStreamWriter());\n+              processingContext.zeebeState(zeebeState);\n+              processingContext.logStreamWriter(mockedLogStreamWriter);\n+              return processors(zeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldProcessingThrowException.get()) {\n+                            throw new RuntimeException(\"processing failed\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    return streamProcessor;\n+  }\n+\n+  private final class WrappedStreamWriter implements TypedStreamWriter {\n+\n+    private final TypedStreamWriter wrappedWriter;\n+\n+    private WrappedStreamWriter(final TypedStreamWriter wrappedWriter) {\n+      this.wrappedWriter = wrappedWriter;\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason) {\n+      wrappedWriter.appendRejection(command, type, reason);\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason,\n+        final Consumer<RecordMetadata> metadata) {\n+      wrappedWriter.appendRejection(command, type, reason, metadata);\n+    }\n+\n+    @Override\n+    public void appendNewEvent(final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendNewEvent(key, intent, value);\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendFollowUpEvent(key, intent, value);\n+      if (shouldFailErrorHandlingInTransaction.get()) {\n+        throw new RuntimeException(\"append followup event failed\");\n+      }\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key,\n+        final Intent intent,\n+        final UnpackedObject value,\n+        final Consumer<RecordMetadata> metadata) {\n+      if (shouldFailErrorHandlingInTransaction.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyODE0OQ==", "bodyText": "No. Just copy paste error \ud83d\ude01 It should throw exception with out invoking the actual method.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395028149", "createdAt": "2020-03-19T13:35:03Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    shouldFlushThrowException.set(true);\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              final ZeebeState zeebeState = processingContext.getZeebeState();\n+              mockedLogStreamWriter =\n+                  new WrappedStreamWriter(processingContext.getLogStreamWriter());\n+              processingContext.zeebeState(zeebeState);\n+              processingContext.logStreamWriter(mockedLogStreamWriter);\n+              return processors(zeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldProcessingThrowException.get()) {\n+                            throw new RuntimeException(\"processing failed\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    return streamProcessor;\n+  }\n+\n+  private final class WrappedStreamWriter implements TypedStreamWriter {\n+\n+    private final TypedStreamWriter wrappedWriter;\n+\n+    private WrappedStreamWriter(final TypedStreamWriter wrappedWriter) {\n+      this.wrappedWriter = wrappedWriter;\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason) {\n+      wrappedWriter.appendRejection(command, type, reason);\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason,\n+        final Consumer<RecordMetadata> metadata) {\n+      wrappedWriter.appendRejection(command, type, reason, metadata);\n+    }\n+\n+    @Override\n+    public void appendNewEvent(final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendNewEvent(key, intent, value);\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendFollowUpEvent(key, intent, value);\n+      if (shouldFailErrorHandlingInTransaction.get()) {\n+        throw new RuntimeException(\"append followup event failed\");\n+      }\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key,\n+        final Intent intent,\n+        final UnpackedObject value,\n+        final Consumer<RecordMetadata> metadata) {\n+      if (shouldFailErrorHandlingInTransaction.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzAxNw=="}, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODQ1NTY1OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoxOTowMVrOF4t92A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoxOTowMVrOF4t92A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzY4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n          \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOnWriteEventFails() {", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017688", "createdAt": "2020-03-19T13:19:01Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODQ2MjY5OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyMDo1MlrOF4uCaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzo0NTo0NFrOF4vDyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ==", "bodyText": "i think this is not different to the other processing exception or?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395018859", "createdAt": "2020-03-19T13:20:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzMTA2NA==", "bodyText": "When processing fails, it goes to error handling. It should fail again in errorHandlingInTransaction. This test checks that particular error path. The other test tests when 'errorHandlingInTransaction' succeeds, but the next step writeEvent fails.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395031064", "createdAt": "2020-03-19T13:39:30Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ=="}, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzNTU5NQ==", "bodyText": "aaah get it - since error events also appended ok makes sense", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395035595", "createdAt": "2020-03-19T13:45:44Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ=="}, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjMxMzU1OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODowMlrOF5T_5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNDoyOToxNlrOF5WA3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg==", "bodyText": "shouldnt this log be a level higher in the actor class?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395640806", "createdAt": "2020-03-20T13:38:02Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTQ0Ng==", "bodyText": "We have a log in the actor class. But it says, \"actor continue with the next job.\" But here we are not continuing with next jobs, but want to log that it failed.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395649446", "createdAt": "2020-03-20T13:51:32Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MjQyNg==", "bodyText": "I thought we don't want to continue anymore \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395652426", "createdAt": "2020-03-20T13:56:05Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MzcwMA==", "bodyText": "Default behavior is we continue, unless the actor decides to fail by overriding 'handleFailure()`", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395653700", "createdAt": "2020-03-20T13:58:00Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1NDYyMg==", "bodyText": "#4009 (comment)", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395654622", "createdAt": "2020-03-20T13:59:24Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MzgyMQ==", "bodyText": "sorry", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395673821", "createdAt": "2020-03-20T14:29:16Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjMxNjYzOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODo0OFrOF5UB3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODo0OFrOF5UB3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTMxMQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395641311", "createdAt": "2020-03-20T13:38:48Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -269,12 +275,13 @@ private void onRecovered() {\n   }\n \n   private void onFailure(final Throwable throwable) {\n-    phase = Phase.FAILED;\n-    openFuture.completeExceptionally(throwable);\n-    closeFuture = new CompletableActorFuture<>();\n-    isOpened.set(false);\n-    failureListener.onFailure();\n-    actor.close();\n+    actor.fail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4927, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}