{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMjk3NDI0", "number": 5388, "title": "Update acknowledged position of up to date exporters when skipping records", "bodyText": "Description\nThis PR fixes an issue where the last exported position was never updated if all subsequent records were skipped by the ExporterDirector. The fix is to keep track of the last unacknowledged position of an exporter - that is, the position of the last record which was passed on via Exporter#export(Record<?>). When skipping a record (either because all exporters are filtering it out, or because a single one is), iff the exporter's last acknowledged position is greater than or equal to its last unacknowledged position, and the position of the record to be skipped is greater than the last acknowledged position, then we can safely increase the last acknowledged position to the new value. This is safe to do as we know that there are no unacknowledged records between the last acknowledged one, and the one we're about to skip.\nRelated issues\ncloses #3166\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-09-21T13:28:39Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5388", "merged": true, "mergeCommit": {"oid": "7ac85a78d23bd7d28c2b4f0271de585deae887ac"}, "closed": true, "closedAt": "2020-09-25T15:03:52Z", "author": {"login": "npepinpe"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLDeIrAFqTQ5MjYwNDAyMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMWvVCABqjM4MDgwMjE5MjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNjA0MDIx", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#pullrequestreview-492604021", "createdAt": "2020-09-21T13:33:02Z", "commit": {"oid": "0dd4291d68a8b3d453a00135707462390469437a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzozMzowMlrOHVQL4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzozMzowMlrOHVQL4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzMzMA==", "bodyText": "If you remember why we're catching throwable and not exception then I'll gladly revert, otherwise this is just strange to me.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492047330", "createdAt": "2020-09-21T13:33:02Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/exporter/stream/ExporterDirector.java", "diffHunk": "@@ -129,7 +132,7 @@ protected void onActorStarted() {\n       eventFilter = createEventFilter(containers);\n       LOG.debug(\"Set event filter for exporters: {}\", eventFilter);\n \n-    } catch (final Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dd4291d68a8b3d453a00135707462390469437a"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dd4291d68a8b3d453a00135707462390469437a", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/0dd4291d68a8b3d453a00135707462390469437a", "committedDate": "2020-09-21T13:17:03Z", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position"}, "afterCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/b5d9909bb2054a860d439e928ee8aeb4be53b776", "committedDate": "2020-09-21T14:35:01Z", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMTMxOTIy", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#pullrequestreview-493131922", "createdAt": "2020-09-22T05:16:48Z", "commit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNToxNjo0OFrOHVqftA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODowMjo1NlrOHVugIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3ODM4OA==", "bodyText": "No. I see no reason why we should catch Throwable \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492478388", "createdAt": "2020-09-22T05:16:48Z", "author": {"login": "saig0"}, "path": "broker/src/main/java/io/zeebe/broker/exporter/stream/ExporterDirector.java", "diffHunk": "@@ -129,7 +132,7 @@ protected void onActorStarted() {\n       eventFilter = createEventFilter(containers);\n       LOG.debug(\"Set event filter for exporters: {}\", eventFilter);\n \n-    } catch (final Throwable e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzMzMA=="}, "originalCommit": {"oid": "0dd4291d68a8b3d453a00135707462390469437a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxNzk0Mw==", "bodyText": "Using the first exporter may lead to a flaky test because the second exporter may haven't seen the record yet.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492517943", "createdAt": "2020-09-22T07:13:16Z", "author": {"login": "saig0"}, "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxOTkzOA==", "bodyText": "I think it would be more readable and realistic to wait until the exporter saw the record before updating its position. To wait until the exporter is opened looks a bit confusing.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492519938", "createdAt": "2020-09-22T07:17:28Z", "author": {"login": "saig0"}, "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyNDcxMg==", "bodyText": "Again, using the first exporter may lead to a flaky test because the second exporter may haven't seen the record yet.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492524712", "createdAt": "2020-09-22T07:26:59Z", "author": {"login": "saig0"}, "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);\n+    // skipped entirely\n+    final long skippedRecordPosition =\n+        rule.writeCommand(IncidentIntent.CREATE, new IncidentRecord());\n+    // accepted by both again\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfSkippingInitialRecordForSingleExporter() {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+\n+    // skipped only by filteringExporter\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    // accepted by both\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyODIxNw==", "bodyText": "Same as before, I would prefer to wait until the record is read before updating the position.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492528217", "createdAt": "2020-09-22T07:34:12Z", "author": {"login": "saig0"}, "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);\n+    // skipped entirely\n+    final long skippedRecordPosition =\n+        rule.writeCommand(IncidentIntent.CREATE, new IncidentRecord());\n+    // accepted by both again\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfSkippingInitialRecordForSingleExporter() {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+\n+    // skipped only by filteringExporter\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    // accepted by both\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfRecordSkipsSingleUpToDateExporter() throws InterruptedException {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0NDAzNA==", "bodyText": "These IT tests look complicated and just not right \ud83d\ude48\nHowever, I don't have a better idea for now.", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492544034", "createdAt": "2020-09-22T08:02:56Z", "author": {"login": "saig0"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/SingleBrokerDataDeletionTest.java", "diffHunk": "@@ -58,6 +67,100 @@ private void configureCustomExporter(final BrokerCfg brokerCfg) {\n     brokerCfg.setExporters(Collections.singletonMap(\"snapshot-test-exporter\", exporterCfg));\n   }\n \n+  @Test\n+  public void shouldCompactEvenIfSkippingAllRecords() {\n+    // given\n+    final Broker broker = clusteringRule.getBroker(0);\n+\n+    // when\n+    ControllableExporter.updatePosition(false);\n+    ControllableExporter.RECORD_TYPE_FILTER.set(r -> r == RecordType.COMMAND);\n+    ControllableExporter.VALUE_TYPE_FILTER.set(r -> r == ValueType.DEPLOYMENT);\n+    writeSegments(broker, 2);\n+    clusteringRule\n+        .getClient()\n+        .newDeployCommand()\n+        .addWorkflowModel(\n+            Bpmn.createExecutableProcess(\"process\").startEvent().done(), \"process.bpmn\")\n+        .send()\n+        .join();\n+    await(\"until at least one record is exported\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(\n+            () -> assertThat(ControllableExporter.EXPORTED_RECORDS).hasValueGreaterThan(0));\n+\n+    // enforce compaction\n+    final var segmentsBeforeSnapshot = getSegmentsCount(broker);\n+    clusteringRule.getClock().addTime(SNAPSHOT_PERIOD);\n+\n+    // then\n+    assertThat(clusteringRule.waitForSnapshotAtBroker(broker)).isNotNull();\n+    await()\n+        .untilAsserted(\n+            () ->\n+                assertThat(getSegmentsCount(broker))\n+                    .describedAs(\"Expected less segments after a snapshot is taken\")\n+                    .isLessThan(segmentsBeforeSnapshot));\n+  }\n+\n+  @Test\n+  public void shouldNotCompactUnacknowledgedEventsEvenIfSkipping() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTk1MzA5", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#pullrequestreview-495195309", "createdAt": "2020-09-24T03:32:20Z", "commit": {"oid": "ac40defd421f187b023aea7d30c8ebe0ac3276d4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "committedDate": "2020-09-25T14:33:47Z", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac40defd421f187b023aea7d30c8ebe0ac3276d4", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ac40defd421f187b023aea7d30c8ebe0ac3276d4", "committedDate": "2020-09-23T13:04:46Z", "message": "chore(broker): apply review feedback"}, "afterCommit": {"oid": "119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "committedDate": "2020-09-25T14:33:47Z", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2513, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}