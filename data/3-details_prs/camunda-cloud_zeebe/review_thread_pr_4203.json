{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2ODc5OTEz", "number": 4203, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzoyOTozMVrODt1FUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTo0ODoxN1rODubw0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzgyMjI3OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzoyOTozMVrOF_elmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzo0Nzo0NFrOF_fKMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA==", "bodyText": "I did not understand the intention of this test. The name says no processor process event, but there is a processor processing the event. \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402105754", "createdAt": "2020-04-02T07:29:31Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -578,16 +587,25 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTg4Mg==", "bodyText": "The name is misleading, true; what it means is that between an open/close of the processor, even if we didn't process an event, on close we still snapshot.\nYou can see we process the event then close, then re-open the processor. This is because we don't take snapshots if we have never processed anything (i.e. if the last processed position is -1) - to support \"empty\" snapshots (e.g. index -1), we'd need to refactor Atomix more, so skipping at -1 seemed simpler. We can challenge that.\nIn the mean time, we can find a better name, any ideas?", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402111882", "createdAt": "2020-04-02T07:41:47Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -578,16 +587,25 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}, "originalCommit": {"oid": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExNDQ3MQ==", "bodyText": "It sounds like shouldNotCreateSnapshotIfNoProcessorProcessEvent().", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402114471", "createdAt": "2020-04-02T07:46:38Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -578,16 +587,25 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}, "originalCommit": {"oid": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExNTEyMA==", "bodyText": "But we want to test that it does create one \ud83d\ude05 Let's just quickly clear it up on Zoom\nI think I wasn't clear on my explanation \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r402115120", "createdAt": "2020-04-02T07:47:44Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -578,16 +587,25 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() {\n+  public void shouldCreateSnapshotsEvenIfNoProcessorProcessEvent() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNTc1NA=="}, "originalCommit": {"oid": "b5bebfd3293c3559a1715b8f217b3ce8595a27e7"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDE1OTUzOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTo0ODoxN1rOGAbQUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzoxMTo0OVrOGAe0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA5OTcyOQ==", "bodyText": "This log statement can be removed.", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r403099729", "createdAt": "2020-04-03T15:48:17Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -731,31 +693,56 @@ public void processRecord(\n   }\n \n   @Test\n-  public void shouldInvokeOnProcessedListener() throws InterruptedException {\n+  public void shouldInvokeOnProcessedListener() throws InterruptedException, TimeoutException {\n     // given\n-    final CountDownLatch processLatch = new CountDownLatch(1);\n+    final var onProcessedListener = new AwaitableProcessedListener();\n     streamProcessorRule.startTypedStreamProcessor(\n         (processors, context) ->\n             processors.onEvent(\n                 ValueType.WORKFLOW_INSTANCE,\n                 WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                new TypedRecordProcessor<UnifiedRecordValue>() {\n-                  @Override\n-                  public void processRecord(\n-                      final long position,\n-                      final TypedRecord<UnifiedRecordValue> record,\n-                      final TypedResponseWriter responseWriter,\n-                      final TypedStreamWriter streamWriter,\n-                      final Consumer<SideEffectProducer> sideEffect) {\n-                    processLatch.countDown();\n-                  }\n-                }));\n+                mock(TypedRecordProcessor.class)),\n+        onProcessedListener.expect(1));\n \n     // when\n-    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processLatch.await();\n+    final var position =\n+        streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n \n     // then\n-    verify(streamProcessorRule.getProcessedListener(), timeout(1000).times(1)).accept(any());\n+    onProcessedListener.await();\n+    assertThat(onProcessedListener.lastProcessedRecord.getPosition()).isEqualTo(position);\n+  }\n+\n+  /**\n+   * A simple listener which allows you to wait for specific amount of records to be processed.\n+   *\n+   * <p>As it uses a phaser internally, you must always call {@link #expect(int)} before {@link\n+   * #accept(TypedRecord)}}!\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  private static final class AwaitableProcessedListener implements Consumer<TypedRecord> {\n+    private static final Duration TIMEOUT = Duration.ofSeconds(5);\n+    private final Phaser phaser = new Phaser();\n+\n+    private int expectedPhase = -1;\n+    private TypedRecord lastProcessedRecord;\n+\n+    private AwaitableProcessedListener() {}\n+\n+    @Override\n+    public void accept(final TypedRecord typedRecord) {\n+      phaser.arrive();\n+      lastProcessedRecord = typedRecord;\n+    }\n+\n+    private AwaitableProcessedListener expect(final int expectedCount) {\n+      expectedPhase = phaser.bulkRegister(expectedCount);\n+      return this;\n+    }\n+\n+    private void await() throws TimeoutException, InterruptedException {\n+      Loggers.LOGSTREAMS_LOGGER.info(\"Expected phase: {}\", expectedPhase);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c584c3be8a2a675f08d6dfc2201a199704e741"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1ODA2Ng==", "bodyText": "Oops, yes \ud83d\ude48", "url": "https://github.com/camunda-cloud/zeebe/pull/4203#discussion_r403158066", "createdAt": "2020-04-03T17:11:49Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -731,31 +693,56 @@ public void processRecord(\n   }\n \n   @Test\n-  public void shouldInvokeOnProcessedListener() throws InterruptedException {\n+  public void shouldInvokeOnProcessedListener() throws InterruptedException, TimeoutException {\n     // given\n-    final CountDownLatch processLatch = new CountDownLatch(1);\n+    final var onProcessedListener = new AwaitableProcessedListener();\n     streamProcessorRule.startTypedStreamProcessor(\n         (processors, context) ->\n             processors.onEvent(\n                 ValueType.WORKFLOW_INSTANCE,\n                 WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n-                new TypedRecordProcessor<UnifiedRecordValue>() {\n-                  @Override\n-                  public void processRecord(\n-                      final long position,\n-                      final TypedRecord<UnifiedRecordValue> record,\n-                      final TypedResponseWriter responseWriter,\n-                      final TypedStreamWriter streamWriter,\n-                      final Consumer<SideEffectProducer> sideEffect) {\n-                    processLatch.countDown();\n-                  }\n-                }));\n+                mock(TypedRecordProcessor.class)),\n+        onProcessedListener.expect(1));\n \n     // when\n-    streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n-    processLatch.await();\n+    final var position =\n+        streamProcessorRule.writeWorkflowInstanceEvent(WorkflowInstanceIntent.ELEMENT_ACTIVATING);\n \n     // then\n-    verify(streamProcessorRule.getProcessedListener(), timeout(1000).times(1)).accept(any());\n+    onProcessedListener.await();\n+    assertThat(onProcessedListener.lastProcessedRecord.getPosition()).isEqualTo(position);\n+  }\n+\n+  /**\n+   * A simple listener which allows you to wait for specific amount of records to be processed.\n+   *\n+   * <p>As it uses a phaser internally, you must always call {@link #expect(int)} before {@link\n+   * #accept(TypedRecord)}}!\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  private static final class AwaitableProcessedListener implements Consumer<TypedRecord> {\n+    private static final Duration TIMEOUT = Duration.ofSeconds(5);\n+    private final Phaser phaser = new Phaser();\n+\n+    private int expectedPhase = -1;\n+    private TypedRecord lastProcessedRecord;\n+\n+    private AwaitableProcessedListener() {}\n+\n+    @Override\n+    public void accept(final TypedRecord typedRecord) {\n+      phaser.arrive();\n+      lastProcessedRecord = typedRecord;\n+    }\n+\n+    private AwaitableProcessedListener expect(final int expectedCount) {\n+      expectedPhase = phaser.bulkRegister(expectedCount);\n+      return this;\n+    }\n+\n+    private void await() throws TimeoutException, InterruptedException {\n+      Loggers.LOGSTREAMS_LOGGER.info(\"Expected phase: {}\", expectedPhase);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA5OTcyOQ=="}, "originalCommit": {"oid": "41c584c3be8a2a675f08d6dfc2201a199704e741"}, "originalPosition": 415}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4831, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}