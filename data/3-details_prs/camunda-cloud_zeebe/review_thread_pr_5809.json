{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5MDcyNTk0", "number": 5809, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozMzowMVrOE4nLnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo1MToxMlrOE4njyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk3NjYzOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozMzowMVrOHypF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODozMDo0NVrOH0pj1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDEwNA==", "bodyText": "ioe?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522864104", "createdAt": "2020-11-13T10:33:01Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -332,11 +332,17 @@ public void onDiskSpaceAvailable() {\n     final CompletableActorFuture<Void> completed = new CompletableActorFuture<>();\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(true);\n-          if (context.getStreamProcessor() != null) {\n-            context.getStreamProcessor().pauseProcessing().onComplete(completed);\n-          } else {\n-            completed.complete(null);\n+          try {\n+            context.setProcessingPaused(true);\n+\n+            if (context.getStreamProcessor() != null && !context.shouldProcess()) {\n+              context.getStreamProcessor().pauseProcessing().onComplete(completed);\n+            } else {\n+              completed.complete(null);\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3Mjc2OA==", "bodyText": "What happens then ? Do we return an error?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522872768", "createdAt": "2020-11-13T10:49:19Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -332,11 +332,17 @@ public void onDiskSpaceAvailable() {\n     final CompletableActorFuture<Void> completed = new CompletableActorFuture<>();\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(true);\n-          if (context.getStreamProcessor() != null) {\n-            context.getStreamProcessor().pauseProcessing().onComplete(completed);\n-          } else {\n-            completed.complete(null);\n+          try {\n+            context.setProcessingPaused(true);\n+\n+            if (context.getStreamProcessor() != null && !context.shouldProcess()) {\n+              context.getStreamProcessor().pauseProcessing().onComplete(completed);\n+            } else {\n+              completed.complete(null);\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDEwNA=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3Nzk2Mg==", "bodyText": "The returned future is completed exceptionally. But the api to pause processing is async, so it is not returned to the client.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r523977962", "createdAt": "2020-11-16T08:47:47Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -332,11 +332,17 @@ public void onDiskSpaceAvailable() {\n     final CompletableActorFuture<Void> completed = new CompletableActorFuture<>();\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(true);\n-          if (context.getStreamProcessor() != null) {\n-            context.getStreamProcessor().pauseProcessing().onComplete(completed);\n-          } else {\n-            completed.complete(null);\n+          try {\n+            context.setProcessingPaused(true);\n+\n+            if (context.getStreamProcessor() != null && !context.shouldProcess()) {\n+              context.getStreamProcessor().pauseProcessing().onComplete(completed);\n+            } else {\n+              completed.complete(null);\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDEwNA=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0NzA0MA==", "bodyText": "async means you could complete it right with the error right? But might make it to complex idk", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r524947040", "createdAt": "2020-11-17T07:58:40Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -332,11 +332,17 @@ public void onDiskSpaceAvailable() {\n     final CompletableActorFuture<Void> completed = new CompletableActorFuture<>();\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(true);\n-          if (context.getStreamProcessor() != null) {\n-            context.getStreamProcessor().pauseProcessing().onComplete(completed);\n-          } else {\n-            completed.complete(null);\n+          try {\n+            context.setProcessingPaused(true);\n+\n+            if (context.getStreamProcessor() != null && !context.shouldProcess()) {\n+              context.getStreamProcessor().pauseProcessing().onComplete(completed);\n+            } else {\n+              completed.complete(null);\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDEwNA=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk2ODkxNg==", "bodyText": "Yes. It is completed with error. But the actuators that call this method does not wait for the future. It is just trigger and go.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r524968916", "createdAt": "2020-11-17T08:30:45Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -332,11 +332,17 @@ public void onDiskSpaceAvailable() {\n     final CompletableActorFuture<Void> completed = new CompletableActorFuture<>();\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(true);\n-          if (context.getStreamProcessor() != null) {\n-            context.getStreamProcessor().pauseProcessing().onComplete(completed);\n-          } else {\n-            completed.complete(null);\n+          try {\n+            context.setProcessingPaused(true);\n+\n+            if (context.getStreamProcessor() != null && !context.shouldProcess()) {\n+              context.getStreamProcessor().pauseProcessing().onComplete(completed);\n+            } else {\n+              completed.complete(null);\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDEwNA=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk3NzQyOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozMzoxOFrOHypGbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODo0ODoyMFrOHztGJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDIzNw==", "bodyText": "ioe?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522864237", "createdAt": "2020-11-13T10:33:18Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -345,9 +351,13 @@ public void onDiskSpaceAvailable() {\n   public void resumeProcessing() {\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(false);\n-          if (context.getStreamProcessor() != null && context.shouldProcess()) {\n-            context.getStreamProcessor().resumeProcessing();\n+          try {\n+            context.setProcessingPaused(false);\n+            if (context.getStreamProcessor() != null && context.shouldProcess()) {\n+              context.getStreamProcessor().resumeProcessing();\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MjgyMA==", "bodyText": "What happens then ? Do we return an error?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522872820", "createdAt": "2020-11-13T10:49:22Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -345,9 +351,13 @@ public void onDiskSpaceAvailable() {\n   public void resumeProcessing() {\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(false);\n-          if (context.getStreamProcessor() != null && context.shouldProcess()) {\n-            context.getStreamProcessor().resumeProcessing();\n+          try {\n+            context.setProcessingPaused(false);\n+            if (context.getStreamProcessor() != null && context.shouldProcess()) {\n+              context.getStreamProcessor().resumeProcessing();\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDIzNw=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3ODI3OA==", "bodyText": "Same as above. The api to resume processing is async, so the error is not returned to the client.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r523978278", "createdAt": "2020-11-16T08:48:20Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -345,9 +351,13 @@ public void onDiskSpaceAvailable() {\n   public void resumeProcessing() {\n     actor.call(\n         () -> {\n-          context.setProcessingPaused(false);\n-          if (context.getStreamProcessor() != null && context.shouldProcess()) {\n-            context.getStreamProcessor().resumeProcessing();\n+          try {\n+            context.setProcessingPaused(false);\n+            if (context.getStreamProcessor() != null && context.shouldProcess()) {\n+              context.getStreamProcessor().resumeProcessing();\n+            }\n+          } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NDIzNw=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk5MzQ3OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozODowM1rOHypP_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODo1MTo0MlrOHztPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NjY4Nw==", "bodyText": "what is this \ud83d\udc40", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522866687", "createdAt": "2020-11-13T10:38:03Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;\n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";\n+  private boolean isProcessingPaused;\n+  private final RaftPartition raftPartition;\n+  private boolean diskSpaceAvailable;\n+\n+  public PartitionProcessingState(final RaftPartition raftPartition) {\n+    this.raftPartition = raftPartition;\n+    initProcessingStatus();\n+  }\n+\n+  public boolean isDiskSpaceAvailable() {\n+    return diskSpaceAvailable;\n+  }\n+\n+  public void setDiskSpaceAvailable(final boolean diskSpaceAvailable) {\n+    this.diskSpaceAvailable = diskSpaceAvailable;\n+  }\n+\n+  public boolean isProcessingPaused() {\n+    return isProcessingPaused;\n+  }\n+\n+  @SuppressWarnings({\"squid:S899\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk4MDcwOQ==", "bodyText": "Sonar complains that the returned value of createNewFile is not used. We are checking if the file exists in the next line.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r523980709", "createdAt": "2020-11-16T08:51:42Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;\n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";\n+  private boolean isProcessingPaused;\n+  private final RaftPartition raftPartition;\n+  private boolean diskSpaceAvailable;\n+\n+  public PartitionProcessingState(final RaftPartition raftPartition) {\n+    this.raftPartition = raftPartition;\n+    initProcessingStatus();\n+  }\n+\n+  public boolean isDiskSpaceAvailable() {\n+    return diskSpaceAvailable;\n+  }\n+\n+  public void setDiskSpaceAvailable(final boolean diskSpaceAvailable) {\n+    this.diskSpaceAvailable = diskSpaceAvailable;\n+  }\n+\n+  public boolean isProcessingPaused() {\n+    return isProcessingPaused;\n+  }\n+\n+  @SuppressWarnings({\"squid:S899\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NjY4Nw=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk5NDMzOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozODoxOFrOHypQhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozODoxOFrOHypQhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NjgyMw==", "bodyText": "why we have this twice?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522866823", "createdAt": "2020-11-13T10:38:18Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;\n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk5NzE5OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozOToyMFrOHypSXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozOToyMFrOHypSXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NzI5Mw==", "bodyText": "Would like to have two methods here. One is pause processing which does the first branch and another for resume processing which does the second.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522867293", "createdAt": "2020-11-13T10:39:20Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;\n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";\n+  private boolean isProcessingPaused;\n+  private final RaftPartition raftPartition;\n+  private boolean diskSpaceAvailable;\n+\n+  public PartitionProcessingState(final RaftPartition raftPartition) {\n+    this.raftPartition = raftPartition;\n+    initProcessingStatus();\n+  }\n+\n+  public boolean isDiskSpaceAvailable() {\n+    return diskSpaceAvailable;\n+  }\n+\n+  public void setDiskSpaceAvailable(final boolean diskSpaceAvailable) {\n+    this.diskSpaceAvailable = diskSpaceAvailable;\n+  }\n+\n+  public boolean isProcessingPaused() {\n+    return isProcessingPaused;\n+  }\n+\n+  @SuppressWarnings({\"squid:S899\"})\n+  public void setProcessingPaused(final boolean processingPaused) throws IOException {\n+    final File persistedPauseState = getPersistedPauseState();\n+    if (processingPaused) {\n+      persistedPauseState.createNewFile();\n+      if (persistedPauseState.exists()) {\n+        isProcessingPaused = processingPaused;\n+      }\n+    } else {\n+      Files.deleteIfExists(persistedPauseState.toPath());\n+      if (!persistedPauseState.exists()) {\n+        isProcessingPaused = processingPaused;\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODAxODI0OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0NToyNVrOHypfIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0NToyNVrOHypfIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MDU2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final Logger LOG = Loggers.SYSTEM_LOGGER;", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522870561", "createdAt": "2020-11-13T10:45:25Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODAyNTQxOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0NzozNlrOHypjcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0NzozNlrOHypjcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MTY2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final boolean pauseProcessing = getPersistedPauseState().exists();\n          \n          \n            \n                isProcessingPaused = pauseProcessing;\n          \n          \n            \n                isProcessingPaused = getPersistedPauseState().exists();", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522871665", "createdAt": "2020-11-13T10:47:36Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionProcessingState.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.partition.RaftPartition;\n+import io.zeebe.broker.Loggers;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import org.slf4j.Logger;\n+\n+public class PartitionProcessingState {\n+\n+  public static final Logger LOG = Loggers.SYSTEM_LOGGER;\n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";\n+  private boolean isProcessingPaused;\n+  private final RaftPartition raftPartition;\n+  private boolean diskSpaceAvailable;\n+\n+  public PartitionProcessingState(final RaftPartition raftPartition) {\n+    this.raftPartition = raftPartition;\n+    initProcessingStatus();\n+  }\n+\n+  public boolean isDiskSpaceAvailable() {\n+    return diskSpaceAvailable;\n+  }\n+\n+  public void setDiskSpaceAvailable(final boolean diskSpaceAvailable) {\n+    this.diskSpaceAvailable = diskSpaceAvailable;\n+  }\n+\n+  public boolean isProcessingPaused() {\n+    return isProcessingPaused;\n+  }\n+\n+  @SuppressWarnings({\"squid:S899\"})\n+  public void setProcessingPaused(final boolean processingPaused) throws IOException {\n+    final File persistedPauseState = getPersistedPauseState();\n+    if (processingPaused) {\n+      persistedPauseState.createNewFile();\n+      if (persistedPauseState.exists()) {\n+        isProcessingPaused = processingPaused;\n+      }\n+    } else {\n+      Files.deleteIfExists(persistedPauseState.toPath());\n+      if (!persistedPauseState.exists()) {\n+        isProcessingPaused = processingPaused;\n+      }\n+    }\n+  }\n+\n+  private File getPersistedPauseState() {\n+    return raftPartition.dataDirectory().toPath().resolve(PERSISTED_PAUSE_STATE_FILENAME).toFile();\n+  }\n+\n+  private void initProcessingStatus() {\n+    final boolean pauseProcessing = getPersistedPauseState().exists();\n+    isProcessingPaused = pauseProcessing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODAyNzY1OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/PartitionContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0ODoxNlrOHypkxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo0ODoxNlrOHypkxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MjAwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522872006", "createdAt": "2020-11-13T10:48:16Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/PartitionContext.java", "diffHunk": "@@ -27,11 +28,13 @@\n import io.zeebe.util.sched.ActorControl;\n import io.zeebe.util.sched.ActorScheduler;\n import io.zeebe.util.sched.ScheduledTimer;\n+import java.io.IOException;\n import java.util.Collections;\n import java.util.List;\n \n public class PartitionContext {\n \n+  private static final String PERSISTED_PAUSE_STATE_FILENAME = \".paused\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODAzODQ4OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/system/BrokerAdminServiceClusterTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDo1MToxMlrOHyprmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwODozMjoxMlrOH0pnaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3Mzc1Mg==", "bodyText": "How do we know that 1 is the leader?", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r522873752", "createdAt": "2020-11-13T10:51:12Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/system/BrokerAdminServiceClusterTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.system;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.RaftServer.Role;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.clustering.ClusteringRule;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.management.BrokerAdminService;\n+import io.zeebe.broker.system.management.PartitionStatus;\n+import io.zeebe.engine.processing.streamprocessor.StreamProcessor.Phase;\n+import java.time.Duration;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.Timeout;\n+\n+public class BrokerAdminServiceClusterTest {\n+\n+  private final Timeout testTimeout = Timeout.seconds(60);\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(\n+          1,\n+          3,\n+          3,\n+          cfg -> {\n+            cfg.getData().setLogIndexDensity(1);\n+            cfg.getData().setSnapshotPeriod(Duration.ofMinutes(15));\n+          });\n+  private final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(testTimeout).around(clusteringRule).around(clientRule);\n+\n+  private BrokerAdminService leaderAdminService;\n+  private Broker leader;\n+\n+  @Before\n+  public void before() {\n+    leader = clusteringRule.getBroker(clusteringRule.getLeaderForPartition(1).getNodeId());\n+    leaderAdminService = leader.getBrokerAdminService();\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusOnFollowersAndLeader() {\n+    // given\n+    final var followers =\n+        clusteringRule.getOtherBrokerObjects(clusteringRule.getLeaderForPartition(1).getNodeId());\n+\n+    // when\n+    final var followerStatus =\n+        followers.stream()\n+            .map(Broker::getBrokerAdminService)\n+            .map(BrokerAdminService::getPartitionStatus)\n+            .map(status -> status.get(1));\n+\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);\n+\n+    // then\n+    followerStatus.forEach(\n+        partitionStatus -> {\n+          assertThat(partitionStatus.getRole()).isEqualTo(Role.FOLLOWER);\n+          assertThat(partitionStatus.getProcessedPosition()).isNull();\n+          assertThat(partitionStatus.getSnapshotId()).isNull();\n+          assertThat(partitionStatus.getProcessedPositionInSnapshot()).isNull();\n+          assertThat(partitionStatus.getStreamProcessorPhase()).isNull();\n+        });\n+\n+    assertThat(leaderStatus.getRole()).isEqualTo(Role.LEADER);\n+    assertThat(leaderStatus.getProcessedPosition()).isEqualTo(-1);\n+    assertThat(leaderStatus.getSnapshotId()).isNull();\n+    assertThat(leaderStatus.getProcessedPositionInSnapshot()).isNull();\n+    assertThat(leaderStatus.getStreamProcessorPhase()).isEqualTo(Phase.PROCESSING);\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusWithSnapshotOnFollowers() {\n+    // given\n+    clientRule.createSingleJob(\"test\");\n+    leaderAdminService.takeSnapshot();\n+\n+    // when\n+    waitForSnapshotAtBroker(leaderAdminService);\n+\n+    // then\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk4MjU2MA==", "bodyText": "1 is the partitionId. It is getting the status of partition 1.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r523982560", "createdAt": "2020-11-16T08:53:23Z", "author": {"login": "deepthidevaki"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/system/BrokerAdminServiceClusterTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.system;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.RaftServer.Role;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.clustering.ClusteringRule;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.management.BrokerAdminService;\n+import io.zeebe.broker.system.management.PartitionStatus;\n+import io.zeebe.engine.processing.streamprocessor.StreamProcessor.Phase;\n+import java.time.Duration;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.Timeout;\n+\n+public class BrokerAdminServiceClusterTest {\n+\n+  private final Timeout testTimeout = Timeout.seconds(60);\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(\n+          1,\n+          3,\n+          3,\n+          cfg -> {\n+            cfg.getData().setLogIndexDensity(1);\n+            cfg.getData().setSnapshotPeriod(Duration.ofMinutes(15));\n+          });\n+  private final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(testTimeout).around(clusteringRule).around(clientRule);\n+\n+  private BrokerAdminService leaderAdminService;\n+  private Broker leader;\n+\n+  @Before\n+  public void before() {\n+    leader = clusteringRule.getBroker(clusteringRule.getLeaderForPartition(1).getNodeId());\n+    leaderAdminService = leader.getBrokerAdminService();\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusOnFollowersAndLeader() {\n+    // given\n+    final var followers =\n+        clusteringRule.getOtherBrokerObjects(clusteringRule.getLeaderForPartition(1).getNodeId());\n+\n+    // when\n+    final var followerStatus =\n+        followers.stream()\n+            .map(Broker::getBrokerAdminService)\n+            .map(BrokerAdminService::getPartitionStatus)\n+            .map(status -> status.get(1));\n+\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);\n+\n+    // then\n+    followerStatus.forEach(\n+        partitionStatus -> {\n+          assertThat(partitionStatus.getRole()).isEqualTo(Role.FOLLOWER);\n+          assertThat(partitionStatus.getProcessedPosition()).isNull();\n+          assertThat(partitionStatus.getSnapshotId()).isNull();\n+          assertThat(partitionStatus.getProcessedPositionInSnapshot()).isNull();\n+          assertThat(partitionStatus.getStreamProcessorPhase()).isNull();\n+        });\n+\n+    assertThat(leaderStatus.getRole()).isEqualTo(Role.LEADER);\n+    assertThat(leaderStatus.getProcessedPosition()).isEqualTo(-1);\n+    assertThat(leaderStatus.getSnapshotId()).isNull();\n+    assertThat(leaderStatus.getProcessedPositionInSnapshot()).isNull();\n+    assertThat(leaderStatus.getStreamProcessorPhase()).isEqualTo(Phase.PROCESSING);\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusWithSnapshotOnFollowers() {\n+    // given\n+    clientRule.createSingleJob(\"test\");\n+    leaderAdminService.takeSnapshot();\n+\n+    // when\n+    waitForSnapshotAtBroker(leaderAdminService);\n+\n+    // then\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3Mzc1Mg=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk2NTg5Mg==", "bodyText": "but it says leaderStatus", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r524965892", "createdAt": "2020-11-17T08:25:45Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/system/BrokerAdminServiceClusterTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.system;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.RaftServer.Role;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.clustering.ClusteringRule;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.management.BrokerAdminService;\n+import io.zeebe.broker.system.management.PartitionStatus;\n+import io.zeebe.engine.processing.streamprocessor.StreamProcessor.Phase;\n+import java.time.Duration;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.Timeout;\n+\n+public class BrokerAdminServiceClusterTest {\n+\n+  private final Timeout testTimeout = Timeout.seconds(60);\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(\n+          1,\n+          3,\n+          3,\n+          cfg -> {\n+            cfg.getData().setLogIndexDensity(1);\n+            cfg.getData().setSnapshotPeriod(Duration.ofMinutes(15));\n+          });\n+  private final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(testTimeout).around(clusteringRule).around(clientRule);\n+\n+  private BrokerAdminService leaderAdminService;\n+  private Broker leader;\n+\n+  @Before\n+  public void before() {\n+    leader = clusteringRule.getBroker(clusteringRule.getLeaderForPartition(1).getNodeId());\n+    leaderAdminService = leader.getBrokerAdminService();\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusOnFollowersAndLeader() {\n+    // given\n+    final var followers =\n+        clusteringRule.getOtherBrokerObjects(clusteringRule.getLeaderForPartition(1).getNodeId());\n+\n+    // when\n+    final var followerStatus =\n+        followers.stream()\n+            .map(Broker::getBrokerAdminService)\n+            .map(BrokerAdminService::getPartitionStatus)\n+            .map(status -> status.get(1));\n+\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);\n+\n+    // then\n+    followerStatus.forEach(\n+        partitionStatus -> {\n+          assertThat(partitionStatus.getRole()).isEqualTo(Role.FOLLOWER);\n+          assertThat(partitionStatus.getProcessedPosition()).isNull();\n+          assertThat(partitionStatus.getSnapshotId()).isNull();\n+          assertThat(partitionStatus.getProcessedPositionInSnapshot()).isNull();\n+          assertThat(partitionStatus.getStreamProcessorPhase()).isNull();\n+        });\n+\n+    assertThat(leaderStatus.getRole()).isEqualTo(Role.LEADER);\n+    assertThat(leaderStatus.getProcessedPosition()).isEqualTo(-1);\n+    assertThat(leaderStatus.getSnapshotId()).isNull();\n+    assertThat(leaderStatus.getProcessedPositionInSnapshot()).isNull();\n+    assertThat(leaderStatus.getStreamProcessorPhase()).isEqualTo(Phase.PROCESSING);\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusWithSnapshotOnFollowers() {\n+    // given\n+    clientRule.createSingleJob(\"test\");\n+    leaderAdminService.takeSnapshot();\n+\n+    // when\n+    waitForSnapshotAtBroker(leaderAdminService);\n+\n+    // then\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3Mzc1Mg=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk2OTgzMg==", "bodyText": "Ya. Status of the leader for partition 1.", "url": "https://github.com/camunda-cloud/zeebe/pull/5809#discussion_r524969832", "createdAt": "2020-11-17T08:32:12Z", "author": {"login": "deepthidevaki"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/system/BrokerAdminServiceClusterTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.system;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.RaftServer.Role;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.clustering.ClusteringRule;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.management.BrokerAdminService;\n+import io.zeebe.broker.system.management.PartitionStatus;\n+import io.zeebe.engine.processing.streamprocessor.StreamProcessor.Phase;\n+import java.time.Duration;\n+import org.awaitility.Awaitility;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.Timeout;\n+\n+public class BrokerAdminServiceClusterTest {\n+\n+  private final Timeout testTimeout = Timeout.seconds(60);\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(\n+          1,\n+          3,\n+          3,\n+          cfg -> {\n+            cfg.getData().setLogIndexDensity(1);\n+            cfg.getData().setSnapshotPeriod(Duration.ofMinutes(15));\n+          });\n+  private final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(testTimeout).around(clusteringRule).around(clientRule);\n+\n+  private BrokerAdminService leaderAdminService;\n+  private Broker leader;\n+\n+  @Before\n+  public void before() {\n+    leader = clusteringRule.getBroker(clusteringRule.getLeaderForPartition(1).getNodeId());\n+    leaderAdminService = leader.getBrokerAdminService();\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusOnFollowersAndLeader() {\n+    // given\n+    final var followers =\n+        clusteringRule.getOtherBrokerObjects(clusteringRule.getLeaderForPartition(1).getNodeId());\n+\n+    // when\n+    final var followerStatus =\n+        followers.stream()\n+            .map(Broker::getBrokerAdminService)\n+            .map(BrokerAdminService::getPartitionStatus)\n+            .map(status -> status.get(1));\n+\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);\n+\n+    // then\n+    followerStatus.forEach(\n+        partitionStatus -> {\n+          assertThat(partitionStatus.getRole()).isEqualTo(Role.FOLLOWER);\n+          assertThat(partitionStatus.getProcessedPosition()).isNull();\n+          assertThat(partitionStatus.getSnapshotId()).isNull();\n+          assertThat(partitionStatus.getProcessedPositionInSnapshot()).isNull();\n+          assertThat(partitionStatus.getStreamProcessorPhase()).isNull();\n+        });\n+\n+    assertThat(leaderStatus.getRole()).isEqualTo(Role.LEADER);\n+    assertThat(leaderStatus.getProcessedPosition()).isEqualTo(-1);\n+    assertThat(leaderStatus.getSnapshotId()).isNull();\n+    assertThat(leaderStatus.getProcessedPositionInSnapshot()).isNull();\n+    assertThat(leaderStatus.getStreamProcessorPhase()).isEqualTo(Phase.PROCESSING);\n+  }\n+\n+  @Test\n+  public void shouldReportPartitionStatusWithSnapshotOnFollowers() {\n+    // given\n+    clientRule.createSingleJob(\"test\");\n+    leaderAdminService.takeSnapshot();\n+\n+    // when\n+    waitForSnapshotAtBroker(leaderAdminService);\n+\n+    // then\n+    final var leaderStatus = leaderAdminService.getPartitionStatus().get(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3Mzc1Mg=="}, "originalCommit": {"oid": "3d1dac93fc379b37d9415fa9247689c43b352c3f"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 142, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}