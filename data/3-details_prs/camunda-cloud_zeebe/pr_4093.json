{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNTIxNDMy", "number": 4093, "title": "chore(engine): add inconsistency check", "bodyText": "Description\nI added an position check to the reprocessing. I think based on that we can discuss further.\nIt just throws an exception, which causes to fail the StreamProcessor etc. This is the same as we detect a problem in the source positions. Currently there is no recovery or handling. There is already a plan to implement such things, since there several other places where StreamProcessor can go into the failed state, we need to look at this then.\nAt least with this check we do not start and we detect this quite fast, since also all requests will timeout then etc.\nTest was no really possible without breaking our complete abstraction etc. Writers are created in the LogStream. I think we can this discuss this further. We also plan to write a tool which generates inconsistent logs. It makes sense to see how the processor then reacts on such things.\nUpdate:\nThe test creates one log storage and two LogStreams, which use the same\nstorage. On both streams events are written, which means events with\nsame position end in the same log. The test verifies that\nstarting a stream processor will mean that the StreamProcessor ends in\nfail mode.\n\nRelated issues\n\ncloses #3936\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-03-20T13:05:34Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4093", "merged": true, "mergeCommit": {"oid": "a9a654bb1eb3ae2e08e6013f4fc1d8bac6bea5c7"}, "closed": true, "closedAt": "2020-03-23T18:05:12Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQaW-lABqjMxNTQyMDEyMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQhh3uABqjMxNTYyMjE0Mjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c5d33f1dfb777c5e8fe7edd206ffafafc6cc80a", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/2c5d33f1dfb777c5e8fe7edd206ffafafc6cc80a", "committedDate": "2020-03-23T07:44:01Z", "message": "test(engine): add inconsistency log test\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode."}, "afterCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/43bacc645c48263687ebf8d1a4a7d2d46c21cec0", "committedDate": "2020-03-23T08:51:18Z", "message": "test(engine): add inconsistency log test\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Mjc4ODU4", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#pullrequestreview-379278858", "createdAt": "2020-03-23T09:58:58Z", "commit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1ODo1OFrOF5-KKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMDoyNTowNlrOF5_E8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTU2MQ==", "bodyText": "Nit: can we keep the same wording as we usually do for error messages?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331561", "createdAt": "2020-03-23T09:58:58Z", "author": {"login": "npepinpe"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -79,6 +79,10 @@\n       \"Processor finished reprocessing at event position {}\";\n   private static final String LOG_STMT_FAILED_ON_PROCESSING =\n       \"Event {} failed on processing last time, will call #onError to update workflow instance blacklist.\";\n+\n+  private static final String ERROR_INCONSISTENT_LOG =\n+      \"Inconsistent log detected! Last position was '%d' and current position is '%d'.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMTg4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // ERROR", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396331885", "createdAt": "2020-03-23T09:59:28Z", "author": {"login": "npepinpe"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ReProcessingStateMachine.java", "diffHunk": "@@ -146,9 +150,19 @@ private long scanLog(final long snapshotPosition) {\n \n     if (logStreamReader.hasNext()) {\n       lastSourceEventPosition = snapshotPosition;\n+\n+      long lastPosition = snapshotPosition;\n       while (logStreamReader.hasNext()) {\n         final LoggedEvent newEvent = logStreamReader.next();\n \n+        final var currentPosition = newEvent.getPosition();\n+        if (lastPosition >= currentPosition) {\n+          // ERROR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0MzMzMg==", "bodyText": "Since on recovery we switch the processor phase to Phase.PROCESSING, would comparing phases only not be enough? What additional guarantees does the latch provide?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396343332", "createdAt": "2020-03-23T10:19:24Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NDI4Nw==", "bodyText": "Shouldn't it be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        new RecordStream(testStreams.events(getLogName(2)))\n          \n          \n            \n                        new RecordStream(testStreams.events(getLogName(1)))", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396344287", "createdAt": "2020-03-23T10:21:06Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NTM2OQ==", "bodyText": "Is it enough to only test the first processor composite?", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396345369", "createdAt": "2020-03-23T10:22:59Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorInconsistentPositionTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.state.DefaultZeebeDbFactory.DEFAULT_DB_FACTORY;\n+import static io.zeebe.engine.util.StreamProcessingComposite.getLogName;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_COMPLETING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.util.RecordStream;\n+import io.zeebe.engine.util.StreamProcessingComposite;\n+import io.zeebe.engine.util.TestStreams;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.test.util.AutoCloseableRule;\n+import io.zeebe.util.sched.clock.ControlledActorClock;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class StreamProcessorInconsistentPositionTest {\n+\n+  private final TemporaryFolder tempFolder = new TemporaryFolder();\n+  private final AutoCloseableRule closeables = new AutoCloseableRule();\n+  private final ControlledActorClock clock = new ControlledActorClock();\n+  private final ActorSchedulerRule actorSchedulerRule = new ActorSchedulerRule(clock);\n+\n+  @Rule\n+  public RuleChain ruleChain =\n+      RuleChain.outerRule(tempFolder).around(actorSchedulerRule).around(closeables);\n+\n+  private StreamProcessingComposite firstStreamProcessorComposite;\n+  private StreamProcessingComposite secondStreamProcessorComposite;\n+  private TestStreams testStreams;\n+\n+  @Before\n+  public void setup() throws Exception {\n+\n+    testStreams = new TestStreams(tempFolder, closeables, actorSchedulerRule.get());\n+\n+    final var dataDirectory = tempFolder.newFolder();\n+\n+    final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(tempFolder, 1);\n+    logStorageRule.open(\n+        b ->\n+            b.withDirectory(dataDirectory)\n+                .withMaxEntrySize(4 * 1024 * 1024)\n+                .withMaxSegmentSize(128 * 1024 * 1024));\n+\n+    testStreams.createLogStream(getLogName(1), 1, logStorageRule);\n+    testStreams.createLogStream(getLogName(2), 2, logStorageRule);\n+\n+    firstStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 1, DEFAULT_DB_FACTORY);\n+    secondStreamProcessorComposite =\n+        new StreamProcessingComposite(testStreams, 2, DEFAULT_DB_FACTORY);\n+  }\n+\n+  @Test\n+  public void shouldNotStartOnInconsistentLog() {\n+    // given\n+    final var position =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var secondPosition =\n+        firstStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_ACTIVATED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    final var otherPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETING);\n+    final var otherSecondPosition =\n+        secondStreamProcessorComposite.writeWorkflowInstanceEvent(ELEMENT_COMPLETED);\n+    waitUntil(\n+        () ->\n+            new RecordStream(testStreams.events(getLogName(2)))\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_COMPLETED)\n+                .exists());\n+\n+    assertThat(position).isEqualTo(otherPosition);\n+    assertThat(secondPosition).isEqualTo(otherSecondPosition);\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final TypedRecordProcessor typedRecordProcessor = mock(TypedRecordProcessor.class);\n+    final var streamProcessor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM0NjYwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // things provisioned by this rule", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#discussion_r396346609", "createdAt": "2020-03-23T10:25:06Z", "author": {"login": "npepinpe"}, "path": "engine/src/test/java/io/zeebe/engine/util/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.util;\n+\n+import static io.zeebe.engine.util.Records.workflowInstance;\n+\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.engine.processor.ReadonlyProcessingContext;\n+import io.zeebe.engine.processor.StreamProcessor;\n+import io.zeebe.engine.processor.TypedRecordProcessorFactory;\n+import io.zeebe.engine.processor.TypedRecordProcessors;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.logstreams.log.LogStreamRecordWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.record.RecordType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+\n+public class StreamProcessingComposite {\n+\n+  // things provisioned by this rule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43bacc645c48263687ebf8d1a4a7d2d46c21cec0"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MzI5NzQ2", "url": "https://github.com/camunda-cloud/zeebe/pull/4093#pullrequestreview-379329746", "createdAt": "2020-03-23T11:09:42Z", "commit": {"oid": "79241fed4cf519b7a0dfa2168ccf409955025e46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79241fed4cf519b7a0dfa2168ccf409955025e46", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/79241fed4cf519b7a0dfa2168ccf409955025e46", "committedDate": "2020-03-23T10:50:56Z", "message": "chore(engine): apply review hints"}, "afterCommit": {"oid": "64edf6f041bf18c878be8be4ba24013776bba72b", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/64edf6f041bf18c878be8be4ba24013776bba72b", "committedDate": "2020-03-23T11:20:45Z", "message": "chore(engine): add inconsistence check\n\n On reprocessing we verify that the positions are increasing, if not we\n fail the stream processor.\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bb0ea0683a03e23dbef01ef4f8221e7835552ab", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/8bb0ea0683a03e23dbef01ef4f8221e7835552ab", "committedDate": "2020-03-23T12:02:32Z", "message": "chore(engine): add inconsistence check\n\n On reprocessing we verify that the positions are increasing, if not we\n fail the stream processor.\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "committedDate": "2020-03-23T12:26:31Z", "message": "chore(engine): fix tear down in test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64edf6f041bf18c878be8be4ba24013776bba72b", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/64edf6f041bf18c878be8be4ba24013776bba72b", "committedDate": "2020-03-23T11:20:45Z", "message": "chore(engine): add inconsistence check\n\n On reprocessing we verify that the positions are increasing, if not we\n fail the stream processor.\n\n The test creates one log storage and two LogStreams, which use the same\n storage. On both streams events are written, which means events with\n same position end in the same log. The test verifies that\n starting a stream processor will mean that the StreamProcessor ends in\n fail mode."}, "afterCommit": {"oid": "352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/352ff2bae152c77efcd1e31fa3715a0ed47ac9d3", "committedDate": "2020-03-23T12:26:31Z", "message": "chore(engine): fix tear down in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "committedDate": "2020-03-23T17:12:29Z", "message": "chore(engine): fix AsyncDirector closing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f8eb020a2acb137b3c14930323ddea67f7ea468", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/4f8eb020a2acb137b3c14930323ddea67f7ea468", "committedDate": "2020-03-23T15:44:48Z", "message": "chore(engine): fix AsyncDirector closing"}, "afterCommit": {"oid": "20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/20ab63b792a6dd22a2a9d83f57f2d84fa9933f13", "committedDate": "2020-03-23T17:12:29Z", "message": "chore(engine): fix AsyncDirector closing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3092, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}