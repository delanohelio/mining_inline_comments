{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2Nzg5NTk0", "number": 5463, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoxODoyNlrOEsBhBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyOTowM1rOEsBurA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTk3NjM3OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoxODoyNlrOHfHR9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMTozN1rOHfLciw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ==", "bodyText": "I don't think this is correct - we flush on commit for the leader because the leader already includes itself in the quorum, so before we can truly commit we need to persist the write.", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502387189", "createdAt": "2020-10-09T12:18:26Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MjUxNw==", "bodyText": "That's true, but the reason why we need to persist the write at all is because the buffer is not shared with the readers, right?", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502452517", "createdAt": "2020-10-09T14:06:59Z", "author": {"login": "korthout"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MzY0Mg==", "bodyText": "commits need to be persisted - you should not lose commits otherwise your raft protocol is broken", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502453642", "createdAt": "2020-10-09T14:08:52Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NDU5NQ==", "bodyText": "No, it's because the leader counts itself in the quorum as already persisted. So, let's say your quorum is 2. On a new append, the leader will write (but not flush), and so it starts its count at 1, and only needs a follower to acknowledge before achieving quorum.\nSo the leader is not flushing on append; what if it also didn't flush on commit? Then when the follower acknowledges the append, it would commit. Let's say this happens, and the leader now sends a new request to other nodes with the new commit index, then dies. And let's say as it dies, it hadn't flushed (since we don't know when the OS will flush automatically). Now, only one node had truly persisted the write, so we didn't actually achieve quorum.", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502454595", "createdAt": "2020-10-09T14:10:20Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTQzNQ==", "bodyText": "commits need to be persisted - you should not lose commits otherwise your raft protocol is broken\n\nNot quite true - the Raft paper describes that if you also wait for the async flush of the leader before counting it in the quorum, then if you still reach quorum (e.g. the 2 followers acknowledged the write before the leader flushed), then it doesn't matter, you still got quorum, so who cares if it's not flushed on the leader \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455435", "createdAt": "2020-10-09T14:11:37Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTk3Nzc3OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoxODo1NFrOHfHSzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMTo1MFrOHfLdGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw==", "bodyText": "Just a side note, most screens are probably big enough to put this on a single line ;)\nAlso, it's not because the writer's buffer is isolated from readers, but because for us to truly acknowledge the append to the leader, we need to ensure the write is truly persisted, not just buffered in memory and eventually flushed.", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502387407", "createdAt": "2020-10-09T12:18:54Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -609,6 +609,10 @@ protected void appendEntries(\n       raft.notifyCommitListeners(commitIndex);\n     }\n \n+    // Make sure all entries are flushed before ack\n+    // because writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NDg5Ng==", "bodyText": "Just a side note, most screens are probably big enough to put this on a single line ;)\n\nThat's just like your opinion, man \ud83d\ude0e", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502454896", "createdAt": "2020-10-09T14:10:49Z", "author": {"login": "korthout"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -609,6 +609,10 @@ protected void appendEntries(\n       raft.notifyCommitListeners(commitIndex);\n     }\n \n+    // Make sure all entries are flushed before ack\n+    // because writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTU3OA==", "bodyText": "Also, it's not because the writer's buffer is isolated from readers, but because for us to truly acknowledge the append to the leader, we need to ensure the write is truly persisted, not just buffered in memory and eventually flushed.\n\nIt makes sense to explain this better. I'll change the comment ;)", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455578", "createdAt": "2020-10-09T14:11:50Z", "author": {"login": "korthout"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -609,6 +609,10 @@ protected void appendEntries(\n       raft.notifyCommitListeners(commitIndex);\n     }\n \n+    // Make sure all entries are flushed before ack\n+    // because writer's buffer is isolated from readers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTk4NDA5OnYy", "diffSide": "LEFT", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyMDo0N1rOHfHWkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMjowNlrOHfLdwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4ODM3MQ==", "bodyText": "I'm guessing this was unused?", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502388371", "createdAt": "2020-10-09T12:20:47Z", "author": {"login": "npepinpe"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java", "diffHunk": "@@ -325,11 +330,6 @@ public boolean isFull() {\n         || getNextIndex() - firstIndex >= segment.descriptor().maxEntries();\n   }\n \n-  /** Returns the first index written to the segment. */\n-  public long firstIndex() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTc0NA==", "bodyText": "Yup, dead code", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455744", "createdAt": "2020-10-09T14:12:06Z", "author": {"login": "korthout"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java", "diffHunk": "@@ -325,11 +330,6 @@ public boolean isFull() {\n         || getNextIndex() - firstIndex >= segment.descriptor().maxEntries();\n   }\n \n-  /** Returns the first index written to the segment. */\n-  public long firstIndex() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4ODM3MQ=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjAwNDc0OnYy", "diffSide": "RIGHT", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyNzowN1rOHfHjYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMjozN1rOHfLe_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTY1MA==", "bodyText": "afaik you can close the channel once you've mapped it, no need to keep it around.\nSo you could do:\ntry(final FileChannel channel = file.openChannel(\n            StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n  buffer = mapChannel(channel, segment);\n}\nBut verify in case I'm wrong \ud83d\ude42\nOr you can just use org.agrona.IoUtil.mapExistingFile(File, MapMode, String) and forgo opening the channel at all \ud83d\ude42", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502391650", "createdAt": "2020-10-09T12:27:07Z", "author": {"login": "npepinpe"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -46,38 +49,41 @@\n  */\n class MappedJournalSegmentWriter<E> implements JournalWriter<E> {\n \n-  private final MappedByteBuffer mappedBuffer;\n-  private final ByteBuffer buffer;\n+  private final FileChannel channel;\n+  private final MappedByteBuffer buffer;\n   private final JournalSegment<E> segment;\n   private final int maxEntrySize;\n   private final JournalIndex index;\n   private final Namespace namespace;\n   private final long firstIndex;\n   private Indexed<E> lastEntry;\n+  private boolean isOpen = true;\n \n   MappedJournalSegmentWriter(\n-      final MappedByteBuffer buffer,\n+      final JournalSegmentFile file,\n       final JournalSegment<E> segment,\n       final int maxEntrySize,\n       final JournalIndex index,\n       final Namespace namespace) {\n-    mappedBuffer = buffer;\n-    this.buffer = buffer.slice();\n     this.segment = segment;\n     this.maxEntrySize = maxEntrySize;\n     this.index = index;\n     this.namespace = namespace;\n     firstIndex = segment.index();\n+    channel =\n+        file.openChannel(\n+            StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n+    buffer = mapChannel(channel, segment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NjA2MQ==", "bodyText": "I'll give this a try \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456061", "createdAt": "2020-10-09T14:12:37Z", "author": {"login": "korthout"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -46,38 +49,41 @@\n  */\n class MappedJournalSegmentWriter<E> implements JournalWriter<E> {\n \n-  private final MappedByteBuffer mappedBuffer;\n-  private final ByteBuffer buffer;\n+  private final FileChannel channel;\n+  private final MappedByteBuffer buffer;\n   private final JournalSegment<E> segment;\n   private final int maxEntrySize;\n   private final JournalIndex index;\n   private final Namespace namespace;\n   private final long firstIndex;\n   private Indexed<E> lastEntry;\n+  private boolean isOpen = true;\n \n   MappedJournalSegmentWriter(\n-      final MappedByteBuffer buffer,\n+      final JournalSegmentFile file,\n       final JournalSegment<E> segment,\n       final int maxEntrySize,\n       final JournalIndex index,\n       final Namespace namespace) {\n-    mappedBuffer = buffer;\n-    this.buffer = buffer.slice();\n     this.segment = segment;\n     this.maxEntrySize = maxEntrySize;\n     this.index = index;\n     this.namespace = namespace;\n     firstIndex = segment.index();\n+    channel =\n+        file.openChannel(\n+            StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n+    buffer = mapChannel(channel, segment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTY1MA=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjAwODUwOnYy", "diffSide": "RIGHT", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyODoxNFrOHfHlpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMzoxNlrOHfLgmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjIzMA==", "bodyText": "Nit: you can also use org.agrona.IoUtil.unmap(buffer). It just calls BufferUtil, however imo it's a bit more readable in its intention.", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502392230", "createdAt": "2020-10-09T12:28:14Z", "author": {"login": "npepinpe"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -259,16 +262,20 @@ public void truncate(final long index) {\n \n   @Override\n   public void flush() {\n-    mappedBuffer.force();\n+    buffer.force();\n   }\n \n   @Override\n   public void close() {\n-    flush();\n-    try {\n-      BufferCleaner.freeBuffer(mappedBuffer);\n-    } catch (final IOException e) {\n-      throw new StorageException(e);\n+    if (isOpen) {\n+      isOpen = false;\n+      flush();\n+      BufferUtil.free(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NjQ3Mw==", "bodyText": "Make sense \ud83d\udc4d  Still learning the agrona api. Thanks for sharing these", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456473", "createdAt": "2020-10-09T14:13:16Z", "author": {"login": "korthout"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -259,16 +262,20 @@ public void truncate(final long index) {\n \n   @Override\n   public void flush() {\n-    mappedBuffer.force();\n+    buffer.force();\n   }\n \n   @Override\n   public void close() {\n-    flush();\n-    try {\n-      BufferCleaner.freeBuffer(mappedBuffer);\n-    } catch (final IOException e) {\n-      throw new StorageException(e);\n+    if (isOpen) {\n+      isOpen = false;\n+      flush();\n+      BufferUtil.free(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjIzMA=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjAxMTMyOnYy", "diffSide": "LEFT", "path": "broker/src/main/java/io/zeebe/broker/system/SystemContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjoyOTowM1rOHfHnQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNDoxMzo0M1rOHfLhxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjY0Mg==", "bodyText": "I guess we can also remove the constant MMAP_REPLICATION_ERROR_MSG?", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502392642", "createdAt": "2020-10-09T12:29:03Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/SystemContext.java", "diffHunk": "@@ -76,13 +75,7 @@ private void validateConfiguration() {\n       throw new IllegalArgumentException(String.format(NODE_ID_ERROR_MSG, nodeId, clusterSize));\n     }\n \n-    final StorageLevel storageLevel = data.getAtomixStorageLevel();\n     final int replicationFactor = cluster.getReplicationFactor();\n-\n-    if (storageLevel == StorageLevel.MAPPED && replicationFactor > 1) {\n-      throw new IllegalStateException(MMAP_REPLICATION_ERROR_MSG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1Njc3NQ==", "bodyText": "Woops, I'll make sure to remove it.", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456775", "createdAt": "2020-10-09T14:13:43Z", "author": {"login": "korthout"}, "path": "broker/src/main/java/io/zeebe/broker/system/SystemContext.java", "diffHunk": "@@ -76,13 +75,7 @@ private void validateConfiguration() {\n       throw new IllegalArgumentException(String.format(NODE_ID_ERROR_MSG, nodeId, clusterSize));\n     }\n \n-    final StorageLevel storageLevel = data.getAtomixStorageLevel();\n     final int replicationFactor = cluster.getReplicationFactor();\n-\n-    if (storageLevel == StorageLevel.MAPPED && replicationFactor > 1) {\n-      throw new IllegalStateException(MMAP_REPLICATION_ERROR_MSG);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjY0Mg=="}, "originalCommit": {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 163, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}