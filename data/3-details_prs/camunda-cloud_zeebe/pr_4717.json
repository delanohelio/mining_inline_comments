{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNzU5NzY0", "number": 4717, "title": "Ensure log consistency", "bodyText": "Description\nPositions are now consecutive and, before appending we check that records are well-ordered and that there are no gaps in appended blocks.\nRelated issues\ncloses #3987\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-06-12T15:54:00Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4717", "merged": true, "mergeCommit": {"oid": "0d8b420e7867a7320b2d5c5ace115b86d1585298"}, "closed": true, "closedAt": "2020-06-26T13:00:02Z", "author": {"login": "MiguelPires"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqzzUlgBqjM0NDA2MjM2NDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvBsGmABqjM0ODYyNTA4Mzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10a6940e651a6253e6759873791fbe72f05ab268", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/10a6940e651a6253e6759873791fbe72f05ab268", "committedDate": "2020-06-12T15:48:40Z", "message": "fix(benchmarks): fix profiler script"}, "afterCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/dd1334b5fab43ef2b657ec25e3ef4a913738044f", "committedDate": "2020-06-13T09:11:22Z", "message": "fix(benchmarks): fix profiler script"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMTAxMTk1", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#pullrequestreview-432101195", "createdAt": "2020-06-17T06:43:39Z", "commit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo0MzozOVrOGk3vPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzowOTowOFrOGk4eKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNTEzNA==", "bodyText": "Why you switched to exceptions instead of return just an boolean? It looks from the api perspecitve a bit weird to call a validate method which returns nothing. I would expect it would return a boolean which indicates valid or not. These are the two expected cases, right? Thats why I'm not sure whether throwing exception in the impl of the listener makes sense. If not valid, which means the result is false then I might be ok with throwing a exception but not in the validator. Maybe we can also create a separate interface for the validation?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441315134", "createdAt": "2020-06-17T06:43:39Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -710,9 +710,12 @@ private boolean isEntryConsistent(final long newEntryPosition) {\n       } while (index > 0 && lastEntry != null && lastEntry.type() != ZeebeEntry.class);\n     }\n \n-    return lastEntry == null\n-        || lastEntry.type() != ZeebeEntry.class\n-        || newEntryPosition > ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    long lastPosition = -1;\n+    if (lastEntry != null && lastEntry.type() == ZeebeEntry.class) {\n+      lastPosition = ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    }\n+\n+    listener.validatePositions(lastPosition, entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjMyOQ==", "bodyText": "Why the asserts before If you anyway throw an exception?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441316329", "createdAt": "2020-06-17T06:46:35Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/roles/LeaderRoleTest.java", "diffHunk": "@@ -431,12 +456,24 @@ public void onCommit(final Indexed<ZeebeEntry> indexed) {}\n \n           @Override\n           public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {}\n+\n+          @Override\n+          public void validatePositions(final long lastPosition, final ZeebeEntry entry) {\n+            assertThat(lastPosition).isEqualTo(7);\n+            assertThat(entry.lowestPosition()).isEqualTo(9);\n+            assertThat(entry.highestPosition()).isEqualTo(9);\n+            entry.data().rewind();\n+            data.rewind();\n+            assertThat(entry.data()).isEqualTo(data);\n+\n+            throw new IllegalStateException(\"expected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNjU4MA==", "bodyText": "Maybe we  can add an comment that we need that because we use jre-slim, which removes man pages etc.", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441316580", "createdAt": "2020-06-17T06:47:09Z", "author": {"login": "Zelldon"}, "path": "benchmarks/docs/scripts/profile.sh", "diffHunk": "@@ -9,16 +9,18 @@ unset JAVA_TOOL_OPTIONS\n if hash apk 2> /dev/null; then\n     apk add --no-cache openjdk11 openjdk11-dbg\n else\n+    mkdir -p /usr/share/man/man1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxNzc2MQ==", "bodyText": "magic ?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441317761", "createdAt": "2020-06-17T06:49:46Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -142,6 +145,7 @@ public long claim(final ClaimedFragment claim, final int length, final int strea\n         (partition, activePartitionId) ->\n             logAppender.claim(\n                 partition, activePartitionId, claim, length, streamId, onClaimComplete),\n+        1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng==", "bodyText": "what do you mean with this comment?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441318066", "createdAt": "2020-06-17T06:50:23Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -191,10 +198,12 @@ private long offer(\n \n         newPosition = updatePublisherPosition(activePartitionId, newOffset);\n \n-        if (publisherPosition.proposeMaxOrdered(newPosition)) {\n-          LOG.trace(\"Updated publisher position to {}\", newPosition);\n+        // if successful, replace position with simple counter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODQ2Ng==", "bodyText": "shouldn't this be volatile or an atomic long?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441318466", "createdAt": "2020-06-17T06:51:10Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -35,12 +35,13 @@\n \n   private final AtomicPosition publisherLimit;\n   private final AtomicPosition publisherPosition;\n+  private long recordPosition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTAwNg==", "bodyText": "I think you could use a atomic long and do here an compare and set or something similar then we probably don't need this synchronize", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441319006", "createdAt": "2020-06-17T06:52:27Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -191,10 +198,12 @@ private long offer(\n \n         newPosition = updatePublisherPosition(activePartitionId, newOffset);\n \n-        if (publisherPosition.proposeMaxOrdered(newPosition)) {\n-          LOG.trace(\"Updated publisher position to {}\", newPosition);\n+        // if successful, replace position with simple counter\n+        if (newPosition > 0) {\n+          newPosition = recordPosition;\n+          recordPosition += fragmentCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTYzMw==", "bodyText": "Why is this necessary now? \ud83d\udc40", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441319633", "createdAt": "2020-06-17T06:53:49Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -207,18 +216,22 @@ private long updatePublisherPosition(final int activePartitionId, final int newO\n     if (newOffset > 0) {\n       newPosition = position(activePartitionId, newOffset);\n     } else if (newOffset == RESULT_PADDING_AT_END_OF_PARTITION) {\n-      logBuffer.onActiveParitionFilled(activePartitionId);\n+      logBuffer.onActivePartitionFilled(activePartitionId);\n       newPosition = -2;\n     }\n \n+    if (publisherPosition.proposeMaxOrdered(newPosition)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDU5OA==", "bodyText": "Why this was removed?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441320598", "createdAt": "2020-06-17T06:55:38Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeLogAppenderTest.java", "diffHunk": "@@ -103,24 +103,6 @@ public void shouldNotifyOnError() {\n     assertEquals(0L, appenderListener.getCommitted().size());\n   }\n \n-  @Test(timeout = 5000)\n-  public void shouldNotAppendInconsistent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMDc2MQ==", "bodyText": "And these?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441320761", "createdAt": "2020-06-17T06:55:56Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeTest.java", "diffHunk": "@@ -260,79 +258,6 @@ public void shouldNotifyCommitListeners() {\n     }\n   }\n \n-  @Test\n-  public void shouldBeConsistentAfterFailOver() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMjE3NA==", "bodyText": "If we separate the interface I think all these other method implementations would not necessary. Maybe the validator can be registered at the beginning. No need to give it on each append right?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441322174", "createdAt": "2020-06-17T06:58:56Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/Listener.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.impl.log;\n+\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.zeebe.logstreams.spi.LogStorage.AppendListener;\n+import java.util.NoSuchElementException;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class Listener implements AppendListener {\n+\n+  private final LogStorageAppender appender;\n+  private final long highestPosition;\n+  private final UnsafeBuffer reader;\n+\n+  public Listener(\n+      final LogStorageAppender appender, final long highestPosition, final UnsafeBuffer reader) {\n+    this.appender = appender;\n+    this.highestPosition = highestPosition;\n+    this.reader = reader;\n+  }\n+\n+  @Override\n+  public void onWrite(final long address) {}\n+\n+  @Override\n+  public void onWriteError(final Throwable error) {\n+    LogStorageAppender.LOG.error(\n+        \"Failed to append block with last event position {}.\", highestPosition, error);\n+    if (error instanceof NoSuchElementException) {\n+      // Not a failure. It is probably during transition to follower.\n+      return;\n+    }\n+\n+    appender.runOnFailure(error);\n+  }\n+\n+  @Override\n+  public void onCommit(final long address) {\n+    releaseBackPressure();\n+  }\n+\n+  @Override\n+  public void onCommitError(final long address, final Throwable error) {\n+    LogStorageAppender.LOG.error(\n+        \"Failed to commit block with last event position {}.\", highestPosition, error);\n+    releaseBackPressure();\n+    appender.runOnFailure(error);\n+  }\n+\n+  @Override\n+  public void validatePositions(long lastPosition, final ZeebeEntry entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyMzQ2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Tuple<Long, Long> readMinMax(final ByteBuffer buffer) {\n          \n          \n            \n              private Tuple<Long, Long> readLowestHighestPosition(final ByteBuffer buffer) {", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441323460", "createdAt": "2020-06-17T07:01:32Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStorageAppender.java", "diffHunk": "@@ -172,13 +168,16 @@ private void onWriteBufferAvailable() {\n     }\n   }\n \n-  private Positions readPositions(final ByteBuffer buffer) {\n+  private Tuple<Long, Long> readMinMax(final ByteBuffer buffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ==", "bodyText": "didn't you wrote an test in the dispatcher where the claim returned the the position based on the fragment count?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441324209", "createdAt": "2020-06-17T07:03:03Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamBatchWriterImpl.java", "diffHunk": "@@ -197,11 +196,12 @@ public long tryWrite() {\n       copyExistingEventToBuffer();\n     }\n \n-    long result = claimBatchForEvents();\n-    if (result >= 0) {\n+    long position = claimBatchForEvents();\n+    if (position >= 0) {\n       try {\n         // return position of last event\n-        result = writeEventsToBuffer(claimedBatch.getBuffer());\n+        writeEventsToBuffer(claimedBatch.getBuffer(), position);\n+        position += eventCount - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDY5OQ==", "bodyText": "So I think claim will return already the last position? ANd you then add again the event count?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441324699", "createdAt": "2020-06-17T07:04:13Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamBatchWriterImpl.java", "diffHunk": "@@ -197,11 +196,12 @@ public long tryWrite() {\n       copyExistingEventToBuffer();\n     }\n \n-    long result = claimBatchForEvents();\n-    if (result >= 0) {\n+    long position = claimBatchForEvents();\n+    if (position >= 0) {\n       try {\n         // return position of last event\n-        result = writeEventsToBuffer(claimedBatch.getBuffer());\n+        writeEventsToBuffer(claimedBatch.getBuffer(), position);\n+        position += eventCount - 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng==", "bodyText": "Hm this makes me thinking that this setup here is not ideal, since we now actually test this code and not the code in the Raft appender. It is easy that they drift away when we change something here or there. Any idea how we could use the actual code, which we use in production?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r441327146", "createdAt": "2020-06-17T07:09:08Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -87,12 +89,25 @@ public void appendEntry(\n       final long highestPosition,\n       final ByteBuffer data,\n       final AppendListener listener) {\n-    final Indexed<ZeebeEntry> entry =\n-        raftLog\n-            .writer()\n-            .append(\n-                new ZeebeEntry(\n-                    0, System.currentTimeMillis(), lowestPosition, highestPosition, data));\n+    final ZeebeEntry zbEntry =\n+        new ZeebeEntry(0, System.currentTimeMillis(), lowestPosition, highestPosition, data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTgxNTA4", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#pullrequestreview-435581508", "createdAt": "2020-06-23T08:58:46Z", "commit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwODo1ODo0NlrOGnf8xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOToxNjoyMVrOGngnbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTExMQ==", "bodyText": "Maybe it makes more sense to just keep the last append entry in memory (e.g. as a field) and then give it to the next append validation as last appended entry. In the validation we then get the last and the new and check the positions. I would like not to couple the position and index here to much. Currently the LeaderRole knows me to much about the entry.", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444071111", "createdAt": "2020-06-23T08:58:46Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -710,9 +710,12 @@ private boolean isEntryConsistent(final long newEntryPosition) {\n       } while (index > 0 && lastEntry != null && lastEntry.type() != ZeebeEntry.class);\n     }\n \n-    return lastEntry == null\n-        || lastEntry.type() != ZeebeEntry.class\n-        || newEntryPosition > ((ZeebeEntry) lastEntry.entry()).highestPosition();\n+    long lastPosition = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3MTgxNA==", "bodyText": "I like that", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444071814", "createdAt": "2020-06-23T08:59:45Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -664,11 +667,10 @@ private void safeAppendEntry(\n       return;\n     }\n \n-    if (!isEntryConsistent(lowestPosition)) {\n-      appendListener.onWriteError(\n-          new IllegalStateException(\"New entry has lower Zeebe log position than last entry.\"));\n+    final ValidationResult result = validateEntryConsistency(entry, appendListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTg3Ng==", "bodyText": "Still I think this doesn't need to be part of the Listener.\nI think what we can do is to create a Validator on Broker start and put it on the Atomix configuration, then it is added to the RaftContext and can be used in the LeaderAppender. There is no need that this logic is here, since it just checks the incoming parameters no other context is needed.\nShould I prepare something to show that as example?!", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444075876", "createdAt": "2020-06-23T09:06:13Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/zeebe/ZeebeLogAppender.java", "diffHunk": "@@ -71,5 +71,16 @@ void appendEntry(\n      * @param error the error that occurred\n      */\n     void onCommitError(Indexed<ZeebeEntry> indexed, Throwable error);\n+\n+    /**\n+     * Called before writing to validated that the entry to be appended will not make the log\n+     * inconsistent.\n+     *\n+     * @param lastPosition the highest position of the previous entry\n+     * @param entry current to append\n+     * @return a ValidationResult containing the validation result and an error message, if it\n+     *     failed\n+     */\n+    ValidationResult validatePositions(long lastPosition, ZeebeEntry entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NjQwOQ==", "bodyText": "This would make the other code more cleaner since you dont need to implement the method everywhere else", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444076409", "createdAt": "2020-06-23T09:07:06Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/zeebe/ZeebeLogAppender.java", "diffHunk": "@@ -71,5 +71,16 @@ void appendEntry(\n      * @param error the error that occurred\n      */\n     void onCommitError(Indexed<ZeebeEntry> indexed, Throwable error);\n+\n+    /**\n+     * Called before writing to validated that the entry to be appended will not make the log\n+     * inconsistent.\n+     *\n+     * @param lastPosition the highest position of the previous entry\n+     * @param entry current to append\n+     * @return a ValidationResult containing the validation result and an error message, if it\n+     *     failed\n+     */\n+    ValidationResult validatePositions(long lastPosition, ZeebeEntry entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3NTg3Ng=="}, "originalCommit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA3ODI5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if successful, replace position with simple counter\n          \n          \n            \n                    // if successful, replace internal publisher position with simple counter which will be returned", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444078298", "createdAt": "2020-06-23T09:10:16Z", "author": {"login": "Zelldon"}, "path": "dispatcher/src/main/java/io/zeebe/dispatcher/Dispatcher.java", "diffHunk": "@@ -191,10 +198,12 @@ private long offer(\n \n         newPosition = updatePublisherPosition(activePartitionId, newOffset);\n \n-        if (publisherPosition.proposeMaxOrdered(newPosition)) {\n-          LOG.trace(\"Updated publisher position to {}\", newPosition);\n+        // if successful, replace position with simple counter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxODA2Ng=="}, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MDgzMw==", "bodyText": "I have the feeling the api can still be improved. We dont need to do that now but just an Idea.\nWe could return a list of claimed fragments. The ClaimedFragment holds and buffer and a position, which the write can use. You can then iterate over the list write in each fragment the corresponding data and the related position and dont need to recalculate it by yourself. wdyt?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444080833", "createdAt": "2020-06-23T09:14:31Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamBatchWriterImpl.java", "diffHunk": "@@ -197,11 +196,12 @@ public long tryWrite() {\n       copyExistingEventToBuffer();\n     }\n \n-    long result = claimBatchForEvents();\n-    if (result >= 0) {\n+    long position = claimBatchForEvents();\n+    if (position >= 0) {\n       try {\n         // return position of last event\n-        result = writeEventsToBuffer(claimedBatch.getBuffer());\n+        writeEventsToBuffer(claimedBatch.getBuffer(), position);\n+        position += eventCount - 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNDIwOQ=="}, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MTM0OQ==", "bodyText": "Why we need this class actually?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444081349", "createdAt": "2020-06-23T09:15:19Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/AtomixAppendListenerAdapter.java", "diffHunk": "@@ -38,4 +39,9 @@ public void onCommit(final Indexed<ZeebeEntry> indexed) {\n   public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable error) {\n     delegate.onCommitError(indexed.index(), error);\n   }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fcf77eff628120328bd9dafba03f71803120f3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MTk1OQ==", "bodyText": "Maybe we can use the LeaderAppender somehow", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444081959", "createdAt": "2020-06-23T09:16:14Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -87,12 +89,25 @@ public void appendEntry(\n       final long highestPosition,\n       final ByteBuffer data,\n       final AppendListener listener) {\n-    final Indexed<ZeebeEntry> entry =\n-        raftLog\n-            .writer()\n-            .append(\n-                new ZeebeEntry(\n-                    0, System.currentTimeMillis(), lowestPosition, highestPosition, data));\n+    final ZeebeEntry zbEntry =\n+        new ZeebeEntry(0, System.currentTimeMillis(), lowestPosition, highestPosition, data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng=="}, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4MjAyOQ==", "bodyText": "Follow up issue?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r444082029", "createdAt": "2020-06-23T09:16:21Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -87,12 +89,25 @@ public void appendEntry(\n       final long highestPosition,\n       final ByteBuffer data,\n       final AppendListener listener) {\n-    final Indexed<ZeebeEntry> entry =\n-        raftLog\n-            .writer()\n-            .append(\n-                new ZeebeEntry(\n-                    0, System.currentTimeMillis(), lowestPosition, highestPosition, data));\n+    final ZeebeEntry zbEntry =\n+        new ZeebeEntry(0, System.currentTimeMillis(), lowestPosition, highestPosition, data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzE0Ng=="}, "originalCommit": {"oid": "dd1334b5fab43ef2b657ec25e3ef4a913738044f"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfb676c24328f0ac2c78427ef795ababfd87c478", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/dfb676c24328f0ac2c78427ef795ababfd87c478", "committedDate": "2020-06-23T21:00:53Z", "message": "chore(atomix): keep last entry in memory"}, "afterCommit": {"oid": "c59fbe08251435f3d23a750a62c4ee040b931c48", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/c59fbe08251435f3d23a750a62c4ee040b931c48", "committedDate": "2020-06-23T21:02:01Z", "message": "chore(atomix): keep last entry in memory"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c59fbe08251435f3d23a750a62c4ee040b931c48", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/c59fbe08251435f3d23a750a62c4ee040b931c48", "committedDate": "2020-06-23T21:02:01Z", "message": "chore(atomix): keep last entry in memory"}, "afterCommit": {"oid": "402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "committedDate": "2020-06-24T15:13:48Z", "message": "chore(atomix): keep last ZeebeEntry in memory"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/402150e0aaafcddf8e70486ce5c83c65e6c5a89e", "committedDate": "2020-06-24T15:13:48Z", "message": "chore(atomix): keep last ZeebeEntry in memory"}, "afterCommit": {"oid": "a272c22c2271d810314b05a7312cc347739aa467", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/a272c22c2271d810314b05a7312cc347739aa467", "committedDate": "2020-06-24T15:17:38Z", "message": "chore(atomix): keep last ZeebeEntry in memory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MjEwMDc3", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#pullrequestreview-437210077", "createdAt": "2020-06-25T06:46:29Z", "commit": {"oid": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjo0NjoyOVrOGotceQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzowNzo0N1rOGot96w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDc5Mw==", "bodyText": "\ud83c\udf89", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445340793", "createdAt": "2020-06-25T06:46:29Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/ZeebeEntryValidator.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.impl.log;\n+\n+import io.atomix.raft.zeebe.EntryValidator;\n+import io.atomix.raft.zeebe.ValidationResult;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public class ZeebeEntryValidator implements EntryValidator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDk4NA==", "bodyText": "Why this class was added again?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445340984", "createdAt": "2020-06-25T06:46:59Z", "author": {"login": "Zelldon"}, "path": "atomix/core/src/test/java/io/atomix/core/AbstractAtomixTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2017-present Open Networking Foundation\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.core;\n+\n+import io.atomix.cluster.Node;\n+import io.atomix.cluster.discovery.BootstrapDiscoveryProvider;\n+import io.atomix.cluster.discovery.MulticastDiscoveryProvider;\n+import io.atomix.utils.net.Address;\n+import io.zeebe.test.util.socket.SocketUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Base Atomix test. */\n+public abstract class AbstractAtomixTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0NzMyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Called before writing to validated that the entry to be appended will not make the log\n          \n          \n            \n               * inconsistent.\n          \n          \n            \n               Validates the current entry, which should be append to the log and compares it with the last already appended entry to ensure consistency.\n          \n          \n            \n               The ValidationResult reflects the outcome of the validation and holds an error message when the validation fails.", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445347320", "createdAt": "2020-06-25T07:02:53Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/zeebe/EntryValidator.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.zeebe;\n+\n+@FunctionalInterface\n+public interface EntryValidator {\n+\n+  /**\n+   * Called before writing to validated that the entry to be appended will not make the log\n+   * inconsistent.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcf9c9c9989d96c4392d5014cc7a5811b4cc1ef"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTEzMg==", "bodyText": "Do we even need that?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445349132", "createdAt": "2020-06-25T07:07:12Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -678,6 +680,9 @@ private boolean appendEntry(\n       final CompletableFuture<AppendResponse> future) {\n     try {\n       final Indexed<RaftLogEntry> indexed = writer.append(entry);\n+      if (indexed.type() == ZeebeEntry.class) {\n+        lastZbEntry = ((ZeebeEntry) indexed.entry());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a272c22c2271d810314b05a7312cc347739aa467"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTM1NQ==", "bodyText": "I think we only validate in leader role right? So for followers we probably dont need that. Or what do you think?", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#discussion_r445349355", "createdAt": "2020-06-25T07:07:47Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -678,6 +680,9 @@ private boolean appendEntry(\n       final CompletableFuture<AppendResponse> future) {\n     try {\n       final Indexed<RaftLogEntry> indexed = writer.append(entry);\n+      if (indexed.type() == ZeebeEntry.class) {\n+        lastZbEntry = ((ZeebeEntry) indexed.entry());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTEzMg=="}, "originalCommit": {"oid": "a272c22c2271d810314b05a7312cc347739aa467"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjAzNTcz", "url": "https://github.com/camunda-cloud/zeebe/pull/4717#pullrequestreview-438203573", "createdAt": "2020-06-26T10:59:28Z", "commit": {"oid": "51028bada20d08277f3cc5a662c70ea2777a3ce9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c73738adf3b8e4be59cd69cf81f38baa95195b32", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/c73738adf3b8e4be59cd69cf81f38baa95195b32", "committedDate": "2020-06-26T11:37:23Z", "message": "chore(logstreams): check records are consistently appended\n  * positions are now consecutive (they increase by 1)\n  * before appending, we check that there are no gaps between records"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51028bada20d08277f3cc5a662c70ea2777a3ce9", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/51028bada20d08277f3cc5a662c70ea2777a3ce9", "committedDate": "2020-06-26T07:19:56Z", "message": "chore(atomix): removed unnecessary code"}, "afterCommit": {"oid": "c73738adf3b8e4be59cd69cf81f38baa95195b32", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/c73738adf3b8e4be59cd69cf81f38baa95195b32", "committedDate": "2020-06-26T11:37:23Z", "message": "chore(logstreams): check records are consistently appended\n  * positions are now consecutive (they increase by 1)\n  * before appending, we check that there are no gaps between records"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2771, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}