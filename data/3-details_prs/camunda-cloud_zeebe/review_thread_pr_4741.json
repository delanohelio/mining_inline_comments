{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTg3NDc2", "number": 4741, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOTowNDoyMVrOEGQzLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOTowNDoyMVrOEGQzLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDAyMTU2OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/nwe/event/BoundaryEventProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOTowNDoyMVrOGk8qCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMTowODoyNVrOGlA8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM5NTcyMQ==", "bodyText": "Is the flownode that the boundary event is attached to already terminated when the boundary event completed? I would expect some logic here to check whether the boundary event is interrupting or not.", "url": "https://github.com/camunda-cloud/zeebe/pull/4741#discussion_r441395721", "createdAt": "2020-06-17T09:04:21Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/event/BoundaryEventProcessor.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.event;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableBoundaryEvent;\n+\n+public final class BoundaryEventProcessor implements BpmnElementProcessor<ExecutableBoundaryEvent> {\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+\n+  public BoundaryEventProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableBoundaryEvent> getType() {\n+    return ExecutableBoundaryEvent.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+    // the boundary event is already triggered when the activating event is written\n+\n+    stateTransitionBehavior.transitionToActivated(context);\n+  }\n+\n+  @Override\n+  public void onActivated(final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.transitionToCompleting(context);\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    variableMappingBehavior\n+        .applyOutputMappings(context, element)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToCompleted(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onCompleted(final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79a8de5786672af690b31024a9e73c0234c828b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ2NTk0Mg==", "bodyText": "This logic is in the activity itself. When the activating event is written for the boundary event then it was already triggered and the activity was terminated - if it is an interrupting boundary event. So, there is no much to do here.", "url": "https://github.com/camunda-cloud/zeebe/pull/4741#discussion_r441465942", "createdAt": "2020-06-17T11:08:25Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/event/BoundaryEventProcessor.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.event;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableBoundaryEvent;\n+\n+public final class BoundaryEventProcessor implements BpmnElementProcessor<ExecutableBoundaryEvent> {\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+\n+  public BoundaryEventProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableBoundaryEvent> getType() {\n+    return ExecutableBoundaryEvent.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+    // the boundary event is already triggered when the activating event is written\n+\n+    stateTransitionBehavior.transitionToActivated(context);\n+  }\n+\n+  @Override\n+  public void onActivated(final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.transitionToCompleting(context);\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    variableMappingBehavior\n+        .applyOutputMappings(context, element)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToCompleted(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onCompleted(final ExecutableBoundaryEvent element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM5NTcyMQ=="}, "originalCommit": {"oid": "a79a8de5786672af690b31024a9e73c0234c828b"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 526, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}