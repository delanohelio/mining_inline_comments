{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2Nzc3Njg4", "number": 4040, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo0NDo1NlrODnxUZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1Nzo0MFrODn14eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI5MDkzOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/deployment/PersistedWorkflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo0NDo1NlrOF19UJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTo0NDo1NlrOF19UJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMzQzMA==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392123430", "createdAt": "2020-03-13T09:44:56Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/deployment/PersistedWorkflow.java", "diffHunk": "@@ -7,103 +7,68 @@\n  */\n package io.zeebe.engine.state.deployment;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-import static io.zeebe.util.buffer.BufferUtil.bufferAsString;\n-import static io.zeebe.util.buffer.BufferUtil.readIntoBuffer;\n-import static io.zeebe.util.buffer.BufferUtil.writeIntoBuffer;\n-\n import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.BinaryProperty;\n+import io.zeebe.msgpack.property.IntegerProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.StringProperty;\n import io.zeebe.protocol.impl.record.value.deployment.DeploymentResource;\n import io.zeebe.protocol.impl.record.value.deployment.Workflow;\n import org.agrona.DirectBuffer;\n import org.agrona.MutableDirectBuffer;\n import org.agrona.concurrent.UnsafeBuffer;\n \n-public final class PersistedWorkflow implements DbValue {\n-  final UnsafeBuffer bpmnProcessId = new UnsafeBuffer(0, 0);\n-  final UnsafeBuffer resourceName = new UnsafeBuffer(0, 0);\n-  final UnsafeBuffer resource = new UnsafeBuffer(0, 0);\n-  int version = -1;\n-  long key = -1;\n+public final class PersistedWorkflow extends UnpackedObject implements DbValue {\n+  private final IntegerProperty versionProp = new IntegerProperty(\"version\", -1);\n+  private final LongProperty keyProp = new LongProperty(\"key\", -1L);\n+  private final StringProperty bpmnProcessIdProp = new StringProperty(\"bpmnProcessId\");\n+  private final StringProperty resourceNameProp = new StringProperty(\"resourceName\");\n+  private final BinaryProperty resourceProp = new BinaryProperty(\"resource\");\n+\n+  public PersistedWorkflow() {\n+    declareProperty(versionProp)\n+        .declareProperty(keyProp)\n+        .declareProperty(bpmnProcessIdProp)\n+        .declareProperty(resourceNameProp)\n+        .declareProperty(resourceProp);\n+  }\n \n   public void wrap(\n       final DeploymentResource resource, final Workflow workflow, final long workflowKey) {\n-    this.resource.wrap(resource.getResourceBuffer());\n-    this.resourceName.wrap(resource.getResourceNameBuffer());\n-    this.bpmnProcessId.wrap(workflow.getBpmnProcessIdBuffer());\n+    bpmnProcessIdProp.setValue(workflow.getBpmnProcessIdBuffer());\n+    resourceNameProp.setValue(resource.getResourceNameBuffer());\n+    resourceProp.setValue(resource.getResourceBuffer());\n \n-    this.version = workflow.getVersion();\n-    this.key = workflowKey;\n+    versionProp.setValue(workflow.getVersion());\n+    keyProp.setValue(workflowKey);\n   }\n \n   public int getVersion() {\n-    return version;\n+    return versionProp.getValue();\n   }\n \n   public long getKey() {\n-    return key;\n+    return keyProp.getValue();\n   }\n \n-  public UnsafeBuffer getBpmnProcessId() {\n-    return bpmnProcessId;\n+  public DirectBuffer getBpmnProcessId() {\n+    return bpmnProcessIdProp.getValue();\n   }\n \n-  public UnsafeBuffer getResourceName() {\n-    return resourceName;\n+  public DirectBuffer getResourceName() {\n+    return resourceNameProp.getValue();\n   }\n \n-  public UnsafeBuffer getResource() {\n-    return resource;\n+  public DirectBuffer getResource() {\n+    return resourceProp.getValue();\n   }\n \n   @Override\n   public void wrap(final DirectBuffer buffer, final int offset, final int length) {\n-    int valueOffset = offset;\n-    version = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    valueOffset += Integer.BYTES;\n-    key = buffer.getLong(valueOffset, ZB_DB_BYTE_ORDER);\n-    valueOffset += Long.BYTES;\n-    valueOffset = readIntoBuffer(buffer, valueOffset, bpmnProcessId);\n-    valueOffset = readIntoBuffer(buffer, valueOffset, resourceName);\n-    readIntoBuffer(buffer, valueOffset, resource);\n-  }\n-\n-  @Override\n-  public int getLength() {\n-    return Long.BYTES\n-        + Integer.BYTES\n-        + Integer.BYTES * 3 // sizes\n-        + bpmnProcessId.capacity()\n-        + resourceName.capacity()\n-        + resource.capacity();\n-  }\n-\n-  @Override\n-  public void write(final MutableDirectBuffer buffer, final int offset) {\n-    int valueOffset = offset;\n-    buffer.putInt(offset, version, ZB_DB_BYTE_ORDER);\n-    valueOffset += Integer.BYTES;\n-    buffer.putLong(valueOffset, key, ZB_DB_BYTE_ORDER);\n-    valueOffset += Long.BYTES;\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, bpmnProcessId);\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, resourceName);\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, resource);\n-    assert (valueOffset - offset) == getLength() : \"End offset differs with getLength()\";\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"PersistedWorkflow{\"\n-        + \"version=\"\n-        + version\n-        + \", key=\"\n-        + key\n-        + \", bpmnProcessId=\"\n-        + bufferAsString(bpmnProcessId)\n-        + \", resourceName=\"\n-        + bufferAsString(resourceName)\n-        + \", resource=\"\n-        + bufferAsString(resource)\n-        + '}';\n+    final byte[] bytes = new byte[length];\n+    final MutableDirectBuffer newBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(0, bytes, 0, length);\n+    super.wrap(newBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beacba411affdbbf7eac5d82b9221608e25d2e30"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDM1MTg5OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/deployment/WorkflowPersistenceCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDowNDowMlrOF196pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNjowMzoxMFrOF2mY8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzI4NA==", "bodyText": "We should think about combining latestWorkflowColumnFamily and digestByIdColumnFamily. Both column families are mapped by the BPMN process id (here called workflowId). One column family stores the latest version number of the workflow and the other stores the digest of the latest workflow.", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392133284", "createdAt": "2020-03-13T10:04:02Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/deployment/WorkflowPersistenceCache.java", "diffHunk": "@@ -50,14 +49,15 @@\n   private final PersistedWorkflow persistedWorkflow;\n \n   private final ColumnFamily<DbCompositeKey, PersistedWorkflow> workflowByIdAndVersionColumnFamily;\n+  private final DbLong workflowVersion;\n   private final DbCompositeKey<DbString, DbLong> idAndVersionKey;\n \n-  private final ColumnFamily<DbString, DbLong> latestWorkflowColumnFamily;\n+  private final ColumnFamily<DbString, LatestWorkflowVersion> latestWorkflowColumnFamily;\n   private final DbString workflowId;\n-  private final DbLong workflowVersion;\n+  private final LatestWorkflowVersion latestVersion = new LatestWorkflowVersion();\n \n-  private final ColumnFamily<DbString, DbBuffer> digestByIdColumnFamily;\n-  private final DbBuffer digest;\n+  private final ColumnFamily<DbString, Digest> digestByIdColumnFamily;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMyMTQ1Mw==", "bodyText": "I tried to do this but it's not very nice since they're used in different contexts it's not very easy to join them. The digest is only read and written during the workflow transformation but the version is often used in the engine so by uniting them we'd be constantly reading the digest unnecessarily. They're also written in different places, the digest is written during the transformation and the version is put in with the deployment. I'm not sure if that needs to stay like that or maybe it can be refactored", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392321453", "createdAt": "2020-03-13T16:03:11Z", "author": {"login": "MiguelPires"}, "path": "engine/src/main/java/io/zeebe/engine/state/deployment/WorkflowPersistenceCache.java", "diffHunk": "@@ -50,14 +49,15 @@\n   private final PersistedWorkflow persistedWorkflow;\n \n   private final ColumnFamily<DbCompositeKey, PersistedWorkflow> workflowByIdAndVersionColumnFamily;\n+  private final DbLong workflowVersion;\n   private final DbCompositeKey<DbString, DbLong> idAndVersionKey;\n \n-  private final ColumnFamily<DbString, DbLong> latestWorkflowColumnFamily;\n+  private final ColumnFamily<DbString, LatestWorkflowVersion> latestWorkflowColumnFamily;\n   private final DbString workflowId;\n-  private final DbLong workflowVersion;\n+  private final LatestWorkflowVersion latestVersion = new LatestWorkflowVersion();\n \n-  private final ColumnFamily<DbString, DbBuffer> digestByIdColumnFamily;\n-  private final DbBuffer digest;\n+  private final ColumnFamily<DbString, Digest> digestByIdColumnFamily;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzI4NA=="}, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5NjQwMA==", "bodyText": "I don't see a problem that the properties are written and read in different places. I agree that reading the digest if it is not needed, feels not right. On the other side, having another column family may cost a lot of memory. But I'm not sure what is better here. Let's wait on the RocksDB investigation results of Chris.", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392796400", "createdAt": "2020-03-16T06:03:10Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/deployment/WorkflowPersistenceCache.java", "diffHunk": "@@ -50,14 +49,15 @@\n   private final PersistedWorkflow persistedWorkflow;\n \n   private final ColumnFamily<DbCompositeKey, PersistedWorkflow> workflowByIdAndVersionColumnFamily;\n+  private final DbLong workflowVersion;\n   private final DbCompositeKey<DbString, DbLong> idAndVersionKey;\n \n-  private final ColumnFamily<DbString, DbLong> latestWorkflowColumnFamily;\n+  private final ColumnFamily<DbString, LatestWorkflowVersion> latestWorkflowColumnFamily;\n   private final DbString workflowId;\n-  private final DbLong workflowVersion;\n+  private final LatestWorkflowVersion latestVersion = new LatestWorkflowVersion();\n \n-  private final ColumnFamily<DbString, DbBuffer> digestByIdColumnFamily;\n-  private final DbBuffer digest;\n+  private final ColumnFamily<DbString, Digest> digestByIdColumnFamily;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEzMzI4NA=="}, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQzOTAxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozMjoxN1rOF1-xYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNjowNTozN1rOF2mbYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzI5Ng==", "bodyText": "Now, every DbValue class extends UnpackedObject implements DbValue. What do you think about making it more clear that a DbValue must extend UnpackedObject?\nAnd deleting the other DbValue implementations?\nFor example:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class ElementInstance extends UnpackedObject implements DbValue {\n          \n          \n            \n            public final class ElementInstance extends DbObject {", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392147296", "createdAt": "2020-03-13T10:32:17Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -7,80 +7,95 @@\n  */\n package io.zeebe.engine.state.instance;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-import static io.zeebe.util.buffer.BufferUtil.readIntoBuffer;\n-import static io.zeebe.util.buffer.BufferUtil.writeIntoBuffer;\n-\n import io.zeebe.db.DbValue;\n import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.IntegerProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n import org.agrona.DirectBuffer;\n-import org.agrona.MutableDirectBuffer;\n-\n-public final class ElementInstance implements DbValue {\n-\n-  private final IndexedRecord elementRecord;\n-\n-  private long parentKey = -1;\n-  private int childCount;\n-  private long jobKey;\n-  private int activeTokens = 0;\n-\n-  private int multiInstanceLoopCounter = 0;\n-  private long interruptingEventKey = -1;\n-\n-  private long calledChildInstanceKey = -1L;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class ElementInstance extends UnpackedObject implements DbValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4ODYzMg==", "bodyText": "I'm not sure about this. Unless we change the db to only take msgpack format instead of DbValues, this doesn't give us much right? And we don't want to force the db values to be msgpack since in the future we might want a column family with a different format for whatever reason (even if it has different backwards compat properties). But I agree we can delete some of the DbValue implementations that are not also DbKeys.", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392588632", "createdAt": "2020-03-14T13:31:25Z", "author": {"login": "MiguelPires"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -7,80 +7,95 @@\n  */\n package io.zeebe.engine.state.instance;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-import static io.zeebe.util.buffer.BufferUtil.readIntoBuffer;\n-import static io.zeebe.util.buffer.BufferUtil.writeIntoBuffer;\n-\n import io.zeebe.db.DbValue;\n import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.IntegerProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n import org.agrona.DirectBuffer;\n-import org.agrona.MutableDirectBuffer;\n-\n-public final class ElementInstance implements DbValue {\n-\n-  private final IndexedRecord elementRecord;\n-\n-  private long parentKey = -1;\n-  private int childCount;\n-  private long jobKey;\n-  private int activeTokens = 0;\n-\n-  private int multiInstanceLoopCounter = 0;\n-  private long interruptingEventKey = -1;\n-\n-  private long calledChildInstanceKey = -1L;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class ElementInstance extends UnpackedObject implements DbValue {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzI5Ng=="}, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5NzAyNA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392797024", "createdAt": "2020-03-16T06:05:37Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -7,80 +7,95 @@\n  */\n package io.zeebe.engine.state.instance;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-import static io.zeebe.util.buffer.BufferUtil.readIntoBuffer;\n-import static io.zeebe.util.buffer.BufferUtil.writeIntoBuffer;\n-\n import io.zeebe.db.DbValue;\n import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.IntegerProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n import org.agrona.DirectBuffer;\n-import org.agrona.MutableDirectBuffer;\n-\n-public final class ElementInstance implements DbValue {\n-\n-  private final IndexedRecord elementRecord;\n-\n-  private long parentKey = -1;\n-  private int childCount;\n-  private long jobKey;\n-  private int activeTokens = 0;\n-\n-  private int multiInstanceLoopCounter = 0;\n-  private long interruptingEventKey = -1;\n-\n-  private long calledChildInstanceKey = -1L;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class ElementInstance extends UnpackedObject implements DbValue {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzI5Ng=="}, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQ3NDMwOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo0NDozMVrOF1_Hdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo0NDozMVrOF1_Hdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE1Mjk1MA==", "bodyText": "We increment or decrement a property in different places. What about implementing both functions in  IntegerProperty/LongProperty?", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392152950", "createdAt": "2020-03-13T10:44:31Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -105,11 +120,12 @@ public boolean isInFinalState() {\n   }\n \n   public void spawnToken() {\n-    activeTokens += 1;\n+    activeTokensProp.setValue(activeTokensProp.getValue() + 1);\n   }\n \n   public void consumeToken() {\n-    activeTokens -= 1;\n+    final int activeTokens = activeTokensProp.getValue() - 1;\n+    activeTokensProp.setValue(activeTokens);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQ4MDQ3OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo0NjozOVrOF1_Leg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDo0NjozOVrOF1_Leg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE1Mzk3OA==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392153978", "createdAt": "2020-03-13T10:46:39Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/ElementInstance.java", "diffHunk": "@@ -163,91 +179,13 @@ public boolean isInterrupted() {\n \n   @Override\n   public void wrap(final DirectBuffer buffer, int offset, final int length) {\n-    final int startOffset = offset;\n-    childCount = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    jobKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    activeTokens = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    parentKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    offset = readIntoBuffer(buffer, offset, elementRecord);\n-\n-    multiInstanceLoopCounter = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    calledChildInstanceKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    interruptingEventKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    assert (offset - startOffset) == length : \"End offset differs from length\";\n-  }\n-\n-  @Override\n-  public int getLength() {\n-    return 4 * Long.BYTES + 4 * Integer.BYTES + elementRecord.getLength();\n-  }\n-\n-  @Override\n-  public void write(final MutableDirectBuffer buffer, int offset) {\n-    final int startOffset = offset;\n-\n-    buffer.putInt(offset, childCount, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    buffer.putLong(offset, jobKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putInt(offset, activeTokens, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    buffer.putLong(offset, parentKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    offset = writeIntoBuffer(buffer, offset, elementRecord);\n-\n-    buffer.putInt(offset, multiInstanceLoopCounter, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    buffer.putLong(offset, calledChildInstanceKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putLong(offset, interruptingEventKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    assert (offset - startOffset) == getLength() : \"End offset differs from getLength()\";\n+    final byte[] bytes = new byte[length];\n+    final UnsafeBuffer mutableBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(offset, bytes, 0, length);\n+    super.wrap(mutableBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDUzNzk4OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/IncidentKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTowNTo1N1rOF1_vqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTowNTo1N1rOF1_vqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MzI0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final LongProperty keyProp = new LongProperty(\"key\");\n          \n          \n            \n              private final LongProperty keyProp = new LongProperty(\"incidentKey\");", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392163240", "createdAt": "2020-03-13T11:05:57Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/IncidentKey.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state.instance;\n+\n+import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.LongProperty;\n+\n+public class IncidentKey extends UnpackedObject implements DbValue {\n+\n+  private final LongProperty keyProp = new LongProperty(\"key\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDU1MTUxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/IndexedRecord.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMDo1MVrOF1_4Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMToxMDo1MVrOF1_4Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NTM4Ng==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392165386", "createdAt": "2020-03-13T11:10:51Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/IndexedRecord.java", "diffHunk": "@@ -7,96 +7,76 @@\n  */\n package io.zeebe.engine.state.instance;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-\n import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.EnumProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.ObjectProperty;\n import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n-import io.zeebe.util.buffer.BufferUtil;\n import org.agrona.DirectBuffer;\n import org.agrona.MutableDirectBuffer;\n import org.agrona.concurrent.UnsafeBuffer;\n \n-public final class IndexedRecord implements DbValue {\n-\n-  private final WorkflowInstanceRecord value = new WorkflowInstanceRecord();\n-  private long key;\n-  private WorkflowInstanceIntent state;\n+public final class IndexedRecord extends UnpackedObject implements DbValue {\n+  private final LongProperty keyProp = new LongProperty(\"key\", 0L);\n+  private final EnumProperty<WorkflowInstanceIntent> stateProp =\n+      new EnumProperty<>(\"state\", WorkflowInstanceIntent.class);\n+  private final ObjectProperty<WorkflowInstanceRecord> valueProp =\n+      new ObjectProperty<>(\"record\", new WorkflowInstanceRecord());\n \n-  IndexedRecord() {}\n+  IndexedRecord() {\n+    declareProperty(keyProp).declareProperty(stateProp).declareProperty(valueProp);\n+  }\n \n   public IndexedRecord(\n       final long key,\n       final WorkflowInstanceIntent instanceState,\n       final WorkflowInstanceRecord record) {\n-    this.key = key;\n-    this.state = instanceState;\n+    this();\n+    keyProp.setValue(key);\n+    stateProp.setValue(instanceState);\n     setValue(record);\n   }\n \n   public long getKey() {\n-    return key;\n+    return keyProp.getValue();\n+  }\n+\n+  public IndexedRecord setKey(final long key) {\n+    keyProp.setValue(key);\n+    return this;\n   }\n \n   public WorkflowInstanceIntent getState() {\n-    return state;\n+    return stateProp.getValue();\n   }\n \n-  public void setState(final WorkflowInstanceIntent state) {\n-    this.state = state;\n+  public IndexedRecord setState(final WorkflowInstanceIntent state) {\n+    stateProp.setValue(state);\n+    return this;\n   }\n \n   public WorkflowInstanceRecord getValue() {\n-    return value;\n+    return valueProp.getValue();\n   }\n \n-  public void setValue(final WorkflowInstanceRecord value) {\n+  public IndexedRecord setValue(final WorkflowInstanceRecord value) {\n     final MutableDirectBuffer valueBuffer = new UnsafeBuffer(0, 0);\n     final int encodedLength = value.getLength();\n     valueBuffer.wrap(new byte[encodedLength]);\n \n     value.write(valueBuffer, 0);\n-    this.value.wrap(valueBuffer, 0, encodedLength);\n-  }\n-\n-  @Override\n-  public void wrap(final DirectBuffer buffer, int offset, final int length) {\n-    final int startOffset = offset;\n-    key = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    final short stateIdx = buffer.getShort(offset, ZB_DB_BYTE_ORDER);\n-    state = WorkflowInstanceIntent.values()[stateIdx];\n-    offset += Short.BYTES;\n+    valueProp.getValue().wrap(valueBuffer, 0, encodedLength);\n \n-    final int currentLength = offset - startOffset;\n-    final DirectBuffer clonedBuffer =\n-        BufferUtil.cloneBuffer(buffer, offset, length - currentLength);\n-    value.wrap(clonedBuffer);\n+    return this;\n   }\n \n   @Override\n-  public int getLength() {\n-    return Long.BYTES + Short.BYTES + value.getLength();\n-  }\n-\n-  @Override\n-  public void write(final MutableDirectBuffer buffer, int offset) {\n-    final int startOffset = offset;\n-\n-    buffer.putLong(offset, key, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putShort(offset, state.value(), ZB_DB_BYTE_ORDER);\n-    offset += Short.BYTES;\n-\n-    assert (offset - startOffset) == getLength() - value.getLength()\n-        : \"End offset differs with getLength()\";\n-    value.write(buffer, offset);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"IndexedRecord{\" + \"key=\" + key + \", state=\" + state + \", value=\" + value + '}';\n+  public void wrap(final DirectBuffer buffer, int offset, final int length) {\n+    final byte[] bytes = new byte[length];\n+    final UnsafeBuffer mutableBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(offset, bytes, 0, length);\n+    super.wrap(mutableBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDc1NTg5OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMjoyOTo0OFrOF2B4IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMjoyOTo0OFrOF2B4IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE5ODE3Nw==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392198177", "createdAt": "2020-03-13T12:29:48Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/instance/TimerInstance.java", "diffHunk": "@@ -7,133 +7,97 @@\n  */\n package io.zeebe.engine.state.instance;\n \n-import static io.zeebe.db.impl.ZeebeDbConstants.ZB_DB_BYTE_ORDER;\n-import static io.zeebe.util.buffer.BufferUtil.readIntoBuffer;\n-import static io.zeebe.util.buffer.BufferUtil.writeIntoBuffer;\n-\n import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.IntegerProperty;\n+import io.zeebe.msgpack.property.LongProperty;\n+import io.zeebe.msgpack.property.StringProperty;\n import org.agrona.DirectBuffer;\n-import org.agrona.MutableDirectBuffer;\n import org.agrona.concurrent.UnsafeBuffer;\n \n-public final class TimerInstance implements DbValue {\n+public final class TimerInstance extends UnpackedObject implements DbValue {\n \n   public static final int NO_ELEMENT_INSTANCE = -1;\n \n-  private final DirectBuffer handlerNodeId = new UnsafeBuffer(0, 0);\n-  private long workflowKey;\n-  private long key;\n-  private long elementInstanceKey;\n-  private long workflowInstanceKey;\n-  private long dueDate;\n-  private int repetitions;\n+  private final StringProperty handlerNodeIdProp = new StringProperty(\"handlerNodeId\", \"\");\n+  private final LongProperty workflowKeyProp = new LongProperty(\"workflowKey\", 0L);\n+  private final LongProperty keyProp = new LongProperty(\"key\", 0L);\n+  private final LongProperty elementInstanceKeyProp = new LongProperty(\"elementInstanceKey\", 0L);\n+  private final LongProperty workflowInstanceKeyProp = new LongProperty(\"workflowInstanceKey\", 0L);\n+  private final LongProperty dueDateProp = new LongProperty(\"dueDate\", 0L);\n+  private final IntegerProperty repetitionsProp = new IntegerProperty(\"repetitions\", 0);\n+\n+  public TimerInstance() {\n+    declareProperty(handlerNodeIdProp)\n+        .declareProperty(workflowKeyProp)\n+        .declareProperty(keyProp)\n+        .declareProperty(elementInstanceKeyProp)\n+        .declareProperty(workflowInstanceKeyProp)\n+        .declareProperty(dueDateProp)\n+        .declareProperty(repetitionsProp);\n+  }\n \n   public long getElementInstanceKey() {\n-    return elementInstanceKey;\n+    return elementInstanceKeyProp.getValue();\n   }\n \n   public void setElementInstanceKey(final long elementInstanceKey) {\n-    this.elementInstanceKey = elementInstanceKey;\n+    elementInstanceKeyProp.setValue(elementInstanceKey);\n   }\n \n   public long getDueDate() {\n-    return dueDate;\n+    return dueDateProp.getValue();\n   }\n \n   public void setDueDate(final long dueDate) {\n-    this.dueDate = dueDate;\n+    dueDateProp.setValue(dueDate);\n   }\n \n   public long getKey() {\n-    return key;\n+    return keyProp.getValue();\n   }\n \n   public void setKey(final long key) {\n-    this.key = key;\n+    keyProp.setValue(key);\n   }\n \n   public DirectBuffer getHandlerNodeId() {\n-    return handlerNodeId;\n+    return handlerNodeIdProp.getValue();\n   }\n \n   public void setHandlerNodeId(final DirectBuffer handlerNodeId) {\n-    this.handlerNodeId.wrap(handlerNodeId);\n+    handlerNodeIdProp.setValue(handlerNodeId);\n   }\n \n   public int getRepetitions() {\n-    return repetitions;\n+    return repetitionsProp.getValue();\n   }\n \n   public void setRepetitions(final int repetitions) {\n-    this.repetitions = repetitions;\n+    repetitionsProp.setValue(repetitions);\n   }\n \n   public long getWorkflowKey() {\n-    return this.workflowKey;\n+    return workflowKeyProp.getValue();\n   }\n \n   public void setWorkflowKey(final long workflowKey) {\n-    this.workflowKey = workflowKey;\n+    workflowKeyProp.setValue(workflowKey);\n   }\n \n   public long getWorkflowInstanceKey() {\n-    return workflowInstanceKey;\n+    return workflowInstanceKeyProp.getValue();\n   }\n \n   public void setWorkflowInstanceKey(final long workflowInstanceKey) {\n-    this.workflowInstanceKey = workflowInstanceKey;\n-  }\n-\n-  @Override\n-  public int getLength() {\n-    return 5 * Long.BYTES + 2 * Integer.BYTES + handlerNodeId.capacity();\n-  }\n-\n-  @Override\n-  public void write(final MutableDirectBuffer buffer, int offset) {\n-    buffer.putLong(offset, elementInstanceKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putLong(offset, workflowInstanceKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putLong(offset, dueDate, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putLong(offset, key, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putLong(offset, workflowKey, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    buffer.putInt(offset, repetitions, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    offset = writeIntoBuffer(buffer, offset, handlerNodeId);\n-    assert offset == getLength() : \"End offset differs from getLength()\";\n+    workflowInstanceKeyProp.setValue(workflowInstanceKey);\n   }\n \n   @Override\n   public void wrap(final DirectBuffer buffer, int offset, final int length) {\n-    elementInstanceKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    workflowInstanceKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    dueDate = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    key = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    workflowKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    repetitions = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    offset = readIntoBuffer(buffer, offset, handlerNodeId);\n-    assert offset == length : \"End offset differs from length\";\n+    final byte[] bytes = new byte[length];\n+    final UnsafeBuffer mutableBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(offset, bytes, 0, length);\n+    super.wrap(mutableBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDc2MzM5OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/message/Message.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMjozMjoyMFrOF2B8jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMjozMjoyMFrOF2B8jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE5OTMxMA==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392199310", "createdAt": "2020-03-13T12:32:20Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/message/Message.java", "diffHunk": "@@ -36,82 +44,51 @@ public Message(\n       final DirectBuffer id,\n       final long timeToLive,\n       final long deadline) {\n-    this.name.wrap(name);\n-    this.correlationKey.wrap(correlationKey);\n-    this.variables.wrap(variables);\n-    this.id.wrap(id);\n-\n-    this.key = key;\n-    this.timeToLive = timeToLive;\n-    this.deadline = deadline;\n+    this();\n+\n+    nameProp.setValue(name);\n+    correlationKeyProp.setValue(correlationKey);\n+    variablesProp.setValue(variables);\n+    idProp.setValue(id);\n+\n+    keyProp.setValue(key);\n+    timeToLiveProp.setValue(timeToLive);\n+    deadlineProp.setValue(deadline);\n   }\n \n   public DirectBuffer getName() {\n-    return name;\n+    return nameProp.getValue();\n   }\n \n   public DirectBuffer getCorrelationKey() {\n-    return correlationKey;\n+    return correlationKeyProp.getValue();\n   }\n \n   public DirectBuffer getVariables() {\n-    return variables;\n+    return variablesProp.getValue();\n   }\n \n   public DirectBuffer getId() {\n-    return id;\n+    return idProp.getValue();\n   }\n \n   public long getTimeToLive() {\n-    return timeToLive;\n+    return timeToLiveProp.getValue();\n   }\n \n   public long getDeadline() {\n-    return deadline;\n+    return deadlineProp.getValue();\n   }\n \n   public long getKey() {\n-    return key;\n+    return keyProp.getValue();\n   }\n \n   @Override\n   public void wrap(final DirectBuffer buffer, int offset, final int length) {\n-    offset = readIntoBuffer(buffer, offset, name);\n-    offset = readIntoBuffer(buffer, offset, correlationKey);\n-    offset = readIntoBuffer(buffer, offset, variables);\n-    offset = readIntoBuffer(buffer, offset, id);\n-\n-    timeToLive = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-    deadline = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-    key = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-  }\n-\n-  @Override\n-  public int getLength() {\n-    return name.capacity()\n-        + correlationKey.capacity()\n-        + variables.capacity()\n-        + id.capacity()\n-        + Integer.BYTES * 4\n-        + Long.BYTES * 3;\n-  }\n-\n-  @Override\n-  public void write(final MutableDirectBuffer buffer, final int offset) {\n-    int valueOffset = offset;\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, name);\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, correlationKey);\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, variables);\n-    valueOffset = writeIntoBuffer(buffer, valueOffset, id);\n-\n-    buffer.putLong(valueOffset, timeToLive, ZB_DB_BYTE_ORDER);\n-    valueOffset += Long.BYTES;\n-    buffer.putLong(valueOffset, deadline, ZB_DB_BYTE_ORDER);\n-    valueOffset += Long.BYTES;\n-    buffer.putLong(valueOffset, key, ZB_DB_BYTE_ORDER);\n-    valueOffset += Long.BYTES;\n-    assert (valueOffset - offset) == getLength() : \"End offset differs with getLength()\";\n+    final byte[] bytes = new byte[length];\n+    final MutableDirectBuffer newBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(0, bytes, 0, length);\n+    super.wrap(newBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDkxNjE3OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/message/SubscriptionValue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzoyMjo0MFrOF2DbDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMjo0NjoxM1rOF2yqiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIyMzUwMA==", "bodyText": "We have multiple of these value objects which just wraps the record in it. What do you think about having only one wrapper class?", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392223500", "createdAt": "2020-03-13T13:22:40Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/message/SubscriptionValue.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state.message;\n+\n+import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.ObjectProperty;\n+import io.zeebe.protocol.impl.record.value.message.MessageStartEventSubscriptionRecord;\n+\n+public class SubscriptionValue extends UnpackedObject implements DbValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5NzUxMw==", "bodyText": "The ObjectProperty needs a record object so we need to know the type. Besides, this way if we want to add something to the state we just have to add a property, so I guess it's easier for the future", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392997513", "createdAt": "2020-03-16T12:46:13Z", "author": {"login": "MiguelPires"}, "path": "engine/src/main/java/io/zeebe/engine/state/message/SubscriptionValue.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.state.message;\n+\n+import io.zeebe.db.DbValue;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.msgpack.property.ObjectProperty;\n+import io.zeebe.protocol.impl.record.value.message.MessageStartEventSubscriptionRecord;\n+\n+public class SubscriptionValue extends UnpackedObject implements DbValue {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIyMzUwMA=="}, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDk4MzUxOnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/state/message/WorkflowInstanceSubscription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo0MjozMlrOF2EFsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo0MjozMlrOF2EFsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzNDQxNg==", "bodyText": "See 1).", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392234416", "createdAt": "2020-03-13T13:42:32Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/state/message/WorkflowInstanceSubscription.java", "diffHunk": "@@ -58,186 +68,112 @@ public WorkflowInstanceSubscription(\n       final boolean closeOnCorrelate) {\n     this(workflowInstanceKey, elementInstanceKey, bpmnProcessId);\n \n-    this.targetElementId.wrap(targetElementId);\n-    this.commandSentTime = commandSentTime;\n-    this.messageName.wrap(messageName);\n-    this.correlationKey.wrap(correlationKey);\n-    this.closeOnCorrelate = closeOnCorrelate;\n+    targetElementIdProp.setValue(targetElementId);\n+    commandSentTimeProp.setValue(commandSentTime);\n+    messageNameProp.setValue(messageName);\n+    correlationKeyProp.setValue(correlationKey);\n+    closeOnCorrelateProp.setValue(closeOnCorrelate);\n   }\n \n   public DirectBuffer getMessageName() {\n-    return messageName;\n+    return messageNameProp.getValue();\n   }\n \n   public void setMessageName(final DirectBuffer messageName) {\n-    this.messageName.wrap(messageName);\n+    messageNameProp.setValue(messageName);\n   }\n \n   public DirectBuffer getCorrelationKey() {\n-    return correlationKey;\n+    return correlationKeyProp.getValue();\n   }\n \n   public void setCorrelationKey(final DirectBuffer correlationKey) {\n-    this.correlationKey.wrap(correlationKey);\n+    correlationKeyProp.setValue(correlationKey);\n   }\n \n   public DirectBuffer getTargetElementId() {\n-    return targetElementId;\n+    return targetElementIdProp.getValue();\n   }\n \n   public void setTargetElementId(final DirectBuffer targetElementId) {\n-    this.targetElementId.wrap(targetElementId);\n+    targetElementIdProp.setValue(targetElementId);\n   }\n \n   public long getWorkflowInstanceKey() {\n-    return workflowInstanceKey;\n+    return workflowInstanceKeyProp.getValue();\n   }\n \n   public void setWorkflowInstanceKey(final long workflowInstanceKey) {\n-    this.workflowInstanceKey = workflowInstanceKey;\n+    workflowInstanceKeyProp.setValue(workflowInstanceKey);\n   }\n \n   public long getElementInstanceKey() {\n-    return elementInstanceKey;\n+    return elementInstanceKeyProp.getValue();\n   }\n \n   public void setElementInstanceKey(final long elementInstanceKey) {\n-    this.elementInstanceKey = elementInstanceKey;\n+    elementInstanceKeyProp.setValue(elementInstanceKey);\n   }\n \n   public DirectBuffer getBpmnProcessId() {\n-    return bpmnProcessId;\n+    return bpmnProcessIdProp.getValue();\n   }\n \n   public void setBpmnProcessId(final DirectBuffer bpmnProcessId) {\n-    this.bpmnProcessId.wrap(bpmnProcessId);\n+    bpmnProcessIdProp.setValue(bpmnProcessId);\n   }\n \n   public long getCommandSentTime() {\n-    return commandSentTime;\n+    return commandSentTimeProp.getValue();\n   }\n \n   public void setCommandSentTime(final long commandSentTime) {\n-    this.commandSentTime = commandSentTime;\n+    commandSentTimeProp.setValue(commandSentTime);\n   }\n \n   public int getSubscriptionPartitionId() {\n-    return subscriptionPartitionId;\n+    return subscriptionPartitionIdProp.getValue();\n   }\n \n   public void setSubscriptionPartitionId(final int subscriptionPartitionId) {\n-    this.subscriptionPartitionId = subscriptionPartitionId;\n+    subscriptionPartitionIdProp.setValue(subscriptionPartitionId);\n   }\n \n   public boolean shouldCloseOnCorrelate() {\n-    return closeOnCorrelate;\n+    return closeOnCorrelateProp.getValue();\n   }\n \n   public void setCloseOnCorrelate(final boolean closeOnCorrelate) {\n-    this.closeOnCorrelate = closeOnCorrelate;\n+    closeOnCorrelateProp.setValue(closeOnCorrelate);\n   }\n \n   public boolean isOpening() {\n-    return state == STATE_OPENING;\n+    return stateProp.getValue() == State.STATE_OPENING;\n   }\n \n   public boolean isClosing() {\n-    return state == STATE_CLOSING;\n+    return stateProp.getValue() == State.STATE_CLOSING;\n   }\n \n   public void setOpened() {\n-    state = STATE_OPENED;\n+    stateProp.setValue(State.STATE_OPENED);\n   }\n \n   public void setClosing() {\n-    state = STATE_CLOSING;\n+    stateProp.setValue(State.STATE_CLOSING);\n   }\n \n   @Override\n   public void wrap(final DirectBuffer buffer, int offset, final int length) {\n-    final int startOffset = offset;\n-    workflowInstanceKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    elementInstanceKey = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    subscriptionPartitionId = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    commandSentTime = buffer.getLong(offset, ZB_DB_BYTE_ORDER);\n-    offset += Long.BYTES;\n-\n-    state = buffer.getInt(offset, ZB_DB_BYTE_ORDER);\n-    offset += Integer.BYTES;\n-\n-    closeOnCorrelate = buffer.getByte(offset) == 1;\n-    offset += 1;\n-\n-    offset = readIntoBuffer(buffer, offset, messageName);\n-    offset = readIntoBuffer(buffer, offset, correlationKey);\n-    offset = readIntoBuffer(buffer, offset, targetElementId);\n-    offset = readIntoBuffer(buffer, offset, bpmnProcessId);\n-\n-    assert (offset - startOffset) == length : \"End offset differs from length\";\n+    final byte[] bytes = new byte[length];\n+    final MutableDirectBuffer newBuffer = new UnsafeBuffer(bytes);\n+    buffer.getBytes(0, bytes, 0, length);\n+    super.wrap(newBuffer, 0, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTAxMTIzOnYy", "diffSide": "RIGHT", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1MDowMlrOF2EW0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1MDowMlrOF2EW0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzODgwMw==", "bodyText": "No more upgrade tests \ud83d\ude02\nWe should remember to enable the test again at some point.", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392238803", "createdAt": "2020-03-13T13:50:02Z", "author": {"login": "saig0"}, "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -37,6 +38,7 @@\n import org.junit.runners.Parameterized.Parameter;\n import org.junit.runners.Parameterized.Parameters;\n \n+@Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTAzODY0OnYy", "diffSide": "RIGHT", "path": "protocol-impl/src/main/java/io/zeebe/protocol/impl/record/value/incident/IncidentRecord.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1Nzo0MFrOF2EooQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMzo1Nzo0MFrOF2EooQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0MzM2MQ==", "bodyText": "We implemented this copy method in different records. What about implementing this in a generic way?\nIn the ObjectValue/UnpackedObject class, we have access to all properties and could copy the values.", "url": "https://github.com/camunda-cloud/zeebe/pull/4040#discussion_r392243361", "createdAt": "2020-03-13T13:57:40Z", "author": {"login": "saig0"}, "path": "protocol-impl/src/main/java/io/zeebe/protocol/impl/record/value/incident/IncidentRecord.java", "diffHunk": "@@ -45,6 +45,18 @@ public IncidentRecord() {\n         .declareProperty(variableScopeKeyProp);\n   }\n \n+  public void wrap(final IncidentRecord record) {\n+    errorTypeProp.setValue(record.getErrorType());\n+    errorMessageProp.setValue(record.getErrorMessage());\n+    bpmnProcessIdProp.setValue(record.getBpmnProcessIdBuffer());\n+    workflowKeyProp.setValue(record.getWorkflowKey());\n+    workflowInstanceKeyProp.setValue(record.getWorkflowInstanceKey());\n+    elementIdProp.setValue(record.getElementIdBuffer());\n+    elementInstanceKeyProp.setValue(record.getElementInstanceKey());\n+    jobKeyProp.setValue(record.getJobKey());\n+    variableScopeKeyProp.setValue(record.getVariableScopeKey());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448311a042a81fd3d1e3b11867d2136599f8677a"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4910, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}