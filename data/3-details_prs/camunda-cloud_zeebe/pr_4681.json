{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxMTg1NDk3", "number": 4681, "title": "4396 long polling blocked bug - target 0.23.0", "bodyText": "Description\nThis PR proposes a fix to the long polling blocked bug. I don't expect it be approved right away. Instead I hope for some critical comments and engaging discussion.\nPlease read the issue and the analysis therein to understand what was fixed.\nTalking about the fixes:\n\nfor the backpressure the ActivateJobsHandler now tracks whether some brokers returned a resource exhausted error and if so, it tells the polling handler about it. I think this change is solid, albeit not very elegant.\nfor the time window where the long polling handler did not know that a request is currently running: Here the main idea is to register any active request right away. I think the approach is solid, but the implementation is somewhat lacking. It is quite big for a simple bugfix, and rather small for a major refactoring. Also, besides the intended change in behavior there are some unintended side effects. Like scheduling of long polling requests will change slightly in order. And the number of how often the Broker is queried also changes. The existing code had some downsides, in my opinion, so I took some liberty in deviating from the existing implementation. Having said that, it is hard to know which specific behavior was intended and which was arbitrary.\n\nHappy to discuss the details and answer any questions. Just want to create the review early given that it is a critical bug and I did the best I could.\nRelated issues\ncloses #4396\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-06-08T14:35:25Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4681", "merged": true, "mergeCommit": {"oid": "e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3"}, "closed": true, "closedAt": "2020-06-29T08:44:35Z", "author": {"login": "pihme"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpgpWJAFqTQyNjg1MjE4OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvAhztgBqjM0ODYwMTEyNDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODUyMTg5", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#pullrequestreview-426852189", "createdAt": "2020-06-09T07:18:55Z", "commit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzoxODo1NVrOGg716g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODoxNzoyN1rOGg94OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4ODA3NA==", "bodyText": "Why are these methods synchronized?", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437188074", "createdAt": "2020-06-09T07:18:55Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/InFlightLongPollingActivateJobsRequestsState.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.impl.job;\n+\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.metrics.LongPollingMetrics;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.slf4j.Logger;\n+\n+public final class InFlightLongPollingActivateJobsRequestsState {\n+\n+  private static final Logger LOGGER = Loggers.GATEWAY_LOGGER;\n+\n+  private final String jobType;\n+  private final LongPollingMetrics metrics;\n+  private final Queue<LongPollingActivateJobsRequest> pendingRequests = new LinkedList<>();\n+  private LongPollingActivateJobsRequest activeRequest;\n+  private int failedAttempts;\n+  private long lastUpdatedTime;\n+\n+  public InFlightLongPollingActivateJobsRequestsState(\n+      final String jobType, final LongPollingMetrics metrics) {\n+    this.jobType = jobType;\n+    this.metrics = metrics;\n+  }\n+\n+  public void incrementFailedAttempts(final long lastUpdatedTime) {\n+    failedAttempts++;\n+    this.lastUpdatedTime = lastUpdatedTime;\n+  }\n+\n+  public void resetFailedAttempts(final int failedAttempts) {\n+    this.failedAttempts = failedAttempts;\n+  }\n+\n+  public int getFailedAttempts() {\n+    return failedAttempts;\n+  }\n+\n+  public long getLastUpdatedTime() {\n+    return lastUpdatedTime;\n+  }\n+\n+  public synchronized void enqueueRequest(final LongPollingActivateJobsRequest request) {\n+    pendingRequests.offer(request);\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  private synchronized void removeObsoleteRequestsAndUpdateMetrics() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5MTI3NA==", "bodyText": "I think this is not necessary. This class is only used in our LongPollingActivateJobsHandler, since this is an actor it can make sure that this state is only accessed in this actor.", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437191274", "createdAt": "2020-06-09T07:25:02Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/InFlightLongPollingActivateJobsRequestsState.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.impl.job;\n+\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.metrics.LongPollingMetrics;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.slf4j.Logger;\n+\n+public final class InFlightLongPollingActivateJobsRequestsState {\n+\n+  private static final Logger LOGGER = Loggers.GATEWAY_LOGGER;\n+\n+  private final String jobType;\n+  private final LongPollingMetrics metrics;\n+  private final Queue<LongPollingActivateJobsRequest> pendingRequests = new LinkedList<>();\n+  private LongPollingActivateJobsRequest activeRequest;\n+  private int failedAttempts;\n+  private long lastUpdatedTime;\n+\n+  public InFlightLongPollingActivateJobsRequestsState(\n+      final String jobType, final LongPollingMetrics metrics) {\n+    this.jobType = jobType;\n+    this.metrics = metrics;\n+  }\n+\n+  public void incrementFailedAttempts(final long lastUpdatedTime) {\n+    failedAttempts++;\n+    this.lastUpdatedTime = lastUpdatedTime;\n+  }\n+\n+  public void resetFailedAttempts(final int failedAttempts) {\n+    this.failedAttempts = failedAttempts;\n+  }\n+\n+  public int getFailedAttempts() {\n+    return failedAttempts;\n+  }\n+\n+  public long getLastUpdatedTime() {\n+    return lastUpdatedTime;\n+  }\n+\n+  public synchronized void enqueueRequest(final LongPollingActivateJobsRequest request) {\n+    pendingRequests.offer(request);\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  private synchronized void removeObsoleteRequestsAndUpdateMetrics() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4ODA3NA=="}, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5Mjk1OA==", "bodyText": "this should also be not necessary", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437192958", "createdAt": "2020-06-09T07:27:57Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE5NzE1MQ==", "bodyText": "This is not necessary", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437197151", "createdAt": "2020-06-09T07:35:47Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));\n     }\n   }\n \n   private void onResponse(\n       final LongPollingActivateJobsRequest request,\n       final ActivateJobsResponse activateJobsResponse) {\n-    actor.submit(\n-        () -> {\n-          request.onResponse(activateJobsResponse);\n-          jobsAvailable(request.getType());\n-        });\n+    actor.submit(() -> request.onResponse(activateJobsResponse));\n   }\n \n-  private void jobsNotAvailable(final LongPollingActivateJobsRequest request) {\n-    final JobTypeAvailabilityState state =\n-        jobTypeState.computeIfAbsent(\n-            request.getType(), type -> new JobTypeAvailabilityState(type, metrics));\n-    state.incrementEmptyResponses(currentTimeMillis());\n-    block(state, request);\n-  }\n+  private void handlePendingRequests(final String jobType) {\n+    final InFlightLongPollingActivateJobsRequestsState state = getJobTypeState(jobType);\n \n-  private void jobsAvailable(final String jobType) {\n-    final JobTypeAvailabilityState removedState = jobTypeState.remove(jobType);\n-    if (removedState != null) {\n-      unblockRequests(removedState);\n-    }\n-  }\n+    state.resetFailedAttempts(0);\n \n-  private void unblockRequests(final JobTypeAvailabilityState state) {\n-    final Queue<LongPollingActivateJobsRequest> requests = state.getBlockedRequests();\n-    if (requests == null) {\n-      return;\n+    if (state.getActiveRequest() == null) {\n+\n+      final LongPollingActivateJobsRequest nextPendingRequest = state.getNextPendingRequest();\n+\n+      if (nextPendingRequest != null) {\n+        LOG.trace(\"Unblocking ActivateJobsRequest {}\", nextPendingRequest.getRequest());\n+        activateJobs(nextPendingRequest);\n+      } else {\n+        synchronized (jobTypeState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwODYwOA==", "bodyText": "This seems new right? Before we just blocked?\nBut do we still check the other brokers before we return to the client?", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437208608", "createdAt": "2020-06-09T07:55:45Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyMTQzMw==", "bodyText": "So we just continue with sending requests?", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r437221433", "createdAt": "2020-06-09T08:17:27Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NjMwNjUx", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#pullrequestreview-428630651", "createdAt": "2020-06-11T06:40:39Z", "commit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjo0MDozOVrOGiQY-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNzowMzo0MlrOGiQ90A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MzMwNw==", "bodyText": "This would block the second request if the first request is in-flight even if there are plenty of jobs available in broker. Isn't it? Then we won't be able to process requests from multiple job workers concurrently.", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438573307", "createdAt": "2020-06-11T06:40:39Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MjczNg==", "bodyText": "Isn't this again preventing concurrent requests?", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r438582736", "createdAt": "2020-06-11T07:03:42Z", "author": {"login": "deepthidevaki"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -77,87 +80,110 @@ public void activateJobs(\n   public void activateJobs(final LongPollingActivateJobsRequest request) {\n     actor.run(\n         () -> {\n-          final JobTypeAvailabilityState state = jobTypeState.get(request.getType());\n-          final boolean isJobAvailable =\n-              state == null || (state.getEmptyResponses() < emptyResponseThreshold);\n-          if (isJobAvailable) {\n-            activateJobsUnchecked(request);\n+          final InFlightLongPollingActivateJobsRequestsState state =\n+              getJobTypeState(request.getType());\n+\n+          if (state.getActiveRequest() == null\n+              && (state.getFailedAttempts() < failedAttemptThreshold)) {\n+            activateJobsUnchecked(state, request);\n           } else {\n-            block(state, request);\n+            completeOrEnqueueRequest(state, request);\n           }\n         });\n   }\n \n-  private void activateJobsUnchecked(final LongPollingActivateJobsRequest request) {\n+  private InFlightLongPollingActivateJobsRequestsState getJobTypeState(String jobType) {\n+    synchronized (jobTypeState) {\n+      return jobTypeState.computeIfAbsent(\n+          jobType, type -> new InFlightLongPollingActivateJobsRequestsState(type, metrics));\n+    }\n+  }\n+\n+  private void activateJobsUnchecked(\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request) {\n+\n     final BrokerClusterState topology = brokerClient.getTopologyManager().getTopology();\n     if (topology != null) {\n+\n+      state.setActiveRequest(request);\n+\n       final int partitionsCount = topology.getPartitionsCount();\n       activateJobsHandler.activateJobs(\n           partitionsCount,\n           request.getRequest(),\n           request.getMaxJobsToActivate(),\n           request.getType(),\n           response -> onResponse(request, response),\n-          remainingAmount -> onCompleted(request, remainingAmount));\n+          (remainingAmount, containedResourceExhaustedResponse) ->\n+              onCompleted(state, request, remainingAmount, containedResourceExhaustedResponse));\n     }\n   }\n \n   private void onNotification(final String jobType) {\n     LOG.trace(\"Received jobs available notification for type {}.\", jobType);\n-    actor.call(() -> jobsAvailable(jobType));\n+    actor.run(() -> handlePendingRequests(jobType));\n   }\n \n   private void onCompleted(\n-      final LongPollingActivateJobsRequest request, final Integer remainingAmount) {\n+      final InFlightLongPollingActivateJobsRequestsState state,\n+      final LongPollingActivateJobsRequest request,\n+      final Integer remainingAmount,\n+      final Boolean containedResourceExhaustedResponse) {\n+    state.removeActiveRequest();\n     if (remainingAmount == request.getMaxJobsToActivate()) {\n-      actor.submit(() -> jobsNotAvailable(request));\n+      if (containedResourceExhaustedResponse) {\n+        actor.submit(\n+            () ->\n+                request\n+                    .getResponseObserver()\n+                    .onError(\n+                        new BrokerErrorException(\n+                            new BrokerError(\n+                                ErrorCode.RESOURCE_EXHAUSTED,\n+                                \"Some brokers returned resource exhausted\"))));\n+      } else {\n+        actor.submit(\n+            () -> {\n+              state.incrementFailedAttempts(currentTimeMillis());\n+              activateJobs(request);\n+            });\n+      }\n     } else {\n       actor.submit(request::complete);\n+      actor.submit(() -> handlePendingRequests(request.getType()));\n     }\n   }\n \n   private void onResponse(\n       final LongPollingActivateJobsRequest request,\n       final ActivateJobsResponse activateJobsResponse) {\n-    actor.submit(\n-        () -> {\n-          request.onResponse(activateJobsResponse);\n-          jobsAvailable(request.getType());\n-        });\n+    actor.submit(() -> request.onResponse(activateJobsResponse));\n   }\n \n-  private void jobsNotAvailable(final LongPollingActivateJobsRequest request) {\n-    final JobTypeAvailabilityState state =\n-        jobTypeState.computeIfAbsent(\n-            request.getType(), type -> new JobTypeAvailabilityState(type, metrics));\n-    state.incrementEmptyResponses(currentTimeMillis());\n-    block(state, request);\n-  }\n+  private void handlePendingRequests(final String jobType) {\n+    final InFlightLongPollingActivateJobsRequestsState state = getJobTypeState(jobType);\n \n-  private void jobsAvailable(final String jobType) {\n-    final JobTypeAvailabilityState removedState = jobTypeState.remove(jobType);\n-    if (removedState != null) {\n-      unblockRequests(removedState);\n-    }\n-  }\n+    state.resetFailedAttempts(0);\n \n-  private void unblockRequests(final JobTypeAvailabilityState state) {\n-    final Queue<LongPollingActivateJobsRequest> requests = state.getBlockedRequests();\n-    if (requests == null) {\n-      return;\n+    if (state.getActiveRequest() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f64679a1d07de344becfd5f17f6fa0b4b1cf66b"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjA2NjYw", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#pullrequestreview-431206660", "createdAt": "2020-06-16T06:52:38Z", "commit": {"oid": "436aa8229d8c921f00162f3e7fb33e7d4abeff38"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NjIxMTQx", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#pullrequestreview-435621141", "createdAt": "2020-06-23T09:48:37Z", "commit": {"oid": "436aa8229d8c921f00162f3e7fb33e7d4abeff38"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOTo0ODozN1rOGnhx9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOTo1ODo1OVrOGniJyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwMTExMA==", "bodyText": "I would like to have a refactoring of these chain of recursive calls it is really hard to understand and determine what is actually happening. Can we create an follow up issue which we can maybe prioritize.\nEspecially these boolean flags are always hard to understand I'm a fan of specific methods in these cases maybe it is possible to refactor them also then away.", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444101110", "createdAt": "2020-06-23T09:48:37Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/ActivateJobsHandler.java", "diffHunk": "@@ -50,9 +51,16 @@ private void activateJobs(\n       final int remainingAmount,\n       final String jobType,\n       final Consumer<ActivateJobsResponse> onResponse,\n-      final Consumer<Integer> onCompleted) {\n+      final BiConsumer<Integer, Boolean> onCompleted) {\n     activateJobs(\n-        request, partitionIdIterator, remainingAmount, jobType, onResponse, onCompleted, false);\n+        request,\n+        partitionIdIterator,\n+        remainingAmount,\n+        jobType,\n+        onResponse,\n+        onCompleted,\n+        false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436aa8229d8c921f00162f3e7fb33e7d4abeff38"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwNDg3Ng==", "bodyText": "should it also remove from activeRequestsToBeRepeated?", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444104876", "createdAt": "2020-06-23T09:55:01Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/InFlightLongPollingActivateJobsRequestsState.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.gateway.impl.job;\n+\n+import io.zeebe.gateway.Loggers;\n+import io.zeebe.gateway.metrics.LongPollingMetrics;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.slf4j.Logger;\n+\n+public final class InFlightLongPollingActivateJobsRequestsState {\n+\n+  private static final Logger LOGGER = Loggers.GATEWAY_LOGGER;\n+\n+  private final String jobType;\n+  private final LongPollingMetrics metrics;\n+  private final Queue<LongPollingActivateJobsRequest> activeRequests = new LinkedList<>();\n+  private final Queue<LongPollingActivateJobsRequest> activeRequestsToBeRepeated =\n+      new LinkedList<>();\n+  private final Queue<LongPollingActivateJobsRequest> pendingRequests = new LinkedList<>();\n+  private int failedAttempts;\n+  private long lastUpdatedTime;\n+\n+  public InFlightLongPollingActivateJobsRequestsState(\n+      final String jobType, final LongPollingMetrics metrics) {\n+    this.jobType = jobType;\n+    this.metrics = metrics;\n+  }\n+\n+  public void incrementFailedAttempts(final long lastUpdatedTime) {\n+    failedAttempts++;\n+    this.lastUpdatedTime = lastUpdatedTime;\n+  }\n+\n+  public void resetFailedAttempts(final int failedAttempts) {\n+    this.failedAttempts = failedAttempts;\n+    if (failedAttempts == 0) {\n+      activeRequestsToBeRepeated.addAll(activeRequests);\n+    }\n+  }\n+\n+  public int getFailedAttempts() {\n+    return failedAttempts;\n+  }\n+\n+  public long getLastUpdatedTime() {\n+    return lastUpdatedTime;\n+  }\n+\n+  public void enqueueRequest(final LongPollingActivateJobsRequest request) {\n+    if (!pendingRequests.contains(request)) {\n+      pendingRequests.offer(request);\n+    }\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  public Queue<LongPollingActivateJobsRequest> getPendingRequests() {\n+    removeObsoleteRequestsAndUpdateMetrics();\n+    return pendingRequests;\n+  }\n+\n+  private void removeObsoleteRequestsAndUpdateMetrics() {\n+    pendingRequests.removeIf(this::isObsolete);\n+    activeRequests.removeIf(this::isObsolete);\n+    activeRequestsToBeRepeated.removeIf(this::isObsolete);\n+    metrics.setBlockedRequestsCount(jobType, pendingRequests.size());\n+  }\n+\n+  private boolean isObsolete(final LongPollingActivateJobsRequest request) {\n+    return request.isTimedOut() || request.isCanceled() || request.isCompleted();\n+  }\n+\n+  public void removeRequest(final LongPollingActivateJobsRequest request) {\n+    pendingRequests.remove(request);\n+    removeObsoleteRequestsAndUpdateMetrics();\n+  }\n+\n+  public LongPollingActivateJobsRequest getNextPendingRequest() {\n+    removeObsoleteRequestsAndUpdateMetrics();\n+    final LongPollingActivateJobsRequest request = pendingRequests.poll();\n+    metrics.setBlockedRequestsCount(jobType, pendingRequests.size());\n+    return request;\n+  }\n+\n+  public void addActiveRequest(final LongPollingActivateJobsRequest request) {\n+    activeRequests.offer(request);\n+    pendingRequests.remove(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436aa8229d8c921f00162f3e7fb33e7d4abeff38"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEwNzIwOQ==", "bodyText": "Maybe we create two methods for these both cases instead of having this parameter which sometime acts as an flag and to set it to a value.\nSo like:\nstate.resetFailedAttemtps() sets to zero here then dont need the if internally.\nstate.setFailedAttempts(int) sets to value we give it to", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#discussion_r444107209", "createdAt": "2020-06-23T09:58:59Z", "author": {"login": "Zelldon"}, "path": "gateway/src/main/java/io/zeebe/gateway/impl/job/LongPollingActivateJobsHandler.java", "diffHunk": "@@ -201,15 +241,13 @@ private void probe() {\n     jobTypeState.forEach(\n         (type, state) -> {\n           if (state.getLastUpdatedTime() < (now - probeTimeoutMillis)) {\n-            state.removeCanceledRequests();\n-\n-            final LongPollingActivateJobsRequest probeRequest = state.pollBlockedRequests();\n+            final LongPollingActivateJobsRequest probeRequest = state.getNextPendingRequest();\n             if (probeRequest != null) {\n-              activateJobsUnchecked(probeRequest);\n+              activateJobsUnchecked(state, probeRequest);\n             } else {\n               // there are no blocked requests, so use next request as probe\n-              if (state.getEmptyResponses() >= emptyResponseThreshold) {\n-                state.resetEmptyResponses(emptyResponseThreshold - 1);\n+              if (state.getFailedAttempts() >= failedAttemptThreshold) {\n+                state.resetFailedAttempts(failedAttemptThreshold - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436aa8229d8c921f00162f3e7fb33e7d4abeff38"}, "originalPosition": 255}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTE2MjYy", "url": "https://github.com/camunda-cloud/zeebe/pull/4681#pullrequestreview-438116262", "createdAt": "2020-06-26T08:38:59Z", "commit": {"oid": "19b7b1a45a87efa2dffbc6ca0a4c88cb80491f8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "160035f0708a5ee93f5bd881feabc30ca7544baa", "author": {"user": {"login": "pihme", "name": "Peter Ihme"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/160035f0708a5ee93f5bd881feabc30ca7544baa", "committedDate": "2020-06-26T08:44:31Z", "message": "chore(broker): increment log4j version"}, "afterCommit": {"oid": "e822d9596b556715d2af2e1abcaa3ab34555fece", "author": {"user": {"login": "pihme", "name": "Peter Ihme"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e822d9596b556715d2af2e1abcaa3ab34555fece", "committedDate": "2020-06-26T08:48:15Z", "message": "chore(broker): Keep records of active long polling requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "author": {"user": {"login": "pihme", "name": "Peter Ihme"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "committedDate": "2020-06-26T10:17:06Z", "message": "chore(broker): Keep records of active long polling requests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e822d9596b556715d2af2e1abcaa3ab34555fece", "author": {"user": {"login": "pihme", "name": "Peter Ihme"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e822d9596b556715d2af2e1abcaa3ab34555fece", "committedDate": "2020-06-26T08:48:15Z", "message": "chore(broker): Keep records of active long polling requests"}, "afterCommit": {"oid": "e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "author": {"user": {"login": "pihme", "name": "Peter Ihme"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e1d8cb3326f084858cfaa93dbd91c4cd6e6dbcf3", "committedDate": "2020-06-26T10:17:06Z", "message": "chore(broker): Keep records of active long polling requests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2738, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}