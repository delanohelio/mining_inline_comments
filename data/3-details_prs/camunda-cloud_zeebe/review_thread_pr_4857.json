{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNDg3MTA2", "number": 4857, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMTo0OVrOEKab4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTowNDoyOVrOEKjJZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU0MzM4OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/NettyMessagingService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMTo0OVrOGrb36w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMTo0OVrOGrb36w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5ODYzNQ==", "bodyText": "Just to understand, what was previously happening here? Were the connections eventually closed (e.g. when they were garbage collected), or...?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448198635", "createdAt": "2020-07-01T08:21:49Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/NettyMessagingService.java", "diffHunk": "@@ -296,6 +297,13 @@ public boolean isRunning() {\n                 interrupted = true;\n               }\n               timeoutExecutor.shutdown();\n+\n+              for (final var entry : connections.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU0NTgzOnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/AbstractRole.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMjoyOVrOGrb5fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMjoyOVrOGrb5fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5OTAzNg==", "bodyText": "If we want to enable debug logging for Atomix, wouldn't this create tons of noise?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448199036", "createdAt": "2020-07-01T08:22:29Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/AbstractRole.java", "diffHunk": "@@ -59,13 +59,13 @@ protected AbstractRole(final RaftContext raft) {\n \n   /** Logs a request. */\n   protected final <R extends RaftRequest> R logRequest(final R request) {\n-    log.trace(\"Received {}\", request);\n+    log.debug(\"Received {}\", request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU3MTQzOnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyOToxMFrOGrcJqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyOToxMFrOGrcJqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMzE3OA==", "bodyText": "Nit: no need to compute it on every loop, and probably more readable if assigned to a variable \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448203178", "createdAt": "2020-07-01T08:29:10Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -189,6 +194,19 @@ protected void before() throws IOException {\n       getBroker(nodeId);\n     }\n \n+    for (int nodeId = 0; nodeId < clusterSize; nodeId++) {\n+      final var brokerCfg = getBrokerCfg(nodeId);\n+\n+      setInitialContactPoints(\n+              brokerCfgs.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU3NTEyOnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyOTo1OVrOGrcL5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyOTo1OVrOGrcL5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMzc0OA==", "bodyText": "Any reason not to use Awaitility here?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448203748", "createdAt": "2020-07-01T08:29:59Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -512,6 +530,52 @@ public long getPartitionLeaderCount() {\n         .count();\n   }\n \n+  public Broker stepDownFromPartition(final int partitionId) {\n+    final int leaderNodeId = getLeaderForPartition(partitionId).getNodeId();\n+    final Broker leader = getBroker(leaderNodeId);\n+    stepDown(leader, partitionId);\n+\n+    final BrokerInfo newLeaderInfo = awaitOtherLeader(partitionId, leaderNodeId);\n+\n+    return getBroker(newLeaderInfo.getNodeId());\n+  }\n+\n+  public BrokerInfo awaitOtherLeader(final int partitionId, final int previousLeader) {\n+    return doRepeatedly(() -> getLeaderForPartition(partitionId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzYwMjQxOnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODozNzoyMlrOGrccvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODozNzoyMlrOGrccvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwODA2MQ==", "bodyText": "Nit: I find it more readable splitting the conditions in 2 filter calls \ud83e\udd37\u200d\u2642\ufe0f\n.stream()\n.filter(partition -> partition.id().id() == partitionId)\n.filter(partition -> partition.members().contains(nodeId))\n...\nafaik it's equivalent, though maybe less efficient (but here I don't think it matters)", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448208061", "createdAt": "2020-07-01T08:37:22Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -512,6 +530,52 @@ public long getPartitionLeaderCount() {\n         .count();\n   }\n \n+  public Broker stepDownFromPartition(final int partitionId) {\n+    final int leaderNodeId = getLeaderForPartition(partitionId).getNodeId();\n+    final Broker leader = getBroker(leaderNodeId);\n+    stepDown(leader, partitionId);\n+\n+    final BrokerInfo newLeaderInfo = awaitOtherLeader(partitionId, leaderNodeId);\n+\n+    return getBroker(newLeaderInfo.getNodeId());\n+  }\n+\n+  public BrokerInfo awaitOtherLeader(final int partitionId, final int previousLeader) {\n+    return doRepeatedly(() -> getLeaderForPartition(partitionId))\n+        .until(curLeader -> curLeader.getNodeId() != previousLeader, 1000);\n+  }\n+\n+  public void stepDown(final Broker broker, final int partitionId) {\n+    final var atomix = broker.getAtomix();\n+    final MemberId nodeId = atomix.getMembershipService().getLocalMember().id();\n+\n+    final var raftPartition =\n+        atomix.getPartitionService().getPartitionGroup(AtomixFactory.GROUP_NAME).getPartitions()\n+            .stream()\n+            .filter(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzYyMTM4OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo0Mjo1NFrOGrcoxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo0Mjo1NFrOGrcoxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxMTE0MQ==", "bodyText": "Side note, I'd love to test these more with TestContainers actually, since we can simulate a real network partition and disconnect instead of closing the messaging service. That said I'm happy we have these until then \ud83d\ude42", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448211141", "createdAt": "2020-07-01T08:42:54Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzYzNTA2OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo0Njo1N1rOGrcxqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTozNzo1OFrOGrejVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxMzQxNg==", "bodyText": "Isn't this testing mostly that disconnecting works as expected? Or what are we testing here?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448213416", "createdAt": "2020-07-01T08:46:57Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0MjUxNw==", "bodyText": "Please comment explaining why this test is there", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448242517", "createdAt": "2020-07-01T09:37:58Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxMzQxNg=="}, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY1Njk4OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1MzowOFrOGrc_xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTo0NTowOFrOGrey8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxNzAyOA==", "bodyText": "I'm not sure about this test, specially the verification...I get that we want to test that replication occurs on fail over, but not sure if it makes sense to test this as an integration test. From the system pov, what do we want to occur on fail over? That we replicate events, or that if the node were to become leader again, it could rebuild the state properly and execute commands properly (e.g. deployments are present, we can continue workflow instances, etc.)? I feel like just checking if events are replicated belongs more to the Raft tests than Zeebe's integration tests \ud83e\udd14\nNot sure if I'm clear, we can also zoom quickly, might be faster \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448217028", "createdAt": "2020-07-01T08:53:08Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI0NjUxNQ==", "bodyText": "Let's remove this and rewrite to ensure we are compacting after failover", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448246515", "createdAt": "2020-07-01T09:45:08Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxNzAyOA=="}, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY2MjE4OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NDo0MVrOGrdDKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NDo0MVrOGrdDKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxNzg5Nw==", "bodyText": "Could this test be flaky? Just wondering, because iirc we don't retry snapshot replication to a follower that was partitioned off, so you'd have to wait for the next snapshot, right?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448217897", "createdAt": "2020-07-01T08:54:41Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.stepDownFromPartition(1);\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // when\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveSnapshotAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    clusteringRule.disconnect(previousLeader);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderInfo.getNodeId());\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(previousLeaderId);\n+    fillSegments(followers, segmentCount);\n+    final var snapshotMetadata = awaitSnapshot(newLeader);\n+\n+    // when\n+    clusteringRule.connect(previousLeader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY2Mzc1OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NTowNVrOGrdEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NTowNVrOGrdEJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxODE0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // send some commands", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448218149", "createdAt": "2020-07-01T08:55:05Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.stepDownFromPartition(1);\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // when\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveSnapshotAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    clusteringRule.disconnect(previousLeader);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderInfo.getNodeId());\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(previousLeaderId);\n+    fillSegments(followers, segmentCount);\n+    final var snapshotMetadata = awaitSnapshot(newLeader);\n+\n+    // when\n+    clusteringRule.connect(previousLeader);\n+\n+    // then\n+    final var receivedSnapshot = clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+    assertThat(receivedSnapshot).isEqualTo(snapshotMetadata);\n+  }\n+\n+  // regression test for https://github.com/zeebe-io/zeebe/issues/4810\n+  @Test\n+  public void shouldFormClusterEvenWhenMissingEvents() {\n+    // given\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    // send some commands", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY3MTQwOnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NzowOVrOGrdJDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODo1NzowOVrOGrdJDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxOTQwNA==", "bodyText": "Even with the comment I'm not sure why it's necessary \ud83d\ude05 So, dumb question, what does BECAUSE IT HAS ONE ON GOING refer to? One append request?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448219404", "createdAt": "2020-07-01T08:57:09Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.stepDownFromPartition(1);\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // when\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveSnapshotAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    clusteringRule.disconnect(previousLeader);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderInfo.getNodeId());\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(previousLeaderId);\n+    fillSegments(followers, segmentCount);\n+    final var snapshotMetadata = awaitSnapshot(newLeader);\n+\n+    // when\n+    clusteringRule.connect(previousLeader);\n+\n+    // then\n+    final var receivedSnapshot = clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+    assertThat(receivedSnapshot).isEqualTo(snapshotMetadata);\n+  }\n+\n+  // regression test for https://github.com/zeebe-io/zeebe/issues/4810\n+  @Test\n+  public void shouldFormClusterEvenWhenMissingEvents() {\n+    // given\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    // send some commands\n+    client.newDeployCommand().addWorkflowModel(WORKFLOW, WORKFLOW_RESOURCE_NAME).send().join();\n+\n+    // disconnect leader - becomes follower\n+    clusteringRule.disconnect(previousLeader);\n+    // IMPORTANT NOTE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY4ODI2OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowMTo1NlrOGrdTtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowMTo1NlrOGrdTtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyMjEzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void fillSegments(final List<Broker> brokers, final int segmentCount) {\n          \n          \n            \n              private void sendCommandAndAwaitMinimumSegmentCount(final List<Broker> brokers, final int segmentCount) {", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448222134", "createdAt": "2020-07-01T09:01:56Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.stepDownFromPartition(1);\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // when\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveSnapshotAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    clusteringRule.disconnect(previousLeader);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderInfo.getNodeId());\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(previousLeaderId);\n+    fillSegments(followers, segmentCount);\n+    final var snapshotMetadata = awaitSnapshot(newLeader);\n+\n+    // when\n+    clusteringRule.connect(previousLeader);\n+\n+    // then\n+    final var receivedSnapshot = clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+    assertThat(receivedSnapshot).isEqualTo(snapshotMetadata);\n+  }\n+\n+  // regression test for https://github.com/zeebe-io/zeebe/issues/4810\n+  @Test\n+  public void shouldFormClusterEvenWhenMissingEvents() {\n+    // given\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    // send some commands\n+    client.newDeployCommand().addWorkflowModel(WORKFLOW, WORKFLOW_RESOURCE_NAME).send().join();\n+\n+    // disconnect leader - becomes follower\n+    clusteringRule.disconnect(previousLeader);\n+    // IMPORTANT NOTE:\n+    // BE AWARE THAT WE NEED TO STEP DOWN AFTER DISCONNECT\n+    // IT HAPPENS FROM TIME TO TIME THAT THE LEADER DOESN'T DETECT FAST ENOUGH THE NETWORK\n+    // PARTITION.\n+    // THIS MEANS IT WILL NOT STEP DOWN AND SEND NO NEW APPENDS TO THE FOLLOWER, BECAUSE IT HAS ONE\n+    // ON GOING,\n+    // WHICH SEEM NOT TO TIMEOUT CORRECTLY. SINCE MESSAGING SERVICE IS NOT STOPPED IN PRODUCTION\n+    // ENV.\n+    // WE WILL NOT FIX THIS - INSTEAD USE THIS AS WORK AROUND.\n+    clusteringRule.stepDown(previousLeader, 1);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeaderId = newLeaderInfo.getNodeId();\n+    assertThat(newLeaderId).isNotEqualTo(previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderId);\n+\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(newLeaderId);\n+    final var followerA =\n+        followers.stream()\n+            .filter(broker -> broker.getConfig().getCluster().getNodeId() != previousLeaderId)\n+            .findFirst()\n+            .orElseThrow();\n+\n+    // Leader and Follower A have new entries\n+    // which Follower B - old leader hasn't\n+    fillSegments(List.of(newLeader, followerA), 2);\n+    awaitSnapshot(newLeader);\n+    clusteringRule.waitForSnapshotAtBroker(followerA);\n+\n+    // when shutdown current leader and connect follower (old leader with old log)\n+    clusteringRule.stopBroker(newLeaderId);\n+    clusteringRule.connect(previousLeader);\n+\n+    // then\n+    // we should be able to form a cluster via replicating snapshot etc.\n+    clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+    final var nextLeader = clusteringRule.awaitOtherLeader(1, newLeaderId);\n+\n+    assertThat(nextLeader.getNodeId()).isEqualTo(getNodeId(followerA));\n+    clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+  }\n+\n+  private int getNodeId(final Broker broker) {\n+    return broker.getConfig().getCluster().getNodeId();\n+  }\n+\n+  private FileBasedSnapshotMetadata awaitSnapshot(final Broker leader) {\n+    triggerSnapshotCreation();\n+    return clusteringRule.waitForSnapshotAtBroker(leader);\n+  }\n+\n+  private int getSegmentsCount(final Broker broker) {\n+    return getSegments(broker).size();\n+  }\n+\n+  private Collection<Path> getSegments(final Broker broker) {\n+    try {\n+      return Files.list(clusteringRule.getSegmentsDirectory(broker))\n+          .filter(path -> path.toString().endsWith(\".log\"))\n+          .collect(Collectors.toList());\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void fillSegments(final List<Broker> brokers, final int segmentCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY5MzE0OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowMzoxNVrOGrdWwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowMzoxNVrOGrdWwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyMjkxMg==", "bodyText": "Why are we waiting for a snapshot/the snapshot to be replicated?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448222912", "createdAt": "2020-07-01T09:03:15Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/FailOverReplicationTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.it.clustering;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.raft.snapshot.impl.FileBasedSnapshotMetadata;\n+import io.zeebe.broker.Broker;\n+import io.zeebe.broker.it.util.GrpcClientRule;\n+import io.zeebe.broker.system.configuration.BrokerCfg;\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.test.util.TestUtil;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.springframework.util.unit.DataSize;\n+\n+public class FailOverReplicationTest {\n+\n+  private static final int PARTITION_COUNT = 1;\n+  private static final Duration SNAPSHOT_PERIOD = Duration.ofMinutes(5);\n+  private static final BpmnModelInstance WORKFLOW =\n+      Bpmn.createExecutableProcess(\"process\").startEvent().endEvent().done();\n+  private static final String WORKFLOW_RESOURCE_NAME = \"workflow.bpmn\";\n+\n+  private final ClusteringRule clusteringRule =\n+      new ClusteringRule(PARTITION_COUNT, 3, 3, FailOverReplicationTest::configureBroker);\n+  public final GrpcClientRule clientRule = new GrpcClientRule(clusteringRule);\n+  @Rule public RuleChain ruleChain = RuleChain.outerRule(clusteringRule).around(clientRule);\n+  private ZeebeClient client;\n+\n+  @Before\n+  public void init() {\n+    client = clientRule.getClient();\n+  }\n+\n+  @Test\n+  public void shouldFailOverOnNetworkPartition() {\n+    // given\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var leader = clusteringRule.getBroker(leaderNodeId);\n+\n+    // when\n+    clusteringRule.disconnect(leader);\n+\n+    // then\n+    final var newLeader = clusteringRule.awaitOtherLeader(1, leaderNodeId);\n+    assertThat(newLeader.getNodeId()).isNotEqualTo(leaderNodeId);\n+  }\n+\n+  @Test\n+  public void shouldNotReceiveEntriesOnDisconnect() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.disconnect(oldLeader);\n+\n+    // when\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    assertThat(getSegmentsCount(oldLeader)).isLessThan(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveEntriesAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var leaderNodeId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(leaderNodeId);\n+    clusteringRule.disconnect(oldLeader);\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(leaderNodeId);\n+    fillSegments(followers, segmentCount);\n+\n+    // when\n+    clusteringRule.connect(oldLeader);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldStillReceiveEntriesAfterStepDown() {\n+    // given\n+    final var segmentCount = 2;\n+    final var oldLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var oldLeader = clusteringRule.getBroker(oldLeaderId);\n+    clusteringRule.stepDownFromPartition(1);\n+    final List<Broker> others = clusteringRule.getOtherBrokerObjects(oldLeaderId);\n+    fillSegments(others, segmentCount);\n+\n+    // when\n+    fillSegments(others, segmentCount);\n+\n+    // then\n+    TestUtil.doRepeatedly(() -> getSegmentsCount(oldLeader)).until(count -> count >= segmentCount);\n+    assertThat(getSegmentsCount(oldLeader)).isGreaterThanOrEqualTo(segmentCount);\n+  }\n+\n+  @Test\n+  public void shouldReceiveSnapshotAfterNetworkPartition() {\n+    // given\n+    final var segmentCount = 2;\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    clusteringRule.disconnect(previousLeader);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderInfo.getNodeId());\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(previousLeaderId);\n+    fillSegments(followers, segmentCount);\n+    final var snapshotMetadata = awaitSnapshot(newLeader);\n+\n+    // when\n+    clusteringRule.connect(previousLeader);\n+\n+    // then\n+    final var receivedSnapshot = clusteringRule.waitForSnapshotAtBroker(previousLeader);\n+    assertThat(receivedSnapshot).isEqualTo(snapshotMetadata);\n+  }\n+\n+  // regression test for https://github.com/zeebe-io/zeebe/issues/4810\n+  @Test\n+  public void shouldFormClusterEvenWhenMissingEvents() {\n+    // given\n+    final var previousLeaderId = clusteringRule.getLeaderForPartition(1).getNodeId();\n+    final var previousLeader = clusteringRule.getBroker(previousLeaderId);\n+    // send some commands\n+    client.newDeployCommand().addWorkflowModel(WORKFLOW, WORKFLOW_RESOURCE_NAME).send().join();\n+\n+    // disconnect leader - becomes follower\n+    clusteringRule.disconnect(previousLeader);\n+    // IMPORTANT NOTE:\n+    // BE AWARE THAT WE NEED TO STEP DOWN AFTER DISCONNECT\n+    // IT HAPPENS FROM TIME TO TIME THAT THE LEADER DOESN'T DETECT FAST ENOUGH THE NETWORK\n+    // PARTITION.\n+    // THIS MEANS IT WILL NOT STEP DOWN AND SEND NO NEW APPENDS TO THE FOLLOWER, BECAUSE IT HAS ONE\n+    // ON GOING,\n+    // WHICH SEEM NOT TO TIMEOUT CORRECTLY. SINCE MESSAGING SERVICE IS NOT STOPPED IN PRODUCTION\n+    // ENV.\n+    // WE WILL NOT FIX THIS - INSTEAD USE THIS AS WORK AROUND.\n+    clusteringRule.stepDown(previousLeader, 1);\n+    final var newLeaderInfo = clusteringRule.awaitOtherLeader(1, previousLeaderId);\n+    final var newLeaderId = newLeaderInfo.getNodeId();\n+    assertThat(newLeaderId).isNotEqualTo(previousLeaderId);\n+    final var newLeader = clusteringRule.getBroker(newLeaderId);\n+\n+    final List<Broker> followers = clusteringRule.getOtherBrokerObjects(newLeaderId);\n+    final var followerA =\n+        followers.stream()\n+            .filter(broker -> broker.getConfig().getCluster().getNodeId() != previousLeaderId)\n+            .findFirst()\n+            .orElseThrow();\n+\n+    // Leader and Follower A have new entries\n+    // which Follower B - old leader hasn't\n+    fillSegments(List.of(newLeader, followerA), 2);\n+    awaitSnapshot(newLeader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzY5NTE1OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowMzo1M1rOGrdYEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoxNTozOFrOGrnz6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyMzI1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final List<AsyncClosable> asyncClosables = new ArrayList<>();\n          \n          \n            \n              private final List<AsyncClosable> managedResources = new ArrayList<>();", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448223251", "createdAt": "2020-07-01T09:03:53Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private final TypedRecordProcessorsFactory typedRecordProcessorsFactory;\n   private final CommandApiService commandApiService;\n   private final List<PartitionListener> partitionListeners;\n-  private final List<Actor> closeables = new ArrayList<>();\n+  private final List<AsyncClosable> asyncClosables = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM5NDIxNg==", "bodyText": "would be nice if github had a replace all", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448394216", "createdAt": "2020-07-01T14:15:38Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -84,7 +84,7 @@\n   private final TypedRecordProcessorsFactory typedRecordProcessorsFactory;\n   private final CommandApiService commandApiService;\n   private final List<PartitionListener> partitionListeners;\n-  private final List<Actor> closeables = new ArrayList<>();\n+  private final List<AsyncClosable> asyncClosables = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyMzI1MQ=="}, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzcwNzQ3OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowNzoyN1rOGrdfzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowNzoyN1rOGrdfzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyNTIyOQ==", "bodyText": "Nit: can we also extract this to a method?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448225229", "createdAt": "2020-07-01T09:07:27Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -399,30 +395,34 @@ private void transitionToLeader(final CompletableActorFuture<Void> transitionCom\n   }\n \n   private ActorFuture<Void> installStorageServices() {\n-    final var pendingDirectory =\n-        atomixRaftPartition.dataDirectory().toPath().resolve(\"pushed-pending\");\n-    try {\n-      FileUtil.ensureDirectoryExists(pendingDirectory);\n-    } catch (final IOException e) {\n-      LOG.error(\"Failed to created snapshot storage pending directory {}\", pendingDirectory, e);\n-      return CompletableActorFuture.completedExceptionally(e);\n-    }\n-\n     persistedSnapshotStore = atomixRaftPartition.getServer().getPersistedSnapshotStore();\n-    snapshotController = createSnapshotController();\n+\n+    final var controller = createSnapshotController();\n+    asyncClosables.add(this::closeSnapshotController);\n+    snapshotController = controller;\n \n     final LogCompactor logCompactor = new AtomixLogCompactor(atomixRaftPartition.getServer());\n     final LogDeletionService deletionService =\n         new LogDeletionService(\n             localBroker.getNodeId(), partitionId, logCompactor, persistedSnapshotStore);\n-    closeables.add(deletionService);\n+    asyncClosables.add(deletionService);\n \n     return scheduler.submitActor(deletionService);\n   }\n \n+  private void registerSnapshotListenerForReplication() {\n+    asyncClosables.add(\n+        () -> {\n+          persistedSnapshotStore.removeSnapshotListener(snapshotController);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzcxNTM2OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowOTozOVrOGrdkrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTowOTozOVrOGrdkrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyNjQ3OQ==", "bodyText": "Who closes zeebeDb? ZeebePartition? StateSnapshotController? Just wondering if this null check is enough.\nAlso, a little out of scope but since we're here, should we rather reschedule the next metrics export here instead of using runAtFixedRate? We've ran into issues before where you may build up a lot of tasks with runAtFixedRate, no? Though I guess here our actor is usually not very busy, so \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448226479", "createdAt": "2020-07-01T09:09:39Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -485,6 +486,22 @@ private void installProcessingPartition(final CompletableActorFuture<Void> insta\n             });\n   }\n \n+  private void installRocksDBMetricExporter(final ZeebeRocksDBMetricExporter metricExporter) {\n+    final var metricsTimer =\n+        actor.runAtFixedRate(\n+            Duration.ofSeconds(5),\n+            () -> {\n+              if (zeebeDb != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1fee58efbcee01c5c5a866bb95ced579fe581"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDk3MDYxOnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTowNDoyOVrOGrp3_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTowNDoyOVrOGrp3_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQyODAzMA==", "bodyText": "This is a pretty long lambda, can we extract it to a method?", "url": "https://github.com/camunda-cloud/zeebe/pull/4857#discussion_r448428030", "createdAt": "2020-07-01T15:04:29Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -634,38 +692,28 @@ public FileBasedSnapshotMetadata waitForSnapshotAtBroker(final Broker broker) {\n    * @param broker the broker to check on\n    * @param previousSnapshot the previous expected snapshot\n    * @return the new snapshot metadata\n-   * @throws AssertionError if no new snapshot has been found after enough repetitions (see {@link\n-   *     io.zeebe.test.util.TestUtil#waitUntil(BooleanSupplier)}\n-   * @throws IllegalStateException if no new snapshot has been found but {@link\n-   *     io.zeebe.test.util.TestUtil#waitUntil(BooleanSupplier)} did not fail\n    */\n   FileBasedSnapshotMetadata waitForNewSnapshotAtBroker(\n       final Broker broker, final FileBasedSnapshotMetadata previousSnapshot) {\n-    final var referenceToResult =\n-        new AtomicReference<>(Optional.<FileBasedSnapshotMetadata>empty());\n     final File snapshotsDir = getSnapshotsDirectory(broker);\n-    waitUntil(\n-        () -> {\n-          final File[] files = snapshotsDir.listFiles();\n-          if (files == null || files.length != 1) {\n-            return false;\n-          }\n-\n-          final var snapshotPath = files[0].toPath();\n-          final var latestSnapshot = FileBasedSnapshotMetadata.ofPath(snapshotPath);\n-          if (latestSnapshot.isPresent()\n-              && (previousSnapshot == null\n-                  || latestSnapshot.get().compareTo(previousSnapshot) > 0)) {\n-            referenceToResult.set(latestSnapshot);\n-            return true;\n-          }\n-\n-          return false;\n-        },\n-        1000);\n-\n-    return referenceToResult\n-        .get()\n+\n+    return Awaitility.await()\n+        .pollInterval(Duration.ofMillis(100))\n+        .atMost(Duration.ofMinutes(1))\n+        .until(\n+            () -> {\n+              final var files = snapshotsDir.listFiles();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6600855f44e9c0f8393dbaa6ebb92e8384d5b74e"}, "originalPosition": 226}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 418, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}