{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDAxMDQ5", "number": 3660, "title": "Fix inconsistent position creation", "bodyText": "Description\nAs I wrote here #3651 (comment)\n\nOn partition bootstrap the LogStream is created and on becoming a leader only the related actors, like processor, exporter etc. are created. This makes sense since the log stream has the same life time as the partition.\n\n\nOn LogStream starting the Appender and WriteBuffer are created/opened.\nhttps://github.com/zeebe-io/zeebe/blob/develop/logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java#L194\n\n\nTo open the Writebuffer we need to determine the partition ID and scan the log. All nodes will start there write buffer and on leader change the log is not scanned again. This means the next leader will probably start to append on a lower position. We have currently a test which verifies that our log is consistent between restarts, but this test only checks this for a single node. This issue will only happen in a cluster.\n\nTo solve this issue we introduced reference counting for log stream writers\n\non first writer creation the log appender and write buffer is created and the initial position is determined\non last writer closing the appender and write buffer is closed again\n\nThis also solves the issue, where we saw that the appender still runs after an leader change (#3652).\nNote: I will setup a benchmark and add the results here.\n\nRelated issues\n\ncloses #3651\ncloses #3652\ncloses #3667\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-01-15T07:47:17Z", "url": "https://github.com/camunda-cloud/zeebe/pull/3660", "merged": true, "mergeCommit": {"oid": "6aa68ac059d2baed401bacbc3d4b90bfdf378239"}, "closed": true, "closedAt": "2020-01-15T15:05:48Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6VXt_gH2gAyMzYzMDAxMDQ5OmM3ZmFjN2M2ZTFkNWZhNzc2OWE3NTAyZDJlYmIzNGYwYWY4ODAzMjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6kBIIgBqjI5NTA0ODkxNTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7fac7c6e1d5fa7769a7502d2ebb34f0af880323", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/c7fac7c6e1d5fa7769a7502d2ebb34f0af880323", "committedDate": "2020-01-14T18:36:27Z", "message": "chore(qa): add failing test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b12949797f96304325f123805460780e0155bde3", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/b12949797f96304325f123805460780e0155bde3", "committedDate": "2020-01-15T07:43:07Z", "message": "fix(logstreams): introduce reference counting for log stream writers\n\n * on first writer creation the log appender and write buffer is created and the initial position is determined\n * on last writer closing the appender and write buffer is closed again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a417a8fee9c93856420ed59ab10f2517a925a081", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/a417a8fee9c93856420ed59ab10f2517a925a081", "committedDate": "2020-01-15T07:43:10Z", "message": "chore(broker): close all used writers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba", "committedDate": "2020-01-15T07:43:13Z", "message": "chore(engine): close all writers after usage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDQ2NDk5", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#pullrequestreview-343046499", "createdAt": "2020-01-15T08:20:29Z", "commit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDoyOVrOFdwKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyNjo1NVrOFdwTSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA0Nw==", "bodyText": "Out of curiosity, why call and not run if we don't return anything? Doesn't it just wrap the runnable in a Callable<Void>?\nEDIT: ah, I just saw this isn't really new code, just moved. I'm still wondering why we used call there anyway \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366742047", "createdAt": "2020-01-15T08:20:29Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -144,6 +149,38 @@ private void internalSetCommitPosition(final long commitPosition) {\n     onCommitPositionUpdatedConditions.signalConsumers();\n   }\n \n+  @Override\n+  public void delete(final long position) {\n+    actor.call(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDEyOQ==", "bodyText": "If using call, couldn't createWriter not just return the LogStreamWriter? Then you don't need to create an extra future. Or just switch to run; these call calls (\ud83d\ude05) are strange to me when they return nothing.", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744129", "createdAt": "2020-01-15T08:26:15Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDM5NQ==", "bodyText": "We're in an actor context, no? Why do we need an atomic integer?", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744395", "createdAt": "2020-01-15T08:26:55Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n-    return actor.call(() -> new LogStreamBatchWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    return writerFuture;\n+  }\n+\n+  private <T extends LogStreamWriter> void createWriter(\n+      final CompletableActorFuture<T> writerFuture, final WriterCreator<T> creator) {\n+    final var alreadyOpenWriters = openWriterCount.getAndIncrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "181e87bddd7166ac46157aa060d73ea9cc9e1711", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/181e87bddd7166ac46157aa060d73ea9cc9e1711", "committedDate": "2020-01-15T09:29:52Z", "message": "chore(logstreams): replace Actor#call with #run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aa68ac059d2baed401bacbc3d4b90bfdf378239", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/6aa68ac059d2baed401bacbc3d4b90bfdf378239", "committedDate": "2020-01-15T11:40:02Z", "message": "chore(logstreams): fix deadlock\n\n * after log was closed new writer futures where never completed"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da9c6dcaf29ab5a8bd2e0dfde792b444a553313c", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/da9c6dcaf29ab5a8bd2e0dfde792b444a553313c", "committedDate": "2020-01-15T11:00:39Z", "message": "chore(logstreams): fix deadlock\n\n * after log was closed new writer futures where never completed"}, "afterCommit": {"oid": "6aa68ac059d2baed401bacbc3d4b90bfdf378239", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/6aa68ac059d2baed401bacbc3d4b90bfdf378239", "committedDate": "2020-01-15T11:40:02Z", "message": "chore(logstreams): fix deadlock\n\n * after log was closed new writer futures where never completed"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3195, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}