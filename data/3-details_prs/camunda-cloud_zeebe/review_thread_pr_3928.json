{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzEzNDE4", "number": 3928, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1MDoyMlrODktTrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxNFrODkuYgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODE3NjQ1OnYy", "diffSide": "RIGHT", "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1MDoyMlrOFxLe0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1MDoyMlrOFxLe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExMjY1Ng==", "bodyText": "Can use floorEntry()\n   public long lookupPosition(final long position) {\n    final var lowerEntry = positionIndexMapping.floorEntry(position);\n    if (lowerEntry != null) {\n      return lowerEntry.getValue();\n    }\n    return -1;\n  }", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387112656", "createdAt": "2020-03-03T15:50:22Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.index.JournalIndex;\n+import io.atomix.storage.journal.index.Position;\n+import io.atomix.storage.journal.index.SparseJournalIndex;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+public final class ZeebeIndexAdapter implements JournalIndex, ZeebeIndexMapping {\n+\n+  private final ConcurrentNavigableMap<Long, Long> positionIndexMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final ConcurrentNavigableMap<Long, Long> indexPositionMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final SparseJournalIndex sparseJournalIndex;\n+  private final int density;\n+\n+  private ZeebeIndexAdapter(int density) {\n+    this.density = density;\n+    sparseJournalIndex = new SparseJournalIndex(density);\n+  }\n+\n+  public static ZeebeIndexAdapter ofDensity(int density) {\n+    return new ZeebeIndexAdapter(density);\n+  }\n+\n+  @Override\n+  public void index(final Indexed indexedEntry, final int position) {\n+    final var index = indexedEntry.index();\n+    if (index % density == 0) {\n+      if (indexedEntry.type() == ZeebeEntry.class) {\n+        final ZeebeEntry zeebeEntry = (ZeebeEntry) indexedEntry.entry();\n+        final var lowestPosition = zeebeEntry.lowestPosition();\n+\n+        positionIndexMapping.put(lowestPosition, index);\n+        indexPositionMapping.put(index, lowestPosition);\n+      }\n+    }\n+\n+    sparseJournalIndex.index(indexedEntry, position);\n+  }\n+\n+  @Override\n+  public long lookupPosition(final long position) {\n+    var index = positionIndexMapping.getOrDefault(position, -1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODIwMTY1OnYy", "diffSide": "RIGHT", "path": "logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1NjowMlrOFxLuaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1NjowMlrOFxLuaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExNjY0OA==", "bodyText": "Just for completeness may be test one at exact position.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n          \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(20)).isEqualTo(5);", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387116648", "createdAt": "2020-03-03T15:56:02Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.log.entry.InitializeEntry;\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import java.nio.ByteBuffer;\n+import org.junit.Test;\n+\n+public class ZeebeIndexTest {\n+\n+  @Test\n+  public void shouldNotFindIndexWhenNotReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    final var index = zeebeIndexAdapter.lookupPosition(1L);\n+\n+    // then\n+    assertThat(index).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void shouldFindIndexWhenReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n+    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n+    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n+    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n+    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n+\n+    // then\n+    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM0Mjc5OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyNjoxM1rOFxNEpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNjowOToyNVrOFzbxqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA==", "bodyText": "Can we use atomixLogStorage.newReader()?", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387138724", "createdAt": "2020-03-03T16:26:13Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MTk2NA==", "bodyText": "Actually here I was not 100% sure, since it used a different index as on newReader. Might that @npepinpe knows.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388281964", "createdAt": "2020-03-05T13:09:42Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTI3Mw==", "bodyText": "Hm, I guess we could use it, don't see any reason why not - the goal is just that it starts at the beginning.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289273", "createdAt": "2020-03-05T13:23:49Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4OTg0NQ==", "bodyText": "newReader uses index zero or 1 and this one -1 \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388289845", "createdAt": "2020-03-05T13:24:53Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDI2NQ==", "bodyText": "Yeah, doesn't really matter I think, just that it starts at the beginning, as far as I remember. Just try it and see, should be fine", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290265", "createdAt": "2020-03-05T13:25:43Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxMzUwMg==", "bodyText": "I have approved the PR. You can change to atomixLogStorage.newReader() if you think it wouldn't break anything.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388413502", "createdAt": "2020-03-05T16:34:39Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3Njc3Ng==", "bodyText": "We currently need the implementation class in the AtomixRecordSupplier. I will leave it for now.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r389476776", "createdAt": "2020-03-09T06:09:25Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM1MjY3OnYy", "diffSide": "RIGHT", "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxNFrOFxNKlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoyNzo0NVrOFyTa9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw==", "bodyText": "This returns an address <= the current address, right? It will be better explained in the doc.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387140247", "createdAt": "2020-03-03T16:28:14Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MzUxNA==", "bodyText": "What do you mean with the current address? Which current? \ud83d\ude05 It just checks the index.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388283514", "createdAt": "2020-03-05T13:12:52Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MDc0Ng==", "bodyText": "Sorry. I mean it returns an index corresponding to a pos <= given position.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388290746", "createdAt": "2020-03-05T13:26:34Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5MTMxNg==", "bodyText": "Ok I think I get it :D", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r388291316", "createdAt": "2020-03-05T13:27:45Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw=="}, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 7, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}