{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MDM2MTU5", "number": 5631, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDo1NjowNlrOEvmR_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzo0Mzo0NVrOEvpECA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzQ1NzI1OnYy", "diffSide": "RIGHT", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDo1NjowNlrOHkqngg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDo1NjowNlrOHkqngg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTAyNg==", "bodyText": "We may want to align the names with the other tests.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final NoopPartitionStep firstComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep secondComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep leaderComponent = spy(new NoopPartitionStep());\n          \n          \n            \n                final NoopPartitionStep followerComponent = spy(new NoopPartitionStep());", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508209026", "createdAt": "2020-10-20T04:56:06Z", "author": {"login": "saig0"}, "path": "broker/src/test/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionTest.java", "diffHunk": "@@ -73,6 +73,210 @@ public void shouldCloseInOppositeOrderOfOpen() {\n     order.verify(firstComponent).close(ctx);\n   }\n \n+  @Test\n+  public void shouldTransitionFromLeaderToFollowerInSequence() {\n+    // given\n+    final NoopPartitionStep firstComponent = spy(new NoopPartitionStep());\n+    final NoopPartitionStep secondComponent = spy(new NoopPartitionStep());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzQ2MTgyOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDo1ODo0N1rOHkqqKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDowODo1NlrOHk00hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg==", "bodyText": "I'm not sure if it is necessary to expose the current future. We can store the future in ZeebePartition itself when calling transition.toLeader() etc.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508209706", "createdAt": "2020-10-20T04:58:47Z", "author": {"login": "saig0"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }\n+\n+  @Override\n+  public ActorFuture<Void> currentTransitionFuture() {\n+    return currentTransition;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwODAyOQ==", "bodyText": "I agree with this. It'd be good to use the last returned future instead of adding more methods to the interface", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508308029", "createdAt": "2020-10-20T08:28:16Z", "author": {"login": "MiguelPires"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }\n+\n+  @Override\n+  public ActorFuture<Void> currentTransitionFuture() {\n+    return currentTransition;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NjE5Ng==", "bodyText": "What I didn't like on this suggestion is that we need to keep and maintain the same state in the ZeebePartition as we already have in the Transition. I have the feeling that this is a bit unstable, but I change it for now.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508376196", "createdAt": "2020-10-20T10:08:56Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }\n+\n+  @Override\n+  public ActorFuture<Void> currentTransitionFuture() {\n+    return currentTransition;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTcwNg=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzQ2NjUxOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNTowMTowMFrOHkqs1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODoyODoyNFrOHkwqqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ==", "bodyText": "We may want to synchronize this method to be safe. Just in case.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508210389", "createdAt": "2020-10-20T05:01:00Z", "author": {"login": "saig0"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNDU1NA==", "bodyText": "Locking \ud83d\udc40 really? This is a component by an actor right? Why we should access this by multiple threads?", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508214554", "createdAt": "2020-10-20T05:16:15Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwODEzOA==", "bodyText": "After discussion we decided to keep it as it is, since it is currently only use by the same actor and multi thread solution is not necessary here.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508308138", "createdAt": "2020-10-20T08:28:24Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, EMPTY_LIST));\n+    enqueueTransition(future, EMPTY_LIST);\n     return future;\n   }\n \n+  /**\n+   * This method allows to enqueue the next transition, such that the transitions are executed in\n+   * order. Previous we had the issue that all transitions have subscribe to the current transition,\n+   * which lead to undefined behavior.\n+   *\n+   * @param nextTransitionFuture the future of the next transition\n+   * @param partitionStepList the steps which should be installed on the transition\n+   */\n+  private void enqueueTransition(\n+      final CompletableActorFuture<Void> nextTransitionFuture,\n+      final List<PartitionStep> partitionStepList) {\n+    final var nextCurrentTransition = currentTransitionFuture();\n+    currentTransition = nextTransitionFuture;\n+    nextCurrentTransition.onComplete(\n+        (nothing, err) -> transition(nextTransitionFuture, partitionStepList));\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMDM4OQ=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzQ4MTA2OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNTowOToxMlrOHkq1Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwODoyNToxMlrOHkwhxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ==", "bodyText": "Do we really want to wait until the current transition is done? I'm not sure how long this can take \ud83e\udd14\nSince we want to close the partition, it may be faster to interrupt the current transition.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508212575", "createdAt": "2020-10-20T05:09:12Z", "author": {"login": "saig0"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -203,6 +208,28 @@ protected void onActorStarted() {\n         .registerComponent(zeebePartitionHealth.getName(), zeebePartitionHealth);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (closeFuture != null) {\n+      return closeFuture;\n+    }\n+\n+    closeFuture = new CompletableActorFuture<>();\n+\n+    actor.call(\n+        () ->\n+            // allows to await current transition to avoid concurrent modifications and\n+            // transitioning\n+            currentTransition()\n+                .onComplete(\n+                    (nothing, err) -> {\n+                      LOG.debug(\"Closing Zeebe Partition {}.\", context.getPartitionId());\n+                      super.closeAsync();\n+                    }));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNDI1Ng==", "bodyText": "This is not safe and not easy to do so. We talking about a graceful shutdown, then I think we should close everything we have opened otherwise we might end up in an inconsistent state, as we did. How long do you think it will take and why? In all our qa tests we doing a normal close and it worked right?", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508214256", "createdAt": "2020-10-20T05:15:11Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -203,6 +208,28 @@ protected void onActorStarted() {\n         .registerComponent(zeebePartitionHealth.getName(), zeebePartitionHealth);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (closeFuture != null) {\n+      return closeFuture;\n+    }\n+\n+    closeFuture = new CompletableActorFuture<>();\n+\n+    actor.call(\n+        () ->\n+            // allows to await current transition to avoid concurrent modifications and\n+            // transitioning\n+            currentTransition()\n+                .onComplete(\n+                    (nothing, err) -> {\n+                      LOG.debug(\"Closing Zeebe Partition {}.\", context.getPartitionId());\n+                      super.closeAsync();\n+                    }));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4NTQ3OQ==", "bodyText": "My only issue is that this will wait for all the enqueued transitions instead of just the one currently running. During normal operations we probably won't have many transitions but if we do then we'll take a long time to close. One alternative would be to store the \"new\" futures in a list when we transition instead of replacing the current future with them. We'd only replace the current one when the current finishes. This would then allow us to \"jump\" the queue when closing it, just wait for the current one and close after that one. However, it adds complexity to the PartitionTransition behavior and it's less elegant than the current solution, so I like it the way it is. Still, I thought it was worth discussing. Thoughts?", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508285479", "createdAt": "2020-10-20T07:54:37Z", "author": {"login": "MiguelPires"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -203,6 +208,28 @@ protected void onActorStarted() {\n         .registerComponent(zeebePartitionHealth.getName(), zeebePartitionHealth);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (closeFuture != null) {\n+      return closeFuture;\n+    }\n+\n+    closeFuture = new CompletableActorFuture<>();\n+\n+    actor.call(\n+        () ->\n+            // allows to await current transition to avoid concurrent modifications and\n+            // transitioning\n+            currentTransition()\n+                .onComplete(\n+                    (nothing, err) -> {\n+                      LOG.debug(\"Closing Zeebe Partition {}.\", context.getPartitionId());\n+                      super.closeAsync();\n+                    }));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwNTg2Mg==", "bodyText": "I discussed this with @saig0 . We decided to keep it that way for now, since it is safe and simple. If we see any issues regarding closing time we can investigate here further how to interrupt or close faster. Personally I think it might be dangerous to do that or at least it needs more effort to do it right.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508305862", "createdAt": "2020-10-20T08:25:12Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -203,6 +208,28 @@ protected void onActorStarted() {\n         .registerComponent(zeebePartitionHealth.getName(), zeebePartitionHealth);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {\n+    if (closeFuture != null) {\n+      return closeFuture;\n+    }\n+\n+    closeFuture = new CompletableActorFuture<>();\n+\n+    actor.call(\n+        () ->\n+            // allows to await current transition to avoid concurrent modifications and\n+            // transitioning\n+            currentTransition()\n+                .onComplete(\n+                    (nothing, err) -> {\n+                      LOG.debug(\"Closing Zeebe Partition {}.\", context.getPartitionId());\n+                      super.closeAsync();\n+                    }));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMjU3NQ=="}, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzkxMzA0OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzo0Mzo0NVrOHku3Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzo0Mzo0NVrOHku3Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI3ODU3NQ==", "bodyText": "You can move the creation of this future into the enqueueTransition method and simply return it from there. That would reduce each of these methods to a single return statement.", "url": "https://github.com/camunda-cloud/zeebe/pull/5631#discussion_r508278575", "createdAt": "2020-10-20T07:43:45Z", "author": {"login": "korthout"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/PartitionTransitionImpl.java", "diffHunk": "@@ -41,27 +41,48 @@ public PartitionTransitionImpl(\n   @Override\n   public ActorFuture<Void> toFollower() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, followerSteps));\n+    enqueueTransition(future, followerSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toLeader() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();\n-    currentTransition.onComplete((nothing, err) -> transition(future, leaderSteps));\n+    enqueueTransition(future, leaderSteps);\n     return future;\n   }\n \n   @Override\n   public ActorFuture<Void> toInactive() {\n     final CompletableActorFuture<Void> future = new CompletableActorFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f356b398501baa4f66027551b4a00ee95cb5be41"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 215, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}