{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMDU1MDUx", "number": 3962, "title": "chore(broker): move compaction responsibility from LogStream to broker", "bodyText": "Description\nThis PR removes the compaction responsibility from the log stream abstraction, and instead moves it to the broker as a LogCompactor API, with currently a single implementation for the Atomix Raft Log, AtomixLogCompactor. It also replaces the position from the snapshot interface with a compactionBound, which is to be interpreted by the implementation as it sees fit. In the case of this one, it is the upper bound index, such that it is not necessary anymore to open snapshots except for recovery purposes.\nSnapshot positions are then only used by the AsyncSnapshotDirector for the purpose of committing snapshot, but then we always work off of the positions that are stored in the snapshot itself.\nAs such, compaction now never has issues with \"not found\" positions, as the index is just an upper bound, whether or not it is present is irrelevant. Note however that Atomix still guarantees that we always have one segment present, so it's not possible to entirely compact the whole log - as such I think the solution is as safe that our current one.\nRelated issues\ncloses #3991\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-03-01T15:04:15Z", "url": "https://github.com/camunda-cloud/zeebe/pull/3962", "merged": true, "mergeCommit": {"oid": "92d121d5764ea607d2e8e44037ece3fe50709627"}, "closed": true, "closedAt": "2020-03-11T10:02:56Z", "author": {"login": "npepinpe"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKruozgBqjMxMDEyNDMwMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMjnE8ABqjMxMTc5NDQxMjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed081b7f3a8d4db8531ddc1cffd11dee0f58b612", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ed081b7f3a8d4db8531ddc1cffd11dee0f58b612", "committedDate": "2020-03-01T14:58:05Z", "message": "chore(broker): introduce LogDeletion service\n\n- adds AtomixLogDeletionService a specialized class to compaction the\n  log based on a given snapshot upper compaction bound"}, "afterCommit": {"oid": "b27315872a6123ac70bdf8c9f99540f3024ae09e", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/b27315872a6123ac70bdf8c9f99540f3024ae09e", "committedDate": "2020-03-05T13:42:03Z", "message": "chore(qa): minor quality improvement"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b27315872a6123ac70bdf8c9f99540f3024ae09e", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/b27315872a6123ac70bdf8c9f99540f3024ae09e", "committedDate": "2020-03-05T13:42:03Z", "message": "chore(qa): minor quality improvement"}, "afterCommit": {"oid": "1f1b559a4b719c0817dc54c8078d703b05bcc134", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1f1b559a4b719c0817dc54c8078d703b05bcc134", "committedDate": "2020-03-05T13:48:48Z", "message": "chore(qa): minor quality improvement"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f1b559a4b719c0817dc54c8078d703b05bcc134", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1f1b559a4b719c0817dc54c8078d703b05bcc134", "committedDate": "2020-03-05T13:48:48Z", "message": "chore(qa): minor quality improvement"}, "afterCommit": {"oid": "418636af04343eba2fda893654a5e71701131ae4", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/418636af04343eba2fda893654a5e71701131ae4", "committedDate": "2020-03-05T14:23:05Z", "message": "chore(qa): minor quality improvement"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0acecb5ac9e57a4f51cfae0efd6333f60a29e0c", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f0acecb5ac9e57a4f51cfae0efd6333f60a29e0c", "committedDate": "2020-03-05T16:12:34Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}, "afterCommit": {"oid": "ad926660ad5edcce342cb273aacfeb2a360335d2", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ad926660ad5edcce342cb273aacfeb2a360335d2", "committedDate": "2020-03-06T09:36:29Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b818c647036dc181ed1ed41dee1683b9a711fd15", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/b818c647036dc181ed1ed41dee1683b9a711fd15", "committedDate": "2020-03-10T07:55:41Z", "message": "chore(engine): do not access deprecated getLastValidSnapshotPosition API"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad926660ad5edcce342cb273aacfeb2a360335d2", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ad926660ad5edcce342cb273aacfeb2a360335d2", "committedDate": "2020-03-06T09:36:29Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}, "afterCommit": {"oid": "f24ff33d0bc1226c5c94771b1e25bd43b73c479a", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f24ff33d0bc1226c5c94771b1e25bd43b73c479a", "committedDate": "2020-03-10T07:57:51Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNzE0OTkx", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#pullrequestreview-371714991", "createdAt": "2020-03-10T07:00:39Z", "commit": {"oid": "ad926660ad5edcce342cb273aacfeb2a360335d2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNzowMDozOVrOF0DQ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoyMzozOVrOF0FBlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyMzc1OQ==", "bodyText": "Why is this method called onCompaction but only called on error? A bit unclear to me. As you wrote in the comment I think it make sense to complete the future exceptionally ? \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390123759", "createdAt": "2020-03-10T07:00:39Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/logstreams/AtomixLogCompactor.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.logstreams;\n+\n+import io.atomix.protocols.raft.partition.impl.RaftPartitionServer;\n+import io.zeebe.broker.Loggers;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class AtomixLogCompactor implements LogCompactor {\n+  private final RaftPartitionServer partitionServer;\n+\n+  public AtomixLogCompactor(final RaftPartitionServer partitionServer) {\n+    this.partitionServer = partitionServer;\n+  }\n+\n+  /**\n+   * Sets the compactable index on the Atomix side and triggers compaction. On failure will log the\n+   * error but will return a \"successful\" future - arguable if this is desired behavior.\n+   *\n+   * @param compactionBound the upper index compaction bound\n+   * @return a future which is completed after compaction is finished\n+   */\n+  @Override\n+  public CompletableFuture<Void> compactLog(final long compactionBound) {\n+    Loggers.DELETION_SERVICE.debug(\"Compacting Atomix log up to index {}\", compactionBound);\n+    partitionServer.setCompactableIndex(compactionBound);\n+    return partitionServer.snapshot().exceptionally(error -> onCompaction(compactionBound, error));\n+  }\n+\n+  private Void onCompaction(final long compactionBound, final Throwable error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad926660ad5edcce342cb273aacfeb2a360335d2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDQ2Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390124463", "createdAt": "2020-03-10T07:03:20Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -294,10 +295,9 @@ private void transitionToLeader(final CompletableActorFuture<Void> transitionCom\n           e);\n     }\n \n-    final StatePositionSupplier positionSupplier = new StatePositionSupplier(LOG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad926660ad5edcce342cb273aacfeb2a360335d2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NDU4Mw==", "bodyText": "Why do you think they are null?", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390144583", "createdAt": "2020-03-10T08:04:17Z", "author": {"login": "Zelldon"}, "path": "broker/src/test/java/io/zeebe/broker/logstreams/AtomixLogDeletionServiceTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.logstreams;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.RaftStorage;\n+import io.atomix.protocols.raft.storage.log.RaftLogReader;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.storage.journal.JournalSegmentDescriptor;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.AtomixRecordEntrySupplierImpl;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.AtomixSnapshotStorage;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.DbSnapshotStore;\n+import io.zeebe.logstreams.state.SnapshotMetrics;\n+import io.zeebe.logstreams.storage.atomix.AtomixLogStorageReader;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class AtomixLogDeletionServiceTest {\n+\n+  private static final ByteBuffer DATA = ByteBuffer.allocate(Integer.BYTES).putInt(0, 1);\n+  private static final int PARTITION_ID = 1;\n+\n+  private final ActorSchedulerRule actorScheduler = new ActorSchedulerRule();\n+  private final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  private final AtomixLogStorageRule logStorageRule =\n+      new AtomixLogStorageRule(temporaryFolder, PARTITION_ID, b -> builder(b, temporaryFolder));\n+\n+  @Rule\n+  public final RuleChain chain =\n+      RuleChain.outerRule(temporaryFolder).around(actorScheduler).around(logStorageRule);\n+\n+  private AtomixSnapshotStorage snapshotStorage;\n+  private AtomixLogStorageReader storageReader;\n+  private LogDeletionService deletionService;\n+  private Compactor compactor;\n+\n+  @Before\n+  public void setUp() {\n+    storageReader =\n+        new AtomixLogStorageReader(logStorageRule.getRaftLog().openReader(-1, Mode.COMMITS));\n+    snapshotStorage =\n+        new AtomixSnapshotStorage(\n+            null,\n+            logStorageRule.getSnapshotStore(),\n+            new AtomixRecordEntrySupplierImpl(storageReader),\n+            1,\n+            new SnapshotMetrics(PARTITION_ID));\n+    compactor = new Compactor();\n+\n+    deletionService = new LogDeletionService(0, PARTITION_ID, compactor, snapshotStorage);\n+    actorScheduler.submitActor(deletionService).join();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (storageReader != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NTYwNw==", "bodyText": "Not sure whether this makes sense or not. This would mean if we get a snapshot with index 5 we keep 3, so actually we have an gap in between. Hopefully we will start not  at the beginning \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390145607", "createdAt": "2020-03-10T08:06:50Z", "author": {"login": "Zelldon"}, "path": "broker/src/test/java/io/zeebe/broker/logstreams/AtomixLogDeletionServiceTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.logstreams;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.RaftStorage;\n+import io.atomix.protocols.raft.storage.log.RaftLogReader;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.storage.journal.JournalSegmentDescriptor;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.AtomixRecordEntrySupplierImpl;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.AtomixSnapshotStorage;\n+import io.zeebe.broker.clustering.atomix.storage.snapshot.DbSnapshotStore;\n+import io.zeebe.logstreams.state.SnapshotMetrics;\n+import io.zeebe.logstreams.storage.atomix.AtomixLogStorageReader;\n+import io.zeebe.logstreams.util.AtomixLogStorageRule;\n+import io.zeebe.util.sched.testing.ActorSchedulerRule;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public final class AtomixLogDeletionServiceTest {\n+\n+  private static final ByteBuffer DATA = ByteBuffer.allocate(Integer.BYTES).putInt(0, 1);\n+  private static final int PARTITION_ID = 1;\n+\n+  private final ActorSchedulerRule actorScheduler = new ActorSchedulerRule();\n+  private final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  private final AtomixLogStorageRule logStorageRule =\n+      new AtomixLogStorageRule(temporaryFolder, PARTITION_ID, b -> builder(b, temporaryFolder));\n+\n+  @Rule\n+  public final RuleChain chain =\n+      RuleChain.outerRule(temporaryFolder).around(actorScheduler).around(logStorageRule);\n+\n+  private AtomixSnapshotStorage snapshotStorage;\n+  private AtomixLogStorageReader storageReader;\n+  private LogDeletionService deletionService;\n+  private Compactor compactor;\n+\n+  @Before\n+  public void setUp() {\n+    storageReader =\n+        new AtomixLogStorageReader(logStorageRule.getRaftLog().openReader(-1, Mode.COMMITS));\n+    snapshotStorage =\n+        new AtomixSnapshotStorage(\n+            null,\n+            logStorageRule.getSnapshotStore(),\n+            new AtomixRecordEntrySupplierImpl(storageReader),\n+            1,\n+            new SnapshotMetrics(PARTITION_ID));\n+    compactor = new Compactor();\n+\n+    deletionService = new LogDeletionService(0, PARTITION_ID, compactor, snapshotStorage);\n+    actorScheduler.submitActor(deletionService).join();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (storageReader != null) {\n+      storageReader.close();\n+      storageReader = null;\n+    }\n+\n+    if (snapshotStorage != null) {\n+      snapshotStorage.close();\n+      snapshotStorage = null;\n+    }\n+\n+    if (deletionService != null) {\n+      deletionService.close();\n+      deletionService = null;\n+    }\n+  }\n+\n+  @Test\n+  public void shouldDeleteUpToCompactionBound() {\n+    // given\n+    final var reader = logStorageRule.getRaftLog().openReader(-1);\n+\n+    // when\n+    logStorageRule.appendEntry(1, 1, DATA).index();\n+    logStorageRule.appendEntry(2, 2, DATA).index();\n+    logStorageRule.appendEntry(3, 3, DATA).index();\n+    createSnapshot(2);\n+\n+    // then\n+    compactor.awaitCompaction(2L, Duration.ofSeconds(5));\n+    reader.reset();\n+    final var entries = readAllEntries(reader);\n+    assertThat(entries).isNotEmpty().hasSize(2).extracting(Indexed::index).containsExactly(2L, 3L);\n+  }\n+\n+  @Test\n+  public void shouldNotDeleteOnLowerCompactionBound() {\n+    // given\n+    final var reader = logStorageRule.getRaftLog().openReader(-1);\n+\n+    // when\n+    logStorageRule.appendEntry(1, 1, DATA).index();\n+    logStorageRule.appendEntry(2, 2, DATA).index();\n+    logStorageRule.appendEntry(3, 3, DATA).index();\n+    createSnapshot(0);\n+\n+    // then\n+    compactor.awaitCompaction(0L, Duration.ofSeconds(5));\n+    reader.reset();\n+    final var entries = readAllEntries(reader);\n+    assertThat(entries)\n+        .isNotEmpty()\n+        .hasSize(3)\n+        .extracting(Indexed::index)\n+        .containsExactly(1L, 2L, 3L);\n+  }\n+\n+  @Test\n+  public void shouldDeleteLowerEntriesEvenIfIndexNotFound() {\n+    // given\n+    final var reader = logStorageRule.getRaftLog().openReader(-1);\n+\n+    // when\n+    logStorageRule.appendEntry(1, 1, DATA).index();\n+    logStorageRule.appendEntry(2, 2, DATA).index();\n+    logStorageRule.appendEntry(3, 3, DATA).index();\n+    createSnapshot(5L);\n+\n+    // then - expect exactly one segment left with entry 3\n+    compactor.awaitCompaction(5L, Duration.ofSeconds(5));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NjUyNQ==", "bodyText": "Is it correct to continue from here?", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390146525", "createdAt": "2020-03-10T08:09:13Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/AsyncSnapshotDirector.java", "diffHunk": "@@ -78,17 +78,75 @@ protected void onActorStarting() {\n     commitCondition = actor.onCondition(getConditionNameForPosition(), this::onCommitCheck);\n     logStream.registerOnCommitPositionUpdatedCondition(commitCondition);\n \n-    lastValidSnapshotPosition = snapshotController.getLastValidSnapshotPosition();\n-    LOG.debug(\n-        \"The position of the last valid snapshot is '{}'. Taking snapshots beyond this position.\",\n-        lastValidSnapshotPosition);\n+    lastValidSnapshotPosition = -1;\n+    actor.runOnCompletionBlockingCurrentPhase(\n+        streamProcessor.getLastProcessedPositionAsync(),\n+        (position, error) -> {\n+          if (error == null) {\n+            lastValidSnapshotPosition = position;\n+            LOG.debug(\n+                \"The position of the last valid snapshot is '{}'. Taking snapshots beyond this position.\",\n+                lastValidSnapshotPosition);\n+          } else {\n+            LOG.error(ERROR_MSG_ON_RESOLVE_PROCESSED_POS, error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzQwNg==", "bodyText": "We have to check our format settings again. In the latest reviews I often saw methods rearrangements. It is is really hard to follow.", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390147406", "createdAt": "2020-03-10T08:11:24Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/AsyncSnapshotDirector.java", "diffHunk": "@@ -78,17 +78,75 @@ protected void onActorStarting() {\n     commitCondition = actor.onCondition(getConditionNameForPosition(), this::onCommitCheck);\n     logStream.registerOnCommitPositionUpdatedCondition(commitCondition);\n \n-    lastValidSnapshotPosition = snapshotController.getLastValidSnapshotPosition();\n-    LOG.debug(\n-        \"The position of the last valid snapshot is '{}'. Taking snapshots beyond this position.\",\n-        lastValidSnapshotPosition);\n+    lastValidSnapshotPosition = -1;\n+    actor.runOnCompletionBlockingCurrentPhase(\n+        streamProcessor.getLastProcessedPositionAsync(),\n+        (position, error) -> {\n+          if (error == null) {\n+            lastValidSnapshotPosition = position;\n+            LOG.debug(\n+                \"The position of the last valid snapshot is '{}'. Taking snapshots beyond this position.\",\n+                lastValidSnapshotPosition);\n+          } else {\n+            LOG.error(ERROR_MSG_ON_RESOLVE_PROCESSED_POS, error);\n+          }\n+        });\n   }\n \n   @Override\n   protected void onActorCloseRequested() {\n     logStream.removeOnCommitPositionUpdatedCondition(commitCondition);\n   }\n \n+  @Override\n+  public ActorFuture<Void> closeAsync() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODIyOA==", "bodyText": "When we could get rid of this limitation then we would also get updates from exporter position.", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390148228", "createdAt": "2020-03-10T08:13:34Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorTest.java", "diffHunk": "@@ -575,7 +572,7 @@ public void onRecovered(final ReadonlyProcessingContext context) {\n   }\n \n   @Test\n-  public void shouldNotCreateSnapshotsIfNoProcessorProcessEvent() throws Exception {\n+  public void shouldNotCreateSnapshotsIfNoProcessorProcessEvent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODQ1Nw==", "bodyText": "This could cause merge conflicts - I think I renamed it already :D", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390148457", "createdAt": "2020-03-10T08:14:08Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -335,13 +324,13 @@ private int determineInitialPartitionId() {\n       final long lastPosition = logReader.seekToEnd();\n \n       // dispatcher needs to generate positions greater than the last position\n-      int partitionId = 0;\n+      int dispatcherPartitionId = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0OTU1Ng==", "bodyText": "\ud83d\ude48 This is often really hard to spot", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390149556", "createdAt": "2020-03-10T08:16:44Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/state/StateSnapshotController.java", "diffHunk": "@@ -119,7 +115,7 @@ public long recover() throws Exception {\n         // open database to verify that the snapshot is recoverable\n         openDb();\n         LOG.debug(\"Recovered state from snapshot '{}'\", snapshot);\n-        lowerBoundSnapshotPosition = snapshot.getPosition();\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1MDc2MQ==", "bodyText": "Should we fail then? I'm wondering what we should do in the processor actually, if we have no snapshot to open (because they are corrupted)", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390150761", "createdAt": "2020-03-10T08:19:30Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/state/StateSnapshotControllerTest.java", "diffHunk": "@@ -73,14 +74,14 @@ public void shouldTakeSnapshot() throws Exception {\n   }\n \n   @Test\n-  public void shouldOpenNewDatabaseIfNoSnapshotsToRecoverFrom() throws Exception {\n+  public void shouldDoNothingIfNoSnapshotsToRecoverFrom() throws Exception {\n     // given\n \n     // when\n-    final long lowerBoundSnapshotPosition = snapshotController.recover();\n+    snapshotController.recover();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1MjQ0OA==", "bodyText": "\ud83d\ude06 \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390152448", "createdAt": "2020-03-10T08:23:21Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/SnapshotReplicationTest.java", "diffHunk": "@@ -28,7 +29,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.zip.CRC32;\n+import java.util.zip.CRC32C;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1MjU5Nw==", "bodyText": "We can also use that in the replication chunks right?", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#discussion_r390152597", "createdAt": "2020-03-10T08:23:39Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/SnapshotReplicationTest.java", "diffHunk": "@@ -28,7 +29,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.zip.CRC32;\n+import java.util.zip.CRC32C;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1MjQ0OA=="}, "originalCommit": {"oid": "c575fc393063e4d4276fe84791d3d478d73b8710"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e723530bec7c303cd12d17fe7955c441f81caba", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/9e723530bec7c303cd12d17fe7955c441f81caba", "committedDate": "2020-03-10T08:58:52Z", "message": "chore(broker): move compaction error log to service"}, "afterCommit": {"oid": "8ee58d11f155056b7df806ff44fefd1b634f9659", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/8ee58d11f155056b7df806ff44fefd1b634f9659", "committedDate": "2020-03-10T09:00:37Z", "message": "chore(broker): move compaction error log to service"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMDMyNTQ4", "url": "https://github.com/camunda-cloud/zeebe/pull/3962#pullrequestreview-372032548", "createdAt": "2020-03-10T14:57:36Z", "commit": {"oid": "c8b635d6a686fe9895ffb05e7e53a9c7e344f02b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43543afe7748f57a2022254bea04fa86b3507955", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/43543afe7748f57a2022254bea04fa86b3507955", "committedDate": "2020-03-11T09:15:30Z", "message": "chore(logstreams): remove deletion responsibility from LogStream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e51197a6b3bd54d61b82b13a168378b768efe828", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e51197a6b3bd54d61b82b13a168378b768efe828", "committedDate": "2020-03-11T09:15:30Z", "message": "chore(qa): minor quality improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7c55b849a5a2880627338b5da6e22a4b0d6a0b8", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f7c55b849a5a2880627338b5da6e22a4b0d6a0b8", "committedDate": "2020-03-11T09:15:30Z", "message": "chore(broker): introduce LogDeletion service\n\n- adds AtomixLogDeletionService a specialized class to compaction the\n  log based on a given snapshot upper compaction bound"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2063146e61bbc73636be83534de44bdddc69466d", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/2063146e61bbc73636be83534de44bdddc69466d", "committedDate": "2020-03-11T09:15:30Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8b635d6a686fe9895ffb05e7e53a9c7e344f02b", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/c8b635d6a686fe9895ffb05e7e53a9c7e344f02b", "committedDate": "2020-03-10T09:57:54Z", "message": "chore(broker): remove null checks"}, "afterCommit": {"oid": "2063146e61bbc73636be83534de44bdddc69466d", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/2063146e61bbc73636be83534de44bdddc69466d", "committedDate": "2020-03-11T09:15:30Z", "message": "chore(engine): fetch last processed position on async snapshot director start"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3024, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}