{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Nzg3NDgw", "number": 4641, "title": "Rewrite Snapshotting", "bodyText": "Hey Team,\nsorry for the big PR but was saw no better way to do this. I think most of the new lines are actually unit tests.\n@pihme I think it is just for you to learn how it works don't need to be to check every details.\n@npepinpe or @deepthidevaki who ever has time would be nice if you could take a look, especially for raft and zeebe endpoints where we use it. Hope it makes sense to you.\nHappy to get your feedback.\nDescription\nIntroduces new interfaces for Snapshotting and rewrites and merge existing implementation.\nPersistedSnapshotStore can be used to take snapshots and receive\nsnapshot chunks. After all chunks are received or the snapshot is taken\nthe volatile snapshot can be persisted. It is always possible\nto abort an snapshot, before persisting. The store can also be used\nto get the latest snapshot which was persisted. The store allows\nto register listeners, which are called on new persisted snapshots.\nOn receiving snapshot chunks and consuming them, checksums of the chunks\nare verified. On persisting an received snapshot the complete snapshot\nchecksum is verified.\nAn persisted snapshot can be read from its persisted storage via a\nreader and will be chunked in several snapshot chunks, which\nthen can be transmitted and consumed again by the store.\nThe StateSnapshotController use by the AsyncSnapshotDirector and is the\nonly one which takes a snapshot. The ReplicationController is\nregistered at the SnapshotStore as listener to replicate new persisted\nsnapshots. The replication will send all chunks over the network.\nThe ReplicationController will receive the chunks on the follower side and will use\nthe newReceviedSnapshot method of the store to consume the SnapshotChunks.\nOn the LeaderRole (in the AbstractAppender) the last snapshot can also\nbe replicated. This is done via the SnapshotChunkReader, which\nreads the chunks from the persisted store.\nThe Follower (in PassiveRole) will consume the replicated chunks and\nwill store it similar to the ReplicationController.\nOn both ReplicationController and PassiveRole the checksum of the\nsnapshot chunks but also of the complete snapshot is verified before\nthe received snapshot is persisted.\nRelated work:\n\nMost snapshot implementation details are now in Atomix\nZeebe related snapshoting like replication and taking of snapshot is\npart of Broker\nUse SBE for snapshot chunk replication/consumption\nStreamProcessorTests moved again to engine module - removed snapshot\nrelated tests, dont need to be part of that\nclean up management schema file in broker\nWrote a bunch of new unit tests for snapshot implementation\n\nClass Diagram\nGenerate Class diagram via Intellij:\n\nRelated issues\n\ncloses #4424\ncloses #4604\ncloses #4345\ncloses #4122\ncloses #4067\ncloses #3214\ncloses #2721\ncloses #4425\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-06-01T06:42:55Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4641", "merged": true, "mergeCommit": {"oid": "3ca5f98d3ce7746a2e03bdc414e43d79007a7e4d"}, "closed": true, "closedAt": "2020-06-08T15:24:09Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcm6gZWgH2gAyNDI1Nzg3NDgwOmQ4MzA1MDA3Y2FiZDY4MDVhNjliZDcwZjRiNjkzMGRiYTc3Yjk1OWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpRhphgBqjM0MjA0MTUyMDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d8305007cabd6805a69bd70f4b6930dba77b959f", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/d8305007cabd6805a69bd70f4b6930dba77b959f", "committedDate": "2020-06-01T06:45:05Z", "message": "chore(logstreams): remove takeSnapshot"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc0632e7d27d745b3ac24a3160e04ed273b6a7c8", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/fc0632e7d27d745b3ac24a3160e04ed273b6a7c8", "committedDate": "2020-06-01T06:12:53Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}, "afterCommit": {"oid": "93d121352ee07af5e0a104e410880bc9486cca6a", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/93d121352ee07af5e0a104e410880bc9486cca6a", "committedDate": "2020-06-01T06:52:37Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93d121352ee07af5e0a104e410880bc9486cca6a", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/93d121352ee07af5e0a104e410880bc9486cca6a", "committedDate": "2020-06-01T06:52:37Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}, "afterCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f89f99c64572bf1aa4b363b69c096660b3fbaffb", "committedDate": "2020-06-02T05:13:59Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNDc2MjY3", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-422476267", "createdAt": "2020-06-02T08:56:18Z", "commit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODo1NjoxOFrOGdoaUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1MjoxMFrOGd4Uow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA==", "bodyText": "This method is hard to understand without context.\n\nNot sure why sending append requests fulfills the task to replicate a snapshot.\nNot sure the method does what it claims to do; in the caller there is a condition \"If there's a snapshot at the member's nextIndex, replicate the snapshot.\" but it is not clear whether this conidtion is checked in the caller or in the method itself", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433723984", "createdAt": "2020-06-02T08:56:18Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderAppender.java", "diffHunk": "@@ -277,26 +276,47 @@ else if (member.getConfigTerm() < raft.getTerm()\n     else if (member.getMember().getType() == RaftMember.Type.ACTIVE\n         || member.getMember().getType() == RaftMember.Type.PROMOTABLE\n         || member.getMember().getType() == RaftMember.Type.PASSIVE) {\n-      final Snapshot snapshot = raft.getSnapshotStore().getCurrentSnapshot();\n-      if (snapshot != null\n-          && member.getSnapshotIndex() < snapshot.index()\n-          && snapshot.index() >= member.getLogReader().getCurrentIndex()) {\n-        if (!member.canInstall()) {\n-          return;\n-        }\n-\n-        log.debug(\"Replicating snapshot {} to {}\", snapshot.index(), member.getMember().memberId());\n-        sendInstallRequest(member, buildInstallRequest(member, snapshot));\n-      } else if (member.canAppend()) {\n-        sendAppendRequest(member, buildAppendRequest(member, -1));\n-      }\n+      replicateSnapshot(member);\n     }\n     // If no AppendRequest is already being sent, send an AppendRequest.\n     else if (member.canAppend()) {\n       sendAppendRequest(member, buildAppendRequest(member, -1));\n     }\n   }\n \n+  private void replicateSnapshot(final RaftMemberContext member) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNjkyMQ==", "bodyText": "Can we assume single threaded execution or do we need to synchronize access to this property?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433726921", "createdAt": "2020-06-02T09:01:11Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -35,27 +35,27 @@\n import io.atomix.raft.protocol.ReconfigureResponse;\n import io.atomix.raft.protocol.VoteRequest;\n import io.atomix.raft.protocol.VoteResponse;\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.impl.SnapshotChunkImpl;\n import io.atomix.raft.storage.log.RaftLogReader;\n import io.atomix.raft.storage.log.RaftLogWriter;\n import io.atomix.raft.storage.log.entry.RaftLogEntry;\n-import io.atomix.raft.storage.snapshot.PendingSnapshot;\n-import io.atomix.raft.storage.snapshot.Snapshot;\n-import io.atomix.raft.storage.snapshot.SnapshotListener;\n-import io.atomix.raft.storage.snapshot.SnapshotStore;\n import io.atomix.storage.StorageException;\n import io.atomix.storage.journal.Indexed;\n import io.atomix.utils.concurrent.ThreadContext;\n-import io.atomix.utils.time.WallClockTimestamp;\n import java.io.IOException;\n import java.util.concurrent.CompletableFuture;\n+import org.agrona.concurrent.UnsafeBuffer;\n import org.slf4j.Logger;\n \n /** Passive state. */\n public class PassiveRole extends InactiveRole {\n   private final SnapshotReplicationMetrics snapshotReplicationMetrics;\n \n   private long pendingSnapshotStartTimestamp;\n-  private PendingSnapshot pendingSnapshot;\n+  private ReceivedSnapshot pendingSnapshot;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzM4NQ==", "bodyText": "typo \"Represents a snapshot\"", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433727385", "createdAt": "2020-06-02T09:01:57Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNzcxNw==", "bodyText": "How is time synchronized between nodes?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433727717", "createdAt": "2020-06-02T09:02:32Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyODUzNA==", "bodyText": "\"Written\" is maybe a little ambiguous. Written to disk? Written to the state machine?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433728534", "createdAt": "2020-06-02T09:03:56Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was\n+   * taken.\n+   *\n+   * @return The snapshot timestamp.\n+   */\n+  WallClockTimestamp getTimestamp();\n+\n+  /**\n+   * Returns the snapshot format version.\n+   *\n+   * @return the snapshot format version\n+   */\n+  int version();\n+\n+  /**\n+   * Returns the snapshot index.\n+   *\n+   * <p>The snapshot index is the index of the state machine at the point at which the snapshot was\n+   * written.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyOTU1MQ==", "bodyText": "type \"a listener\"", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433729551", "createdAt": "2020-06-02T09:05:32Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotListener.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+/**\n+ * Represents an listener which can be added to the {@link PersistedSnapshotStore} to be notified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyOTg4NQ==", "bodyText": "typo \"a store\"", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433729885", "createdAt": "2020-06-02T09:06:03Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMTU2OA==", "bodyText": "Again typo \"a registered\" I guess I will stop pointing these out from now on", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433731568", "createdAt": "2020-06-02T09:08:52Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);\n+\n+  /**\n+   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n+   *\n+   * @param index the index to which the snapshot corresponds to\n+   * @param term the term to which the snapshots corresponds to\n+   * @param timestamp the time to which the snapshots corresponds to\n+   * @return the new transient snapshot\n+   */\n+  TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp);\n+\n+  /**\n+   * Starts a new received volatile snapshot which can be persisted later.\n+   *\n+   * @param snapshotId the snapshot id which is defined as {@code index-term-timestamp}\n+   * @return the new volatile received snapshot\n+   */\n+  ReceivedSnapshot newReceivedSnapshot(String snapshotId);\n+\n+  /** @return the latest {@link PersistedSnapshot} if exists */\n+  Optional<PersistedSnapshot> getLatestSnapshot();\n+\n+  /**\n+   * Purges all ongoing pending/transient/volatile snapshots.\n+   *\n+   * @throws IOException when there was an unexpected IO issue\n+   */\n+  void purgePendingSnapshots() throws IOException;\n+\n+  /**\n+   * Adds an {@link PersistedSnapshotListener} to the store, which is notified when a new {@link\n+   * PersistedSnapshot} is persisted at this store.\n+   *\n+   * @param listener the listener which should be added and notified later\n+   */\n+  void addSnapshotListener(PersistedSnapshotListener listener);\n+\n+  /**\n+   * Removes an registered {@link PersistedSnapshotListener} from the store. The listener will no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczMzM1Mw==", "bodyText": "I find the method name confusing. Currently it only checks whether the one snapshot which is kept has this ID. But the method sounds as if it would know whether any snapshot with that id exists globally.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433733353", "createdAt": "2020-06-02T09:11:55Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTIwNQ==", "bodyText": "Personally, I would prefer to separate the storing interface from the \"snapshot replication\" interface. This means, I would move\n\nnewTransientSnapshot(...)\nnewReceivedSnapshot(...)\npurgePendingSnapshots(...)\n\nInto one or two distinct interfaces. Two interfaces to separate the creating of new transient snapshots (which I see as the \"sending part\" and the receiving of snapshots (receiving part)\nNote that separating on an interface level does not prohibit to implement all interfaces in the same class,\nAlso don't udnerstand why newSnapshot(...) is not exposed in the interface. In fact, I would understand the design better, if the persist(..) method of \"PersistableSnapshot\" was in this interface and then you could document that it will only be persisted, if it is newer than the current snapshot and that the snapshot returned might be a a different snapshot altogether (i.e. the new snapshot will be returned if the snapshot to be persisted is older)", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433739205", "createdAt": "2020-06-02T09:21:45Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * Represents an store, which allows to persist snapshots on a storage, which is implementation\n+ * dependent. It is possible to take a transient snapshot, which means you can start taking an\n+ * snapshot and can persist it later or abort it. Furthermore it is possible to persist/receive\n+ * {@link SnapshotChunk}'s from an already {@link PersistedSnapshot} and persist them in this\n+ * current store.\n+ *\n+ * <p>Only one {@link PersistedSnapshot} at a time is stored in the {@link PersistedSnapshotStore}\n+ * and can be received via {@link PersistedSnapshotStore#getLatestSnapshot()}.\n+ */\n+public interface PersistedSnapshotStore extends CloseableSilently {\n+\n+  /**\n+   * Returns true if a snapshot with the given identifier exists already, false otherwise.\n+   *\n+   * @param id the snapshot ID to look for\n+   * @return true if there is a committed snapshot with this ID, false otherwise\n+   * @see SnapshotId\n+   */\n+  boolean exists(String id);\n+\n+  /**\n+   * Starts a new transient snapshot which can be persisted after the snapshot was taken.\n+   *\n+   * @param index the index to which the snapshot corresponds to\n+   * @param term the term to which the snapshots corresponds to\n+   * @param timestamp the time to which the snapshots corresponds to\n+   * @return the new transient snapshot\n+   */\n+  TransientSnapshot newTransientSnapshot(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNDc4MA==", "bodyText": "Isn't there a name pattern or something to disambiguate the files we want to count from potential files just lying around?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433924780", "createdAt": "2020-06-02T14:33:59Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotChunkReader.java", "diffHunk": "@@ -28,19 +40,39 @@\n  * ordered lexicographically, and the files are assumed to be immutable, i.e. no more are added to\n  * the directory once this is created.\n  */\n-public final class DbSnapshotChunkReader implements SnapshotChunkReader {\n-  public static final Charset ID_CHARSET = StandardCharsets.US_ASCII;\n+public final class FileBasedSnapshotChunkReader implements SnapshotChunkReader {\n+  static final Charset ID_CHARSET = StandardCharsets.US_ASCII;\n+\n   private final Path directory;\n   private final NavigableSet<CharSequence> chunks;\n   private final CharSequenceView chunkIdView;\n \n   private NavigableSet<CharSequence> chunksView;\n+  private final int totalCount;\n+  private final long snapshotChecksum;\n+  private final String snapshotID;\n \n-  public DbSnapshotChunkReader(final Path directory, final NavigableSet<CharSequence> chunks) {\n+  FileBasedSnapshotChunkReader(final Path directory) throws IOException {\n     this.directory = directory;\n-    this.chunks = chunks;\n+    this.chunks = collectChunks(directory);\n+    this.totalCount = chunks.size();\n     this.chunksView = this.chunks;\n     this.chunkIdView = new CharSequenceView();\n+\n+    try (final var fileStream = Files.list(directory).sorted()) {\n+      this.snapshotChecksum =\n+          ChecksumUtil.createCombinedChecksum(fileStream.collect(Collectors.toList()));\n+    }\n+\n+    this.snapshotID = directory.getFileName().toString();\n+  }\n+\n+  private NavigableSet<CharSequence> collectChunks(final Path directory) throws IOException {\n+    final var set = new TreeSet<>(CharSequence::compare);\n+    try (final var stream = Files.list(directory).sorted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyODE1Mg==", "bodyText": "Single threaded of need for synchronization?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433928152", "createdAt": "2020-06-02T14:38:46Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDA3MA==", "bodyText": "Why error?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930070", "createdAt": "2020-06-02T14:41:30Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDQ2Nw==", "bodyText": "Why error?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930467", "createdAt": "2020-06-02T14:42:04Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);\n+    snapshotMetrics.incrementSnapshotCount();\n+    observeSnapshotSize(currentPersistedSnapshot);\n+\n+    LOGGER.debug(\"Purging snapshots older than {}\", currentPersistedSnapshot);\n+    if (previousSnapshot != null) {\n+      LOGGER.error(\"Deleting snapshot {}\", previousSnapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDU5OA==", "bodyText": "Why error?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930598", "createdAt": "2020-06-02T14:42:15Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);\n+    snapshotMetrics.incrementSnapshotCount();\n+    observeSnapshotSize(currentPersistedSnapshot);\n+\n+    LOGGER.debug(\"Purging snapshots older than {}\", currentPersistedSnapshot);\n+    if (previousSnapshot != null) {\n+      LOGGER.error(\"Deleting snapshot {}\", previousSnapshot);\n+      previousSnapshot.delete();\n+    }\n+    purgePendingSnapshots(currentPersistedSnapshot.getIndex());\n+\n+    listeners.forEach(listener -> listener.onNewSnapshot(currentPersistedSnapshot));\n+\n+    LOGGER.debug(\"Created new snapshot {}\", currentPersistedSnapshot);\n+    return currentPersistedSnapshot;\n+  }\n+\n+  private void purgePendingSnapshot(final Path pendingSnapshot) {\n+    try {\n+      FileUtil.deleteFolder(pendingSnapshot);\n+      LOGGER.error(\"Delete not completed (orphaned) snapshot {}\", pendingSnapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMDk2MA==", "bodyText": "Why error?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433930960", "createdAt": "2020-06-02T14:42:42Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzMTA2MA==", "bodyText": "Why error?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433931060", "createdAt": "2020-06-02T14:42:51Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzNDAzOA==", "bodyText": "That is a strange use of predicate. Maybe better use Function<Path, Boolean>", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433934038", "createdAt": "2020-06-02T14:46:44Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzOTc1Ng==", "bodyText": "Optional: Not sure if you made changes here. Personally I am not a fan of using lambdas this way. It makes debugging more complicated. Instead I like the auto closeable style:\ntry (Timer timer = snapshotMetrics. createTimer()) { // SNAPSHOT_DURATION.labels(partitionId).startTimer()\n  // your code goes here\n}", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433939756", "createdAt": "2020-06-02T14:54:38Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {\n+    final var snapshotMetrics = snapshotStore.getSnapshotMetrics();\n+\n+    return snapshotMetrics.observeSnapshotOperation(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MTI4Ng==", "bodyText": "This could be simplified with return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE)", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433941286", "createdAt": "2020-06-02T14:56:28Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedTransientSnapshot.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Represents a pending snapshot, that is a snapshot in the process of being written and has not yet\n+ * been committed to the store.\n+ */\n+public final class FileBasedTransientSnapshot implements TransientSnapshot {\n+  private static final Logger LOGGER = new ZbLogger(FileBasedTransientSnapshot.class);\n+\n+  private final Path directory;\n+  private final FileBasedSnapshotStore snapshotStore;\n+  private final FileBasedSnapshotMetadata metadata;\n+\n+  FileBasedTransientSnapshot(\n+      final FileBasedSnapshotMetadata metadata,\n+      final Path directory,\n+      final FileBasedSnapshotStore snapshotStore) {\n+    this.metadata = metadata;\n+    this.snapshotStore = snapshotStore;\n+    this.directory = directory;\n+  }\n+\n+  @Override\n+  public boolean take(final Predicate<Path> takeSnapshot) {\n+    final var snapshotMetrics = snapshotStore.getSnapshotMetrics();\n+\n+    return snapshotMetrics.observeSnapshotOperation(\n+        () -> {\n+          boolean failed;\n+\n+          try {\n+            failed = !takeSnapshot.test(getPath());\n+          } catch (final Exception exception) {\n+            LOGGER.warn(\n+                \"Catched unexpected exception on taking snapshot ({})\", metadata, exception);\n+            failed = true;\n+          }\n+\n+          if (failed) {\n+            abort();\n+          }\n+\n+          return !failed;\n+        });\n+  }\n+\n+  @Override\n+  public PersistedSnapshot persist() {\n+    return snapshotStore.newSnapshot(metadata, directory);\n+  }\n+\n+  @Override\n+  public void abort() {\n+    try {\n+      LOGGER.error(\"DELETE dir {}\", directory);\n+      FileUtil.deleteFolder(directory);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to delete pending snapshot {}\", this, e);\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return directory;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"FileBasedTransientSnapshot{\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MjEzMw==", "bodyText": "is this still important?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433942133", "createdAt": "2020-06-02T14:57:39Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/main/resources/snapshot-schema.xml", "diffHunk": "@@ -0,0 +1,36 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n+<sbe:messageSchema xmlns:sbe=\"http://fixprotocol.io/2016/sbe\"\n+  xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n+  package=\"io.atomix.raft.snapshot.impl\" id=\"6\" version=\"2\"\n+  semanticVersion=\"0.1.0\" description=\"Zeebe Snapshot Management Protocol\" byteOrder=\"littleEndian\">\n+\n+  <xi:include href=\"../../../../../protocol/src/main/resources/common-types.xml\"/>\n+\n+  <types>\n+    <!-- binary data -->\n+    <composite name=\"blob\">\n+      <type name=\"length\" primitiveType=\"uint32\" maxValue=\"2147483647\"/>\n+      <type name=\"varData\" primitiveType=\"uint8\" length=\"0\"/>\n+    </composite>\n+\n+  </types>\n+\n+  <sbe:message name=\"SnapshotChunk\" id=\"4\">\n+    <field name=\"totalCount\" id=\"0\" type=\"int32\"/>\n+    <field name=\"checksum\" id=\"1\" type=\"uint64\"/>\n+    <field name=\"snapshotChecksum\" id=\"5\" type=\"uint64\" sinceVersion=\"2\"/>\n+    <data name=\"snapshotId\" id=\"2\" type=\"varDataEncoding\"/>\n+    <data name=\"chunkName\" id=\"3\" type=\"varDataEncoding\"/>\n+    <data name=\"content\" id=\"4\" type=\"blob\"/>\n+  </sbe:message>\n+\n+<!--  <sbe:message name=\"SnapshotRestoreRequest\" id=\"9\">-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0NDc2NQ==", "bodyText": "That doesn't feel right. Don't we have a logger somewhere?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433944765", "createdAt": "2020-06-02T15:01:05Z", "author": {"login": "pihme"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -280,43 +282,50 @@ public void doSnapshot(final long index) throws Exception {\n   public boolean allNodesHaveSnapshotWithIndex(final long index) {\n     return servers.values().stream()\n             .map(RaftServer::getContext)\n-            .map(RaftContext::getSnapshotStore)\n-            .map(SnapshotStore::getCurrentSnapshotIndex)\n+            .map(RaftContext::getPersistedSnapshotStore)\n+            .map(PersistedSnapshotStore::getCurrentSnapshotIndex)\n             .filter(idx -> idx == index)\n             .count()\n         == servers.values().size();\n   }\n \n-  public Snapshot getSnapshotFromLeader() {\n+  public PersistedSnapshot getSnapshotFromLeader() {\n     final var leader = getLeader().orElseThrow();\n     final var context = leader.getContext();\n-    final var snapshotStore = context.getSnapshotStore();\n-    return snapshotStore.getCurrentSnapshot();\n+    final var snapshotStore = context.getPersistedSnapshotStore();\n+    return snapshotStore.getLatestSnapshot().orElseThrow();\n   }\n \n-  public Snapshot getSnapshotOnNode(final String nodeId) {\n+  public PersistedSnapshot getSnapshotOnNode(final String nodeId) {\n     final var raftServer = servers.get(nodeId);\n     final var context = raftServer.getContext();\n-    final var snapshotStore = context.getSnapshotStore();\n-    return snapshotStore.getCurrentSnapshot();\n-  }\n-\n-  private void writeSnapshot(final long index, final long term, final SnapshotStore snapshotStore)\n-      throws IOException {\n-    final var dirName = index + \"-snapshot\";\n-    final var snapshotDir = new File(snapshotStore.getPath().toFile(), dirName);\n-    if (!snapshotDir.mkdirs()) {\n-      throw new IllegalStateException(\"Was not able to create directory: \" + snapshotDir.getName());\n-    }\n-\n-    final var snapshotFile = new File(snapshotDir, \"snapshot.file\");\n-    Files.write(\n-        snapshotFile.toPath(),\n-        RandomStringUtils.random(128).getBytes(),\n-        StandardOpenOption.CREATE_NEW,\n-        StandardOpenOption.WRITE);\n-\n-    snapshotStore.newSnapshot(index, term, new WallClockTimestamp(), snapshotDir.toPath());\n+    final var snapshotStore = context.getPersistedSnapshotStore();\n+    return snapshotStore.getLatestSnapshot().orElseThrow();\n+  }\n+\n+  private void writeSnapshot(\n+      final long index, final long term, final PersistedSnapshotStore persistedSnapshotStore) {\n+\n+    final var transientSnapshot =\n+        persistedSnapshotStore.newTransientSnapshot(index, term, new WallClockTimestamp());\n+    transientSnapshot.take(\n+        path -> {\n+          IoUtil.ensureDirectoryExists(path.toFile(), \"snapshot dir should exist\");\n+          final var snapshotFile = path.resolve(\"snapshot.file\");\n+          try {\n+            Files.write(\n+                snapshotFile,\n+                RandomStringUtils.random(128).getBytes(),\n+                StandardOpenOption.CREATE_NEW,\n+                StandardOpenOption.WRITE);\n+          } catch (final IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NTk4MA==", "bodyText": "Single threaded or need for synchronization?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433965980", "createdAt": "2020-06-02T15:30:19Z", "author": {"login": "pihme"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MTE2Mw==", "bodyText": "It looks like there might be a memory leak here.\n\nentries which are marked as INVALID_SNAPSHOT will never be evicted from the map\nentries which never receive the last chunk will never be evicted from the map.\n\nI think it would make sense to evict entries more aggressively, either by looking at the start time of the replication context or by looking at the index of the snapshot and removing all entries of snapshots which are older than the last successfully replicated snapshot.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433971163", "createdAt": "2020-06-02T15:37:46Z", "author": {"login": "pihme"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk2NTk4MA=="}, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3NjcyNA==", "bodyText": "Optional: There is an implicit assumption here, that all chunks return the same total count. This might not be the case if an attacker / non compliant broker modifies a snapshot chunk. You could capture the total count of the first chunk and then compare it on each subsequent chunk as an additional sanity check.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433976724", "createdAt": "2020-06-02T15:44:16Z", "author": {"login": "pihme"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);\n+\n+    final var optTransientSnapshot =\n+        optionalIndexed\n+            .filter(indexed -> indexed.index() != previousSnapshotIndex)\n+            .map(\n+                indexed ->\n+                    store.newTransientSnapshot(\n+                        indexed.index(),\n+                        indexed.entry().term(),\n+                        WallClockTimestamp.from(System.currentTimeMillis())));\n+\n+    optTransientSnapshot.ifPresent(this::createSnapshot);\n+    return optTransientSnapshot;\n+  }\n+\n+  @Override\n+  public void consumeReplicatedSnapshots() {\n+    replication.consume(this::consumeSnapshotChunk);\n+  }\n+\n+  @Override\n+  public void recover() throws Exception {\n+\n+    if (Files.exists(runtimeDirectory)) {\n+      FileUtil.deleteFolder(runtimeDirectory);\n+    }\n+\n+    final var optLatestSnapshot = store.getLatestSnapshot();\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      LOG.debug(\"Available snapshot: {}\", snapshot);\n+\n+      FileUtil.copySnapshot(runtimeDirectory, snapshot.getPath());\n+\n+      try {\n+        // open database to verify that the snapshot is recoverable\n+        openDb();\n+        LOG.debug(\"Recovered state from snapshot '{}'\", snapshot);\n+      } catch (final Exception exception) {\n+        LOG.error(\n+            \"Failed to open snapshot '{}'. No snapshots available to recover from. Manual action is required.\",\n+            snapshot,\n+            exception);\n+\n+        FileUtil.deleteFolder(runtimeDirectory);\n+        throw new IllegalStateException(\"Failed to recover from snapshots\", exception);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public ZeebeDb openDb() {\n+    if (db == null) {\n+      db = zeebeDbFactory.createDb(runtimeDirectory.toFile());\n+      LOG.debug(\"Opened database from '{}'.\", runtimeDirectory);\n+    }\n+\n+    return db;\n+  }\n+\n+  @Override\n+  public int getValidSnapshotsCount() {\n+    return store.getLatestSnapshot().isPresent() ? 1 : 0;\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    if (db != null) {\n+      db.close();\n+      LOG.debug(\"Closed database from '{}'.\", runtimeDirectory);\n+      db = null;\n+    }\n+  }\n+\n+  boolean isDbOpened() {\n+    return db != null;\n+  }\n+\n+  private void createSnapshot(final TransientSnapshot snapshot) {\n+    snapshot.take(\n+        snapshotDir -> {\n+          if (db == null) {\n+            LOG.error(\"Expected to take a snapshot, but no database was opened\");\n+            return false;\n+          }\n+\n+          LOG.debug(\"Taking temporary snapshot into {}.\", snapshotDir);\n+          try {\n+            db.createSnapshot(snapshotDir.toFile());\n+          } catch (final Exception e) {\n+            LOG.error(\"Failed to create snapshot of runtime database\", e);\n+            return false;\n+          }\n+\n+          return true;\n+        });\n+  }\n+\n+  @Override\n+  public void onNewSnapshot(final PersistedSnapshot newPersistedSnapshot) {\n+    // replicate snapshots when new snapshot was committed\n+    try (final var snapshotChunkReader = newPersistedSnapshot.newChunkReader()) {\n+      while (snapshotChunkReader.hasNext()) {\n+        final var snapshotChunk = snapshotChunkReader.next();\n+        replication.replicate(snapshotChunk);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This is called by the snapshot replication implementation on each snapshot chunk\n+   *\n+   * @param snapshotChunk the chunk to consume\n+   */\n+  private void consumeSnapshotChunk(final SnapshotChunk snapshotChunk) {\n+    final String snapshotId = snapshotChunk.getSnapshotId();\n+    final String chunkName = snapshotChunk.getChunkName();\n+\n+    final ReplicationContext context =\n+        receivedSnapshots.computeIfAbsent(\n+            snapshotId,\n+            id -> {\n+              final var startTimestamp = System.currentTimeMillis();\n+              final ReceivedSnapshot transientSnapshot =\n+                  store.newReceivedSnapshot(snapshotChunk.getSnapshotId());\n+              return newReplication(startTimestamp, transientSnapshot);\n+            });\n+    if (context == INVALID_SNAPSHOT) {\n+      LOG.trace(\n+          \"Ignore snapshot chunk {}, because snapshot {} is marked as invalid.\",\n+          chunkName,\n+          snapshotId);\n+      return;\n+    }\n+\n+    final var receivedSnapshot = context.getReceivedSnapshot();\n+    try {\n+      if (receivedSnapshot.apply(snapshotChunk)) {\n+        validateWhenReceivedAllChunks(snapshotChunk, context);\n+      } else {\n+        markSnapshotAsInvalid(context, snapshotChunk);\n+      }\n+    } catch (final IOException e) {\n+      LOG.error(\"Unexepected error on writing the received snapshot chunk {}\", snapshotChunk, e);\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+    }\n+  }\n+\n+  private void markSnapshotAsInvalid(\n+      final ReplicationContext replicationContext, final SnapshotChunk chunk) {\n+    replicationContext.getReceivedSnapshot().abort();\n+    receivedSnapshots.put(chunk.getSnapshotId(), INVALID_SNAPSHOT);\n+    metrics.decrementCount();\n+  }\n+\n+  private void validateWhenReceivedAllChunks(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    final int totalChunkCount = snapshotChunk.getTotalCount();\n+\n+    if (context.incrementCount() == totalChunkCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NDY3NQ==", "bodyText": "In case of an exception, the decrement already happened as part of markSnapshotAsInvalid(...) In general I am not sure whether the increments and decrements in this class will always balance out perfectly. Maybe they do now, but it is fragile.\nI think it would be better to add a destroy()/deactivate() method to the ReplicationContext which counts the metric down when it is first called, and does nothing when it is called multiple times.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r433984675", "createdAt": "2020-06-02T15:52:10Z", "author": {"login": "pihme"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);\n+\n+    final var optTransientSnapshot =\n+        optionalIndexed\n+            .filter(indexed -> indexed.index() != previousSnapshotIndex)\n+            .map(\n+                indexed ->\n+                    store.newTransientSnapshot(\n+                        indexed.index(),\n+                        indexed.entry().term(),\n+                        WallClockTimestamp.from(System.currentTimeMillis())));\n+\n+    optTransientSnapshot.ifPresent(this::createSnapshot);\n+    return optTransientSnapshot;\n+  }\n+\n+  @Override\n+  public void consumeReplicatedSnapshots() {\n+    replication.consume(this::consumeSnapshotChunk);\n+  }\n+\n+  @Override\n+  public void recover() throws Exception {\n+\n+    if (Files.exists(runtimeDirectory)) {\n+      FileUtil.deleteFolder(runtimeDirectory);\n+    }\n+\n+    final var optLatestSnapshot = store.getLatestSnapshot();\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      LOG.debug(\"Available snapshot: {}\", snapshot);\n+\n+      FileUtil.copySnapshot(runtimeDirectory, snapshot.getPath());\n+\n+      try {\n+        // open database to verify that the snapshot is recoverable\n+        openDb();\n+        LOG.debug(\"Recovered state from snapshot '{}'\", snapshot);\n+      } catch (final Exception exception) {\n+        LOG.error(\n+            \"Failed to open snapshot '{}'. No snapshots available to recover from. Manual action is required.\",\n+            snapshot,\n+            exception);\n+\n+        FileUtil.deleteFolder(runtimeDirectory);\n+        throw new IllegalStateException(\"Failed to recover from snapshots\", exception);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public ZeebeDb openDb() {\n+    if (db == null) {\n+      db = zeebeDbFactory.createDb(runtimeDirectory.toFile());\n+      LOG.debug(\"Opened database from '{}'.\", runtimeDirectory);\n+    }\n+\n+    return db;\n+  }\n+\n+  @Override\n+  public int getValidSnapshotsCount() {\n+    return store.getLatestSnapshot().isPresent() ? 1 : 0;\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    if (db != null) {\n+      db.close();\n+      LOG.debug(\"Closed database from '{}'.\", runtimeDirectory);\n+      db = null;\n+    }\n+  }\n+\n+  boolean isDbOpened() {\n+    return db != null;\n+  }\n+\n+  private void createSnapshot(final TransientSnapshot snapshot) {\n+    snapshot.take(\n+        snapshotDir -> {\n+          if (db == null) {\n+            LOG.error(\"Expected to take a snapshot, but no database was opened\");\n+            return false;\n+          }\n+\n+          LOG.debug(\"Taking temporary snapshot into {}.\", snapshotDir);\n+          try {\n+            db.createSnapshot(snapshotDir.toFile());\n+          } catch (final Exception e) {\n+            LOG.error(\"Failed to create snapshot of runtime database\", e);\n+            return false;\n+          }\n+\n+          return true;\n+        });\n+  }\n+\n+  @Override\n+  public void onNewSnapshot(final PersistedSnapshot newPersistedSnapshot) {\n+    // replicate snapshots when new snapshot was committed\n+    try (final var snapshotChunkReader = newPersistedSnapshot.newChunkReader()) {\n+      while (snapshotChunkReader.hasNext()) {\n+        final var snapshotChunk = snapshotChunkReader.next();\n+        replication.replicate(snapshotChunk);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This is called by the snapshot replication implementation on each snapshot chunk\n+   *\n+   * @param snapshotChunk the chunk to consume\n+   */\n+  private void consumeSnapshotChunk(final SnapshotChunk snapshotChunk) {\n+    final String snapshotId = snapshotChunk.getSnapshotId();\n+    final String chunkName = snapshotChunk.getChunkName();\n+\n+    final ReplicationContext context =\n+        receivedSnapshots.computeIfAbsent(\n+            snapshotId,\n+            id -> {\n+              final var startTimestamp = System.currentTimeMillis();\n+              final ReceivedSnapshot transientSnapshot =\n+                  store.newReceivedSnapshot(snapshotChunk.getSnapshotId());\n+              return newReplication(startTimestamp, transientSnapshot);\n+            });\n+    if (context == INVALID_SNAPSHOT) {\n+      LOG.trace(\n+          \"Ignore snapshot chunk {}, because snapshot {} is marked as invalid.\",\n+          chunkName,\n+          snapshotId);\n+      return;\n+    }\n+\n+    final var receivedSnapshot = context.getReceivedSnapshot();\n+    try {\n+      if (receivedSnapshot.apply(snapshotChunk)) {\n+        validateWhenReceivedAllChunks(snapshotChunk, context);\n+      } else {\n+        markSnapshotAsInvalid(context, snapshotChunk);\n+      }\n+    } catch (final IOException e) {\n+      LOG.error(\"Unexepected error on writing the received snapshot chunk {}\", snapshotChunk, e);\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+    }\n+  }\n+\n+  private void markSnapshotAsInvalid(\n+      final ReplicationContext replicationContext, final SnapshotChunk chunk) {\n+    replicationContext.getReceivedSnapshot().abort();\n+    receivedSnapshots.put(chunk.getSnapshotId(), INVALID_SNAPSHOT);\n+    metrics.decrementCount();\n+  }\n+\n+  private void validateWhenReceivedAllChunks(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    final int totalChunkCount = snapshotChunk.getTotalCount();\n+\n+    if (context.incrementCount() == totalChunkCount) {\n+      LOG.debug(\n+          \"Received all snapshot chunks ({}/{}), snapshot is valid\",\n+          context.getChunkCount(),\n+          totalChunkCount);\n+      if (!tryToMarkSnapshotAsValid(snapshotChunk, context)) {\n+        LOG.debug(\"Failed to mark snapshot {} as valid\", snapshotChunk.getSnapshotId());\n+      }\n+    } else {\n+      LOG.debug(\n+          \"Waiting for more snapshot chunks, currently have {}/{}\",\n+          context.getChunkCount(),\n+          totalChunkCount);\n+    }\n+  }\n+\n+  private boolean tryToMarkSnapshotAsValid(\n+      final SnapshotChunk snapshotChunk, final ReplicationContext context) {\n+    try {\n+      context.getReceivedSnapshot().persist();\n+    } catch (final Exception exception) {\n+      markSnapshotAsInvalid(context, snapshotChunk);\n+      LOG.warn(\"Unexpected error on persisting received snapshot.\", exception);\n+      return false;\n+    } finally {\n+      final var elapsed = System.currentTimeMillis() - context.getStartTimestamp();\n+      receivedSnapshots.remove(snapshotChunk.getSnapshotId());\n+      metrics.decrementCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTEyMjQz", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-424112243", "createdAt": "2020-06-04T05:28:53Z", "commit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNToyODo1NFrOGe2Uxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjo0NToxNlrOGe35zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMDUxOA==", "bodyText": "Nit: Why PersistedSnapshot? Why not just Snapshot?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435000518", "createdAt": "2020-06-04T05:28:54Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -162,7 +162,7 @@ public RaftContext(\n     this.logReader = raftLog.openReader(1, RaftLogReader.Mode.ALL);\n \n     // Open the snapshot store.\n-    this.snapshotStore = storage.getSnapshotStore();\n+    this.persistedSnapshotStore = storage.getPersistedSnapshotStore();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwMjA4NQ==", "bodyText": "I agree with Peter here.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435002085", "createdAt": "2020-06-04T05:34:27Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderAppender.java", "diffHunk": "@@ -277,26 +276,47 @@ else if (member.getConfigTerm() < raft.getTerm()\n     else if (member.getMember().getType() == RaftMember.Type.ACTIVE\n         || member.getMember().getType() == RaftMember.Type.PROMOTABLE\n         || member.getMember().getType() == RaftMember.Type.PASSIVE) {\n-      final Snapshot snapshot = raft.getSnapshotStore().getCurrentSnapshot();\n-      if (snapshot != null\n-          && member.getSnapshotIndex() < snapshot.index()\n-          && snapshot.index() >= member.getLogReader().getCurrentIndex()) {\n-        if (!member.canInstall()) {\n-          return;\n-        }\n-\n-        log.debug(\"Replicating snapshot {} to {}\", snapshot.index(), member.getMember().memberId());\n-        sendInstallRequest(member, buildInstallRequest(member, snapshot));\n-      } else if (member.canAppend()) {\n-        sendAppendRequest(member, buildAppendRequest(member, -1));\n-      }\n+      replicateSnapshot(member);\n     }\n     // If no AppendRequest is already being sent, send an AppendRequest.\n     else if (member.canAppend()) {\n       sendAppendRequest(member, buildAppendRequest(member, -1));\n     }\n   }\n \n+  private void replicateSnapshot(final RaftMemberContext member) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyMzk4NA=="}, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNDQyMQ==", "bodyText": "Why do you compare with compactionBound instead of  index?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435004421", "createdAt": "2020-06-04T05:42:26Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/impl/StateControllerImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.SnapshotChunk;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.broker.system.partitions.AtomixRecordEntrySupplier;\n+import io.zeebe.broker.system.partitions.SnapshotReplication;\n+import io.zeebe.broker.system.partitions.StateController;\n+import io.zeebe.db.ZeebeDb;\n+import io.zeebe.db.ZeebeDbFactory;\n+import io.zeebe.logstreams.impl.Loggers;\n+import io.zeebe.util.FileUtil;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.ToLongFunction;\n+import org.agrona.collections.Object2NullableObjectHashMap;\n+import org.slf4j.Logger;\n+\n+/** Controls how snapshot/recovery operations are performed */\n+public class StateControllerImpl implements StateController, PersistedSnapshotListener {\n+\n+  private static final ReplicationContext INVALID_SNAPSHOT = new ReplicationContext(-1, null);\n+  private static final Logger LOG = Loggers.SNAPSHOT_LOGGER;\n+\n+  private final SnapshotReplication replication;\n+  private final Map<String, ReplicationContext> receivedSnapshots =\n+      new Object2NullableObjectHashMap<>();\n+\n+  private final PersistedSnapshotStore store;\n+\n+  private final Path runtimeDirectory;\n+  private final ZeebeDbFactory zeebeDbFactory;\n+  private final ToLongFunction<ZeebeDb> exporterPositionSupplier;\n+  private final AtomixRecordEntrySupplier entrySupplier;\n+\n+  private final SnapshotReplicationMetrics metrics;\n+\n+  private ZeebeDb db;\n+\n+  public StateControllerImpl(\n+      final int partitionId,\n+      final ZeebeDbFactory zeebeDbFactory,\n+      final PersistedSnapshotStore store,\n+      final Path runtimeDirectory,\n+      final SnapshotReplication replication,\n+      final AtomixRecordEntrySupplier entrySupplier,\n+      final ToLongFunction<ZeebeDb> exporterPositionSupplier) {\n+    this.store = store;\n+    this.runtimeDirectory = runtimeDirectory;\n+    this.zeebeDbFactory = zeebeDbFactory;\n+    this.exporterPositionSupplier = exporterPositionSupplier;\n+    this.entrySupplier = entrySupplier;\n+    this.replication = replication;\n+    this.metrics = new SnapshotReplicationMetrics(Integer.toString(partitionId));\n+    store.addSnapshotListener(this);\n+  }\n+\n+  @Override\n+  public Optional<TransientSnapshot> takeTransientSnapshot(final long lowerBoundSnapshotPosition) {\n+    if (!isDbOpened()) {\n+      return Optional.empty();\n+    }\n+\n+    final long exportedPosition = exporterPositionSupplier.applyAsLong(openDb());\n+    final long snapshotPosition = Math.min(exportedPosition, lowerBoundSnapshotPosition);\n+\n+    final var optionalIndexed = entrySupplier.getIndexedEntry(snapshotPosition);\n+\n+    final Long previousSnapshotIndex =\n+        store.getLatestSnapshot().map(PersistedSnapshot::getCompactionBound).orElse(-1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwNTkyMQ==", "bodyText": "Are we comparing snapshots anywhere?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435005921", "createdAt": "2020-06-04T05:47:30Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/PersistedSnapshot.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.CloseableSilently;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+\n+/** Represents an snapshot, which was persisted at the {@link PersistedSnapshotStore}. */\n+public interface PersistedSnapshot extends CloseableSilently, Comparable<PersistedSnapshot> {\n+\n+  /**\n+   * Returns the snapshot timestamp.\n+   *\n+   * <p>The timestamp is the wall clock time at the {@link #getIndex()} at which the snapshot was\n+   * taken.\n+   *\n+   * @return The snapshot timestamp.\n+   */\n+  WallClockTimestamp getTimestamp();\n+\n+  /**\n+   * Returns the snapshot format version.\n+   *\n+   * @return the snapshot format version\n+   */\n+  int version();\n+\n+  /**\n+   * Returns the snapshot index.\n+   *\n+   * <p>The snapshot index is the index of the state machine at the point at which the snapshot was\n+   * written.\n+   *\n+   * @return The snapshot index.\n+   */\n+  long getIndex();\n+\n+  /**\n+   * Returns the snapshot term.\n+   *\n+   * <p>The snapshot term is the term of the state machine at the point at which the snapshot was\n+   * written.\n+   *\n+   * @return The snapshot term.\n+   */\n+  long getTerm();\n+\n+  /**\n+   * Returns a new snapshot chunk reader for this snapshot. Chunk readers are meant to be one-time\n+   * use and as such don't have to be thread-safe.\n+   *\n+   * @return a new snapshot chunk reader\n+   */\n+  SnapshotChunkReader newChunkReader();\n+\n+  /** Deletes the snapshot. */\n+  void delete();\n+\n+  /** @return a path to the snapshot location */\n+  Path getPath();\n+\n+  @Override\n+  default int compareTo(final PersistedSnapshot other) {\n+    return Comparator.comparingLong(PersistedSnapshot::getIndex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODkyMg==", "bodyText": "There is a chance that raft snapshot receiver and broker snapshot receiver are both trying to write the same snapshot to the same pending directory.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435008922", "createdAt": "2020-06-04T05:57:17Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.PersistedSnapshotStoreFactory;\n+import java.nio.file.Path;\n+import org.agrona.IoUtil;\n+\n+/**\n+ * Loads existing snapshots in memory, cleaning out old and/or invalid snapshots if present.\n+ *\n+ * <p>The current load strategy is to lookup all files directly under the {@code\n+ * SNAPSHOTS_DIRECTORY}, try to extract {@link FileBasedSnapshotMetadata} from them, and if not\n+ * possible skip them (and print out a warning).\n+ *\n+ * <p>The metadata extraction is done by parsing the directory name using '%d-%d-%d-%d', where in\n+ * order we expect: index, term, timestamp, and position.\n+ */\n+public final class FileBasedSnapshotStoreFactory implements PersistedSnapshotStoreFactory {\n+  public static final String SNAPSHOTS_DIRECTORY = \"snapshots\";\n+  public static final String PENDING_DIRECTORY = \"pending\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTQxOQ==", "bodyText": "Not sure if timestamp should be part of SnapshotId. In my opinion index is the snapshot id. term and timestamp are part of snapshot's metadata.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435019419", "createdAt": "2020-06-04T06:28:08Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/SnapshotId.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import java.util.Comparator;\n+\n+/** Represents an identifier of an {@link PersistedSnapshot}. */\n+public interface SnapshotId extends Comparable<SnapshotId> {\n+\n+  /** @return the index of the snapshot */\n+  long getIndex();\n+\n+  /** @return the term when the snapshot was taken */\n+  long getTerm();\n+\n+  /** @return the timestamp when the snapshot was taken */\n+  WallClockTimestamp getTimestamp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyNjM4MQ==", "bodyText": "Would this be a problem when both broker replication and raft replication runs concurrently?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435026381", "createdAt": "2020-06-04T06:45:16Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private PersistedSnapshot currentPersistedSnapshot;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshot = loadLatestSnapshot(snapshotsDirectory);\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean exists(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    final var pendingSnapshotDir = pendingDirectory.resolve(metadata.getSnapshotIdAsString());\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshot);\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshot = null;\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.error(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        LOGGER.error(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    return (currentPersistedSnapshot != null\n+        && currentPersistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {\n+\n+    if (isCurrentSnapshotNewer(metadata)) {\n+      LOGGER.debug(\"Snapshot is older then {} already exists\", currentPersistedSnapshot);\n+      purgePendingSnapshots(metadata.getIndex() + 1);\n+      return currentPersistedSnapshot;\n+    }\n+\n+    final var destination = buildSnapshotDirectory(metadata);\n+    try {\n+      tryAtomicDirectoryMove(directory, destination);\n+    } catch (final FileAlreadyExistsException e) {\n+      LOGGER.debug(\n+          \"Expected to move snapshot from {} to {}, but it already exists\",\n+          directory,\n+          destination,\n+          e);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    final var previousSnapshot = currentPersistedSnapshot;\n+\n+    currentPersistedSnapshot = new FileBasedSnapshot(destination, metadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDEzMTM4", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-425013138", "createdAt": "2020-06-05T05:53:05Z", "commit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTo1MzowNVrOGfhQGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjoxNDoxNVrOGfhn7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwMzgzMg==", "bodyText": "Unused field.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435703832", "createdAt": "2020-06-05T05:53:05Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java", "diffHunk": "@@ -52,22 +59,36 @@\n   public final RuleChain chain =\n       RuleChain.outerRule(autoCloseableRule).around(tempFolderRule).around(actorSchedulerRule);\n \n-  private StateSnapshotController snapshotController;\n+  private StateControllerImpl snapshotController;\n   private LogStream logStream;\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n+  private PersistedSnapshotStore persistedSnapshotStore;\n+  private final AtomicReference<Indexed> indexedAtomicReference = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNTEzMw==", "bodyText": "Was this class supposed to be deleted?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435705133", "createdAt": "2020-06-05T05:57:37Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AtomixSnapshotStorageTest.java", "diffHunk": "@@ -5,265 +5,273 @@\n  * Licensed under the Zeebe Community License 1.0. You may not use this file\n  * except in compliance with the Zeebe Community License 1.0.\n  */\n+/// *\n+// * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+// * one or more contributor license agreements. See the NOTICE file distributed\n+// * with this work for additional information regarding copyright ownership.\n+// * Licensed under the Zeebe Community License 1.0. You may not use this file\n+// * except in compliance with the Zeebe Community License 1.0.\n+// */\n package io.zeebe.broker.system.partitions;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-\n-import io.atomix.raft.impl.zeebe.snapshot.AtomixRecordEntrySupplier;\n-import io.atomix.raft.impl.zeebe.snapshot.AtomixSnapshotStorage;\n-import io.atomix.raft.impl.zeebe.snapshot.DbSnapshotStore;\n-import io.atomix.raft.impl.zeebe.snapshot.Snapshot;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotDeletionListener;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotMetrics;\n-import io.atomix.raft.impl.zeebe.snapshot.SnapshotStorage;\n-import io.atomix.raft.storage.snapshot.SnapshotStore;\n-import io.atomix.storage.journal.JournalReader.Mode;\n-import io.zeebe.logstreams.storage.atomix.AtomixRecordEntrySupplierImpl;\n-import io.zeebe.logstreams.util.AtomixLogStorageRule;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentSkipListMap;\n-import org.agrona.IoUtil;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TemporaryFolder;\n-\n-public final class AtomixSnapshotStorageTest {\n-\n-  private final TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private final AtomixLogStorageRule logStorageRule = new AtomixLogStorageRule(temporaryFolder);\n-  @Rule public final RuleChain chain = RuleChain.outerRule(temporaryFolder).around(logStorageRule);\n-\n-  private Path pendingDirectory;\n-  private SnapshotStore store;\n-  private AtomixSnapshotStorage snapshotStorage;\n-  private AtomixRecordEntrySupplier entrySupplier;\n-\n-  @Before\n-  public void setUp() throws Exception {\n-    final var snapshotsDirectory = temporaryFolder.newFolder(\"snapshots\").toPath();\n-    final var raftPendingDirectory = temporaryFolder.getRoot().toPath().resolve(\"pending\");\n-    pendingDirectory = temporaryFolder.newFolder(\"pushed-pending\").toPath();\n-    entrySupplier =\n-        new AtomixRecordEntrySupplierImpl(\n-            logStorageRule.getIndexMapping(),\n-            logStorageRule.getRaftLog().openReader(-1, Mode.COMMITS));\n-    store =\n-        new DbSnapshotStore(\n-            snapshotsDirectory, raftPendingDirectory, new ConcurrentSkipListMap<>());\n-  }\n-\n-  @After\n-  public void tearDown() {\n-    Optional.ofNullable(snapshotStorage).ifPresent(SnapshotStorage::close);\n-    Optional.ofNullable(store).ifPresent(SnapshotStore::close);\n-  }\n-\n-  @Test\n-  public void shouldNotGetPendingSnapshotForNegativePosition() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(1, 1, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var snapshot = storage.getPendingSnapshotFor(-1);\n-    // then\n-    assertThat(snapshot).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldGetPendingSnapshotForPositions() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(1, 1, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(2, 2, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var first = storage.getPendingSnapshotFor(2).orElseThrow();\n-    final var second = storage.getPendingSnapshotFor(3).orElseThrow();\n-\n-    // then\n-    assertThat(first.getPath()).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(second.getPath()).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(first.getPath()).isNotEqualTo(second.getPath());\n-  }\n-\n-  @Test\n-  public void shouldReturnNullIfNoEntryForPosition() {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-\n-    // when\n-    final var snapshot = storage.getPendingSnapshotFor(1);\n-\n-    // then\n-    assertThat(snapshot).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldGetPendingDirectoryForId() {\n-    // given\n-    final var id = \"1-1-1\";\n-    final var storage = newStorage();\n-\n-    // when\n-    final var directory = storage.getPendingDirectoryFor(id).orElseThrow();\n-\n-    // then\n-    assertThat(directory).doesNotExist().hasParentRaw(pendingDirectory);\n-    assertThat(directory.getFileName()).hasToString(id);\n-  }\n-\n-  @Test\n-  public void shouldDeleteOrphanedPendingSnapshotsOnNewSnapshot() {\n-    // given\n-    final var storage = newStorage();\n-    final var toDelete = pendingDirectory.resolve(\"1-1-1\");\n-    final var snapshotDirectory = pendingDirectory.resolve(\"2-2-2\");\n-    final var toKeep = pendingDirectory.resolve(\"3-3-3\");\n-    IoUtil.ensureDirectoryExists(toDelete.toFile(), \"to delete directory\");\n-    IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"snapshot directory\");\n-    IoUtil.ensureDirectoryExists(toKeep.toFile(), \"to keep directory\");\n-\n-    // when\n-    storage.commitSnapshot(snapshotDirectory);\n-\n-    // then\n-    assertThat(toDelete).doesNotExist();\n-    assertThat(toKeep).exists();\n-  }\n-\n-  @Test\n-  public void shouldDeleteOrphanedPendingSnapshotsEvenIfOneIsNotASnapshot() {\n-    // given\n-    final var storage = newStorage();\n-    // given\n-    final var orphanedSnapshots =\n-        List.of(pendingDirectory.resolve(\"1-1-1\"), pendingDirectory.resolve(\"2-2-2\"));\n-    final var snapshotDirectory = pendingDirectory.resolve(\"3-3-3\");\n-    final var evilFolder = pendingDirectory.resolve(\"not a snapshot\");\n-    orphanedSnapshots.forEach(p -> IoUtil.ensureDirectoryExists(p.toFile(), \"\"));\n-    IoUtil.ensureDirectoryExists(evilFolder.toFile(), \"not a snapshot folder\");\n-    IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"to keep directory\");\n-\n-    // when\n-    storage.commitSnapshot(snapshotDirectory);\n-\n-    // then\n-    orphanedSnapshots.forEach(s -> assertThat(s).doesNotExist());\n-    assertThat(evilFolder).exists();\n-  }\n-\n-  @Test\n-  public void shouldReturnEmptyIfIdIsNotMetadata() {\n-    // given\n-    final var id = \"foo\";\n-    final var storage = newStorage();\n-\n-    // when\n-    final var directory = storage.getPendingDirectoryFor(id);\n-\n-    // then\n-    assertThat(directory).isEmpty();\n-  }\n-\n-  @Test\n-  public void shouldCommitPendingSnapshot() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-\n-    // when\n-    final var snapshot = newPendingSnapshot(2);\n-    Files.createDirectories(snapshot.getPath());\n-    storage.commitSnapshot(snapshot.getPath());\n-\n-    // then\n-    assertThat(store.getSnapshots()).hasSize(1);\n-    assertThat(store.getCurrentSnapshotIndex()).isEqualTo(1);\n-    assertThat(store.getSnapshot(1))\n-        .extracting(s -> s.getPath().getFileName())\n-        .isEqualTo(snapshot.getPath().getFileName());\n-  }\n-\n-  @Test\n-  public void shouldGetLatestSnapshot() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-\n-    // when\n-    final var snapshot = newCommittedSnapshot(1);\n-\n-    // then\n-    assertThat(storage.getLatestSnapshot())\n-        .map(Snapshot::getCompactionBound)\n-        .hasValue(snapshot.getCompactionBound());\n-  }\n-\n-  @Test\n-  public void shouldNotifyDeletionListenersOnMaxSnapshotCount() throws IOException {\n-    // given\n-    final var listener = mock(SnapshotDeletionListener.class);\n-    final var storage = newStorage();\n-    storage.addDeletionListener(listener);\n-\n-    // when the first snapshot then try to delete snapshots older than first\n-    final var first = newCommittedSnapshot(1);\n-    verify(listener).onSnapshotsDeleted(eq(first));\n-\n-    // when the second snapshot then all snapshots up to that snapshot are deleted\n-    final var second = newCommittedSnapshot(2);\n-    verify(listener).onSnapshotsDeleted(eq(second));\n-    assertThat(storage.getSnapshots()).hasSize(1).containsExactly(second);\n-  }\n-\n-  @Test\n-  public void shouldNotCreatePendingSnapshotIfSnapshotExistsForIndex() throws IOException {\n-    // given\n-    final var storage = newStorage();\n-    logStorageRule.appendEntry(2, 2, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(3, 3, ByteBuffer.allocate(1));\n-    final var snapshot = storage.getPendingSnapshotFor(3).orElseThrow();\n-    Files.createDirectories(snapshot.getPath());\n-    storage.commitSnapshot(snapshot.getPath()).orElseThrow();\n-\n-    // when\n-    final var newSnapshot = storage.getPendingSnapshotFor(3);\n-\n-    // then\n-    assertThat(newSnapshot).isEmpty();\n-  }\n-\n-  private Snapshot newPendingSnapshot(final long position) {\n-    logStorageRule.appendEntry(position - 1, position - 1, ByteBuffer.allocate(1));\n-    logStorageRule.appendEntry(position, position, ByteBuffer.allocate(1));\n-    return snapshotStorage.getPendingSnapshotFor(position).orElseThrow();\n-  }\n-\n-  private Snapshot newCommittedSnapshot(final long position) throws IOException {\n-    final var snapshot = newPendingSnapshot(position);\n-    Files.createDirectories(snapshot.getPath());\n-    snapshotStorage.commitSnapshot(snapshot.getPath());\n-\n-    return snapshotStorage.getLatestSnapshot().orElseThrow();\n-  }\n-\n-  private AtomixSnapshotStorage newStorage() {\n-    final var runtimeDirectory = temporaryFolder.getRoot().toPath().resolve(\"runtime\");\n-    snapshotStorage =\n-        new AtomixSnapshotStorage(\n-            runtimeDirectory, pendingDirectory, store, entrySupplier, new SnapshotMetrics(0));\n-    return snapshotStorage;\n-  }\n-}\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwOTkzMw==", "bodyText": "Do we have another test that verifies processor does not reprocess event at the last processed position in snapshot?", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r435709933", "createdAt": "2020-06-05T06:14:15Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -395,8 +390,10 @@ public void processRecord(\n     streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n     final long snapshotPosition =\n         streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    // we write three event to make sure that the second event was committed and is part of the\n+    // state (lastProcessedEvent)\n     processingLatch.await();\n-    streamProcessorRule.waitForNextSnapshot();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f89f99c64572bf1aa4b363b69c096660b3fbaffb"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTQ0NzQ0", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-425944744", "createdAt": "2020-06-08T06:31:37Z", "commit": {"oid": "2702a11c3aa0337cd64802339b472fa0b6f8aba1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MTM1MzIw", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-426135320", "createdAt": "2020-06-08T11:23:05Z", "commit": {"oid": "2702a11c3aa0337cd64802339b472fa0b6f8aba1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMToyMzowNlrOGgZeLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMToyMzowNlrOGgZeLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyNDk0Mg==", "bodyText": "Shouldn't we synchronize access to this method?. There is a potential race condition between comparing current snapshot and assigning the new one when concurrent replication is in progress. Alternative use currentPersistedSnapshotRef.compareAndSet.", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#discussion_r436624942", "createdAt": "2020-06-08T11:23:06Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/main/java/io/atomix/raft/snapshot/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright \u00a9 2020  camunda services GmbH (info@camunda.com)\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package io.atomix.raft.snapshot.impl;\n+\n+import io.atomix.raft.snapshot.PersistedSnapshot;\n+import io.atomix.raft.snapshot.PersistedSnapshotListener;\n+import io.atomix.raft.snapshot.PersistedSnapshotStore;\n+import io.atomix.raft.snapshot.ReceivedSnapshot;\n+import io.atomix.raft.snapshot.TransientSnapshot;\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.util.FileUtil;\n+import io.zeebe.util.ZbLogger;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+public final class FileBasedSnapshotStore implements PersistedSnapshotStore {\n+  // first is the metadata and the second the the received snapshot count\n+  private static final String RECEIVING_DIR_FORMAT = \"%s-%d\";\n+\n+  private static final Logger LOGGER = new ZbLogger(FileBasedSnapshotStore.class);\n+\n+  // the root snapshotsDirectory where all snapshots should be stored\n+  private final Path snapshotsDirectory;\n+  // the root snapshotsDirectory when pending snapshots should be stored\n+  private final Path pendingDirectory;\n+  // keeps track of all snapshot modification listeners\n+  private final Set<PersistedSnapshotListener> listeners;\n+\n+  private final SnapshotMetrics snapshotMetrics;\n+\n+  private final AtomicReference<PersistedSnapshot> currentPersistedSnapshotRef;\n+  // used to write concurrently received snapshots in different pending directories\n+  private final AtomicLong receivingSnapshotStartCount;\n+\n+  public FileBasedSnapshotStore(\n+      final SnapshotMetrics snapshotMetrics,\n+      final Path snapshotsDirectory,\n+      final Path pendingDirectory) {\n+    this.snapshotsDirectory = snapshotsDirectory;\n+    this.pendingDirectory = pendingDirectory;\n+    this.snapshotMetrics = snapshotMetrics;\n+    this.receivingSnapshotStartCount = new AtomicLong();\n+\n+    this.listeners = new CopyOnWriteArraySet<>();\n+\n+    // load previous snapshots\n+    currentPersistedSnapshotRef = new AtomicReference<>(loadLatestSnapshot(snapshotsDirectory));\n+  }\n+\n+  private PersistedSnapshot loadLatestSnapshot(final Path snapshotDirectory) {\n+    PersistedSnapshot latestPersistedSnapshot = null;\n+    try (final var stream = Files.newDirectoryStream(snapshotDirectory)) {\n+      for (final var path : stream) {\n+        latestPersistedSnapshot = collectSnapshot(path);\n+      }\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+    return latestPersistedSnapshot;\n+  }\n+\n+  private PersistedSnapshot collectSnapshot(final Path path) {\n+    final var optionalMeta = FileBasedSnapshotMetadata.ofPath(path);\n+    if (optionalMeta.isPresent()) {\n+      final var metadata = optionalMeta.get();\n+      return new FileBasedSnapshot(path, metadata);\n+    } else {\n+      LOGGER.warn(\"Expected snapshot file format to be %d-%d-%d-%d, but was {}\", path);\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean hasSnapshotId(final String id) {\n+    final var optLatestSnapshot = getLatestSnapshot();\n+\n+    if (optLatestSnapshot.isPresent()) {\n+      final var snapshot = optLatestSnapshot.get();\n+      return snapshot.getPath().getFileName().toString().equals(id);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TransientSnapshot newTransientSnapshot(\n+      final long index, final long term, final WallClockTimestamp timestamp) {\n+    final var directory = buildPendingSnapshotDirectory(index, term, timestamp);\n+    final var fileBasedSnapshotMetadata = new FileBasedSnapshotMetadata(index, term, timestamp);\n+    return new FileBasedTransientSnapshot(fileBasedSnapshotMetadata, directory, this);\n+  }\n+\n+  @Override\n+  public ReceivedSnapshot newReceivedSnapshot(final String snapshotId) {\n+    final var optMetadata = FileBasedSnapshotMetadata.ofFileName(snapshotId);\n+    final var metadata =\n+        optMetadata.orElseThrow(\n+            () ->\n+                new IllegalArgumentException(\n+                    \"Expected snapshot id in a format like 'index-term-timestamp', got '\"\n+                        + snapshotId\n+                        + \"'.\"));\n+\n+    // to make the pending dir unique\n+    final var nextStartCount = receivingSnapshotStartCount.incrementAndGet();\n+    final var pendingDirectoryName =\n+        String.format(RECEIVING_DIR_FORMAT, metadata.getSnapshotIdAsString(), nextStartCount);\n+    final var pendingSnapshotDir = pendingDirectory.resolve(pendingDirectoryName);\n+    return new FileBasedReceivedSnapshot(metadata, pendingSnapshotDir, this);\n+  }\n+\n+  @Override\n+  public Optional<PersistedSnapshot> getLatestSnapshot() {\n+    return Optional.ofNullable(currentPersistedSnapshotRef.get());\n+  }\n+\n+  @Override\n+  public void purgePendingSnapshots() throws IOException {\n+    try (final var files = Files.list(pendingDirectory)) {\n+      files.filter(Files::isDirectory).forEach(this::purgePendingSnapshot);\n+    }\n+  }\n+\n+  @Override\n+  public void addSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeSnapshotListener(final PersistedSnapshotListener listener) {\n+    listeners.remove(listener);\n+  }\n+\n+  @Override\n+  public long getCurrentSnapshotIndex() {\n+    return getLatestSnapshot().map(PersistedSnapshot::getIndex).orElse(0L);\n+  }\n+\n+  @Override\n+  public void delete() {\n+    currentPersistedSnapshotRef.set(null);\n+\n+    try {\n+      LOGGER.debug(\"DELETE FOLDER {}\", snapshotsDirectory);\n+      FileUtil.deleteFolder(snapshotsDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+\n+    try {\n+      LOGGER.debug(\"DELETE FOLDER {}\", pendingDirectory);\n+      FileUtil.deleteFolder(pendingDirectory);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private void observeSnapshotSize(final PersistedSnapshot persistedSnapshot) {\n+    try (final var contents = Files.newDirectoryStream(persistedSnapshot.getPath())) {\n+      var totalSize = 0L;\n+\n+      for (final var path : contents) {\n+        if (Files.isRegularFile(path)) {\n+          final var size = Files.size(path);\n+          snapshotMetrics.observeSnapshotFileSize(size);\n+          totalSize += size;\n+        }\n+      }\n+\n+      snapshotMetrics.observeSnapshotSize(totalSize);\n+    } catch (final IOException e) {\n+      LOGGER.warn(\"Failed to observe size for snapshot {}\", persistedSnapshot, e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshots(final long cutoffIndex) {\n+    LOGGER.debug(\n+        \"Search for orphaned snapshots below oldest valid snapshot with index {} in {}\",\n+        cutoffIndex,\n+        pendingDirectory);\n+\n+    try (final var pendingSnapshots = Files.newDirectoryStream(pendingDirectory)) {\n+      for (final var pendingSnapshot : pendingSnapshots) {\n+        purgePendingSnapshot(cutoffIndex, pendingSnapshot);\n+      }\n+    } catch (final IOException e) {\n+      LOGGER.warn(\n+          \"Failed to delete orphaned snapshots, could not list pending directory {}\",\n+          pendingDirectory,\n+          e);\n+    }\n+  }\n+\n+  private void purgePendingSnapshot(final long cutoffIndex, final Path pendingSnapshot) {\n+    final var optionalMetadata = FileBasedSnapshotMetadata.ofPath(pendingSnapshot);\n+    if (optionalMetadata.isPresent() && optionalMetadata.get().getIndex() < cutoffIndex) {\n+      try {\n+        FileUtil.deleteFolder(pendingSnapshot);\n+        LOGGER.debug(\"Deleted orphaned snapshot {}\", pendingSnapshot);\n+      } catch (final IOException e) {\n+        LOGGER.warn(\n+            \"Failed to delete orphaned snapshot {}, risk using unnecessary disk space\",\n+            pendingSnapshot,\n+            e);\n+      }\n+    }\n+  }\n+\n+  public Path getPath() {\n+    return snapshotsDirectory;\n+  }\n+\n+  @Override\n+  public void close() {\n+    listeners.clear();\n+  }\n+\n+  private boolean isCurrentSnapshotNewer(final FileBasedSnapshotMetadata metadata) {\n+    final var persistedSnapshot = currentPersistedSnapshotRef.get();\n+    return (persistedSnapshot != null && persistedSnapshot.getId().compareTo(metadata) >= 0);\n+  }\n+\n+  PersistedSnapshot newSnapshot(final FileBasedSnapshotMetadata metadata, final Path directory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2702a11c3aa0337cd64802339b472fa0b6f8aba1"}, "originalPosition": 247}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjkzMDk2", "url": "https://github.com/camunda-cloud/zeebe/pull/4641#pullrequestreview-426293096", "createdAt": "2020-06-08T14:22:25Z", "commit": {"oid": "d5ad26f834d9ea0897a9e800e0bb1d2bc2e139d8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "committedDate": "2020-06-08T14:40:37Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5ad26f834d9ea0897a9e800e0bb1d2bc2e139d8", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/d5ad26f834d9ea0897a9e800e0bb1d2bc2e139d8", "committedDate": "2020-06-08T14:04:23Z", "message": "chore(atomix): avoid concurrent snapshot writes"}, "afterCommit": {"oid": "ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ca3eb0b48eec08621a43b11d5a6f809d3b3cb202", "committedDate": "2020-06-08T14:40:37Z", "message": "chore(atomix): rewrite snapshotting\n\n Description:\n\n Introduces new interfaces for Snapshotting.\n\n PersistedSnapshotStore can be used to take snapshots and receive\n snapshot chunks. After all chunks are received or the snapshot is taken\n the volatile snapshot can be persisted. It is always possible\n to abort an snapshot, before persisting. The store can also be used\n to get the latest snapshot which was persisted. The store allows\n to register listeners, which are called on new persisted snapshots.\n\n On receiving snapshot chunks and consuming them, checksums of the chunks\n are verified. On persisting an received snapshot the complete snapshot\n checksum is verified.\n\n An persisted snapshot can be read from it persisted storage via a\n snapshot reader and will be chunked in several snapshot chunks, which\n then can be transmitted and consumed again by the store.\n\n The StateSnapshotController use by the AsyncSnapshotDirector and is the\n only one which takes a snapshot. The ReplicationController is\n registered at the SnapshotStore as listener to replicate new persisted\n snapshots. The replication will send all chunks over the network.\n\n The ReplicationController will receive the chunks on the follower side and will use\n the newReceviedSnapshot method of the store to consume the SnapshotChunks.\n\n On the LeaderRole (in the AbstractAppender) the last snapshot can also\n be replicated. This is done via the SnapshotChunkReader, which\n reads the chunks from ther persisted store.\n\n The Follower (in PassiveRole) will consume the replicated chunks and\n will store it similar to the ReplicationController.\n\n On both ReplicationController and PassiveRole the checksum of the\n snapshot chunks but also of the complete snapshot is verified before\n the received snapshot is persisted.\n\n Related work:\n\n  * Most implemation details are now in Atomix\n  * Zeebe related snapshoting like replication and taking of snapshot is\n    part of Broker\n  * Use sbe for snapshot chunk replication/consumption\n  * StreamProcessorTests moved again to engine module - removed snapshot\n    related tests, dont need to be part of that\n  * clean up managment schema file in broker\n\n  * Wrote a bunch of new unit tests for snapshot implementation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2725, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}