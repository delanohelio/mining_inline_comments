{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMDYzMjk5", "number": 4079, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNDo0MlrODqrrqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODo0MzowMVrODqsQoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgyNDcyOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/deployment/model/validation/ZeebeRuntimeValidationTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNDo0MlrOF6k-2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNToyNDoxMFrOF61kBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzY0Mw==", "bodyText": "Why not use s.zeebeOutput(\"foo\", \"bar\")?", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r396967643", "createdAt": "2020-03-24T08:14:42Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/deployment/model/validation/ZeebeRuntimeValidationTest.java", "diffHunk": "@@ -76,45 +88,93 @@\n         Arrays.asList(expect(ConditionExpression.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // not a json path expression\n+        // not a valid expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_EXPRESSION, \"foo\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // static expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"foo\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, STATIC_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty path expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"=foo\", \"\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_PATH_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // invalid target expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeInput(\"foo\", INVALID_PATH_EXPRESSION))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_EXPRESSION_MESSAGE))\n       },\n-      { // not a json path expression\n+      { // not a valid expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_EXPRESSION, \"foo\"))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeOutput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeOutput.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // input source expression is not supported\n+        // static expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(\"foo[1]\", \"foo\"))\n+            .serviceTask(\"task\", s -> zeebeOutput(s, \"foo\", \"bar\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5ODkxOA==", "bodyText": "I changed the behavior in the model API. So, zeebeInput() puts the given source as an expression (https://github.com/zeebe-io/zeebe/pull/4079/files#diff-c7c98073fc6da8fb8e162a4dcca1ffecR148). But in this test case, I want to verify that a static expression (i.e. without expression prefix =) is not valid.\nMaybe, it is better to have different methods in the model API: zeebeInput() and zeebeInputExpression(). zeebeInput() is only used in this test case for validation. zeebeInputExpression() is used everwhere else.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397098918", "createdAt": "2020-03-24T12:00:15Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/deployment/model/validation/ZeebeRuntimeValidationTest.java", "diffHunk": "@@ -76,45 +88,93 @@\n         Arrays.asList(expect(ConditionExpression.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // not a json path expression\n+        // not a valid expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_EXPRESSION, \"foo\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // static expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"foo\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, STATIC_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty path expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"=foo\", \"\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_PATH_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // invalid target expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeInput(\"foo\", INVALID_PATH_EXPRESSION))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_EXPRESSION_MESSAGE))\n       },\n-      { // not a json path expression\n+      { // not a valid expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_EXPRESSION, \"foo\"))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeOutput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeOutput.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // input source expression is not supported\n+        // static expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(\"foo[1]\", \"foo\"))\n+            .serviceTask(\"task\", s -> zeebeOutput(s, \"foo\", \"bar\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzY0Mw=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzOTMwMQ==", "bodyText": "Thanks. I would leave it as it is. If we never allow static expressions then no need to expose it for testing.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397239301", "createdAt": "2020-03-24T15:24:10Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/deployment/model/validation/ZeebeRuntimeValidationTest.java", "diffHunk": "@@ -76,45 +88,93 @@\n         Arrays.asList(expect(ConditionExpression.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // not a json path expression\n+        // not a valid expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_EXPRESSION, \"foo\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // static expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"foo\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, STATIC_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"\", \"bar\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // empty path expression\n+        Bpmn.createExecutableProcess(\"process\")\n+            .startEvent()\n+            .serviceTask(\"task\", s -> zeebeInput(s, \"=foo\", \"\"))\n+            .endEvent()\n+            .done(),\n+        Arrays.asList(expect(ZeebeInput.class, MISSING_PATH_EXPRESSION_MESSAGE))\n+      },\n+      {\n+        // invalid target expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeInput(\"foo\", INVALID_PATH_EXPRESSION))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeInput.class, INVALID_PATH_EXPRESSION_MESSAGE))\n       },\n-      { // not a json path expression\n+      { // not a valid expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_PATH_QUERY, \"foo\"))\n+            .serviceTask(\"task\", s -> s.zeebeOutput(INVALID_EXPRESSION, \"foo\"))\n             .endEvent()\n             .done(),\n-        Arrays.asList(expect(ZeebeOutput.class, INVALID_PATH_QUERY_MESSAGE))\n+        Arrays.asList(expect(ZeebeOutput.class, INVALID_EXPRESSION_MESSAGE))\n       },\n       {\n-        // input source expression is not supported\n+        // static expression\n         Bpmn.createExecutableProcess(\"process\")\n             .startEvent()\n-            .serviceTask(\"task\", s -> s.zeebeInput(\"foo[1]\", \"foo\"))\n+            .serviceTask(\"task\", s -> zeebeOutput(s, \"foo\", \"bar\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NzY0Mw=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgzMjczOnYy", "diffSide": "LEFT", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/handlers/element/ElementActivatedHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoxNzoxNFrOF6lD5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjowNDo1NVrOF6tJaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2ODkzNQ==", "bodyText": "Why were all theses tests removed?", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r396968935", "createdAt": "2020-03-24T08:17:14Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/handlers/element/ElementActivatedHandlerTest.java", "diffHunk": "@@ -1,70 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwMTQxNg==", "bodyText": "I decided to remove the unit tests of the handlers instead of making them work again. I think these unit tests don't give us much value because they mock too many dependencies and rely heavily on the behavior of the dependencies.\nIn case of the handlers, I prefer integration tests with the engine. As far as I know, we cover each of these cases in an integration test.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397101416", "createdAt": "2020-03-24T12:04:55Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/handlers/element/ElementActivatedHandlerTest.java", "diffHunk": "@@ -1,70 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2ODkzNQ=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDg0NDUzOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODoyMDo0N1rOF6lLXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNTo0ODozNVrOF7M5Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MDg0NA==", "bodyText": "Is this the desired behavior? Just curious.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r396970844", "createdAt": "2020-03-24T08:20:47Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.variable.mapping;\n+\n+import static io.zeebe.test.util.MsgPackUtil.asMsgPack;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.el.ExpressionLanguageFactory;\n+import io.zeebe.el.ResultType;\n+import io.zeebe.engine.processor.workflow.deployment.model.transformer.VariableMappingTransformer;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import io.zeebe.test.util.MsgPackUtil;\n+import java.util.List;\n+import java.util.Map;\n+import org.agrona.DirectBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public final class VariableInputMappingTransformerTest {\n+\n+  @Parameter(0)\n+  public List<ZeebeMapping> mappings;\n+\n+  @Parameter(1)\n+  public Map<String, DirectBuffer> variables;\n+\n+  @Parameter(2)\n+  public String expectedOutput;\n+\n+  private final VariableMappingTransformer transformer = new VariableMappingTransformer();\n+  private final ExpressionLanguage expressionLanguage =\n+      ExpressionLanguageFactory.createExpressionLanguage();\n+\n+  @Parameters(name = \"with {0} to {2}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+      // no mappings\n+      {List.of(), Map.of(), \"{}\"},\n+      // direct mapping\n+      {List.of(mapping(\"x\", \"x\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'x':1}\"},\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"y\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':{'y':1}}\"},\n+      // nested target\n+      {List.of(mapping(\"x\", \"a.b\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':1}}\"},\n+      {\n+        List.of(mapping(\"x\", \"a.b\"), mapping(\"y\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'b':1, 'c':2}}\"\n+      },\n+      {List.of(mapping(\"x\", \"a.b.c\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':{'c':1}}}}\"},\n+      // nested source\n+      {List.of(mapping(\"x.y\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x.y\", \"a\"), mapping(\"x.z\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {\n+        List.of(mapping(\"x.y\", \"a.b\"), mapping(\"x.z\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a': {'b':1, 'c':2}}\"\n+      },\n+      // source FEEL expression\n+      {List.of(mapping(\"1\", \"a\")), Map.of(), \"{'a':1}\"},\n+      {List.of(mapping(\"\\\"foo\\\"\", \"a\")), Map.of(), \"{'a':'foo'}\"},\n+      {List.of(mapping(\"[1,2,3]\", \"a\")), Map.of(), \"{'a':[1,2,3]}\"},\n+      {List.of(mapping(\"x + y\", \"a\")), Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")), \"{'a':3}\"},\n+      {\n+        List.of(mapping(\"{x:x, y:y}\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'x':1, 'y':2}}\"\n+      },\n+      {\n+        List.of(mapping(\"append(x, y)\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"[1,2]\"), \"y\", asMsgPack(\"3\")),\n+        \"{'a':[1,2,3]}\"\n+      },\n+      // evaluate mappings in order\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"a + 1\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\")),\n+        \"{'a':1, 'b':2}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwNTEzNQ==", "bodyText": "Good question \ud83d\ude04 A user asked about it and opened a PR to clarify the behavior (#3515).\nIt is now possible (thanks to FEEL) so I wanted to have a test case. However, I would not feature it. But we don't need to tell the users that it is not possible and maybe confuse them \ud83d\ude05\nDo you think that I should remove the test case?", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397105135", "createdAt": "2020-03-24T12:11:33Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.variable.mapping;\n+\n+import static io.zeebe.test.util.MsgPackUtil.asMsgPack;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.el.ExpressionLanguageFactory;\n+import io.zeebe.el.ResultType;\n+import io.zeebe.engine.processor.workflow.deployment.model.transformer.VariableMappingTransformer;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import io.zeebe.test.util.MsgPackUtil;\n+import java.util.List;\n+import java.util.Map;\n+import org.agrona.DirectBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public final class VariableInputMappingTransformerTest {\n+\n+  @Parameter(0)\n+  public List<ZeebeMapping> mappings;\n+\n+  @Parameter(1)\n+  public Map<String, DirectBuffer> variables;\n+\n+  @Parameter(2)\n+  public String expectedOutput;\n+\n+  private final VariableMappingTransformer transformer = new VariableMappingTransformer();\n+  private final ExpressionLanguage expressionLanguage =\n+      ExpressionLanguageFactory.createExpressionLanguage();\n+\n+  @Parameters(name = \"with {0} to {2}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+      // no mappings\n+      {List.of(), Map.of(), \"{}\"},\n+      // direct mapping\n+      {List.of(mapping(\"x\", \"x\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'x':1}\"},\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"y\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':{'y':1}}\"},\n+      // nested target\n+      {List.of(mapping(\"x\", \"a.b\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':1}}\"},\n+      {\n+        List.of(mapping(\"x\", \"a.b\"), mapping(\"y\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'b':1, 'c':2}}\"\n+      },\n+      {List.of(mapping(\"x\", \"a.b.c\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':{'c':1}}}}\"},\n+      // nested source\n+      {List.of(mapping(\"x.y\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x.y\", \"a\"), mapping(\"x.z\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {\n+        List.of(mapping(\"x.y\", \"a.b\"), mapping(\"x.z\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a': {'b':1, 'c':2}}\"\n+      },\n+      // source FEEL expression\n+      {List.of(mapping(\"1\", \"a\")), Map.of(), \"{'a':1}\"},\n+      {List.of(mapping(\"\\\"foo\\\"\", \"a\")), Map.of(), \"{'a':'foo'}\"},\n+      {List.of(mapping(\"[1,2,3]\", \"a\")), Map.of(), \"{'a':[1,2,3]}\"},\n+      {List.of(mapping(\"x + y\", \"a\")), Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")), \"{'a':3}\"},\n+      {\n+        List.of(mapping(\"{x:x, y:y}\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'x':1, 'y':2}}\"\n+      },\n+      {\n+        List.of(mapping(\"append(x, y)\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"[1,2]\"), \"y\", asMsgPack(\"3\")),\n+        \"{'a':[1,2,3]}\"\n+      },\n+      // evaluate mappings in order\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"a + 1\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\")),\n+        \"{'a':1, 'b':2}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MDg0NA=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MjYxNg==", "bodyText": "I think both are acceptable behaviors i.e results \"{'a':1, 'b':2}\" and \"{'a':1, 'b':1}\". If I didn't know the merge logic, I would have guessed the second one. So it is good to finalize and document the behavior, and keep this test. What do you think?", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397252616", "createdAt": "2020-03-24T15:41:00Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.variable.mapping;\n+\n+import static io.zeebe.test.util.MsgPackUtil.asMsgPack;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.el.ExpressionLanguageFactory;\n+import io.zeebe.el.ResultType;\n+import io.zeebe.engine.processor.workflow.deployment.model.transformer.VariableMappingTransformer;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import io.zeebe.test.util.MsgPackUtil;\n+import java.util.List;\n+import java.util.Map;\n+import org.agrona.DirectBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public final class VariableInputMappingTransformerTest {\n+\n+  @Parameter(0)\n+  public List<ZeebeMapping> mappings;\n+\n+  @Parameter(1)\n+  public Map<String, DirectBuffer> variables;\n+\n+  @Parameter(2)\n+  public String expectedOutput;\n+\n+  private final VariableMappingTransformer transformer = new VariableMappingTransformer();\n+  private final ExpressionLanguage expressionLanguage =\n+      ExpressionLanguageFactory.createExpressionLanguage();\n+\n+  @Parameters(name = \"with {0} to {2}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+      // no mappings\n+      {List.of(), Map.of(), \"{}\"},\n+      // direct mapping\n+      {List.of(mapping(\"x\", \"x\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'x':1}\"},\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"y\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':{'y':1}}\"},\n+      // nested target\n+      {List.of(mapping(\"x\", \"a.b\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':1}}\"},\n+      {\n+        List.of(mapping(\"x\", \"a.b\"), mapping(\"y\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'b':1, 'c':2}}\"\n+      },\n+      {List.of(mapping(\"x\", \"a.b.c\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':{'c':1}}}}\"},\n+      // nested source\n+      {List.of(mapping(\"x.y\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x.y\", \"a\"), mapping(\"x.z\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {\n+        List.of(mapping(\"x.y\", \"a.b\"), mapping(\"x.z\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a': {'b':1, 'c':2}}\"\n+      },\n+      // source FEEL expression\n+      {List.of(mapping(\"1\", \"a\")), Map.of(), \"{'a':1}\"},\n+      {List.of(mapping(\"\\\"foo\\\"\", \"a\")), Map.of(), \"{'a':'foo'}\"},\n+      {List.of(mapping(\"[1,2,3]\", \"a\")), Map.of(), \"{'a':[1,2,3]}\"},\n+      {List.of(mapping(\"x + y\", \"a\")), Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")), \"{'a':3}\"},\n+      {\n+        List.of(mapping(\"{x:x, y:y}\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'x':1, 'y':2}}\"\n+      },\n+      {\n+        List.of(mapping(\"append(x, y)\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"[1,2]\"), \"y\", asMsgPack(\"3\")),\n+        \"{'a':[1,2,3]}\"\n+      },\n+      // evaluate mappings in order\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"a + 1\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\")),\n+        \"{'a':1, 'b':2}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MDg0NA=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NDUzNw==", "bodyText": "Also, I assume the order of the mappings from the initial model (xml or created using bpmn-model api) is preserved.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397264537", "createdAt": "2020-03-24T15:55:40Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.variable.mapping;\n+\n+import static io.zeebe.test.util.MsgPackUtil.asMsgPack;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.el.ExpressionLanguageFactory;\n+import io.zeebe.el.ResultType;\n+import io.zeebe.engine.processor.workflow.deployment.model.transformer.VariableMappingTransformer;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import io.zeebe.test.util.MsgPackUtil;\n+import java.util.List;\n+import java.util.Map;\n+import org.agrona.DirectBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public final class VariableInputMappingTransformerTest {\n+\n+  @Parameter(0)\n+  public List<ZeebeMapping> mappings;\n+\n+  @Parameter(1)\n+  public Map<String, DirectBuffer> variables;\n+\n+  @Parameter(2)\n+  public String expectedOutput;\n+\n+  private final VariableMappingTransformer transformer = new VariableMappingTransformer();\n+  private final ExpressionLanguage expressionLanguage =\n+      ExpressionLanguageFactory.createExpressionLanguage();\n+\n+  @Parameters(name = \"with {0} to {2}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+      // no mappings\n+      {List.of(), Map.of(), \"{}\"},\n+      // direct mapping\n+      {List.of(mapping(\"x\", \"x\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'x':1}\"},\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"y\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':{'y':1}}\"},\n+      // nested target\n+      {List.of(mapping(\"x\", \"a.b\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':1}}\"},\n+      {\n+        List.of(mapping(\"x\", \"a.b\"), mapping(\"y\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'b':1, 'c':2}}\"\n+      },\n+      {List.of(mapping(\"x\", \"a.b.c\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':{'c':1}}}}\"},\n+      // nested source\n+      {List.of(mapping(\"x.y\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x.y\", \"a\"), mapping(\"x.z\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {\n+        List.of(mapping(\"x.y\", \"a.b\"), mapping(\"x.z\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a': {'b':1, 'c':2}}\"\n+      },\n+      // source FEEL expression\n+      {List.of(mapping(\"1\", \"a\")), Map.of(), \"{'a':1}\"},\n+      {List.of(mapping(\"\\\"foo\\\"\", \"a\")), Map.of(), \"{'a':'foo'}\"},\n+      {List.of(mapping(\"[1,2,3]\", \"a\")), Map.of(), \"{'a':[1,2,3]}\"},\n+      {List.of(mapping(\"x + y\", \"a\")), Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")), \"{'a':3}\"},\n+      {\n+        List.of(mapping(\"{x:x, y:y}\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'x':1, 'y':2}}\"\n+      },\n+      {\n+        List.of(mapping(\"append(x, y)\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"[1,2]\"), \"y\", asMsgPack(\"3\")),\n+        \"{'a':[1,2,3]}\"\n+      },\n+      // evaluate mappings in order\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"a + 1\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\")),\n+        \"{'a':1, 'b':2}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MDg0NA=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYyMTU0Nw==", "bodyText": "Correct. Since this behavior is part of FEEL and not easy to prevent, I would keep it and document that this is possible.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397621547", "createdAt": "2020-03-25T05:48:35Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/variable/mapping/VariableInputMappingTransformerTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.variable.mapping;\n+\n+import static io.zeebe.test.util.MsgPackUtil.asMsgPack;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.el.ExpressionLanguageFactory;\n+import io.zeebe.el.ResultType;\n+import io.zeebe.engine.processor.workflow.deployment.model.transformer.VariableMappingTransformer;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import io.zeebe.test.util.MsgPackUtil;\n+import java.util.List;\n+import java.util.Map;\n+import org.agrona.DirectBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public final class VariableInputMappingTransformerTest {\n+\n+  @Parameter(0)\n+  public List<ZeebeMapping> mappings;\n+\n+  @Parameter(1)\n+  public Map<String, DirectBuffer> variables;\n+\n+  @Parameter(2)\n+  public String expectedOutput;\n+\n+  private final VariableMappingTransformer transformer = new VariableMappingTransformer();\n+  private final ExpressionLanguage expressionLanguage =\n+      ExpressionLanguageFactory.createExpressionLanguage();\n+\n+  @Parameters(name = \"with {0} to {2}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+      // no mappings\n+      {List.of(), Map.of(), \"{}\"},\n+      // direct mapping\n+      {List.of(mapping(\"x\", \"x\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'x':1}\"},\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"y\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {List.of(mapping(\"x\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':{'y':1}}\"},\n+      // nested target\n+      {List.of(mapping(\"x\", \"a.b\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':1}}\"},\n+      {\n+        List.of(mapping(\"x\", \"a.b\"), mapping(\"y\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'b':1, 'c':2}}\"\n+      },\n+      {List.of(mapping(\"x\", \"a.b.c\")), Map.of(\"x\", asMsgPack(\"1\")), \"{'a':{'b':{'c':1}}}}\"},\n+      // nested source\n+      {List.of(mapping(\"x.y\", \"a\")), Map.of(\"x\", asMsgPack(\"{'y':1}\")), \"{'a':1}\"},\n+      {\n+        List.of(mapping(\"x.y\", \"a\"), mapping(\"x.z\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a':1, 'b':2}\"\n+      },\n+      {\n+        List.of(mapping(\"x.y\", \"a.b\"), mapping(\"x.z\", \"a.c\")),\n+        Map.of(\"x\", asMsgPack(\"{'y':1, 'z':2}\")),\n+        \"{'a': {'b':1, 'c':2}}\"\n+      },\n+      // source FEEL expression\n+      {List.of(mapping(\"1\", \"a\")), Map.of(), \"{'a':1}\"},\n+      {List.of(mapping(\"\\\"foo\\\"\", \"a\")), Map.of(), \"{'a':'foo'}\"},\n+      {List.of(mapping(\"[1,2,3]\", \"a\")), Map.of(), \"{'a':[1,2,3]}\"},\n+      {List.of(mapping(\"x + y\", \"a\")), Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")), \"{'a':3}\"},\n+      {\n+        List.of(mapping(\"{x:x, y:y}\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"1\"), \"y\", asMsgPack(\"2\")),\n+        \"{'a':{'x':1, 'y':2}}\"\n+      },\n+      {\n+        List.of(mapping(\"append(x, y)\", \"a\")),\n+        Map.of(\"x\", asMsgPack(\"[1,2]\"), \"y\", asMsgPack(\"3\")),\n+        \"{'a':[1,2,3]}\"\n+      },\n+      // evaluate mappings in order\n+      {\n+        List.of(mapping(\"x\", \"a\"), mapping(\"a + 1\", \"b\")),\n+        Map.of(\"x\", asMsgPack(\"1\")),\n+        \"{'a':1, 'b':2}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk3MDg0NA=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDkxOTM2OnYy", "diffSide": "RIGHT", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/VariableMappingTransformer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODo0MzowMVrOF6l6JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNjowMzoxOVrOF7NH1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4MjgyMQ==", "bodyText": "What are the consequences of throwing exception here? Is it handled later and the deployment will be rejected?", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r396982821", "createdAt": "2020-03-24T08:43:01Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/VariableMappingTransformer.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.deployment.model.transformer;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform variable mappings into an expression.\n+ *\n+ * <p>The resulting expression is a FEEL context that has a similar structure as a JSON document.\n+ * Each target of a mapping is a key in the context and the source of this mapping is the context\n+ * value. The source expression can be any FEEL expression. A nested target expression is\n+ * transformed into a nested context.\n+ *\n+ * <p>Variable mappings:\n+ *\n+ * <pre>\n+ *   source | target\n+ *   =======|=======\n+ *    x     | a\n+ *    y     | b.c\n+ *    z     | b.d\n+ * </pre>\n+ *\n+ * FEEL context expression:\n+ *\n+ * <pre>\n+ *   {\n+ *     a: x,\n+ *     b: {\n+ *       c: y,\n+ *       d: z\n+ *     }\n+ *   }\n+ * </pre>\n+ */\n+public final class VariableMappingTransformer {\n+\n+  private static final String EXPRESSION_MARKER = \"=\";\n+\n+  public Expression transformInputMappings(\n+      final Collection<? extends ZeebeMapping> inputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(inputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression =\n+        asFeelContextExpression(context, (contextValue, contextPath) -> contextValue);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  public Expression transformOutputMappings(\n+      final Collection<? extends ZeebeMapping> outputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(outputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression = asFeelContextExpression(context, this::appendContextExpression);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  private List<Mapping> toMappings(\n+      final Collection<? extends ZeebeMapping> mappings,\n+      final ExpressionLanguage expressionLanguage) {\n+    return mappings.stream()\n+        .map(\n+            mapping -> {\n+              final var source = mapping.getSource();\n+              final var sourceExpression = expressionLanguage.parseExpression(source);\n+              return new Mapping(sourceExpression, mapping.getTarget());\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MappingContext asContext(final List<Mapping> mappings) {\n+    final var context = new MappingContext();\n+\n+    for (final Mapping mapping : mappings) {\n+      final var sourceExpression = mapping.source;\n+      final var targetPathExpression = mapping.target;\n+\n+      final var targetPathParts = splitPathExpression(targetPathExpression);\n+      createContextEntry(targetPathParts, sourceExpression, context);\n+    }\n+    return context;\n+  }\n+\n+  private List<String> splitPathExpression(final String path) {\n+    final var parts = path.split(\"\\\\.\");\n+    return new ArrayList<>(Arrays.asList(parts));\n+  }\n+\n+  private void createContextEntry(\n+      final List<String> targetPathParts,\n+      final Expression sourceExpression,\n+      final MappingContext context) {\n+    final String target = targetPathParts.remove(0);\n+\n+    if (targetPathParts.isEmpty()) {\n+      context.addEntry(target, sourceExpression);\n+\n+    } else {\n+      final var nestedContext = context.getOrAddContext(target);\n+      createContextEntry(targetPathParts, sourceExpression, nestedContext);\n+    }\n+  }\n+\n+  private String asFeelContextExpression(\n+      final MappingContext context,\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return context.visit(feelContextBuilder(contextValueVisitor));\n+  }\n+\n+  private MappingContextVisitor<String> feelContextBuilder(\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return new MappingContextVisitor<>() {\n+      @Override\n+      public String onEntry(final String targetKey, final Expression sourceExpression) {\n+        return targetKey + \":\" + sourceExpression.getExpression();\n+      }\n+\n+      @Override\n+      public String onContext(final List<String> entries) {\n+        return \"{\" + String.join(\",\", entries) + \"}\";\n+      }\n+\n+      @Override\n+      public String onContextEntry(\n+          final String targetKey, final String contextValue, final List<String> contextPath) {\n+        return targetKey + \":\" + contextValueVisitor.apply(contextValue, contextPath);\n+      }\n+    };\n+  }\n+\n+  private String appendContextExpression(\n+      final String nestedContext, final List<String> contextPath) {\n+    // for a nested target mapping 'x -> a.b', append the nested property 'b' to\n+    // the existing context variable 'a' (instead of overriding 'a')\n+    // example: x = 1 and a = {'c':2} results in a = {'b':1, 'c':2}\n+    final var existingContext = String.join(\".\", contextPath);\n+    return \"appendTo(\" + existingContext + \",\" + nestedContext + \")\";\n+  }\n+\n+  private Expression parseExpression(\n+      final String contextExpression, final ExpressionLanguage expressionLanguage) {\n+    final var expression =\n+        expressionLanguage.parseExpression(EXPRESSION_MARKER + contextExpression);\n+\n+    if (!expression.isValid()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Failed to build variable mapping expression: %s\", expression.getFailureMessage()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwODA2MA==", "bodyText": "No, I don't think so. There is no explicit failure handling for this case. I hope that this exception is never thrown - or only in a unit/integration test after a refactoring.\nThe transformation of the variable mappings is done after the validation of the individual input/output mappings. To be safe, I could call the same logic in the validator and verify that the expression is valid.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397108060", "createdAt": "2020-03-24T12:16:56Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/VariableMappingTransformer.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.deployment.model.transformer;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform variable mappings into an expression.\n+ *\n+ * <p>The resulting expression is a FEEL context that has a similar structure as a JSON document.\n+ * Each target of a mapping is a key in the context and the source of this mapping is the context\n+ * value. The source expression can be any FEEL expression. A nested target expression is\n+ * transformed into a nested context.\n+ *\n+ * <p>Variable mappings:\n+ *\n+ * <pre>\n+ *   source | target\n+ *   =======|=======\n+ *    x     | a\n+ *    y     | b.c\n+ *    z     | b.d\n+ * </pre>\n+ *\n+ * FEEL context expression:\n+ *\n+ * <pre>\n+ *   {\n+ *     a: x,\n+ *     b: {\n+ *       c: y,\n+ *       d: z\n+ *     }\n+ *   }\n+ * </pre>\n+ */\n+public final class VariableMappingTransformer {\n+\n+  private static final String EXPRESSION_MARKER = \"=\";\n+\n+  public Expression transformInputMappings(\n+      final Collection<? extends ZeebeMapping> inputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(inputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression =\n+        asFeelContextExpression(context, (contextValue, contextPath) -> contextValue);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  public Expression transformOutputMappings(\n+      final Collection<? extends ZeebeMapping> outputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(outputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression = asFeelContextExpression(context, this::appendContextExpression);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  private List<Mapping> toMappings(\n+      final Collection<? extends ZeebeMapping> mappings,\n+      final ExpressionLanguage expressionLanguage) {\n+    return mappings.stream()\n+        .map(\n+            mapping -> {\n+              final var source = mapping.getSource();\n+              final var sourceExpression = expressionLanguage.parseExpression(source);\n+              return new Mapping(sourceExpression, mapping.getTarget());\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MappingContext asContext(final List<Mapping> mappings) {\n+    final var context = new MappingContext();\n+\n+    for (final Mapping mapping : mappings) {\n+      final var sourceExpression = mapping.source;\n+      final var targetPathExpression = mapping.target;\n+\n+      final var targetPathParts = splitPathExpression(targetPathExpression);\n+      createContextEntry(targetPathParts, sourceExpression, context);\n+    }\n+    return context;\n+  }\n+\n+  private List<String> splitPathExpression(final String path) {\n+    final var parts = path.split(\"\\\\.\");\n+    return new ArrayList<>(Arrays.asList(parts));\n+  }\n+\n+  private void createContextEntry(\n+      final List<String> targetPathParts,\n+      final Expression sourceExpression,\n+      final MappingContext context) {\n+    final String target = targetPathParts.remove(0);\n+\n+    if (targetPathParts.isEmpty()) {\n+      context.addEntry(target, sourceExpression);\n+\n+    } else {\n+      final var nestedContext = context.getOrAddContext(target);\n+      createContextEntry(targetPathParts, sourceExpression, nestedContext);\n+    }\n+  }\n+\n+  private String asFeelContextExpression(\n+      final MappingContext context,\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return context.visit(feelContextBuilder(contextValueVisitor));\n+  }\n+\n+  private MappingContextVisitor<String> feelContextBuilder(\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return new MappingContextVisitor<>() {\n+      @Override\n+      public String onEntry(final String targetKey, final Expression sourceExpression) {\n+        return targetKey + \":\" + sourceExpression.getExpression();\n+      }\n+\n+      @Override\n+      public String onContext(final List<String> entries) {\n+        return \"{\" + String.join(\",\", entries) + \"}\";\n+      }\n+\n+      @Override\n+      public String onContextEntry(\n+          final String targetKey, final String contextValue, final List<String> contextPath) {\n+        return targetKey + \":\" + contextValueVisitor.apply(contextValue, contextPath);\n+      }\n+    };\n+  }\n+\n+  private String appendContextExpression(\n+      final String nestedContext, final List<String> contextPath) {\n+    // for a nested target mapping 'x -> a.b', append the nested property 'b' to\n+    // the existing context variable 'a' (instead of overriding 'a')\n+    // example: x = 1 and a = {'c':2} results in a = {'b':1, 'c':2}\n+    final var existingContext = String.join(\".\", contextPath);\n+    return \"appendTo(\" + existingContext + \",\" + nestedContext + \")\";\n+  }\n+\n+  private Expression parseExpression(\n+      final String contextExpression, final ExpressionLanguage expressionLanguage) {\n+    final var expression =\n+        expressionLanguage.parseExpression(EXPRESSION_MARKER + contextExpression);\n+\n+    if (!expression.isValid()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Failed to build variable mapping expression: %s\", expression.getFailureMessage()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4MjgyMQ=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2MDI5Nw==", "bodyText": "We don't expect it to happen due to invalid user input, right?\nIt would be safe as it is now. If transformation fails due to this exception, StreamProcessor detects the error and writes an error event. We don't crash or block other workflows. So it should be fine.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397260297", "createdAt": "2020-03-24T15:50:27Z", "author": {"login": "deepthidevaki"}, "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/VariableMappingTransformer.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.deployment.model.transformer;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform variable mappings into an expression.\n+ *\n+ * <p>The resulting expression is a FEEL context that has a similar structure as a JSON document.\n+ * Each target of a mapping is a key in the context and the source of this mapping is the context\n+ * value. The source expression can be any FEEL expression. A nested target expression is\n+ * transformed into a nested context.\n+ *\n+ * <p>Variable mappings:\n+ *\n+ * <pre>\n+ *   source | target\n+ *   =======|=======\n+ *    x     | a\n+ *    y     | b.c\n+ *    z     | b.d\n+ * </pre>\n+ *\n+ * FEEL context expression:\n+ *\n+ * <pre>\n+ *   {\n+ *     a: x,\n+ *     b: {\n+ *       c: y,\n+ *       d: z\n+ *     }\n+ *   }\n+ * </pre>\n+ */\n+public final class VariableMappingTransformer {\n+\n+  private static final String EXPRESSION_MARKER = \"=\";\n+\n+  public Expression transformInputMappings(\n+      final Collection<? extends ZeebeMapping> inputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(inputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression =\n+        asFeelContextExpression(context, (contextValue, contextPath) -> contextValue);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  public Expression transformOutputMappings(\n+      final Collection<? extends ZeebeMapping> outputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(outputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression = asFeelContextExpression(context, this::appendContextExpression);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  private List<Mapping> toMappings(\n+      final Collection<? extends ZeebeMapping> mappings,\n+      final ExpressionLanguage expressionLanguage) {\n+    return mappings.stream()\n+        .map(\n+            mapping -> {\n+              final var source = mapping.getSource();\n+              final var sourceExpression = expressionLanguage.parseExpression(source);\n+              return new Mapping(sourceExpression, mapping.getTarget());\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MappingContext asContext(final List<Mapping> mappings) {\n+    final var context = new MappingContext();\n+\n+    for (final Mapping mapping : mappings) {\n+      final var sourceExpression = mapping.source;\n+      final var targetPathExpression = mapping.target;\n+\n+      final var targetPathParts = splitPathExpression(targetPathExpression);\n+      createContextEntry(targetPathParts, sourceExpression, context);\n+    }\n+    return context;\n+  }\n+\n+  private List<String> splitPathExpression(final String path) {\n+    final var parts = path.split(\"\\\\.\");\n+    return new ArrayList<>(Arrays.asList(parts));\n+  }\n+\n+  private void createContextEntry(\n+      final List<String> targetPathParts,\n+      final Expression sourceExpression,\n+      final MappingContext context) {\n+    final String target = targetPathParts.remove(0);\n+\n+    if (targetPathParts.isEmpty()) {\n+      context.addEntry(target, sourceExpression);\n+\n+    } else {\n+      final var nestedContext = context.getOrAddContext(target);\n+      createContextEntry(targetPathParts, sourceExpression, nestedContext);\n+    }\n+  }\n+\n+  private String asFeelContextExpression(\n+      final MappingContext context,\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return context.visit(feelContextBuilder(contextValueVisitor));\n+  }\n+\n+  private MappingContextVisitor<String> feelContextBuilder(\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return new MappingContextVisitor<>() {\n+      @Override\n+      public String onEntry(final String targetKey, final Expression sourceExpression) {\n+        return targetKey + \":\" + sourceExpression.getExpression();\n+      }\n+\n+      @Override\n+      public String onContext(final List<String> entries) {\n+        return \"{\" + String.join(\",\", entries) + \"}\";\n+      }\n+\n+      @Override\n+      public String onContextEntry(\n+          final String targetKey, final String contextValue, final List<String> contextPath) {\n+        return targetKey + \":\" + contextValueVisitor.apply(contextValue, contextPath);\n+      }\n+    };\n+  }\n+\n+  private String appendContextExpression(\n+      final String nestedContext, final List<String> contextPath) {\n+    // for a nested target mapping 'x -> a.b', append the nested property 'b' to\n+    // the existing context variable 'a' (instead of overriding 'a')\n+    // example: x = 1 and a = {'c':2} results in a = {'b':1, 'c':2}\n+    final var existingContext = String.join(\".\", contextPath);\n+    return \"appendTo(\" + existingContext + \",\" + nestedContext + \")\";\n+  }\n+\n+  private Expression parseExpression(\n+      final String contextExpression, final ExpressionLanguage expressionLanguage) {\n+    final var expression =\n+        expressionLanguage.parseExpression(EXPRESSION_MARKER + contextExpression);\n+\n+    if (!expression.isValid()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Failed to build variable mapping expression: %s\", expression.getFailureMessage()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4MjgyMQ=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYyNTMwMA==", "bodyText": "Correct. The exception should only happen if there is a bug in the implementation. Invalid user input should be found during validation.", "url": "https://github.com/camunda-cloud/zeebe/pull/4079#discussion_r397625300", "createdAt": "2020-03-25T06:03:19Z", "author": {"login": "saig0"}, "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/deployment/model/transformer/VariableMappingTransformer.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.deployment.model.transformer;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.el.ExpressionLanguage;\n+import io.zeebe.model.bpmn.instance.zeebe.ZeebeMapping;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Transform variable mappings into an expression.\n+ *\n+ * <p>The resulting expression is a FEEL context that has a similar structure as a JSON document.\n+ * Each target of a mapping is a key in the context and the source of this mapping is the context\n+ * value. The source expression can be any FEEL expression. A nested target expression is\n+ * transformed into a nested context.\n+ *\n+ * <p>Variable mappings:\n+ *\n+ * <pre>\n+ *   source | target\n+ *   =======|=======\n+ *    x     | a\n+ *    y     | b.c\n+ *    z     | b.d\n+ * </pre>\n+ *\n+ * FEEL context expression:\n+ *\n+ * <pre>\n+ *   {\n+ *     a: x,\n+ *     b: {\n+ *       c: y,\n+ *       d: z\n+ *     }\n+ *   }\n+ * </pre>\n+ */\n+public final class VariableMappingTransformer {\n+\n+  private static final String EXPRESSION_MARKER = \"=\";\n+\n+  public Expression transformInputMappings(\n+      final Collection<? extends ZeebeMapping> inputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(inputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression =\n+        asFeelContextExpression(context, (contextValue, contextPath) -> contextValue);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  public Expression transformOutputMappings(\n+      final Collection<? extends ZeebeMapping> outputMappings,\n+      final ExpressionLanguage expressionLanguage) {\n+\n+    final var mappings = toMappings(outputMappings, expressionLanguage);\n+    final var context = asContext(mappings);\n+    final var contextExpression = asFeelContextExpression(context, this::appendContextExpression);\n+    return parseExpression(contextExpression, expressionLanguage);\n+  }\n+\n+  private List<Mapping> toMappings(\n+      final Collection<? extends ZeebeMapping> mappings,\n+      final ExpressionLanguage expressionLanguage) {\n+    return mappings.stream()\n+        .map(\n+            mapping -> {\n+              final var source = mapping.getSource();\n+              final var sourceExpression = expressionLanguage.parseExpression(source);\n+              return new Mapping(sourceExpression, mapping.getTarget());\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MappingContext asContext(final List<Mapping> mappings) {\n+    final var context = new MappingContext();\n+\n+    for (final Mapping mapping : mappings) {\n+      final var sourceExpression = mapping.source;\n+      final var targetPathExpression = mapping.target;\n+\n+      final var targetPathParts = splitPathExpression(targetPathExpression);\n+      createContextEntry(targetPathParts, sourceExpression, context);\n+    }\n+    return context;\n+  }\n+\n+  private List<String> splitPathExpression(final String path) {\n+    final var parts = path.split(\"\\\\.\");\n+    return new ArrayList<>(Arrays.asList(parts));\n+  }\n+\n+  private void createContextEntry(\n+      final List<String> targetPathParts,\n+      final Expression sourceExpression,\n+      final MappingContext context) {\n+    final String target = targetPathParts.remove(0);\n+\n+    if (targetPathParts.isEmpty()) {\n+      context.addEntry(target, sourceExpression);\n+\n+    } else {\n+      final var nestedContext = context.getOrAddContext(target);\n+      createContextEntry(targetPathParts, sourceExpression, nestedContext);\n+    }\n+  }\n+\n+  private String asFeelContextExpression(\n+      final MappingContext context,\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return context.visit(feelContextBuilder(contextValueVisitor));\n+  }\n+\n+  private MappingContextVisitor<String> feelContextBuilder(\n+      final BiFunction<String, List<String>, Object> contextValueVisitor) {\n+    return new MappingContextVisitor<>() {\n+      @Override\n+      public String onEntry(final String targetKey, final Expression sourceExpression) {\n+        return targetKey + \":\" + sourceExpression.getExpression();\n+      }\n+\n+      @Override\n+      public String onContext(final List<String> entries) {\n+        return \"{\" + String.join(\",\", entries) + \"}\";\n+      }\n+\n+      @Override\n+      public String onContextEntry(\n+          final String targetKey, final String contextValue, final List<String> contextPath) {\n+        return targetKey + \":\" + contextValueVisitor.apply(contextValue, contextPath);\n+      }\n+    };\n+  }\n+\n+  private String appendContextExpression(\n+      final String nestedContext, final List<String> contextPath) {\n+    // for a nested target mapping 'x -> a.b', append the nested property 'b' to\n+    // the existing context variable 'a' (instead of overriding 'a')\n+    // example: x = 1 and a = {'c':2} results in a = {'b':1, 'c':2}\n+    final var existingContext = String.join(\".\", contextPath);\n+    return \"appendTo(\" + existingContext + \",\" + nestedContext + \")\";\n+  }\n+\n+  private Expression parseExpression(\n+      final String contextExpression, final ExpressionLanguage expressionLanguage) {\n+    final var expression =\n+        expressionLanguage.parseExpression(EXPRESSION_MARKER + contextExpression);\n+\n+    if (!expression.isValid()) {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Failed to build variable mapping expression: %s\", expression.getFailureMessage()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4MjgyMQ=="}, "originalCommit": {"oid": "9173c252f2a96b472631c7a6b5de51e6c29d5d37"}, "originalPosition": 168}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4932, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}