{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MDA2NjU1", "number": 3852, "title": "chore(broker): add top level health monitor", "bodyText": "Description\n\nset up a health monitor that can monitor partitions\nmake ZeebePartition report some failures to the health monitor\nNote that it cannot detect all failures until all components are monitorable\n\nRelated issues\ncloses #3832\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-02-17T08:34:52Z", "url": "https://github.com/camunda-cloud/zeebe/pull/3852", "merged": true, "mergeCommit": {"oid": "fff771a525442f86c966b2f9c7ea47b1eb8df3ba"}, "closed": true, "closedAt": "2020-02-24T10:45:24Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFJtYWgBqjMwNDI4NzYxMDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHZ9WDgBqjMwNjQ1Nzc3MDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "346a89c4e05fc84d50aed0548259a3fd5ef59c5e", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/346a89c4e05fc84d50aed0548259a3fd5ef59c5e", "committedDate": "2020-02-17T08:28:55Z", "message": "chore(broker): add top level health monitor"}, "afterCommit": {"oid": "5a3ce739e6afb47107b821aaa1f8d624c83ea573", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/5a3ce739e6afb47107b821aaa1f8d624c83ea573", "committedDate": "2020-02-17T09:14:08Z", "message": "chore(broker): add top level health monitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjcyNzg3", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#pullrequestreview-360672787", "createdAt": "2020-02-18T21:07:14Z", "commit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMTowNzoxNFrOFrSbQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMTozNDo0MFrOFrTP5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNDk3OQ==", "bodyText": "Let's maybe rename this to monitoring server now that we do a bunch of things here?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380934979", "createdAt": "2020-02-18T21:07:14Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/Broker.java", "diffHunk": "@@ -257,8 +258,7 @@ private AutoCloseable topologyManagerStep(\n \n   private AutoCloseable metricsServerStep(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNTI5Ng==", "bodyText": "Can this be private?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380935296", "createdAt": "2020-02-18T21:08:00Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -24,18 +28,36 @@\n \n public final class BrokerHealthCheckService extends Actor implements PartitionListener {\n \n+  public static final String PARTITION_COMPONENT_NAME_FORMAT = \"Partition-%d\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNjY4Mw==", "bodyText": "I think this can be private as well", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380936683", "createdAt": "2020-02-18T21:10:38Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzA0OA==", "bodyText": "Let's use the expression lambda syntax where possible (e.g. if a single line, no need to use brackets {)", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937048", "createdAt": "2020-02-18T21:11:18Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(\n+        () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzMzMQ==", "bodyText": "Since we don't expect any results, we can use actor.run", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937331", "createdAt": "2020-02-18T21:11:48Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzQ0MQ==", "bodyText": "I think this isn't called?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937441", "createdAt": "2020-02-18T21:12:01Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,28 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.call(\n+        () -> {\n+          healthMonitor.registerComponent(componentName, component);\n+        });\n+  }\n+\n+  public void registerMonitoredPartition(final int partitionId, final HealthMonitorable partition) {\n+    final String componentName = String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId);\n+    registerComponent(componentName, partition);\n+  }\n+\n+  public HealthStatus getBrokerHealth() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzU2NA==", "bodyText": "I think this can be package-private, as it's only called by a sibling class?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380937564", "createdAt": "2020-02-18T21:12:19Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -24,18 +28,36 @@\n \n public final class BrokerHealthCheckService extends Actor implements PartitionListener {\n \n+  public static final String PARTITION_COMPONENT_NAME_FORMAT = \"Partition-%d\";\n   private static final Logger LOG = Loggers.SYSTEM_LOGGER;\n   private final Atomix atomix;\n   private final String actorName;\n   private Map<Integer, Boolean> partitionInstallStatus;\n   /* set to true when all partitions are installed. Once set to true, it is never\n   changed. */\n   private volatile boolean brokerStarted = false;\n+  private final HealthMonitor healthMonitor;\n \n   public BrokerHealthCheckService(final BrokerInfo localBroker, final Atomix atomix) {\n     this.atomix = atomix;\n     this.actorName = buildActorName(localBroker.getNodeId(), \"HealthCheckService\");\n+    this.healthMonitor = new CriticalComponentsHealthMonitor(actor, LOG);\n     initializePartitionInstallStatus();\n+    initializePartitionHealthStatus();\n+  }\n+\n+  private void initializePartitionHealthStatus() {\n+    final RaftPartitionGroup partitionGroup =\n+        (RaftPartitionGroup) atomix.getPartitionService().getPartitionGroup(GROUP_NAME);\n+    final MemberId nodeId = atomix.getMembershipService().getLocalMember().id();\n+\n+    partitionGroup.getPartitions().stream()\n+        .filter(partition -> partition.members().contains(nodeId))\n+        .map(partition -> partition.id().id())\n+        .forEach(\n+            partitionId ->\n+                healthMonitor.monitorComponent(\n+                    String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId)));\n   }\n \n   public boolean isBrokerReady() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODM0NA==", "bodyText": "Can you elaborate on why the partition itself does not implement FailureListener?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380938344", "createdAt": "2020-02-18T21:13:42Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -533,17 +547,27 @@ public void onActorStarting() {\n                 this.logStream = log;\n                 atomixRaftPartition.getServer().addCommitListener(this);\n                 atomixRaftPartition.addRoleChangeListener(this);\n+                onRecovered();\n                 onRoleChange(atomixRaftPartition.getRole(), atomixRaftPartition.term());\n               } else {\n                 LOG.error(\n                     \"Failed to install log stream service for partition {}\",\n                     atomixRaftPartition.id().id(),\n                     error);\n                 actor.close();\n+                onFailure();\n               }\n             });\n   }\n \n+  @Override\n+  protected void onActorStarted() {\n+    criticalComponentsHealthMonitor.startMonitoring();\n+    criticalComponentsHealthMonitor.addFailureListener(\n+        FailureListener.withListeners(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODczMw==", "bodyText": "Same, as we expect no return value we can use actor.run", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380938733", "createdAt": "2020-02-18T21:14:38Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -569,4 +593,28 @@ public void close() {\n \n     super.close();\n   }\n+\n+  private void onFailure() {\n+    healthStatus.set(HealthStatus.UNHEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private void onRecovered() {\n+    healthStatus.set(HealthStatus.HEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onRecovered();\n+    }\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.call(() -> this.failureListener = failureListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTQ2Nw==", "bodyText": "Do we expect this to be called from a non-actor? If no then we can get rid of the AtomicReference and simply use actor.call and return an ActorFuture<HealthStatus>.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380939467", "createdAt": "2020-02-18T21:16:13Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -569,4 +593,28 @@ public void close() {\n \n     super.close();\n   }\n+\n+  private void onFailure() {\n+    healthStatus.set(HealthStatus.UNHEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private void onRecovered() {\n+    healthStatus.set(HealthStatus.HEALTHY);\n+    if (failureListener != null) {\n+      failureListener.onRecovered();\n+    }\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDE3Nw==", "bodyText": "Could it be an issue to run the monitor in the same an actor which is also doing something else (considering we have no supervisor actors yet)? I guess the ZeebePartition one doesn't really do much so it's probably safe there, but could it be an issue later?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940177", "createdAt": "2020-02-18T21:17:39Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDM0Mw==", "bodyText": "I think null is the default value so it's not necessary to initialize it.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940343", "createdAt": "2020-02-18T21:18:00Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDk2Mw==", "bodyText": "Same as others (and below), we can probably use actor.run", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380940963", "createdAt": "2020-02-18T21:19:16Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MTI2Nw==", "bodyText": "You can call forEach directly on a set, e.g. componentHealth.keySet().forEach(", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380941267", "createdAt": "2020-02-18T21:19:58Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MTYzMA==", "bodyText": "Not sure if the re is necessary, it's the same behaviour whether we calculate for the first time or not?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380941630", "createdAt": "2020-02-18T21:20:46Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDU5Nw==", "bodyText": "Should we notify the listener if we go from UNHEALTHY to UNHEALTHY again? Not saying we shouldn't, I'm simply not sure what we want to do - notify of every new failure, notify only of status changes?\nShould we notify that we recovered?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380944597", "createdAt": "2020-02-18T21:26:57Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {\n+    final boolean healthy =\n+        componentHealth.values().stream()\n+            .allMatch(healthStatus -> healthStatus == HealthStatus.HEALTHY);\n+    healthStatus.set(healthy ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY);\n+    if (!healthy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NDc2MA==", "bodyText": "Alternative impl:\nfinal var status = componentHealth.containsValue(HealthStatus.UNHEALTHY) ? HealthStatus.UNHEALTHY : HealthStatus.HEALTHY;\n    final var previousStatus = healthStatus.getAndSet(status);\n\n    if (failureListener != null && previousStatus != status) {\n      switch (status) {\n        case HEALTHY:\n          failureListener.onRecovered();\n          break;\n        case UNHEALTHY:\n          failureListener.onFailure();\n          break;\n      }\n    }", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380944760", "createdAt": "2020-02-18T21:27:17Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NTg0NQ==", "bodyText": "Is this possible? It would be a bug if it happened, no? Then we probably want to log when it is actually null.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380945845", "createdAt": "2020-02-18T21:29:28Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private final AtomicReference<HealthStatus> healthStatus = new AtomicReference<>();\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+    this.failureListener = null;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(\n+              FailureListener.withListeners(\n+                  () -> onComponentFailure(componentName),\n+                  () -> onComponentRecovered(componentName)));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus.get();\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          reCalculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.call(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth.keySet().stream()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    reCalculateHealth();\n+  }\n+\n+  private void reCalculateHealth() {\n+    final boolean healthy =\n+        componentHealth.values().stream()\n+            .allMatch(healthStatus -> healthStatus == HealthStatus.HEALTHY);\n+    healthStatus.set(healthy ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY);\n+    if (!healthy) {\n+      notifyFailureListener();\n+    }\n+  }\n+\n+  private void notifyFailureListener() {\n+    if (this.failureListener != null) {\n+      failureListener.onFailure();\n+    }\n+  }\n+\n+  private HealthStatus getHealth(final String componentName) {\n+    final HealthMonitorable component = monitoredComponents.get(componentName);\n+    if (component != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NjI1Mg==", "bodyText": "Considering this is a public interface that might be implemented by others, it might make sense to document the intent and its contract(s).", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380946252", "createdAt": "2020-02-18T21:30:17Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0NzY1Mg==", "bodyText": "What is the advantage of creating an anonymous class from two runnables over a class implementing this interface?\npublic class MySuperListener implements FailureListener {\n  @Override\n  public void onFailure() {\n    // do stuff\n  }\n  \n  @Override\n  public void onRecovered() {\n    // do other stuff\n  }\n}\nIf the issue is with name collisions, we can make the name more specific - call the interface HealthMonitorableListener and have the method be onHealthMonitorableFailure() and onHealthMonitorableRecovery().", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380947652", "createdAt": "2020-02-18T21:33:07Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {\n+  void onFailure();\n+\n+  void onRecovered();\n+\n+  static FailureListener withListeners(final Runnable onFailure, final Runnable onRecovered) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0ODA2NA==", "bodyText": "Could it make sense to pass the failure itself (e.g. Throwable I guess?), and the component which triggered this? That way implementations can be react on different failures, and also be reused for different components.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380948064", "createdAt": "2020-02-18T21:33:53Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/FailureListener.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+public interface FailureListener {\n+  void onFailure();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0ODQ1Mw==", "bodyText": "I like this - however it seems some of the documentation is missing?", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r380948453", "createdAt": "2020-02-18T21:34:40Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/HealthMonitor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+/**\n+ * A HealthMonitor keeps tracks of all components it should monitor and calculates aggregate health\n+ * status.\n+ */\n+public interface HealthMonitor extends HealthMonitorable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79989c8c3a2fc8b0365ee393458d582cf2b74849"}, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "057a8561a876f5ba9961fea37abc774c6c22df5c", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/057a8561a876f5ba9961fea37abc774c6c22df5c", "committedDate": "2020-02-19T11:56:26Z", "message": "chore(broker): review comment"}, "afterCommit": {"oid": "e52e2a93f74698ce549fe5e952866f3f224965e7", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e52e2a93f74698ce549fe5e952866f3f224965e7", "committedDate": "2020-02-19T12:05:09Z", "message": "chore(broker): review comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf430c28e061746b8021d5eef1216a76162087c8", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/bf430c28e061746b8021d5eef1216a76162087c8", "committedDate": "2020-02-19T12:51:09Z", "message": "chore(qa): add comments"}, "afterCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/5f8d8d3972db5e3484e23a07f374957daa88bd6b", "committedDate": "2020-02-19T13:29:48Z", "message": "chore(broker): review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzg5Nzc5", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#pullrequestreview-361789779", "createdAt": "2020-02-20T10:28:03Z", "commit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMDoyODowM1rOFsOCPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMDo1MjoyN1rOFsO0lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTYxMw==", "bodyText": "Can we also add the TODO comment pointing to the follow up issue where we can remove this (since we will use the HTTP endpoint?).", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381911613", "createdAt": "2020-02-20T10:28:03Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/Broker.java", "diffHunk": "@@ -117,6 +118,13 @@ public void addPartitionListener(final PartitionListener listener) {\n     return startFuture;\n   }\n \n+  public boolean isHealthy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTkwNw==", "bodyText": "Or would it make sense for the Broker to also be HealthMonitorable? \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381911907", "createdAt": "2020-02-20T10:28:35Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/Broker.java", "diffHunk": "@@ -117,6 +118,13 @@ public void addPartitionListener(final PartitionListener listener) {\n     return startFuture;\n   }\n \n+  public boolean isHealthy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkxMTYxMw=="}, "originalCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyMjQ0OA==", "bodyText": "Nit: it's maybe more read-able to express this as a guard clause, in which case you'd want to have the branch for the invariant and not the \"common\" case.\ne.g.\nif (!isBrokerReady()) {\n  return HealthStatus.UNHEALTHY;\n}\n\nreturn healthMonitor.getHealthStatus();", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381922448", "createdAt": "2020-02-20T10:48:29Z", "author": {"login": "npepinpe"}, "path": "broker/src/main/java/io/zeebe/broker/system/monitoring/BrokerHealthCheckService.java", "diffHunk": "@@ -83,4 +105,29 @@ private void initializePartitionInstallStatus() {\n   public String getName() {\n     return actorName;\n   }\n+\n+  @Override\n+  protected void onActorStarted() {\n+    healthMonitor.startMonitoring();\n+  }\n+\n+  private void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(() -> healthMonitor.registerComponent(componentName, component));\n+  }\n+\n+  public void registerMonitoredPartition(final int partitionId, final HealthMonitorable partition) {\n+    final String componentName = String.format(PARTITION_COMPONENT_NAME_FORMAT, partitionId);\n+    registerComponent(componentName, partition);\n+  }\n+\n+  public boolean isBrokerHealthy() {\n+    return !actor.isClosed() && getBrokerHealth() == HealthStatus.HEALTHY;\n+  }\n+\n+  private HealthStatus getBrokerHealth() {\n+    if (isBrokerReady()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyMzcxMg==", "bodyText": "Here and above, I would add a warn logging - in the case we ever add more health statuses, then we'd immediately be aware of it.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381923712", "createdAt": "2020-02-20T10:50:53Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private volatile HealthStatus healthStatus = HealthStatus.UNHEALTHY;\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(new ComponentFailureListener(componentName));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+          calculateHealth();\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          calculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} recovered, marking it as healthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.HEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth\n+        .keySet()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    calculateHealth();\n+  }\n+\n+  private void calculateHealth() {\n+    final var status =\n+        componentHealth.containsValue(HealthStatus.UNHEALTHY)\n+            ? HealthStatus.UNHEALTHY\n+            : HealthStatus.HEALTHY;\n+    final var previousStatus = healthStatus;\n+    healthStatus = status;\n+\n+    if (failureListener != null && previousStatus != status) {\n+      switch (status) {\n+        case HEALTHY:\n+          failureListener.onRecovered();\n+          break;\n+        case UNHEALTHY:\n+          failureListener.onFailure();\n+          break;\n+        default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkyNDUwMQ==", "bodyText": "I guess here would have been a good case for us to actually have the failure listener propagate the component has argument on failure and on recovered. What do you think? Then you don't need a component listener for each component, the monitor can be a single listener.\nI'm fine with this implementation for the first iteration, but we could think about it.", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#discussion_r381924501", "createdAt": "2020-02-20T10:52:27Z", "author": {"login": "npepinpe"}, "path": "util/src/main/java/io/zeebe/util/health/CriticalComponentsHealthMonitor.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.health;\n+\n+import io.zeebe.util.sched.ActorControl;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+\n+/** Healthy only if all components are healthy */\n+public class CriticalComponentsHealthMonitor implements HealthMonitor {\n+  private static final Duration HEALTH_MONITORING_PERIOD = Duration.ofSeconds(60);\n+  private final Map<String, HealthMonitorable> monitoredComponents = new HashMap<>();\n+  private final Map<String, HealthStatus> componentHealth = new HashMap<>();\n+  private volatile HealthStatus healthStatus = HealthStatus.UNHEALTHY;\n+  private final ActorControl actor;\n+  private final Logger log;\n+  private FailureListener failureListener;\n+\n+  public CriticalComponentsHealthMonitor(final ActorControl actor, final Logger log) {\n+    this.actor = actor;\n+    this.log = log;\n+  }\n+\n+  public void startMonitoring() {\n+    actor.runAtFixedRate(HEALTH_MONITORING_PERIOD, this::updateHealth);\n+  }\n+\n+  @Override\n+  public void monitorComponent(final String componentName) {\n+    actor.run(() -> componentHealth.put(componentName, HealthStatus.UNHEALTHY));\n+  }\n+\n+  @Override\n+  public void removeComponent(final String componentName) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.remove(componentName);\n+          componentHealth.remove(componentName);\n+        });\n+  }\n+\n+  @Override\n+  public void registerComponent(final String componentName, final HealthMonitorable component) {\n+    actor.run(\n+        () -> {\n+          monitoredComponents.put(componentName, component);\n+          component.addFailureListener(new ComponentFailureListener(componentName));\n+          componentHealth.put(componentName, component.getHealthStatus());\n+          calculateHealth();\n+        });\n+  }\n+\n+  @Override\n+  public HealthStatus getHealthStatus() {\n+    return healthStatus;\n+  }\n+\n+  @Override\n+  public void addFailureListener(final FailureListener failureListener) {\n+    actor.run(() -> this.failureListener = failureListener);\n+  }\n+\n+  private void onComponentFailure(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} failed, marking it as unhealthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.UNHEALTHY);\n+          calculateHealth();\n+        });\n+  }\n+\n+  private void onComponentRecovered(final String componentName) {\n+    actor.run(\n+        () -> {\n+          log.error(\"{} recovered, marking it as healthy\", componentName);\n+          componentHealth.put(componentName, HealthStatus.HEALTHY);\n+        });\n+  }\n+\n+  private void updateHealth() {\n+    componentHealth\n+        .keySet()\n+        .forEach(component -> componentHealth.put(component, getHealth(component)));\n+    calculateHealth();\n+  }\n+\n+  private void calculateHealth() {\n+    final var status =\n+        componentHealth.containsValue(HealthStatus.UNHEALTHY)\n+            ? HealthStatus.UNHEALTHY\n+            : HealthStatus.HEALTHY;\n+    final var previousStatus = healthStatus;\n+    healthStatus = status;\n+\n+    if (failureListener != null && previousStatus != status) {\n+      switch (status) {\n+        case HEALTHY:\n+          failureListener.onRecovered();\n+          break;\n+        case UNHEALTHY:\n+          failureListener.onFailure();\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+  }\n+\n+  private HealthStatus getHealth(final String componentName) {\n+    final HealthMonitorable component = monitoredComponents.get(componentName);\n+    if (component != null) {\n+      return component.getHealthStatus();\n+    }\n+    return HealthStatus.UNHEALTHY;\n+  }\n+\n+  class ComponentFailureListener implements FailureListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f8d8d3972db5e3484e23a07f374957daa88bd6b"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjMzMzg1", "url": "https://github.com/camunda-cloud/zeebe/pull/3852#pullrequestreview-363233385", "createdAt": "2020-02-24T08:53:55Z", "commit": {"oid": "7fa37b7919adab28979826783927f433a5ff62be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efef34a467d82adeca68ce2003d6a081502576a6", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/efef34a467d82adeca68ce2003d6a081502576a6", "committedDate": "2020-02-24T09:15:44Z", "message": "chore(broker): add top level health monitor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fa37b7919adab28979826783927f433a5ff62be", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/7fa37b7919adab28979826783927f433a5ff62be", "committedDate": "2020-02-24T08:44:52Z", "message": "chore(broker): review comments"}, "afterCommit": {"oid": "efef34a467d82adeca68ce2003d6a081502576a6", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/efef34a467d82adeca68ce2003d6a081502576a6", "committedDate": "2020-02-24T09:15:44Z", "message": "chore(broker): add top level health monitor"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3136, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}