{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NDQwODgy", "number": 5191, "title": "Fix race condition between reprocessing and pausing stream processor", "bodyText": "Description\nAdd new reprocessing tests to reproduce two bugs, which happen during reprocessing and pausing/resuming the stream processor. Changed default behavior of stopping stream processor, after closing stream processor runtime is deleted.\nDeletion of runtime actually causes reprocessing, before it hasn't happened.\nAdd new method to take snapshot explicitly in test, to test recovery with snapshot.\nThe bug issue happened during reprocessing, when the stream processor was paused. It happen that after reprocessing the state was reset to processing, instead of paused. If resuming before reprocessing was done, this caused NPE's, since processors/listeners haven't been initialized yet.\nChanged stream processor life cycle aware guarantees, it is now guaranteed that onRecovered is called as first method. After that onPaused can happen and onResume. Before we haven't had these guarantees.\nRelated issues\n\ncloses #5156\ncloses #5149\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-08-18T11:38:33Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5191", "merged": true, "mergeCommit": {"oid": "c09e656d0a25e3d4faba0b80c8881247e836c51b"}, "closed": true, "closedAt": "2020-08-21T11:20:28Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAYQWegFqTQ3MDExNTk4MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBB8zugBqjM2Nzg5MzExMTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMTE1OTgw", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#pullrequestreview-470115980", "createdAt": "2020-08-19T04:27:36Z", "commit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNDozMjowM1rOHCyD1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTozMDo1NVrOHC_L9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3OTM4MA==", "bodyText": "This constant is used inside the class only.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String SNAPSHOT_FOLDER = \"snapshot\";\n          \n          \n            \n              private static final String SNAPSHOT_FOLDER = \"snapshot\";", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472679380", "createdAt": "2020-08-19T04:32:03Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/util/TestStreams.java", "diffHunk": "@@ -54,6 +55,9 @@\n import org.junit.rules.TemporaryFolder;\n \n public final class TestStreams {\n+\n+  public static final String SNAPSHOT_FOLDER = \"snapshot\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY5NzE4OA==", "bodyText": "Replace magic number 1 with a constant.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472697188", "createdAt": "2020-08-19T05:01:05Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+\n+    // when\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // then\n+    Assert.assertThrows(\n+        StreamWrapperException.class,\n+        () -> engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create());\n+  }\n+\n+  @Test\n+  public void shouldContinueAfterReprocessWhenProcessingWasResumed() {\n+    // given\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+    engineRule.resumeProcessing(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMTg5Nw==", "bodyText": "Unused fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final String ELEMENT_ID = \"task\";\n          \n          \n            \n              private static final String JOB_TYPE = \"test\";\n          \n          \n            \n              private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472701897", "createdAt": "2020-08-19T05:08:53Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMzYzMQ==", "bodyText": "We need to limit the stream to avoid waiting for new records.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .count(),\n          \n          \n            \n                                .limit(100)\n          \n          \n            \n                                .count(),", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472703631", "createdAt": "2020-08-19T05:11:30Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwNTE0Mw==", "bodyText": "Why do we need random variables for the test?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472705143", "createdAt": "2020-08-19T05:13:57Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ==", "bodyText": "This test takes ~6 seconds. It waits until the instance is created which will not happen. It would be nice to avoid this waiting time.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472720761", "createdAt": "2020-08-19T05:38:26Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Nzg5OQ==", "bodyText": "Please add some visual separation. I oversaw the statement \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472887899", "createdAt": "2020-08-19T09:20:55Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ==", "bodyText": "I don't like to verify the behavior by exposing an internal state. Maybe, the currentPhase is set correctly but the processor behaves wrong.\nCan we test the behavior instead? Like in the other test, write a record and verify that it is not read by the stream processor.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472891709", "createdAt": "2020-08-19T09:26:39Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw==", "bodyText": "Can we add a test to verify that the StreamProcessorLifecycleAware is not invoked before reprocessing is done?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472894453", "createdAt": "2020-08-19T09:30:55Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+  }\n+\n+  @Test\n+  public void shouldSwitchToProcessingAfterReprocessingWhenResumed() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    streamProcessor.resumeProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PROCESSING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzQ1MTAy", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#pullrequestreview-472345102", "createdAt": "2020-08-21T09:31:32Z", "commit": {"oid": "7d876e2570c4007c19f4f57c4c308c895d63481e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozMTozMlrOHEl4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozMTozMlrOHEl4vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3NzA4NQ==", "bodyText": "You can use never() instead of times(0).", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r474577085", "createdAt": "2020-08-21T09:31:32Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -111,28 +111,37 @@ public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exce\n             StreamWrapper::exists);\n \n     final var onRecoveredLatch = new CountDownLatch(1);\n+    final var typedRecordProcessor = mock(TypedRecordProcessor.class);\n     final var streamProcessor =\n         streamProcessorRule.startTypedStreamProcessor(\n             (processors, context) ->\n-                processors.withListener(\n-                    new StreamProcessorLifecycleAware() {\n-                      @Override\n-                      public void onRecovered(final ReadonlyProcessingContext context) {\n-                        onRecoveredLatch.countDown();\n-                      }\n-                    }));\n+                processors\n+                    .onEvent(ValueType.WORKFLOW_INSTANCE, ELEMENT_ACTIVATING, typedRecordProcessor)\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            onRecoveredLatch.countDown();\n+                          }\n+                        }));\n+\n     // when\n     streamProcessor.pauseProcessing();\n     final var success = onRecoveredLatch.await(15, TimeUnit.SECONDS);\n \n     // then\n     assertThat(success).isTrue();\n-    final var currentPhase = streamProcessor.getCurrentPhase().join();\n-    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+    Mockito.clearInvocations(typedRecordProcessor);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 0xcafe);\n+\n+    verify(typedRecordProcessor, TIMEOUT.times(0))\n+        .processRecord(anyLong(), any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d876e2570c4007c19f4f57c4c308c895d63481e"}, "originalPosition": 64}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d876e2570c4007c19f4f57c4c308c895d63481e", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/7d876e2570c4007c19f4f57c4c308c895d63481e", "committedDate": "2020-08-21T09:25:16Z", "message": "chore(engine): apply review hints"}, "afterCommit": {"oid": "a95301864f98f044857cb9e925da1d1410bed180", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/a95301864f98f044857cb9e925da1d1410bed180", "committedDate": "2020-08-21T10:04:01Z", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "275146fc78a76922d350fd5a5752200d32953691", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/275146fc78a76922d350fd5a5752200d32953691", "committedDate": "2020-08-21T10:07:18Z", "message": "chore(engine): create new reprocessing tests\n\n New reprocessing tests to reproduce two bugs, which happen during\n reprocessing and pausing/resuming the stream processor.\n\n Changed default, after closing stream processor runtime is deleted.\n Deletion of runtime actually causes reprocessing, before it hasn't\n happened.\n\n Add new method to take snapshot explicitly in test, to test recovery\n with snapshot."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fd20dff6d7aebc3c168b982307621a968086027", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/7fd20dff6d7aebc3c168b982307621a968086027", "committedDate": "2020-08-21T10:07:18Z", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a95301864f98f044857cb9e925da1d1410bed180", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/a95301864f98f044857cb9e925da1d1410bed180", "committedDate": "2020-08-21T10:04:01Z", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume."}, "afterCommit": {"oid": "7fd20dff6d7aebc3c168b982307621a968086027", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/7fd20dff6d7aebc3c168b982307621a968086027", "committedDate": "2020-08-21T10:07:18Z", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2554, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}