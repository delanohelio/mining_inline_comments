{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzEzNDE4", "number": 3928, "title": "Introduce new ZeebeIndex", "bodyText": "Description\nNOTE: The build will fail until zeebe-io/atomix#165 is merged\nIn order to improve seek performance and reduce log deletion time,\nwe introducing a new ZeebeIndex. This index wraps the Atomix\nSparseJournalIndex and builds an own map of position to index.\nWith this index it is easily and in a performant way possible to look\nup an index/address for a given position. This look up is used\nfor example on deletion instead of the old seek strategy. This treats\ntime against space, which means we need to use more space in memory but\nare fast to find an index/position.\nThe ZeebeIndex is on startup injected into the RaftPartition such that\nis filled on leader and follower on appending new entries.\nThe underlying data structure needs to be thread safe, since we access\nit on different threads.\nBe aware that it is currently just created on Broker startup and injected into the partition before opening them. I plan to refactor the Broker bootstrap and ZeebePartition with #3519 and #3518 where I then also rewrite this a bit.\nBenchmark\nI run a benchmarks with the final changes and it looks like this:\nGeneral\n\nWe can see that it looks more stable then the latest benchmarks.\nResources\n\nThe memory consumption is as expected and shows that the map is correctly cleaned up on every deletion/compaction.\n\nNo changes in CPU usage.\n\nThe disk space is correctly cleaned up.\n\nWe can see much less IO load or at least much less read bytes per second every 15 min (which is the snapshot interval). Before we had between 60 - 100 Mb/s now we have between 1 to 8 Mb/s.\nIn benchmarks before I logged how much time it takes to seeking/find the right index. In the first benchmarks it took from 4  to 22 seconds. With introducing the map we can find an approximate index in ~ 1 ms. I also removed the seek to position before deletion since it is not really necessary.\nBenchmark without the map\n\nIn this benchmark we seeing much more the recurring throughput pattern. I'm not 100% sure why in this benchmark the throughput is in general higher as in the other. I probably need to investigate that.\n\nMemory consumption looks different without the mapping.\n\nHere we can see the high spikes of read bytes per s.\nRelated issues\n\ncloses #3918\ncloses #3623\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-02-26T14:35:03Z", "url": "https://github.com/camunda-cloud/zeebe/pull/3928", "merged": true, "mergeCommit": {"oid": "b165da82c4eb9d2825f6c18d73a9b93870e05b66"}, "closed": true, "closedAt": "2020-03-09T06:27:08Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIrVI4gBqjMwODA5MDE4MDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKuLg2AFqTM2OTcyNDg3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71c40ad9ba827d94723d0d6dd14ce0dbd9138339", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/71c40ad9ba827d94723d0d6dd14ce0dbd9138339", "committedDate": "2020-02-26T14:08:33Z", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads."}, "afterCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/ffdb780c8c6be420caba4d029001b8d3ea9d5065", "committedDate": "2020-02-28T06:55:42Z", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDk1Nzkw", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#pullrequestreview-368095790", "createdAt": "2020-03-03T15:50:22Z", "commit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1MDoyMlrOFxLe0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODoxNFrOFxNKlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExMjY1Ng==", "bodyText": "Can use floorEntry()\n   public long lookupPosition(final long position) {\n    final var lowerEntry = positionIndexMapping.floorEntry(position);\n    if (lowerEntry != null) {\n      return lowerEntry.getValue();\n    }\n    return -1;\n  }", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387112656", "createdAt": "2020-03-03T15:50:22Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexAdapter.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.index.JournalIndex;\n+import io.atomix.storage.journal.index.Position;\n+import io.atomix.storage.journal.index.SparseJournalIndex;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+public final class ZeebeIndexAdapter implements JournalIndex, ZeebeIndexMapping {\n+\n+  private final ConcurrentNavigableMap<Long, Long> positionIndexMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final ConcurrentNavigableMap<Long, Long> indexPositionMapping =\n+      new ConcurrentSkipListMap<>();\n+  private final SparseJournalIndex sparseJournalIndex;\n+  private final int density;\n+\n+  private ZeebeIndexAdapter(int density) {\n+    this.density = density;\n+    sparseJournalIndex = new SparseJournalIndex(density);\n+  }\n+\n+  public static ZeebeIndexAdapter ofDensity(int density) {\n+    return new ZeebeIndexAdapter(density);\n+  }\n+\n+  @Override\n+  public void index(final Indexed indexedEntry, final int position) {\n+    final var index = indexedEntry.index();\n+    if (index % density == 0) {\n+      if (indexedEntry.type() == ZeebeEntry.class) {\n+        final ZeebeEntry zeebeEntry = (ZeebeEntry) indexedEntry.entry();\n+        final var lowestPosition = zeebeEntry.lowestPosition();\n+\n+        positionIndexMapping.put(lowestPosition, index);\n+        indexPositionMapping.put(index, lowestPosition);\n+      }\n+    }\n+\n+    sparseJournalIndex.index(indexedEntry, position);\n+  }\n+\n+  @Override\n+  public long lookupPosition(final long position) {\n+    var index = positionIndexMapping.getOrDefault(position, -1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExNjY0OA==", "bodyText": "Just for completeness may be test one at exact position.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);\n          \n          \n            \n                assertThat(zeebeIndexAdapter.lookupPosition(20)).isEqualTo(5);", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387116648", "createdAt": "2020-03-03T15:56:02Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/storage/atomix/ZeebeIndexTest.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.logstreams.storage.atomix;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.protocols.raft.storage.log.entry.InitializeEntry;\n+import io.atomix.protocols.raft.zeebe.ZeebeEntry;\n+import io.atomix.storage.journal.Indexed;\n+import java.nio.ByteBuffer;\n+import org.junit.Test;\n+\n+public class ZeebeIndexTest {\n+\n+  @Test\n+  public void shouldNotFindIndexWhenNotReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    final var index = zeebeIndexAdapter.lookupPosition(1L);\n+\n+    // then\n+    assertThat(index).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void shouldFindIndexWhenReachedDensity() {\n+    // given - every 5 index is added\n+    final ZeebeIndexAdapter zeebeIndexAdapter = ZeebeIndexAdapter.ofDensity(5);\n+\n+    // when\n+    zeebeIndexAdapter.index(asZeebeEntry(1, 1), 2);\n+    zeebeIndexAdapter.index(asZeebeEntry(2, 5), 4);\n+    zeebeIndexAdapter.index(asZeebeEntry(3, 10), 6);\n+    zeebeIndexAdapter.index(asZeebeEntry(4, 15), 8);\n+    zeebeIndexAdapter.index(asZeebeEntry(5, 20), 10);\n+\n+    // then\n+    assertThat(zeebeIndexAdapter.lookupPosition(1)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(16)).isEqualTo(-1);\n+    assertThat(zeebeIndexAdapter.lookupPosition(21)).isEqualTo(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzODcyNA==", "bodyText": "Can we use atomixLogStorage.newReader()?", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387138724", "createdAt": "2020-03-03T16:26:13Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -312,8 +316,10 @@ private StateSnapshotController createSnapshotController() {\n   }\n \n   private SnapshotStorage createSnapshotStorage() {\n+\n     final var reader =\n-        new AtomixLogStorageReader(atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));\n+        new AtomixLogStorageReader(\n+            zeebeIndexMapping, atomixRaftPartition.getServer().openReader(-1, Mode.COMMITS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDI0Nw==", "bodyText": "This returns an address <= the current address, right? It will be better explained in the doc.", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#discussion_r387140247", "createdAt": "2020-03-03T16:28:14Z", "author": {"login": "deepthidevaki"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/log/LogStreamReader.java", "diffHunk": "@@ -64,14 +64,14 @@\n   long getPosition();\n \n   /**\n-   * The last log storage address, from which the last block of events was read.\n-   *\n-   * <p>Useful if you want to found out the related block address, then just seek to a given\n-   * position and call this method.\n+   * Look up the nearest log storage address, where the entry with the given position can be found.\n+   * The implementation do not need to provide the exact log event address, it is more about an\n+   * approximation, which can then be used to find the entry.\n    *\n    * <p>*Note:* The returned address is not the exact log event address.\n    *\n-   * @return the last log storage address, from which the last block of events was read.\n+   * @param position the position, for which the look up should made\n+   * @return the approximated address in the log storage\n    */\n-  long lastReadAddress();\n+  long lookupAddress(long position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdb780c8c6be420caba4d029001b8d3ea9d5065"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa169cc18a4dd3f295d681a9f9baa507df61d968", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/fa169cc18a4dd3f295d681a9f9baa507df61d968", "committedDate": "2020-03-05T13:15:04Z", "message": "chore(util): set cause exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/fb6187c9a99fceba0ea1afd2aba537b19cfea4ae", "committedDate": "2020-03-05T13:16:37Z", "message": "chore(logstreams): introduce new ZeebeIndex\n\n In order to improve seek performance and reduce log deletion time,\n we introducing a new ZeebeIndex. This index wraps the Atomix\n SparseJournalIndex and builds an own map of position to index.\n\n With this index it is easily and in a performant way possible to look\n up an index/address for a given position. This look up is used\n for example on deletion instead of the old seek strategy. This treats\n time against space, which means we need to use more space in memory but\n are fast to find an index/position.\n\n The ZeebeIndex is on startup injected into the RaftPartition such that\n is filled on leader and follower on appending new entries.\n\n The underlying data structure needs to be thread safe, since we access\n it on different threads."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "committedDate": "2020-03-05T13:16:37Z", "message": "chore(logstreams): follow review hints"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a998319887a8393dc19209d616752abae70dfe4", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/8a998319887a8393dc19209d616752abae70dfe4", "committedDate": "2020-03-05T13:14:06Z", "message": "chore(logstreams): follow review hints"}, "afterCommit": {"oid": "564a742c87161fbd8a5491480321edd381ae5d14", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/564a742c87161fbd8a5491480321edd381ae5d14", "committedDate": "2020-03-05T13:16:37Z", "message": "chore(logstreams): follow review hints"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzI0ODc4", "url": "https://github.com/camunda-cloud/zeebe/pull/3928#pullrequestreview-369724878", "createdAt": "2020-03-05T16:33:32Z", "commit": {"oid": "564a742c87161fbd8a5491480321edd381ae5d14"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3172, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}