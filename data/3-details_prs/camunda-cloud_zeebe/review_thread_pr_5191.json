{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NDQwODgy", "number": 5191, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNDozMjowM1rOEZxZYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozMTozMlrOEa5MHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDU5MTcwOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/util/TestStreams.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNDozMjowM1rOHCyD1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNDozMjowM1rOHCyD1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3OTM4MA==", "bodyText": "This constant is used inside the class only.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String SNAPSHOT_FOLDER = \"snapshot\";\n          \n          \n            \n              private static final String SNAPSHOT_FOLDER = \"snapshot\";", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472679380", "createdAt": "2020-08-19T04:32:03Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/util/TestStreams.java", "diffHunk": "@@ -54,6 +55,9 @@\n import org.junit.rules.TemporaryFolder;\n \n public final class TestStreams {\n+\n+  public static final String SNAPSHOT_FOLDER = \"snapshot\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDY5NTYxOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTowMTowNVrOHCzJZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTowMTowNVrOHCzJZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY5NzE4OA==", "bodyText": "Replace magic number 1 with a constant.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472697188", "createdAt": "2020-08-19T05:01:05Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+\n+    // when\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // then\n+    Assert.assertThrows(\n+        StreamWrapperException.class,\n+        () -> engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create());\n+  }\n+\n+  @Test\n+  public void shouldContinueAfterReprocessWhenProcessingWasResumed() {\n+    // given\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+    engineRule.resumeProcessing(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDcyMjgwOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTowODo1M1rOHCzbyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTowODo1M1rOHCzbyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMTg5Nw==", "bodyText": "Unused fields.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final String ELEMENT_ID = \"task\";\n          \n          \n            \n              private static final String JOB_TYPE = \"test\";\n          \n          \n            \n              private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472701897", "createdAt": "2020-08-19T05:08:53Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDczMjg1OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNToxMTozMFrOHCzijw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTo1OToxM1rOHDAKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMzYzMQ==", "bodyText": "We need to limit the stream to avoid waiting for new records.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .count(),\n          \n          \n            \n                                .limit(100)\n          \n          \n            \n                                .count(),", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472703631", "createdAt": "2020-08-19T05:11:30Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDQ3NA==", "bodyText": "ah thanks", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472910474", "createdAt": "2020-08-19T09:59:13Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMzYzMQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDc0MTQ5OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNToxMzo1N1rOHCzodw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTo1OTo1OFrOHDAMPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwNTE0Mw==", "bodyText": "Why do we need random variables for the test?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472705143", "createdAt": "2020-08-19T05:13:57Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDkwOA==", "bodyText": "Tbh I just played a bit around to make the reprocessing take a bit longer. What is your concern? Actually we can build it once.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472910908", "createdAt": "2020-08-19T09:59:58Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwNTE0Mw=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDgzMjc2OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTozODoyNlrOHC0leQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMTozNToyMFrOHDDSgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ==", "bodyText": "This test takes ~6 seconds. It waits until the instance is created which will not happen. It would be nice to avoid this waiting time.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472720761", "createdAt": "2020-08-19T05:38:26Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTAxNg==", "bodyText": "How?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472911016", "createdAt": "2020-08-19T10:00:10Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MTY2NQ==", "bodyText": "I don't know \ud83d\ude48", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472961665", "createdAt": "2020-08-19T11:35:20Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTg0MzQ5OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOToyMDo1NVrOHC-yWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMDoyMDoxNFrOHDA4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Nzg5OQ==", "bodyText": "Please add some visual separation. I oversaw the statement \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472887899", "createdAt": "2020-08-19T09:20:55Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMjE2MQ==", "bodyText": "valid point :D", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472922161", "createdAt": "2020-08-19T10:20:14Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Nzg5OQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTg2OTIzOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOToyNjozOVrOHC_BPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMTozNDo0OFrOHDDRRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ==", "bodyText": "I don't like to verify the behavior by exposing an internal state. Maybe, the currentPhase is set correctly but the processor behaves wrong.\nCan we test the behavior instead? Like in the other test, write a record and verify that it is not read by the stream processor.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472891709", "createdAt": "2020-08-19T09:26:39Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTYzMw==", "bodyText": "Then we have the same issue as above right long timeout? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472911633", "createdAt": "2020-08-19T10:01:16Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MTM1MQ==", "bodyText": "\ud83d\ude48", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472961351", "createdAt": "2020-08-19T11:34:48Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTg4NzQ2OnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTozMDo1NVrOHC_L9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMTozMzo1NFrOHDDPfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw==", "bodyText": "Can we add a test to verify that the StreamProcessorLifecycleAware is not invoked before reprocessing is done?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472894453", "createdAt": "2020-08-19T09:30:55Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+  }\n+\n+  @Test\n+  public void shouldSwitchToProcessingAfterReprocessingWhenResumed() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    streamProcessor.resumeProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PROCESSING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMTk4NQ==", "bodyText": "Via Mockito? Or how you would do that?", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472921985", "createdAt": "2020-08-19T10:19:56Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+  }\n+\n+  @Test\n+  public void shouldSwitchToProcessingAfterReprocessingWhenResumed() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    streamProcessor.resumeProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PROCESSING);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MDg5Mw==", "bodyText": "Yes. Or, using a simple list and add the invocations in the list.", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472960893", "createdAt": "2020-08-19T11:33:54Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+  }\n+\n+  @Test\n+  public void shouldSwitchToProcessingAfterReprocessingWhenResumed() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    streamProcessor.resumeProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PROCESSING);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw=="}, "originalCommit": {"oid": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NjM1NDIwOnYy", "diffSide": "RIGHT", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozMTozMlrOHEl4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozNzoxMVrOHEmNPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3NzA4NQ==", "bodyText": "You can use never() instead of times(0).", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r474577085", "createdAt": "2020-08-21T09:31:32Z", "author": {"login": "saig0"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -111,28 +111,37 @@ public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exce\n             StreamWrapper::exists);\n \n     final var onRecoveredLatch = new CountDownLatch(1);\n+    final var typedRecordProcessor = mock(TypedRecordProcessor.class);\n     final var streamProcessor =\n         streamProcessorRule.startTypedStreamProcessor(\n             (processors, context) ->\n-                processors.withListener(\n-                    new StreamProcessorLifecycleAware() {\n-                      @Override\n-                      public void onRecovered(final ReadonlyProcessingContext context) {\n-                        onRecoveredLatch.countDown();\n-                      }\n-                    }));\n+                processors\n+                    .onEvent(ValueType.WORKFLOW_INSTANCE, ELEMENT_ACTIVATING, typedRecordProcessor)\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            onRecoveredLatch.countDown();\n+                          }\n+                        }));\n+\n     // when\n     streamProcessor.pauseProcessing();\n     final var success = onRecoveredLatch.await(15, TimeUnit.SECONDS);\n \n     // then\n     assertThat(success).isTrue();\n-    final var currentPhase = streamProcessor.getCurrentPhase().join();\n-    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+    Mockito.clearInvocations(typedRecordProcessor);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 0xcafe);\n+\n+    verify(typedRecordProcessor, TIMEOUT.times(0))\n+        .processRecord(anyLong(), any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d876e2570c4007c19f4f57c4c308c895d63481e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MjMzNA==", "bodyText": "Unfortunately not if you use Timeout before :D", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r474582334", "createdAt": "2020-08-21T09:37:11Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -111,28 +111,37 @@ public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exce\n             StreamWrapper::exists);\n \n     final var onRecoveredLatch = new CountDownLatch(1);\n+    final var typedRecordProcessor = mock(TypedRecordProcessor.class);\n     final var streamProcessor =\n         streamProcessorRule.startTypedStreamProcessor(\n             (processors, context) ->\n-                processors.withListener(\n-                    new StreamProcessorLifecycleAware() {\n-                      @Override\n-                      public void onRecovered(final ReadonlyProcessingContext context) {\n-                        onRecoveredLatch.countDown();\n-                      }\n-                    }));\n+                processors\n+                    .onEvent(ValueType.WORKFLOW_INSTANCE, ELEMENT_ACTIVATING, typedRecordProcessor)\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            onRecoveredLatch.countDown();\n+                          }\n+                        }));\n+\n     // when\n     streamProcessor.pauseProcessing();\n     final var success = onRecoveredLatch.await(15, TimeUnit.SECONDS);\n \n     // then\n     assertThat(success).isTrue();\n-    final var currentPhase = streamProcessor.getCurrentPhase().join();\n-    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+    Mockito.clearInvocations(typedRecordProcessor);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 0xcafe);\n+\n+    verify(typedRecordProcessor, TIMEOUT.times(0))\n+        .processRecord(anyLong(), any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3NzA4NQ=="}, "originalCommit": {"oid": "7d876e2570c4007c19f4f57c4c308c895d63481e"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 307, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}