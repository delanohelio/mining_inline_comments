{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMDAxMDQ5", "number": 3660, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDoyOVrODYF5pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyNjo1NVrODYF_1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTg5MDk0OnYy", "diffSide": "RIGHT", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDoyOVrOFdwKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxODowNlrOFdxmpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA0Nw==", "bodyText": "Out of curiosity, why call and not run if we don't return anything? Doesn't it just wrap the runnable in a Callable<Void>?\nEDIT: ah, I just saw this isn't really new code, just moved. I'm still wondering why we used call there anyway \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366742047", "createdAt": "2020-01-15T08:20:29Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -144,6 +149,38 @@ private void internalSetCommitPosition(final long commitPosition) {\n     onCommitPositionUpdatedConditions.signalConsumers();\n   }\n \n+  @Override\n+  public void delete(final long position) {\n+    actor.call(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NTczNQ==", "bodyText": "I moved the method yes. In the past we had the pattern if there comes an request from outside we use call for the context switch. The run method was later improve to handle this as well.", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366765735", "createdAt": "2020-01-15T09:18:06Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -144,6 +149,38 @@ private void internalSetCommitPosition(final long commitPosition) {\n     onCommitPositionUpdatedConditions.signalConsumers();\n   }\n \n+  @Override\n+  public void delete(final long position) {\n+    actor.call(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA0Nw=="}, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTkwNDg4OnYy", "diffSide": "RIGHT", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyNjoxNVrOFdwSQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxNjo1NVrOFdxkpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDEyOQ==", "bodyText": "If using call, couldn't createWriter not just return the LogStreamWriter? Then you don't need to create an extra future. Or just switch to run; these call calls (\ud83d\ude05) are strange to me when they return nothing.", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744129", "createdAt": "2020-01-15T08:26:15Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NTIyMg==", "bodyText": "I need to handle this future in the createWriter method. I can change this to #run yes.", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366765222", "createdAt": "2020-01-15T09:16:55Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDEyOQ=="}, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTkwNjc3OnYy", "diffSide": "RIGHT", "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyNjo1NVrOFdwTSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxNTo0MVrOFdxibA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDM5NQ==", "bodyText": "We're in an actor context, no? Why do we need an atomic integer?", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366744395", "createdAt": "2020-01-15T08:26:55Z", "author": {"login": "npepinpe"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n-    return actor.call(() -> new LogStreamBatchWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    return writerFuture;\n+  }\n+\n+  private <T extends LogStreamWriter> void createWriter(\n+      final CompletableActorFuture<T> writerFuture, final WriterCreator<T> creator) {\n+    final var alreadyOpenWriters = openWriterCount.getAndIncrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NDY1Mg==", "bodyText": "Yes. At the beginning I was not 100% sure how I want to solve it. Either access the count directly, but I decided to sync with the actor. I can replace the count if you want.", "url": "https://github.com/camunda-cloud/zeebe/pull/3660#discussion_r366764652", "createdAt": "2020-01-15T09:15:41Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/main/java/io/zeebe/logstreams/impl/log/LogStreamImpl.java", "diffHunk": "@@ -156,12 +193,55 @@ private void internalSetCommitPosition(final long commitPosition) {\n \n   @Override\n   public ActorFuture<LogStreamRecordWriter> newLogStreamRecordWriter() {\n-    return actor.call(() -> new LogStreamWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamRecordWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamWriterImpl::new));\n+    return writerFuture;\n   }\n \n   @Override\n   public ActorFuture<LogStreamBatchWriter> newLogStreamBatchWriter() {\n-    return actor.call(() -> new LogStreamBatchWriterImpl(partitionId, writeBuffer));\n+    final var writerFuture = new CompletableActorFuture<LogStreamBatchWriter>();\n+    actor.call(() -> createWriter(writerFuture, LogStreamBatchWriterImpl::new));\n+    return writerFuture;\n+  }\n+\n+  private <T extends LogStreamWriter> void createWriter(\n+      final CompletableActorFuture<T> writerFuture, final WriterCreator<T> creator) {\n+    final var alreadyOpenWriters = openWriterCount.getAndIncrement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NDM5NQ=="}, "originalCommit": {"oid": "3220a3a3a9818b3e73f8a85ae1fd5cdf697254ba"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 30, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}