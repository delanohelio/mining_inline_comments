{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNTg5MzIx", "number": 4685, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyNjo1NFrOEDymMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDoxNlrOEDzO-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDEwMTYzOnYy", "diffSide": "RIGHT", "path": "atomix/utils/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyNjo1NFrOGhA4Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTowNjo1MFrOGhv7qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MDYyMw==", "bodyText": "I'm not sure whether we normally have a strong ordering in our dependencies, but I think it's a good idea to keep internal dependencies at the top of the dependencies list.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437270623", "createdAt": "2020-06-09T09:26:54Z", "author": {"login": "korthout"}, "path": "atomix/utils/pom.xml", "diffHunk": "@@ -49,6 +49,11 @@\n       <groupId>org.slf4j</groupId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>zeebe-util</artifactId>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5OTQ4Ng==", "bodyText": "We don't have a rule for it - I used to do it alphabetically, but afaik it's the wild west. I'm open to discussion, but I think that's probably something the team should decide, not just the two of us \ud83d\ude09", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437599486", "createdAt": "2020-06-09T17:29:09Z", "author": {"login": "npepinpe"}, "path": "atomix/utils/pom.xml", "diffHunk": "@@ -49,6 +49,11 @@\n       <groupId>org.slf4j</groupId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>zeebe-util</artifactId>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MDYyMw=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0MTUxNQ==", "bodyText": "SGTM", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438041515", "createdAt": "2020-06-10T11:06:50Z", "author": {"login": "korthout"}, "path": "atomix/utils/pom.xml", "diffHunk": "@@ -49,6 +49,11 @@\n       <groupId>org.slf4j</groupId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>zeebe-util</artifactId>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MDYyMw=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDExMDY4OnYy", "diffSide": "RIGHT", "path": "dist/src/main/config/log4j2.xml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyOToxM1rOGhA-EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTowODoxMFrOGhv-Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MjA4MA==", "bodyText": "I would assume it works fine, but does this newline (and indentation) cause any problems to the pattern?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437272080", "createdAt": "2020-06-09T09:29:13Z", "author": {"login": "korthout"}, "path": "dist/src/main/config/log4j2.xml", "diffHunk": "@@ -3,7 +3,12 @@\n \n   <Properties>\n     <Property name=\"log.path\">${sys:app.home}/logs</Property>\n-    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n</Property>\n+    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level\n+      %logger{36} - %msg%n", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5OTg4MA==", "bodyText": "Hm, it was auto formatted like this. I think you're right and this may cause issues, good catch \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437599880", "createdAt": "2020-06-09T17:29:50Z", "author": {"login": "npepinpe"}, "path": "dist/src/main/config/log4j2.xml", "diffHunk": "@@ -3,7 +3,12 @@\n \n   <Properties>\n     <Property name=\"log.path\">${sys:app.home}/logs</Property>\n-    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n</Property>\n+    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level\n+      %logger{36} - %msg%n", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MjA4MA=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwMzk0OQ==", "bodyText": "Ok, turns out it does nothing. I tested it with the following property:\n    <Property name=\"log.pattern\">\n      %d{HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n\n\n\n      \n    </Property>\nTo add a new line you actually need to add %n, so it seems it trims the pattern. But I can revert it, it's not a useful change anyhow", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437603949", "createdAt": "2020-06-09T17:36:54Z", "author": {"login": "npepinpe"}, "path": "dist/src/main/config/log4j2.xml", "diffHunk": "@@ -3,7 +3,12 @@\n \n   <Properties>\n     <Property name=\"log.path\">${sys:app.home}/logs</Property>\n-    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n</Property>\n+    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level\n+      %logger{36} - %msg%n", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MjA4MA=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0MjE2Nw==", "bodyText": "Agreed, I think it's best to revert. Thanks for checking.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438042167", "createdAt": "2020-06-10T11:08:10Z", "author": {"login": "korthout"}, "path": "dist/src/main/config/log4j2.xml", "diffHunk": "@@ -3,7 +3,12 @@\n \n   <Properties>\n     <Property name=\"log.path\">${sys:app.home}/logs</Property>\n-    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n</Property>\n+    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level\n+      %logger{36} - %msg%n", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MjA4MA=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDEyOTk1OnYy", "diffSide": "RIGHT", "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozMzo0N1rOGhBJuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTowODoyN1rOGhv-qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw==", "bodyText": "What does FQCN stand for?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437275067", "createdAt": "2020-06-09T09:33:47Z", "author": {"login": "korthout"}, "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "diffHunk": "@@ -16,16 +16,18 @@\n  */\n package io.atomix.utils.logging;\n \n+import io.zeebe.util.ZbLogger;\n import org.slf4j.Logger;\n import org.slf4j.Marker;\n \n /** Contextual logger. */\n-public class ContextualLogger extends DelegatingLogger {\n+public class ContextualLogger extends ZbLogger {\n   private static final String SEPARATOR = \" - \";\n+  private static final String FQCN = ContextualLogger.class.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNDgxNw==", "bodyText": "Fully Qualified Class Name; comes directly from Log4J, where you can get logger.getLoggerFcqn() for example, so I went with the same name they use for their own stuff.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437604817", "createdAt": "2020-06-09T17:38:16Z", "author": {"login": "npepinpe"}, "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "diffHunk": "@@ -16,16 +16,18 @@\n  */\n package io.atomix.utils.logging;\n \n+import io.zeebe.util.ZbLogger;\n import org.slf4j.Logger;\n import org.slf4j.Marker;\n \n /** Contextual logger. */\n-public class ContextualLogger extends DelegatingLogger {\n+public class ContextualLogger extends ZbLogger {\n   private static final String SEPARATOR = \" - \";\n+  private static final String FQCN = ContextualLogger.class.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0MjI4Mw==", "bodyText": "Cool. Learned something new", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438042283", "createdAt": "2020-06-10T11:08:27Z", "author": {"login": "korthout"}, "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "diffHunk": "@@ -16,16 +16,18 @@\n  */\n package io.atomix.utils.logging;\n \n+import io.zeebe.util.ZbLogger;\n import org.slf4j.Logger;\n import org.slf4j.Marker;\n \n /** Contextual logger. */\n-public class ContextualLogger extends DelegatingLogger {\n+public class ContextualLogger extends ZbLogger {\n   private static final String SEPARATOR = \" - \";\n+  private static final String FQCN = ContextualLogger.class.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDIwMDUxOnYy", "diffSide": "RIGHT", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1Mjo0MFrOGhB2gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMToxNDoxMlrOGhwJXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA==", "bodyText": "These should write message at level tests would be a good case for parameterized. But since you also have other tests you'd need to use junit5 I think. If you want to have a go at junit5, this could be a good chance. Otherwise, I can also see why you wouldn't want to spend more time on this. In any case, the behaviour is already tested.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286528", "createdAt": "2020-06-09T09:52:40Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjUxMA==", "bodyText": "Good point. I could make them as nested, I guess? Or a separate test suite, why not?\nActually, the whole thing here is a good use case for testing with golden files. We don't do this so I wasn't sure if I should introduce this kind of tests, but we still could.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437606510", "createdAt": "2020-06-09T17:41:08Z", "author": {"login": "npepinpe"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0NTAyMg==", "bodyText": "Yeah, that would be a tighter test, but I also kinda like that each of these tests specific parts (much like TDD tests are written). If something fails, you immediately know what went wrong. Having said that, that might as well be true for golden files.\nAgain, I can also see why you wouldn't want to spend more time on this. So I'm fine either way", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438045022", "createdAt": "2020-06-10T11:14:12Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDIwMjgyOnYy", "diffSide": "RIGHT", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MzoxOFrOGhB35g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMToxODowNVrOGhwQ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng==", "bodyText": "why -1?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286886", "createdAt": "2020-06-09T09:53:18Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNzY1NQ==", "bodyText": "The source location is the file, method, and line at which the logging statement was called (e.g. logger.info). Since I don't want to hard code the line (so when you add code above you need to update this test), but I also don't know how to get the stack trace other than through an exception (\ud83d\ude48), I ended up creating an exception right after the logging statement, and using its stack trace to figure out the line of my logging statement \ud83d\ude05\nIf you know how to get the line of the logging statement programmatically I'm all ears \ud83d\ude42", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437607655", "createdAt": "2020-06-09T17:43:03Z", "author": {"login": "npepinpe"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA0NjkyOQ==", "bodyText": "I had to use my duckduckgo-foo here, but I found this: https://stackoverflow.com/a/25552778 Thread.currentThread().getStackTrace().", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r438046929", "createdAt": "2020-06-10T11:18:05Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng=="}, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDIwNjAwOnYy", "diffSide": "RIGHT", "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDoxNlrOGhB6BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDoxNlrOGhB6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NzQyOA==", "bodyText": "I like that you test for this! \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437287428", "createdAt": "2020-06-09T09:54:16Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))\n+        .doesNotContainKey(\"exception\");\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    final var exception = new ThrowableProxy(new IllegalStateException(\"Failed\"));\n+    logger.error(\"Error message\", exception.getThrowable());\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .containsEntry(\"exception\", exception.getExtendedStackTraceAsString())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .doesNotContainKey(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY));\n+  }\n+\n+  @Test\n+  public void shouldContainFormattedMessage() throws IOException {\n+    // given\n+    final var expectedMessage = \"This is an ultra message\";\n+\n+    // when\n+    logger.info(\"This is an {} message\", \"ultra\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"message\", expectedMessage);\n+  }\n+\n+  @Test\n+  public void shouldContainTime() throws IOException {\n+    // given\n+    final var lowerBound = Instant.now();\n+\n+    // when\n+    logger.info(\"This is a message\");\n+\n+    // then\n+    final var upperBound = Instant.now();\n+    final var jsonMap = readLoggedEvent();\n+    final var timestampSeconds = ((Number) jsonMap.get(\"timestampSeconds\")).longValue();\n+    final var timestampNanos = ((Number) jsonMap.get(\"timestampNanos\")).longValue();\n+\n+    softly\n+        .assertThat(timestampSeconds)\n+        .isBetween(lowerBound.getEpochSecond(), upperBound.getEpochSecond());\n+    softly\n+        .assertThat(timestampNanos)\n+        .isBetween((long) lowerBound.getNano(), (long) upperBound.getNano());\n+  }\n+\n+  @Test\n+  public void shouldTerminateAllEntriesWithALineSeparator() throws IOException {\n+    // given\n+    final var lineSeparator = System.lineSeparator();\n+\n+    // when\n+    logger.info(\"Should be terminated with a line separator\");\n+\n+    // then\n+    final var rawOutput = source.readNBytes(source.available());\n+    softly.assertThat(new String(rawOutput)).endsWith(lineSeparator);\n+  }\n+\n+  @Test\n+  public void shouldContainSourceLocation() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"logging.googleapis.com/sourceLocation\",\n+            sourceLocation ->\n+                softly\n+                    .assertThat(sourceLocation)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"file\", source.getFileName())\n+                    .containsEntry(\"function\", source.getMethodName())\n+                    .containsEntry(\"line\", source.getLineNumber() - 1));\n+  }\n+\n+  @Test\n+  public void shouldContainServiceContext() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"serviceContext\",\n+            serviceContext ->\n+                softly\n+                    .assertThat(serviceContext)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"service\", SERVICE)\n+                    .containsEntry(\"version\", VERSION));\n+  }\n+\n+  @Test\n+  public void shouldContainContext() throws IOException {\n+    // given\n+    final var expectedContext = Map.of(\"foo\", \"bar\", \"baz\", \"boz\");\n+\n+    // when\n+    LogUtil.doWithMDC(expectedContext, () -> logger.info(\"Message\"));\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsAllEntriesOf(expectedContext));\n+  }\n+\n+  @Test\n+  public void shouldContainThreadInfo() throws IOException {\n+    // given\n+    final var currentThread = Thread.currentThread();\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"thread\", currentThread.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"threadName\", currentThread.getName())\n+                    .containsEntry(\n+                        \"threadId\",\n+                        (int) currentThread.getId()) // Jackson will parse small numbers as integers\n+                    .containsEntry(\"threadPriority\", currentThread.getPriority()));\n+  }\n+\n+  @Test\n+  public void shouldContainLogger() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"logger\", logger.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"loggerName\", logger.getName()));\n+  }\n+\n+  @Deprecated(since = \"0.24.0\", forRemoval = true)\n+  @Test\n+  public void shouldBeBackwardsCompatibleWithStackdriverJSONLayout() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 358}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 498, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}