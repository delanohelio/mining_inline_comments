{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NTQ2MTM3", "number": 4531, "title": "Add tests for snapshotting and compaction", "bodyText": "Description\nImproved further the RaftRule such that we are able to trigger snapshotting, which will create snapshots on all nodes. After the snapshot is taken the snapshot listeners are called, which trigger compaction. This setup reflects now how our system works, but it is much easier to test I think.\nNormally we do a snapshot on the Leader and replicate that. The snapshot replication call at the end also SnapshotStore#newSnapshot. With the current test approach we were able to simplify that approach and test the same behavior.\nI added a test for:\n\nnormal snapshot taking and verify that all nodes have this snapshot\nsnapshotting triggers compaction verify log is compacted\nsnapshot is send on rejoin cluster\n\nI plan to add further tests, more complex ones probably.\nI checked #4467 and the problem was that the node was not able to truncate his log because it was at zero index and the leader was not able to send a snapshot, because it had none. The test was wrongly written I would say.\n\nRelated issues\n\ncloses #4467\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-05-15T11:49:14Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4531", "merged": true, "mergeCommit": {"oid": "e41e758f57b50660e36d83fc0bb098836a9f1664"}, "closed": true, "closedAt": "2020-05-25T08:31:18Z", "author": {"login": "Zelldon"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchiqecgBqjMzNDEwODQ4MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckqrPeAFqTQxNzUwMDQ4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b213f08b922ea5c47b8d53b4cdb671c9fce268f", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/4b213f08b922ea5c47b8d53b4cdb671c9fce268f", "committedDate": "2020-05-15T11:48:04Z", "message": "test(atomix): add tests for snapshotting and compaction"}, "afterCommit": {"oid": "74c7404eaa34712e4b220fea69ed6c83d078ce7e", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/74c7404eaa34712e4b220fea69ed6c83d078ce7e", "committedDate": "2020-05-15T14:07:54Z", "message": "test(atomix): add tests for snapshotting and compaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f13895fed1fae7e46d5b1a055cf8e7c01cf56a66", "committedDate": "2020-05-15T14:13:04Z", "message": "test(atomix): add tests for snapshotting and compaction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74c7404eaa34712e4b220fea69ed6c83d078ce7e", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/74c7404eaa34712e4b220fea69ed6c83d078ce7e", "committedDate": "2020-05-15T14:07:54Z", "message": "test(atomix): add tests for snapshotting and compaction"}, "afterCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/f13895fed1fae7e46d5b1a055cf8e7c01cf56a66", "committedDate": "2020-05-15T14:13:04Z", "message": "test(atomix): add tests for snapshotting and compaction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNzA1Mjk1", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#pullrequestreview-413705295", "createdAt": "2020-05-18T15:29:47Z", "commit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToyOTo0N1rOGW8aTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToyOTo0N1rOGW8aTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTYzMA==", "bodyText": "Nit: snapshot is a verb, so just say shouldSnapshot ;)", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r426711630", "createdAt": "2020-05-18T15:29:47Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MTMwMDc5", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#pullrequestreview-414130079", "createdAt": "2020-05-19T06:16:12Z", "commit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoxNjoxMlrOGXRSJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjozMDoxNFrOGXRnaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA==", "bodyText": "Isn't this testing the test setup rather than real implementation. Compaction is triggered by RaftRule.RaftSnapshotListener.", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427053604", "createdAt": "2020-05-19T06:16:12Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjQxNQ==", "bodyText": "In addition to this, another test that would be interesting is to restart follower with data loss. Can you add it?", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427056415", "createdAt": "2020-05-19T06:23:39Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    final var memberLogs = raftRule.getMemberLogs();\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    final var compactedLogs = raftRule.getMemberLogs();\n+\n+    assertThat(compactedLogs.isEmpty()).isFalse();\n+    for (final String raftMember : compactedLogs.keySet()) {\n+      final var compactedLog = compactedLogs.get(raftMember);\n+      final var previousLog = memberLogs.get(raftMember);\n+      assertThat(compactedLog.size()).isLessThan(previousLog.size());\n+      assertThat(compactedLog).isSubsetOf(previousLog);\n+    }\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+\n+    // when\n+    raftRule.startNode(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+    final var snapshot = raftRule.snapshotOnNode(follower);\n+\n+    assertThat(snapshot.index()).isEqualTo(100);\n+    assertThat(snapshot.term()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void shouldTakeMultipleSnapshotAndReplicateSnapshotAfterRestart() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(200);\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(300);\n+\n+    // when\n+    raftRule.startNode(follower);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1OTA1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Snapshot snapshotOnNode(final String nodeId) {\n          \n          \n            \n              public Snapshot getSnapshotOnNode(final String nodeId) {", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427059051", "createdAt": "2020-05-19T06:30:14Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -179,90 +187,119 @@ private MemberId nextNodeId() {\n           .thenAccept(this::addCommitListener)\n           .thenRun(latch::countDown);\n       servers.add(server);\n+      compactAwaiters.put(server.name(), new AtomicReference<>());\n     }\n \n     latch.await(30, TimeUnit.SECONDS);\n \n     return servers;\n   }\n \n-  public void shutdownFollower() throws Exception {\n+  public String shutdownFollower() throws Exception {\n     final var follower = getFollower().orElseThrow();\n     shutdownServer(follower);\n+    return follower.name();\n   }\n \n-  public RaftServer shutdownLeader() throws Exception {\n+  public void startNode(final String nodeId) throws Exception {\n+    final RaftMember member = getRaftMember(nodeId);\n+    createServer(member.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  public String shutdownLeader() throws Exception {\n     final var leader = getLeader().orElseThrow();\n     shutdownServer(leader);\n-    return leader;\n+    return leader.name();\n   }\n \n   public void restartLeader() throws Exception {\n     awaitNewLeader();\n     final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n+    startNode(leader);\n   }\n \n   private List<MemberId> getMemberIds() {\n     return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n   }\n \n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n   public void shutdownServer(final RaftServer raftServer) throws Exception {\n     raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n+    servers.remove(raftServer.name());\n+    compactAwaiters.remove(raftServer.name());\n     memberLog.remove(raftServer.name());\n   }\n \n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n   private RaftMember getRaftMember(final String memberId) {\n     return members.stream()\n         .filter(member -> member.memberId().id().equals(memberId))\n         .findFirst()\n         .orElseThrow();\n   }\n \n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n+  public void doSnapshot(final long index) throws Exception {\n+    awaitNewLeader();\n+\n+    // we write on all nodes the same snapshot\n+    // this is similar to our current logic where leader takes a snapshot and replicates it\n+    // in the end all call the method #newSnapshot and the snapshot listener is triggered to compact\n \n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n+    for (final RaftServer raftServer : servers.values()) {\n+      if (raftServer.isRunning()) {\n+        final var raftContext = raftServer.getContext();\n+        final var snapshotStore = raftContext.getSnapshotStore();\n+\n+        compactAwaiters.get(raftServer.name()).set(new CountDownLatch(1));\n+        writeSnapshot(index, raftContext.getTerm(), snapshotStore);\n+      }\n+    }\n \n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n+    // await the compaction to avoid race condition with reading the logs\n+    for (final RaftServer server : servers.values()) {\n+      final var latchAtomicReference = compactAwaiters.get(server.name());\n+      final var latch = latchAtomicReference.get();\n+      if (!latch.await(30, TimeUnit.SECONDS)) {\n+        throw new TimeoutException(\"Expected to compact the log after 30 seconds!\");\n+      }\n+      latchAtomicReference.set(null);\n     }\n+  }\n \n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  public boolean allNodesHaveSnapshotWithIndex(final long index) {\n+    return servers.values().stream()\n+            .map(RaftServer::getContext)\n+            .map(RaftContext::getSnapshotStore)\n+            .map(SnapshotStore::getCurrentSnapshotIndex)\n+            .filter(idx -> idx == index)\n+            .count()\n+        == servers.values().size();\n   }\n \n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n+  public Snapshot snapshotOnNode(final String nodeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 212}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69dcf5a0ad14f9d781b27647bce31e3db3b23c42", "author": {"user": {"login": "Zelldon", "name": "Christopher Zell"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/69dcf5a0ad14f9d781b27647bce31e3db3b23c42", "committedDate": "2020-05-20T10:08:19Z", "message": "test(atomix): add additional Raft tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NDk0NDkw", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#pullrequestreview-417494490", "createdAt": "2020-05-25T06:58:06Z", "commit": {"oid": "69dcf5a0ad14f9d781b27647bce31e3db3b23c42"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3NTAwNDg4", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#pullrequestreview-417500488", "createdAt": "2020-05-25T07:10:36Z", "commit": {"oid": "69dcf5a0ad14f9d781b27647bce31e3db3b23c42"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2815, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}