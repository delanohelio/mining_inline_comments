{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNTgyMDM3", "number": 4834, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTo0MjowOFrOEJt-pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTo0MjozOVrOEJt_mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjI1OTU5OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTo0MjowOFrOGqW5tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxMDozNVrOGsEU8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODU5Nw==", "bodyText": "Is it guaranteed that the snapshot is available immediately after the bootstrap? Or should it wait until the snapshot is replicated?", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r447068597", "createdAt": "2020-06-29T15:42:08Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -228,7 +228,37 @@ public void shouldReplicateSnapshotAfterDataLoss() throws Exception {\n     final var snapshot = raftRule.getSnapshotOnNode(follower);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(100);\n-    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getTerm()).isEqualTo(leaderSnapshot.getTerm());\n+    assertThat(snapshot.getId()).isEqualTo(leaderSnapshot.getId());\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotMultipleTimesAfterMultipleDataLoss() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+    raftRule.triggerDataLossOnNode(follower);\n+    raftRule.bootstrapNode(follower);\n+\n+    final var firstSnapshot = raftRule.getSnapshotOnNode(follower);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198faaacf04d2009c084b55428a19f519af0bb03"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MTQyNA==", "bodyText": "The test runs without problems so I thought yes. I checked the code again and indeed the follower needs to apply the first entries to become ready.\nOn bootstrap:\n    if (openFutureRef.compareAndSet(null, new AtomixFuture<>())) {\n      joiner\n          .get()\n          .whenComplete(\n              (result, error) -> {\n                if (error == null) {\n                  context.awaitState(\n                      RaftContext.State.READY,\n                      state -> {\n                        started = true;\n                        openFutureRef.get().complete(this);\n                      });\n                } else {\n                  openFutureRef.get().completeExceptionally(error);\n                }\n              });\n    }\n\nState ready is only set on applying entries https://github.com/zeebe-io/zeebe/blob/develop/atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java#L371-L383", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r448861424", "createdAt": "2020-07-02T09:10:35Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -228,7 +228,37 @@ public void shouldReplicateSnapshotAfterDataLoss() throws Exception {\n     final var snapshot = raftRule.getSnapshotOnNode(follower);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(100);\n-    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getTerm()).isEqualTo(leaderSnapshot.getTerm());\n+    assertThat(snapshot.getId()).isEqualTo(leaderSnapshot.getId());\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotMultipleTimesAfterMultipleDataLoss() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+    raftRule.triggerDataLossOnNode(follower);\n+    raftRule.bootstrapNode(follower);\n+\n+    final var firstSnapshot = raftRule.getSnapshotOnNode(follower);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODU5Nw=="}, "originalCommit": {"oid": "198faaacf04d2009c084b55428a19f519af0bb03"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjI2MjAzOnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTo0MjozOVrOGqW7IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTo0MjozOVrOGqW7IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2ODk2MA==", "bodyText": "Same as above.", "url": "https://github.com/camunda-cloud/zeebe/pull/4834#discussion_r447068960", "createdAt": "2020-06-29T15:42:39Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -228,7 +228,37 @@ public void shouldReplicateSnapshotAfterDataLoss() throws Exception {\n     final var snapshot = raftRule.getSnapshotOnNode(follower);\n \n     assertThat(snapshot.getIndex()).isEqualTo(leaderSnapshot.getIndex()).isEqualTo(100);\n-    assertThat(snapshot.getTerm()).isEqualTo(snapshot.getTerm());\n+    assertThat(snapshot.getTerm()).isEqualTo(leaderSnapshot.getTerm());\n+    assertThat(snapshot.getId()).isEqualTo(leaderSnapshot.getId());\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotMultipleTimesAfterMultipleDataLoss() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    final var leaderSnapshot = raftRule.getSnapshotFromLeader();\n+    raftRule.triggerDataLossOnNode(follower);\n+    raftRule.bootstrapNode(follower);\n+\n+    final var firstSnapshot = raftRule.getSnapshotOnNode(follower);\n+\n+    // when another data loss happens\n+    raftRule.shutdownServer(follower);\n+    raftRule.triggerDataLossOnNode(follower);\n+    assertThat(firstSnapshot.getPath()).doesNotExist();\n+    raftRule.bootstrapNode(follower);\n+\n+    // then snapshot is replicated again\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "198faaacf04d2009c084b55428a19f519af0bb03"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 410, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}