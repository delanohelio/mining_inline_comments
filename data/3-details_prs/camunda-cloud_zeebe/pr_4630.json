{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0ODk3Njcz", "number": 4630, "title": "chore(engine): migrate process processor", "bodyText": "Description\n\nmigrate process/workflow processor including the workflow result sender and the message start event correlation behavior\nintroduce new exception type for workflow processing\nremove unused handlers\n\nRelated issues\ncloses #4475\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-05-29T05:42:08Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4630", "merged": true, "mergeCommit": {"oid": "428bc78e67003c9205ee4646a24a30b16d6ad132"}, "closed": true, "closedAt": "2020-06-03T12:38:19Z", "author": {"login": "saig0"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcl9z49ABqjMzODYwODcwMjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnocy5gBqjM0MDE4NzM4MzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e394c01a8c624ffde3bf20ff611c771044830155", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/e394c01a8c624ffde3bf20ff611c771044830155", "committedDate": "2020-05-29T05:37:58Z", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing"}, "afterCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "committedDate": "2020-05-29T08:01:58Z", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTA5MTU0", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#pullrequestreview-422509154", "createdAt": "2020-06-02T09:37:29Z", "commit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTozNzoyOVrOGdp7EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoyMzowMFrOGd0LSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0ODc1Mw==", "bodyText": "Is messageCorrelation here truly something \"Optional\"? Even if, this is not a recommended use case for Optional. I suggest to unravel this to some imperative construct and returning the corresponding Optional in the if-else branches.", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433748753", "createdAt": "2020-06-02T09:37:29Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnBufferedMessageStartEventBehavior.java", "diffHunk": "@@ -111,21 +109,15 @@ private Correlation findNextMessageToCorrelate(\n       }\n     }\n \n-    return messageCorrelation.elementId != null ? messageCorrelation : null;\n+    return Optional.of(messageCorrelation).filter(correlation -> correlation.elementId != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1MjM1OA==", "bodyText": "I like it \ud83e\udd47", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433752358", "createdAt": "2020-06-02T09:43:37Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -109,18 +91,30 @@ public void transitionToTerminated(final BpmnElementContext context) {\n     metrics.elementInstanceTerminated(context.getBpmnElementType());\n   }\n \n-  private void transitionTo(final BpmnElementContext context, final WorkflowInstanceIntent intent) {\n+  private void transitionTo(\n+      final BpmnElementContext context, final WorkflowInstanceIntent transition) {\n+\n+    verifyTransition(context, transition);\n+\n     streamWriter.appendFollowUpEvent(\n-        context.getElementInstanceKey(), intent, context.getRecordValue());\n+        context.getElementInstanceKey(), transition, context.getRecordValue());\n+  }\n+\n+  private void verifyTransition(\n+      final BpmnElementContext context, final WorkflowInstanceIntent transition) {\n+\n+    if (!WorkflowInstanceLifecycle.canTransition(context.getIntent(), transition)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDIyNQ==", "bodyText": "Do we still need to flush? I saw some flushes defined in some lambda's during this review. Perhaps they are different, but it was not immediately clear to me.", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433754225", "createdAt": "2020-06-02T09:46:58Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODQ0MA==", "bodyText": "Does this fetch the variables twice? If so, I think it would be more performant and readable to just iterate with forEach and afterwards check if the result (variablesToCollect) is empty.", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433758440", "createdAt": "2020-06-02T09:54:20Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();\n+  }\n+\n+  private DirectBuffer collectVariables(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final Set<DirectBuffer> variablesToCollect = new HashSet<>();\n+    if (requestMetadata.fetchVariables().iterator().hasNext()) {\n+      requestMetadata\n+          .fetchVariables()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzI4MQ==", "bodyText": "Apart from calling this flush callback, should the writer itself be flushed here too?", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433903281", "createdAt": "2020-06-02T14:05:38Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/TypedResponseWriterProxy.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import java.util.function.Consumer;\n+\n+public final class TypedResponseWriterProxy implements TypedResponseWriter {\n+\n+  private TypedResponseWriter writer;\n+  private Consumer<TypedResponseWriter> flushCallback;\n+\n+  public void wrap(\n+      final TypedResponseWriter writer, final Consumer<TypedResponseWriter> flushCallback) {\n+    this.writer = writer;\n+    this.flushCallback = flushCallback;\n+  }\n+\n+  @Override\n+  public void writeRejectionOnCommand(\n+      final TypedRecord<?> command, final RejectionType type, final String reason) {\n+    writer.writeRejectionOnCommand(command, type, reason);\n+  }\n+\n+  @Override\n+  public void writeEvent(final TypedRecord<?> event) {\n+    writer.writeEvent(event);\n+  }\n+\n+  @Override\n+  public void writeEventOnCommand(\n+      final long eventKey,\n+      final Intent eventState,\n+      final UnpackedObject eventValue,\n+      final TypedRecord<?> command) {\n+    writer.writeEventOnCommand(eventKey, eventState, eventValue, command);\n+  }\n+\n+  @Override\n+  public void writeResponse(\n+      final long eventKey,\n+      final Intent eventState,\n+      final UnpackedObject eventValue,\n+      final ValueType valueType,\n+      final long requestId,\n+      final int requestStreamId) {\n+    writer.writeResponse(eventKey, eventState, eventValue, valueType, requestId, requestStreamId);\n+  }\n+\n+  @Override\n+  public boolean flush() {\n+    flushCallback.accept(writer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNDM2Mw==", "bodyText": "Should we maybe log a warning or throw an exception when parent is not ACTIVATED?", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433914363", "createdAt": "2020-06-02T14:19:40Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTY5MA==", "bodyText": "Is this check really enough to know that it was started as such?", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433915690", "createdAt": "2020-06-02T14:21:30Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjA0Ng==", "bodyText": "Can't the process have multiple message start events?", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433916046", "createdAt": "2020-06-02T14:22:01Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {\n+      workflowResultSenderBehavior.sendResult(context);\n+    }\n+\n+    if (element.hasMessageStartEvent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjc0NQ==", "bodyText": "Does termination not have to be communicated as a workflow result?", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433916745", "createdAt": "2020-06-02T14:23:00Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {\n+      workflowResultSenderBehavior.sendResult(context);\n+    }\n+\n+    if (element.hasMessageStartEvent()) {\n+      bufferedMessageStartEventBehavior.correlateMessage(context);\n+    }\n+\n+    stateBehavior.removeElementInstance(context);\n+  }\n \n   @Override\n   public void onTerminating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+\n+    stateTransitionBehavior.terminateChildInstances(context);\n+  }\n \n   @Override\n   public void onTerminated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    incidentBehavior.resolveIncidents(context);\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING) {\n+        // terminate the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToTerminated(parentElementInstance);\n+      }\n+    }\n+\n+    if (element.hasMessageStartEvent()) {\n+      bufferedMessageStartEventBehavior.correlateMessage(context);\n+    }\n+\n+    stateBehavior.removeElementInstance(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3"}, "originalPosition": 183}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "committedDate": "2020-05-29T08:01:58Z", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing"}, "afterCommit": {"oid": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "committedDate": "2020-06-03T08:47:36Z", "message": "chore(engine): rebasing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDQ5NDc2", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#pullrequestreview-423449476", "createdAt": "2020-06-03T11:11:47Z", "commit": {"oid": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMToxMTo0N1rOGeXIVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMToxMTo0N1rOGeXIVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4OTQyOQ==", "bodyText": "I now notice theres mapping happening before the add, which can be moved to a map(variable -> cloneBuffer(variable.getValue())) before the foreach. It would even be possible to collect(toSet) instead of the forEach(variablesToCollect::add).", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434489429", "createdAt": "2020-06-03T11:11:47Z", "author": {"login": "korthout"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import static io.zeebe.util.buffer.BufferUtil.cloneBuffer;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();\n+  }\n+\n+  private DirectBuffer collectVariables(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final Set<DirectBuffer> variablesToCollect = new HashSet<>();\n+    requestMetadata\n+        .fetchVariables()\n+        .forEach(\n+            variable -> {\n+              final var variableName = cloneBuffer(variable.getValue());\n+              variablesToCollect.add(variableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de44b88258658e0630a46147e8588211e7622839", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/de44b88258658e0630a46147e8588211e7622839", "committedDate": "2020-06-03T12:16:29Z", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "committedDate": "2020-06-03T08:47:36Z", "message": "chore(engine): rebasing"}, "afterCommit": {"oid": "de44b88258658e0630a46147e8588211e7622839", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/de44b88258658e0630a46147e8588211e7622839", "committedDate": "2020-06-03T12:16:29Z", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2713, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}