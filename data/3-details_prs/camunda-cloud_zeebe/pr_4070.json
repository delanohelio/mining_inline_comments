{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNDAyMzMw", "number": 4070, "title": "chore(engine): add streamprocessor health check", "bodyText": "Description\nEnable health check for StreamProcesor\n\nWhen phase changed to FAILED, notify failure listener and mark as unhealthy\nWhen ProcessingStateMachine is retrying onError because of exceptions, mark it as unhealthy. If it comes out of retry loop, mark healthy again.\nWhen ReprocessingStateMachine is in EndlessRetry loop, detect it as unhealthy.\nOn other exception which are not handled, mark the actor as failed\n\nNot done:\n\nIf ProcessingStateMachine is retrying due to RecoverableException, it is not detected as unhealthy.\n\nRelated issues\n\ncloses #3854\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-03-18T12:19:48Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4070", "merged": true, "mergeCommit": {"oid": "9adeefedc88fbb83b1a8cc82269305742a75c3e5"}, "closed": true, "closedAt": "2020-03-20T16:42:58Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcO2WcygBqjMxNDEyMDk5ODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPiomiABqjMxNDk5MDUwMDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3486f049853eb82e14429b3f361912f798cad07", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/c3486f049853eb82e14429b3f361912f798cad07", "committedDate": "2020-03-18T10:58:15Z", "message": "chore(engine): add streamprocessor health check"}, "afterCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/dff6c0da99099701a7c687bae6b62a7493d2c02c", "committedDate": "2020-03-18T12:20:11Z", "message": "chore(engine): add streamprocessor health check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NDQyMDE2", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#pullrequestreview-377442016", "createdAt": "2020-03-19T05:58:29Z", "commit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNTo1ODoyOVrOF4hCAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNjowNzozMlrOF4hL3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNTc2MA==", "bodyText": "Hmm not sure if this is sufficient, since exceptions in the nextStep already catched. So say we have an error on write. You call onError, then try again onWrite this fails again. This will again call onError. But you will not get this in the onError method.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394805760", "createdAt": "2020-03-19T05:58:29Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java", "diffHunk": "@@ -298,12 +299,24 @@ private void onError(final Throwable processingException, final Runnable nextSte\n \n             onErrorHandling = true;\n             nextStep.run();\n+\n+            if (onErrorHandlingLoop) {\n+              onErrorHandlingLoop = false;\n+            }\n           } catch (final Exception ex) {\n+            errorHandlingFailed(ex);\n             onError(ex, nextStep);\n           }\n         });\n   }\n \n+  private void errorHandlingFailed(final Exception ex) {\n+    if (!onErrorHandlingLoop) {\n+      LOG.error(\"Encountered an exception during processing. Retrying.\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA==", "bodyText": "We should probably also close the other resources right? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394806168", "createdAt": "2020-03-19T05:59:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwODI4NQ==", "bodyText": "This is actually the reason why your test works with the onError loop but this doesn't reflect the real production setting. A this will never fail normally b as I wrote above your logic doesn't detect real loops between write and error or processing and error etc.", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394808285", "createdAt": "2020-03-19T06:07:32Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private ZeebeState mockedZeebeState;\n+  private StreamProcessor streamProcessor;\n+  private final AtomicBoolean shouldThrowException = new AtomicBoolean(true);\n+  private final AtomicInteger invocation = new AtomicInteger();\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldThrowException.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenInErrorLoop() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              mockedZeebeState = spy(processingContext.getZeebeState());\n+              processingContext.zeebeState(mockedZeebeState);\n+              return processors(mockedZeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldThrowException.get()) {\n+                            throw new RuntimeException(\"expected\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    Mockito.doAnswer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NzA4MDY4", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#pullrequestreview-377708068", "createdAt": "2020-03-19T13:17:51Z", "commit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoxNzo1MlrOF4t7OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMzoyMDo1MlrOF4uCaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzAxNw==", "bodyText": "Is there a reason why in this method it is done before calling the write in the method above after calling?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017017", "createdAt": "2020-03-19T13:17:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    shouldFlushThrowException.set(true);\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              final ZeebeState zeebeState = processingContext.getZeebeState();\n+              mockedLogStreamWriter =\n+                  new WrappedStreamWriter(processingContext.getLogStreamWriter());\n+              processingContext.zeebeState(zeebeState);\n+              processingContext.logStreamWriter(mockedLogStreamWriter);\n+              return processors(zeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldProcessingThrowException.get()) {\n+                            throw new RuntimeException(\"processing failed\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    return streamProcessor;\n+  }\n+\n+  private final class WrappedStreamWriter implements TypedStreamWriter {\n+\n+    private final TypedStreamWriter wrappedWriter;\n+\n+    private WrappedStreamWriter(final TypedStreamWriter wrappedWriter) {\n+      this.wrappedWriter = wrappedWriter;\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason) {\n+      wrappedWriter.appendRejection(command, type, reason);\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason,\n+        final Consumer<RecordMetadata> metadata) {\n+      wrappedWriter.appendRejection(command, type, reason, metadata);\n+    }\n+\n+    @Override\n+    public void appendNewEvent(final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendNewEvent(key, intent, value);\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendFollowUpEvent(key, intent, value);\n+      if (shouldFailErrorHandlingInTransaction.get()) {\n+        throw new RuntimeException(\"append followup event failed\");\n+      }\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key,\n+        final Intent intent,\n+        final UnpackedObject value,\n+        final Consumer<RecordMetadata> metadata) {\n+      if (shouldFailErrorHandlingInTransaction.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzY4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n          \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOnWriteEventFails() {", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017688", "createdAt": "2020-03-19T13:19:01Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ==", "bodyText": "i think this is not different to the other processing exception or?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395018859", "createdAt": "2020-03-19T13:20:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8722c7edb96180c509779d23d4c158ecac6e4dcb"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDg4NDU3", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#pullrequestreview-378488457", "createdAt": "2020-03-20T13:38:02Z", "commit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODowMlrOF5T_5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODowMlrOF5T_5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg==", "bodyText": "shouldnt this log be a level higher in the actor class?", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395640806", "createdAt": "2020-03-20T13:38:02Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDg5MDkz", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#pullrequestreview-378489093", "createdAt": "2020-03-20T13:38:48Z", "commit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODo0OFrOF5UB3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozODo0OFrOF5UB3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTMxMQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395641311", "createdAt": "2020-03-20T13:38:48Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -269,12 +275,13 @@ private void onRecovered() {\n   }\n \n   private void onFailure(final Throwable throwable) {\n-    phase = Phase.FAILED;\n-    openFuture.completeExceptionally(throwable);\n-    closeFuture = new CompletableActorFuture<>();\n-    isOpened.set(false);\n-    failureListener.onFailure();\n-    actor.close();\n+    actor.fail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTMyNTkx", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#pullrequestreview-378532591", "createdAt": "2020-03-20T14:30:22Z", "commit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "084ce625721e46e77929aaec33275814f5a0df65", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/084ce625721e46e77929aaec33275814f5a0df65", "committedDate": "2020-03-19T15:24:07Z", "message": "chore(engine): close resources"}, "afterCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/dff6c0da99099701a7c687bae6b62a7493d2c02c", "committedDate": "2020-03-18T12:20:11Z", "message": "chore(engine): add streamprocessor health check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "committedDate": "2020-03-20T15:55:35Z", "message": "chore(engine): add streamprocessor health check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/dff6c0da99099701a7c687bae6b62a7493d2c02c", "committedDate": "2020-03-18T12:20:11Z", "message": "chore(engine): add streamprocessor health check"}, "afterCommit": {"oid": "bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "committedDate": "2020-03-20T15:55:35Z", "message": "chore(engine): add streamprocessor health check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3080, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}