{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NDQ1MDE1", "number": 4372, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1Mzo1OVrOD2sh8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTowNzo0M1rOD3ef0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Njc5MjgxOnYy", "diffSide": "RIGHT", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1Mzo1OVrOGMkZOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1Mzo1OVrOGMkZOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMjM3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final var cantReadEntry = memory.remaining() < length;\n          \n          \n            \n                  final var cantReadEntry = memory.remaining() < length + Integer.BYTES;\n          \n      \n    \n    \n  \n\nShould include the checksum.", "url": "https://github.com/camunda-cloud/zeebe/pull/4372#discussion_r415832379", "createdAt": "2020-04-27T13:53:59Z", "author": {"login": "deepthidevaki"}, "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentReader.java", "diffHunk": "@@ -172,54 +172,82 @@ private void readNext() {\n     final long index = getNextIndex();\n \n     try {\n-      // Read more bytes from the segment if necessary.\n-      if (memory.remaining() < maxEntrySize) {\n-        final long position = channel.position() + memory.position();\n-        channel.position(position);\n-        memory.clear();\n-        channel.read(memory);\n-        channel.position(position);\n-        memory.flip();\n-      }\n-\n       // Mark the buffer so it can be reset if necessary.\n       memory.mark();\n \n-      try {\n-        // Read the length of the entry.\n-        final int length = memory.getInt();\n-\n-        // If the buffer length is zero then return.\n-        if (length <= 0 || length > maxEntrySize) {\n-          memory.reset().limit(memory.position());\n-          nextEntry = null;\n-          return;\n-        }\n-\n-        // Read the checksum of the entry.\n-        final long checksum = memory.getInt() & 0xFFFFFFFFL;\n-\n-        // Compute the checksum for the entry bytes.\n-        final Checksum crc32 = new CRC32();\n-        crc32.update(memory.array(), memory.position(), length);\n-\n-        // If the stored checksum equals the computed checksum, return the entry.\n-        if (checksum == crc32.getValue()) {\n-          final int limit = memory.limit();\n-          memory.limit(memory.position() + length);\n-          final E entry = namespace.deserialize(memory);\n-          memory.limit(limit);\n-          nextEntry = new Indexed<>(index, entry, length);\n-        } else {\n-          memory.reset().limit(memory.position());\n-          nextEntry = null;\n-        }\n-      } catch (final BufferUnderflowException e) {\n-        memory.reset().limit(memory.position());\n-        nextEntry = null;\n+      final var cantReadLength = memory.remaining() < Integer.BYTES;\n+      if (cantReadLength) {\n+        readBytesIntoBuffer();\n+        memory.mark();\n+      }\n+\n+      final int length = memory.getInt();\n+      if (isLengthInvalid(length)) {\n+        return;\n+      }\n+\n+      final var cantReadEntry = memory.remaining() < length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af7de134f4c84c11bd92244b149e3ef0f2ef4f38"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDk3OTM5OnYy", "diffSide": "RIGHT", "path": "atomix/storage/src/test/java/io/atomix/storage/journal/AbstractJournalTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTowNzo0M1rOGNv47g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTozMDowMVrOGNwO4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI5NA==", "bodyText": "I'm thinking if it would be good to test with multiple max entry sizes to find other potential bugs in future.", "url": "https://github.com/camunda-cloud/zeebe/pull/4372#discussion_r417069294", "createdAt": "2020-04-29T05:07:43Z", "author": {"login": "deepthidevaki"}, "path": "atomix/storage/src/test/java/io/atomix/storage/journal/AbstractJournalTest.java", "diffHunk": "@@ -91,7 +91,7 @@ public static Collection primeNumbers() {\n         .withNamespace(NAMESPACE)\n         .withStorageLevel(storageLevel())\n         .withMaxSegmentSize(maxSegmentSize)\n-        .withMaxEntrySize(64)\n+        .withMaxEntrySize(48)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b111a977c289674007760213533d0396fccda9b0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MTE4Mw==", "bodyText": "Are you fine in doing this in a separate issue? Then I would create an issue to improve in the journal tests.", "url": "https://github.com/camunda-cloud/zeebe/pull/4372#discussion_r417071183", "createdAt": "2020-04-29T05:16:00Z", "author": {"login": "Zelldon"}, "path": "atomix/storage/src/test/java/io/atomix/storage/journal/AbstractJournalTest.java", "diffHunk": "@@ -91,7 +91,7 @@ public static Collection primeNumbers() {\n         .withNamespace(NAMESPACE)\n         .withStorageLevel(storageLevel())\n         .withMaxSegmentSize(maxSegmentSize)\n-        .withMaxEntrySize(64)\n+        .withMaxEntrySize(48)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI5NA=="}, "originalCommit": {"oid": "b111a977c289674007760213533d0396fccda9b0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjUxMw==", "bodyText": "Yes \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4372#discussion_r417072513", "createdAt": "2020-04-29T05:21:11Z", "author": {"login": "deepthidevaki"}, "path": "atomix/storage/src/test/java/io/atomix/storage/journal/AbstractJournalTest.java", "diffHunk": "@@ -91,7 +91,7 @@ public static Collection primeNumbers() {\n         .withNamespace(NAMESPACE)\n         .withStorageLevel(storageLevel())\n         .withMaxSegmentSize(maxSegmentSize)\n-        .withMaxEntrySize(64)\n+        .withMaxEntrySize(48)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI5NA=="}, "originalCommit": {"oid": "b111a977c289674007760213533d0396fccda9b0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDkxMg==", "bodyText": "#4407", "url": "https://github.com/camunda-cloud/zeebe/pull/4372#discussion_r417074912", "createdAt": "2020-04-29T05:30:01Z", "author": {"login": "Zelldon"}, "path": "atomix/storage/src/test/java/io/atomix/storage/journal/AbstractJournalTest.java", "diffHunk": "@@ -91,7 +91,7 @@ public static Collection primeNumbers() {\n         .withNamespace(NAMESPACE)\n         .withStorageLevel(storageLevel())\n         .withMaxSegmentSize(maxSegmentSize)\n-        .withMaxEntrySize(64)\n+        .withMaxEntrySize(48)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI5NA=="}, "originalCommit": {"oid": "b111a977c289674007760213533d0396fccda9b0"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4744, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}