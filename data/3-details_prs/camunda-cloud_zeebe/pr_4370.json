{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NDIwNjE2", "number": 4370, "title": "chore(engine): draft new implementation of the BPMN lifecycle", "bodyText": "Description\nDraft a new way to implement the BPMN lifecycle.\nRelated issues\ncloses #4333\ncloses #4330\ncloses #4329", "createdAt": "2020-04-24T08:54:56Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4370", "merged": true, "mergeCommit": {"oid": "bb5eb14b97ccc28d623ecbe102b67ca620f63acf"}, "closed": true, "closedAt": "2020-05-15T13:51:07Z", "author": {"login": "saig0"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceQQnBABqjMzMDMyOTkzNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchh6A4gFqTQxMjYzODE5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70047f5e112b790f4659ea5e5ede9cd241c3921a", "author": {"user": {"login": "korthout", "name": "Nico Korthout"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/70047f5e112b790f4659ea5e5ede9cd241c3921a", "committedDate": "2020-05-05T08:49:29Z", "message": "chore(engine): add todo"}, "afterCommit": {"oid": "9b94799a40c832c6a30644fafd34bb69b3ac4077", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/9b94799a40c832c6a30644fafd34bb69b3ac4077", "committedDate": "2020-05-05T09:00:09Z", "message": "chore(engine): introduce new bpmn processing\n\nIncludes new implementation for:\n\n- service task\n- exclusive gateway\n- multi instance\n- boundary event\n- sub process\n\nThis is a combination of 46 commits.\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(engine): try implement exclusive gateway processor\n\nchore(engine): use incidentbehavior\n\nchore(broker): wip\n\nchore(broker): integrate the new BPMN element processor\n\nchore(broker): merging\n\nchore(broker): removing TODOs :)\n\nchore(broker): fix stream writer proxy\n\n* configure event output in context\n\nchore(broker): move state transition in the service task processor\n\n* process service task: terminating successfully\n\nchore(broker): fighting with the step guard\n\nwip\n\nfix(engine): fix token consumption or gw\n\nchore(broker): configure side-effect in context\n\n* fix incident creation\n* handle exception in service task processor\n\nchore(broker): fix incident creation and resolving\n\nchore(broker): fix multi instance behavior\n\nchore(broker): activate exclusive gateway only if no incident\n\nchore(broker): create incident with the correct variable scope\n\nchore(broker): fix code style\n\nchore(broker): fix code style\n\nchore(broker): add missing licence headers\n\nchore(engine): add test to cancel proces with indicent on OR gateway\n\nchore(engine): implement exclusive gateway processor onTerminating\n\nchore(engine): implement onTerminated for or gateway\n\nchore(engine): enable service task completed processor\n\nchore(engine): enable service task completing processor\n\nchore(engine): add test for terminating service task\n\nand improve the similar or gateway test\n\nchore(engine): implement onTerminated for service task processor\n\nchore(engine): fix failing tests after onTerminated implementation\n\nchore(engine): apply exclusive gateway processor also for implicit end\n\nfor example when there are no outgoing sequence flows, or when there is\njust a single one without a condition.\n\nchore(engine): add multi-instance body processor\n\nchore(engine): enable multi-instance activating processor\n\n* increase the stability of the multi-instance test\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): enable multi-instance completing processor\n\nchore(engine): remove explicit state updates on transition\n\nchore(engine): implement onEvent for servicetask processor\n\nchore(engine): handle completing in container processor\n\n* remove explicit state updates on transition\n* extract taking outgoing sequence flows\n\nchore(engine): add license headers :)\n\nchore(engine): add todo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTg1NjM5", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#pullrequestreview-410585639", "createdAt": "2020-05-13T04:52:42Z", "commit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNDo1Mjo0MlrOGUhWvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTo0MTo0M1rOGUiKpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MTE5OQ==", "bodyText": "Why?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424171199", "createdAt": "2020-05-13T04:52:42Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnElementProcessor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+\n+/**\n+ * The business logic of a BPMN element.\n+ *\n+ * <p>The execution of an element is divided into multiple steps that represents the lifecycle of\n+ * the element. Each step defines a set of actions that can be performed in this step. The\n+ * transition to the next step must be triggered explicitly in the current step.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MTQ1Mg==", "bodyText": "Here in the interface you already know that the next step will be activated, but before you mentioned that needs to be triggered by the impl?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424171452", "createdAt": "2020-05-13T04:53:37Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnElementProcessor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+\n+/**\n+ * The business logic of a BPMN element.\n+ *\n+ * <p>The execution of an element is divided into multiple steps that represents the lifecycle of\n+ * the element. Each step defines a set of actions that can be performed in this step. The\n+ * transition to the next step must be triggered explicitly in the current step.\n+ *\n+ * @param <T> the type that represents the BPMN element\n+ */\n+public interface BpmnElementProcessor<T extends ExecutableFlowElement> {\n+\n+  /** @return the class that represents the BPMN element */\n+  Class<T> getType();\n+\n+  /**\n+   * The element is entered (initial step). Perform every action to initialize the element.\n+   *\n+   * <p>Possible actions:\n+   *\n+   * <ul>\n+   *   <li>apply input mappings\n+   *   <li>open event subscriptions\n+   * </ul>\n+   *\n+   * Next step: activated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MTk5MQ==", "bodyText": "Why new ? :D", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424171991", "createdAt": "2020-05-13T04:55:52Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnStreamProcessor.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.Loggers;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviorsImpl;\n+import io.zeebe.engine.nwe.behavior.TypesStreamWriterProxy;\n+import io.zeebe.engine.processor.SideEffectProducer;\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedRecordProcessor;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.BpmnStepContext;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableMultiInstanceBody;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.deployment.WorkflowState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+\n+public final class BpmnStreamProcessor implements TypedRecordProcessor<WorkflowInstanceRecord> {\n+\n+  private static final Logger LOGGER = Loggers.WORKFLOW_PROCESSOR_LOGGER;\n+\n+  private final TypesStreamWriterProxy streamWriterProxy = new TypesStreamWriterProxy();\n+\n+  private final BpmnElementContextImpl context;\n+  private final WorkflowState workflowState;\n+  private final BpmnElementProcessors processors;\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+\n+  private final Consumer<BpmnStepContext<?>> fallback;\n+\n+  public BpmnStreamProcessor(\n+      final ExpressionProcessor expressionProcessor,\n+      final CatchEventBehavior catchEventBehavior,\n+      final ZeebeState zeebeState,\n+      final Consumer<BpmnStepContext<?>> fallback) {\n+    workflowState = zeebeState.getWorkflowState();\n+    context = new BpmnElementContextImpl(zeebeState);\n+\n+    final var bpmnBehaviors =\n+        new BpmnBehaviorsImpl(\n+            expressionProcessor,\n+            streamWriterProxy,\n+            zeebeState,\n+            catchEventBehavior,\n+            this::getContainerProcessor);\n+    processors = new BpmnElementProcessors(bpmnBehaviors);\n+\n+    this.fallback = fallback;\n+    stateTransitionGuard = bpmnBehaviors.stateTransitionGuard();\n+  }\n+\n+  private BpmnElementContainerProcessor<ExecutableFlowElement> getContainerProcessor(\n+      final BpmnElementType elementType) {\n+    return processors.getContainerProcessor(elementType);\n+  }\n+\n+  @Override\n+  public void processRecord(\n+      final TypedRecord<WorkflowInstanceRecord> record,\n+      final TypedResponseWriter responseWriter,\n+      final TypedStreamWriter streamWriter,\n+      final Consumer<SideEffectProducer> sideEffect) {\n+\n+    final var intent = (WorkflowInstanceIntent) record.getIntent();\n+    final var recordValue = record.getValue();\n+    final var bpmnElementType = recordValue.getBpmnElementType();\n+    final var processor = processors.getProcessor(bpmnElementType);\n+\n+    if (processor == null) {\n+      // TODO (saig0): remove multi-instance fallback when the processors of all multi-instance\n+      // elements are migrated\n+      LOGGER.debug(\"[NEW] No processor found for BPMN element type '{}'\", bpmnElementType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MjI4NQ==", "bodyText": "I don't think you want to log this in the hot path right? \ud83d\ude05 probably make sense to put that on trace.", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424172285", "createdAt": "2020-05-13T04:57:07Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnStreamProcessor.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.Loggers;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviorsImpl;\n+import io.zeebe.engine.nwe.behavior.TypesStreamWriterProxy;\n+import io.zeebe.engine.processor.SideEffectProducer;\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedRecordProcessor;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.BpmnStepContext;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableMultiInstanceBody;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.deployment.WorkflowState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+\n+public final class BpmnStreamProcessor implements TypedRecordProcessor<WorkflowInstanceRecord> {\n+\n+  private static final Logger LOGGER = Loggers.WORKFLOW_PROCESSOR_LOGGER;\n+\n+  private final TypesStreamWriterProxy streamWriterProxy = new TypesStreamWriterProxy();\n+\n+  private final BpmnElementContextImpl context;\n+  private final WorkflowState workflowState;\n+  private final BpmnElementProcessors processors;\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+\n+  private final Consumer<BpmnStepContext<?>> fallback;\n+\n+  public BpmnStreamProcessor(\n+      final ExpressionProcessor expressionProcessor,\n+      final CatchEventBehavior catchEventBehavior,\n+      final ZeebeState zeebeState,\n+      final Consumer<BpmnStepContext<?>> fallback) {\n+    workflowState = zeebeState.getWorkflowState();\n+    context = new BpmnElementContextImpl(zeebeState);\n+\n+    final var bpmnBehaviors =\n+        new BpmnBehaviorsImpl(\n+            expressionProcessor,\n+            streamWriterProxy,\n+            zeebeState,\n+            catchEventBehavior,\n+            this::getContainerProcessor);\n+    processors = new BpmnElementProcessors(bpmnBehaviors);\n+\n+    this.fallback = fallback;\n+    stateTransitionGuard = bpmnBehaviors.stateTransitionGuard();\n+  }\n+\n+  private BpmnElementContainerProcessor<ExecutableFlowElement> getContainerProcessor(\n+      final BpmnElementType elementType) {\n+    return processors.getContainerProcessor(elementType);\n+  }\n+\n+  @Override\n+  public void processRecord(\n+      final TypedRecord<WorkflowInstanceRecord> record,\n+      final TypedResponseWriter responseWriter,\n+      final TypedStreamWriter streamWriter,\n+      final Consumer<SideEffectProducer> sideEffect) {\n+\n+    final var intent = (WorkflowInstanceIntent) record.getIntent();\n+    final var recordValue = record.getValue();\n+    final var bpmnElementType = recordValue.getBpmnElementType();\n+    final var processor = processors.getProcessor(bpmnElementType);\n+\n+    if (processor == null) {\n+      // TODO (saig0): remove multi-instance fallback when the processors of all multi-instance\n+      // elements are migrated\n+      LOGGER.debug(\"[NEW] No processor found for BPMN element type '{}'\", bpmnElementType);\n+\n+      final var multiInstanceBody =\n+          workflowState.getFlowElement(\n+              recordValue.getWorkflowKey(),\n+              recordValue.getElementIdBuffer(),\n+              ExecutableMultiInstanceBody.class);\n+      final var element = multiInstanceBody.getInnerActivity();\n+\n+      streamWriterProxy.wrap(streamWriter);\n+      context.init(record, intent, element, streamWriterProxy, sideEffect);\n+\n+      fallback.accept(context.toStepContext());\n+      return;\n+    }\n+\n+    LOGGER.debug(\n+        \"[NEW] process workflow instance event [BPMN element type: {}, intent: {}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Mjc3MQ==", "bodyText": "Could also have this as enum map :D", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424172771", "createdAt": "2020-05-13T04:59:12Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnStreamProcessor.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.Loggers;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviorsImpl;\n+import io.zeebe.engine.nwe.behavior.TypesStreamWriterProxy;\n+import io.zeebe.engine.processor.SideEffectProducer;\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedRecordProcessor;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.BpmnStepContext;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableMultiInstanceBody;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.deployment.WorkflowState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+\n+public final class BpmnStreamProcessor implements TypedRecordProcessor<WorkflowInstanceRecord> {\n+\n+  private static final Logger LOGGER = Loggers.WORKFLOW_PROCESSOR_LOGGER;\n+\n+  private final TypesStreamWriterProxy streamWriterProxy = new TypesStreamWriterProxy();\n+\n+  private final BpmnElementContextImpl context;\n+  private final WorkflowState workflowState;\n+  private final BpmnElementProcessors processors;\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+\n+  private final Consumer<BpmnStepContext<?>> fallback;\n+\n+  public BpmnStreamProcessor(\n+      final ExpressionProcessor expressionProcessor,\n+      final CatchEventBehavior catchEventBehavior,\n+      final ZeebeState zeebeState,\n+      final Consumer<BpmnStepContext<?>> fallback) {\n+    workflowState = zeebeState.getWorkflowState();\n+    context = new BpmnElementContextImpl(zeebeState);\n+\n+    final var bpmnBehaviors =\n+        new BpmnBehaviorsImpl(\n+            expressionProcessor,\n+            streamWriterProxy,\n+            zeebeState,\n+            catchEventBehavior,\n+            this::getContainerProcessor);\n+    processors = new BpmnElementProcessors(bpmnBehaviors);\n+\n+    this.fallback = fallback;\n+    stateTransitionGuard = bpmnBehaviors.stateTransitionGuard();\n+  }\n+\n+  private BpmnElementContainerProcessor<ExecutableFlowElement> getContainerProcessor(\n+      final BpmnElementType elementType) {\n+    return processors.getContainerProcessor(elementType);\n+  }\n+\n+  @Override\n+  public void processRecord(\n+      final TypedRecord<WorkflowInstanceRecord> record,\n+      final TypedResponseWriter responseWriter,\n+      final TypedStreamWriter streamWriter,\n+      final Consumer<SideEffectProducer> sideEffect) {\n+\n+    final var intent = (WorkflowInstanceIntent) record.getIntent();\n+    final var recordValue = record.getValue();\n+    final var bpmnElementType = recordValue.getBpmnElementType();\n+    final var processor = processors.getProcessor(bpmnElementType);\n+\n+    if (processor == null) {\n+      // TODO (saig0): remove multi-instance fallback when the processors of all multi-instance\n+      // elements are migrated\n+      LOGGER.debug(\"[NEW] No processor found for BPMN element type '{}'\", bpmnElementType);\n+\n+      final var multiInstanceBody =\n+          workflowState.getFlowElement(\n+              recordValue.getWorkflowKey(),\n+              recordValue.getElementIdBuffer(),\n+              ExecutableMultiInstanceBody.class);\n+      final var element = multiInstanceBody.getInnerActivity();\n+\n+      streamWriterProxy.wrap(streamWriter);\n+      context.init(record, intent, element, streamWriterProxy, sideEffect);\n+\n+      fallback.accept(context.toStepContext());\n+      return;\n+    }\n+\n+    LOGGER.debug(\n+        \"[NEW] process workflow instance event [BPMN element type: {}, intent: {}]\",\n+        bpmnElementType,\n+        intent);\n+\n+    final ExecutableFlowElement element = getElement(recordValue, processor);\n+\n+    // initialize the stuff\n+    streamWriterProxy.wrap(streamWriter);\n+    context.init(record, intent, element, streamWriterProxy, sideEffect);\n+\n+    // process the event\n+    if (stateTransitionGuard.isValidStateTransition(context)) {\n+      processEvent(intent, processor, element);\n+    }\n+  }\n+\n+  private void processEvent(\n+      final WorkflowInstanceIntent intent,\n+      final BpmnElementProcessor<ExecutableFlowElement> processor,\n+      final ExecutableFlowElement element) {\n+\n+    switch (intent) {\n+      case ELEMENT_ACTIVATING:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MzI3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final var processor = (BpmnElementProcessor<T>) processors.get(bpmnElementType);\n          \n          \n            \n                if (processor == null) {\n          \n          \n            \n                  //      throw new UnsupportedOperationException(\n          \n          \n            \n                  //          String.format(\"no processor found for BPMN element type '%s'\", bpmnElementType));\n          \n          \n            \n                }\n          \n          \n            \n                return processor;\n          \n          \n            \n              return (BpmnElementProcessor<T>) processors.get(bpmnElementType);", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424173276", "createdAt": "2020-05-13T05:01:02Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnElementProcessors.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.container.MultiInstanceBodyProcessor;\n+import io.zeebe.engine.nwe.container.ProcessProcessor;\n+import io.zeebe.engine.nwe.container.SubProcessProcessor;\n+import io.zeebe.engine.nwe.gateway.ExclusiveGatewayProcessor;\n+import io.zeebe.engine.nwe.task.ServiceTaskProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+public final class BpmnElementProcessors {\n+\n+  private final Map<BpmnElementType, BpmnElementProcessor<?>> processors =\n+      new EnumMap<>(BpmnElementType.class);\n+\n+  public BpmnElementProcessors(final BpmnBehaviors bpmnBehaviors) {\n+    // tasks\n+    processors.put(BpmnElementType.SERVICE_TASK, new ServiceTaskProcessor(bpmnBehaviors));\n+    // gateways\n+    processors.put(BpmnElementType.EXCLUSIVE_GATEWAY, new ExclusiveGatewayProcessor(bpmnBehaviors));\n+    // containers\n+    processors.put(BpmnElementType.PROCESS, new ProcessProcessor(bpmnBehaviors));\n+    processors.put(BpmnElementType.SUB_PROCESS, new SubProcessProcessor(bpmnBehaviors));\n+    processors.put(\n+        BpmnElementType.MULTI_INSTANCE_BODY, new MultiInstanceBodyProcessor(bpmnBehaviors));\n+  }\n+\n+  public <T extends ExecutableFlowElement> BpmnElementProcessor<T> getProcessor(\n+      final BpmnElementType bpmnElementType) {\n+    if (bpmnElementType == BpmnElementType.SUB_PROCESS\n+        || bpmnElementType == BpmnElementType.PROCESS) {\n+      return null;\n+    }\n+\n+    final var processor = (BpmnElementProcessor<T>) processors.get(bpmnElementType);\n+    if (processor == null) {\n+      //      throw new UnsupportedOperationException(\n+      //          String.format(\"no processor found for BPMN element type '%s'\", bpmnElementType));\n+    }\n+    return processor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MzM2MQ==", "bodyText": "Why?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424173361", "createdAt": "2020-05-13T05:01:25Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnElementProcessors.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.container.MultiInstanceBodyProcessor;\n+import io.zeebe.engine.nwe.container.ProcessProcessor;\n+import io.zeebe.engine.nwe.container.SubProcessProcessor;\n+import io.zeebe.engine.nwe.gateway.ExclusiveGatewayProcessor;\n+import io.zeebe.engine.nwe.task.ServiceTaskProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+public final class BpmnElementProcessors {\n+\n+  private final Map<BpmnElementType, BpmnElementProcessor<?>> processors =\n+      new EnumMap<>(BpmnElementType.class);\n+\n+  public BpmnElementProcessors(final BpmnBehaviors bpmnBehaviors) {\n+    // tasks\n+    processors.put(BpmnElementType.SERVICE_TASK, new ServiceTaskProcessor(bpmnBehaviors));\n+    // gateways\n+    processors.put(BpmnElementType.EXCLUSIVE_GATEWAY, new ExclusiveGatewayProcessor(bpmnBehaviors));\n+    // containers\n+    processors.put(BpmnElementType.PROCESS, new ProcessProcessor(bpmnBehaviors));\n+    processors.put(BpmnElementType.SUB_PROCESS, new SubProcessProcessor(bpmnBehaviors));\n+    processors.put(\n+        BpmnElementType.MULTI_INSTANCE_BODY, new MultiInstanceBodyProcessor(bpmnBehaviors));\n+  }\n+\n+  public <T extends ExecutableFlowElement> BpmnElementProcessor<T> getProcessor(\n+      final BpmnElementType bpmnElementType) {\n+    if (bpmnElementType == BpmnElementType.SUB_PROCESS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MzUxNQ==", "bodyText": "Why we sometimes throw exceptions and sometimes return null? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424173515", "createdAt": "2020-05-13T05:02:05Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/BpmnElementProcessors.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.container.MultiInstanceBodyProcessor;\n+import io.zeebe.engine.nwe.container.ProcessProcessor;\n+import io.zeebe.engine.nwe.container.SubProcessProcessor;\n+import io.zeebe.engine.nwe.gateway.ExclusiveGatewayProcessor;\n+import io.zeebe.engine.nwe.task.ServiceTaskProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.EnumMap;\n+import java.util.Map;\n+\n+public final class BpmnElementProcessors {\n+\n+  private final Map<BpmnElementType, BpmnElementProcessor<?>> processors =\n+      new EnumMap<>(BpmnElementType.class);\n+\n+  public BpmnElementProcessors(final BpmnBehaviors bpmnBehaviors) {\n+    // tasks\n+    processors.put(BpmnElementType.SERVICE_TASK, new ServiceTaskProcessor(bpmnBehaviors));\n+    // gateways\n+    processors.put(BpmnElementType.EXCLUSIVE_GATEWAY, new ExclusiveGatewayProcessor(bpmnBehaviors));\n+    // containers\n+    processors.put(BpmnElementType.PROCESS, new ProcessProcessor(bpmnBehaviors));\n+    processors.put(BpmnElementType.SUB_PROCESS, new SubProcessProcessor(bpmnBehaviors));\n+    processors.put(\n+        BpmnElementType.MULTI_INSTANCE_BODY, new MultiInstanceBodyProcessor(bpmnBehaviors));\n+  }\n+\n+  public <T extends ExecutableFlowElement> BpmnElementProcessor<T> getProcessor(\n+      final BpmnElementType bpmnElementType) {\n+    if (bpmnElementType == BpmnElementType.SUB_PROCESS\n+        || bpmnElementType == BpmnElementType.PROCESS) {\n+      return null;\n+    }\n+\n+    final var processor = (BpmnElementProcessor<T>) processors.get(bpmnElementType);\n+    if (processor == null) {\n+      //      throw new UnsupportedOperationException(\n+      //          String.format(\"no processor found for BPMN element type '%s'\", bpmnElementType));\n+    }\n+    return processor;\n+  }\n+\n+  public <T extends ExecutableFlowElement> BpmnElementContainerProcessor<T> getContainerProcessor(\n+      final BpmnElementType bpmnElementType) {\n+    switch (bpmnElementType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NDczMQ==", "bodyText": "shouldn't we check the ok value?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424174731", "createdAt": "2020-05-13T05:06:38Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/WorkflowInstanceStateTransitionGuard.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.Loggers;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.Either;\n+import org.slf4j.Logger;\n+\n+/**\n+ * A check to prevent concurrent state transitions of a workflow instance.\n+ *\n+ * <p>A workflow instance can be have concurrent state transitions if a user command is received\n+ * (e.g. cancel workflow instance) or if an internal/external event is triggered (e.g. timer\n+ * boundary event). In this case, the current workflow instance processing needs to be interrupted\n+ * be avoid an inconsistent state.\n+ */\n+public final class WorkflowInstanceStateTransitionGuard {\n+\n+  private static final Logger LOGGER = Loggers.WORKFLOW_PROCESSOR_LOGGER;\n+\n+  private final BpmnStateBehavior stateBehavior;\n+\n+  public WorkflowInstanceStateTransitionGuard(final BpmnStateBehavior stateBehavior) {\n+    this.stateBehavior = stateBehavior;\n+  }\n+\n+  /**\n+   * Checks if a workflow instance event can be processed based on the current state.\n+   *\n+   * @return {@code true} if the transition is valid.\n+   */\n+  public boolean isValidStateTransition(final BpmnElementContext context) {\n+    final var result = checkStateTransition(context);\n+\n+    // log the reason for better debugging\n+    result.ifLeft(\n+        violation ->\n+            LOGGER.debug(\n+                \"Don't process event because of an illegal state transition: {} [context: {}]\",\n+                violation,\n+                context));\n+\n+    return result.isRight();\n+  }\n+\n+  private Either<String, ?> checkStateTransition(final BpmnElementContext context) {\n+    switch (context.getIntent()) {\n+      case ELEMENT_ACTIVATING:\n+      case ELEMENT_ACTIVATED:\n+      case ELEMENT_COMPLETING:\n+      case ELEMENT_COMPLETED:\n+        return hasElementInstanceWithState(context, context.getIntent())\n+            .flatMap(ok -> hasActiveFlowScopeInstance(context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NDk1MQ==", "bodyText": "What is the difference between our old Tuple class and now this either class ? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424174951", "createdAt": "2020-05-13T05:07:24Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/WorkflowInstanceStateTransitionGuard.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe;\n+\n+import io.zeebe.engine.Loggers;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.Either;\n+import org.slf4j.Logger;\n+\n+/**\n+ * A check to prevent concurrent state transitions of a workflow instance.\n+ *\n+ * <p>A workflow instance can be have concurrent state transitions if a user command is received\n+ * (e.g. cancel workflow instance) or if an internal/external event is triggered (e.g. timer\n+ * boundary event). In this case, the current workflow instance processing needs to be interrupted\n+ * be avoid an inconsistent state.\n+ */\n+public final class WorkflowInstanceStateTransitionGuard {\n+\n+  private static final Logger LOGGER = Loggers.WORKFLOW_PROCESSOR_LOGGER;\n+\n+  private final BpmnStateBehavior stateBehavior;\n+\n+  public WorkflowInstanceStateTransitionGuard(final BpmnStateBehavior stateBehavior) {\n+    this.stateBehavior = stateBehavior;\n+  }\n+\n+  /**\n+   * Checks if a workflow instance event can be processed based on the current state.\n+   *\n+   * @return {@code true} if the transition is valid.\n+   */\n+  public boolean isValidStateTransition(final BpmnElementContext context) {\n+    final var result = checkStateTransition(context);\n+\n+    // log the reason for better debugging\n+    result.ifLeft(\n+        violation ->\n+            LOGGER.debug(\n+                \"Don't process event because of an illegal state transition: {} [context: {}]\",\n+                violation,\n+                context));\n+\n+    return result.isRight();\n+  }\n+\n+  private Either<String, ?> checkStateTransition(final BpmnElementContext context) {\n+    switch (context.getIntent()) {\n+      case ELEMENT_ACTIVATING:\n+      case ELEMENT_ACTIVATED:\n+      case ELEMENT_COMPLETING:\n+      case ELEMENT_COMPLETED:\n+        return hasElementInstanceWithState(context, context.getIntent())\n+            .flatMap(ok -> hasActiveFlowScopeInstance(context));\n+\n+      case ELEMENT_TERMINATING:\n+      case ELEMENT_TERMINATED:\n+        return hasElementInstanceWithState(context, context.getIntent());\n+\n+      case EVENT_OCCURRED:\n+        return hasElementInstanceWithState(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+\n+      case SEQUENCE_FLOW_TAKEN:\n+        return hasActiveFlowScopeInstance(context);\n+\n+      default:\n+        return Either.left(\n+            String.format(\n+                \"Expected event to have a workflow instance intent but was '%s'\",\n+                context.getIntent()));\n+    }\n+  }\n+\n+  private Either<String, ElementInstance> getElementInstance(final BpmnElementContext context) {\n+    final var elementInstance = stateBehavior.getElementInstance(context);\n+    if (elementInstance != null) {\n+      return Either.right(elementInstance);\n+\n+    } else {\n+      return Either.left(\n+          String.format(\n+              \"Expected element instance with key '%d' to be present in state but not found.\",\n+              context.getElementInstanceKey()));\n+    }\n+  }\n+\n+  private Either<String, ElementInstance> getFlowScopeInstance(final BpmnElementContext context) {\n+    final var flowScopeInstance = stateBehavior.getFlowScopeInstance(context);\n+    if (flowScopeInstance != null) {\n+      return Either.right(flowScopeInstance);\n+\n+    } else {\n+      return Either.left(\n+          String.format(\n+              \"Expected flow scope instance with key '%d' to be present in state but not found.\",\n+              context.getElementInstanceKey()));\n+    }\n+  }\n+\n+  private Either<String, ElementInstance> hasElementInstanceInState(\n+      final ElementInstance elementInstance, final WorkflowInstanceIntent expectedState) {\n+    final var currentState = elementInstance.getState();\n+    if (currentState != expectedState) {\n+      return Either.left(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTMwMw==", "bodyText": "can we have comment why this could happen?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424175303", "createdAt": "2020-05-13T05:08:37Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnEventSubscriptionBehavior.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor.EvaluationException;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableActivity;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableBoundaryEvent;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventSupplier;\n+import io.zeebe.engine.processor.workflow.message.MessageCorrelationKeyException;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.EventTrigger;\n+import io.zeebe.engine.state.instance.StoredRecord.Purpose;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+import io.zeebe.util.buffer.BufferUtil;\n+\n+public final class BpmnEventSubscriptionBehavior {\n+\n+  private final WorkflowInstanceRecord eventRecord = new WorkflowInstanceRecord();\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final EventScopeInstanceState eventScopeInstanceState;\n+  private final ElementInstanceState elementInstanceState;\n+  private final CatchEventBehavior catchEventBehavior;\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+\n+  public BpmnEventSubscriptionBehavior(\n+      final BpmnStateBehavior stateBehavior,\n+      final BpmnStateTransitionBehavior stateTransitionBehavior,\n+      final CatchEventBehavior catchEventBehavior,\n+      final TypedStreamWriter streamWriter,\n+      final ZeebeState zeebeState) {\n+    this.stateBehavior = stateBehavior;\n+    this.stateTransitionBehavior = stateTransitionBehavior;\n+    this.catchEventBehavior = catchEventBehavior;\n+    this.streamWriter = streamWriter;\n+\n+    eventScopeInstanceState = zeebeState.getWorkflowState().getEventScopeInstanceState();\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    keyGenerator = zeebeState.getKeyGenerator();\n+  }\n+\n+  public <T extends ExecutableActivity> void triggerBoundaryEvent(\n+      final T element, final BpmnElementContext context) {\n+    final var eventTrigger =\n+        eventScopeInstanceState.peekEventTrigger(context.getElementInstanceKey());\n+\n+    if (eventTrigger == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTU4NQ==", "bodyText": "What is the benefit here to use this either?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424175585", "createdAt": "2020-05-13T05:09:35Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnEventSubscriptionBehavior.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor.EvaluationException;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableActivity;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableBoundaryEvent;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventSupplier;\n+import io.zeebe.engine.processor.workflow.message.MessageCorrelationKeyException;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.EventTrigger;\n+import io.zeebe.engine.state.instance.StoredRecord.Purpose;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+import io.zeebe.util.buffer.BufferUtil;\n+\n+public final class BpmnEventSubscriptionBehavior {\n+\n+  private final WorkflowInstanceRecord eventRecord = new WorkflowInstanceRecord();\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final EventScopeInstanceState eventScopeInstanceState;\n+  private final ElementInstanceState elementInstanceState;\n+  private final CatchEventBehavior catchEventBehavior;\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+\n+  public BpmnEventSubscriptionBehavior(\n+      final BpmnStateBehavior stateBehavior,\n+      final BpmnStateTransitionBehavior stateTransitionBehavior,\n+      final CatchEventBehavior catchEventBehavior,\n+      final TypedStreamWriter streamWriter,\n+      final ZeebeState zeebeState) {\n+    this.stateBehavior = stateBehavior;\n+    this.stateTransitionBehavior = stateTransitionBehavior;\n+    this.catchEventBehavior = catchEventBehavior;\n+    this.streamWriter = streamWriter;\n+\n+    eventScopeInstanceState = zeebeState.getWorkflowState().getEventScopeInstanceState();\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    keyGenerator = zeebeState.getKeyGenerator();\n+  }\n+\n+  public <T extends ExecutableActivity> void triggerBoundaryEvent(\n+      final T element, final BpmnElementContext context) {\n+    final var eventTrigger =\n+        eventScopeInstanceState.peekEventTrigger(context.getElementInstanceKey());\n+\n+    if (eventTrigger == null) {\n+      // discard event\n+      return;\n+    }\n+\n+    eventRecord.reset();\n+    eventRecord.wrap(context.getRecordValue());\n+    eventRecord.setElementId(eventTrigger.getElementId());\n+    eventRecord.setBpmnElementType(BpmnElementType.BOUNDARY_EVENT);\n+\n+    final var boundaryEvent = getBoundaryEvent(element, context, eventTrigger);\n+\n+    final long boundaryElementInstanceKey = keyGenerator.nextKey();\n+    if (boundaryEvent.interrupting()) {\n+\n+      deferBoundaryEvent(context, boundaryElementInstanceKey);\n+\n+      stateTransitionBehavior.transitionToTerminating(context);\n+\n+    } else {\n+      activateBoundaryEvent(context, boundaryElementInstanceKey, eventRecord);\n+    }\n+\n+    stateBehavior\n+        .getVariablesState()\n+        .setTemporaryVariables(boundaryElementInstanceKey, eventTrigger.getVariables());\n+\n+    eventScopeInstanceState.deleteTrigger(\n+        context.getElementInstanceKey(), eventTrigger.getEventKey());\n+  }\n+\n+  private <T extends ExecutableActivity> ExecutableBoundaryEvent getBoundaryEvent(\n+      final T element, final BpmnElementContext context, final EventTrigger eventTrigger) {\n+\n+    return element.getBoundaryEvents().stream()\n+        .filter(boundaryEvent -> boundaryEvent.getId().equals(eventTrigger.getElementId()))\n+        .findFirst()\n+        .orElseThrow(\n+            () ->\n+                new IllegalStateException(\n+                    String.format(\n+                        \"Expected boundary event with id '%s' but not found. [context: %s]\",\n+                        BufferUtil.bufferAsString(eventTrigger.getElementId()), context)));\n+  }\n+\n+  private void deferBoundaryEvent(\n+      final BpmnElementContext context, final long boundaryElementInstanceKey) {\n+\n+    elementInstanceState.storeRecord(\n+        boundaryElementInstanceKey,\n+        context.getElementInstanceKey(),\n+        eventRecord,\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n+        Purpose.DEFERRED);\n+  }\n+\n+  public void publishTriggeredBoundaryEvent(final BpmnElementContext context) {\n+\n+    elementInstanceState.getDeferredRecords(context.getElementInstanceKey()).stream()\n+        .filter(record -> record.getValue().getBpmnElementType() == BpmnElementType.BOUNDARY_EVENT)\n+        .findFirst()\n+        .ifPresent(\n+            deferredRecord ->\n+                activateBoundaryEvent(context, deferredRecord.getKey(), deferredRecord.getValue()));\n+  }\n+\n+  private void activateBoundaryEvent(\n+      final BpmnElementContext context,\n+      final long elementInstanceKey,\n+      final WorkflowInstanceRecord eventRecord) {\n+\n+    streamWriter.appendNewEvent(\n+        elementInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, eventRecord);\n+\n+    stateBehavior.createElementInstanceInFlowScope(context, elementInstanceKey, eventRecord);\n+    stateBehavior.spawnToken(context);\n+  }\n+\n+  public <T extends ExecutableCatchEventSupplier> Either<Failure, Void> subscribeToEvents(\n+      final T element, final BpmnElementContext context) {\n+\n+    try {\n+      catchEventBehavior.subscribeToEvents(context.toStepContext(), element);\n+      return Either.right(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTc5MA==", "bodyText": "what is this magic number? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424175790", "createdAt": "2020-05-13T05:10:17Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnEventSubscriptionBehavior.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.CatchEventBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor.EvaluationException;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableActivity;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableBoundaryEvent;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventSupplier;\n+import io.zeebe.engine.processor.workflow.message.MessageCorrelationKeyException;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.EventScopeInstanceState;\n+import io.zeebe.engine.state.instance.EventTrigger;\n+import io.zeebe.engine.state.instance.StoredRecord.Purpose;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+import io.zeebe.util.buffer.BufferUtil;\n+\n+public final class BpmnEventSubscriptionBehavior {\n+\n+  private final WorkflowInstanceRecord eventRecord = new WorkflowInstanceRecord();\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final EventScopeInstanceState eventScopeInstanceState;\n+  private final ElementInstanceState elementInstanceState;\n+  private final CatchEventBehavior catchEventBehavior;\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+\n+  public BpmnEventSubscriptionBehavior(\n+      final BpmnStateBehavior stateBehavior,\n+      final BpmnStateTransitionBehavior stateTransitionBehavior,\n+      final CatchEventBehavior catchEventBehavior,\n+      final TypedStreamWriter streamWriter,\n+      final ZeebeState zeebeState) {\n+    this.stateBehavior = stateBehavior;\n+    this.stateTransitionBehavior = stateTransitionBehavior;\n+    this.catchEventBehavior = catchEventBehavior;\n+    this.streamWriter = streamWriter;\n+\n+    eventScopeInstanceState = zeebeState.getWorkflowState().getEventScopeInstanceState();\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    keyGenerator = zeebeState.getKeyGenerator();\n+  }\n+\n+  public <T extends ExecutableActivity> void triggerBoundaryEvent(\n+      final T element, final BpmnElementContext context) {\n+    final var eventTrigger =\n+        eventScopeInstanceState.peekEventTrigger(context.getElementInstanceKey());\n+\n+    if (eventTrigger == null) {\n+      // discard event\n+      return;\n+    }\n+\n+    eventRecord.reset();\n+    eventRecord.wrap(context.getRecordValue());\n+    eventRecord.setElementId(eventTrigger.getElementId());\n+    eventRecord.setBpmnElementType(BpmnElementType.BOUNDARY_EVENT);\n+\n+    final var boundaryEvent = getBoundaryEvent(element, context, eventTrigger);\n+\n+    final long boundaryElementInstanceKey = keyGenerator.nextKey();\n+    if (boundaryEvent.interrupting()) {\n+\n+      deferBoundaryEvent(context, boundaryElementInstanceKey);\n+\n+      stateTransitionBehavior.transitionToTerminating(context);\n+\n+    } else {\n+      activateBoundaryEvent(context, boundaryElementInstanceKey, eventRecord);\n+    }\n+\n+    stateBehavior\n+        .getVariablesState()\n+        .setTemporaryVariables(boundaryElementInstanceKey, eventTrigger.getVariables());\n+\n+    eventScopeInstanceState.deleteTrigger(\n+        context.getElementInstanceKey(), eventTrigger.getEventKey());\n+  }\n+\n+  private <T extends ExecutableActivity> ExecutableBoundaryEvent getBoundaryEvent(\n+      final T element, final BpmnElementContext context, final EventTrigger eventTrigger) {\n+\n+    return element.getBoundaryEvents().stream()\n+        .filter(boundaryEvent -> boundaryEvent.getId().equals(eventTrigger.getElementId()))\n+        .findFirst()\n+        .orElseThrow(\n+            () ->\n+                new IllegalStateException(\n+                    String.format(\n+                        \"Expected boundary event with id '%s' but not found. [context: %s]\",\n+                        BufferUtil.bufferAsString(eventTrigger.getElementId()), context)));\n+  }\n+\n+  private void deferBoundaryEvent(\n+      final BpmnElementContext context, final long boundaryElementInstanceKey) {\n+\n+    elementInstanceState.storeRecord(\n+        boundaryElementInstanceKey,\n+        context.getElementInstanceKey(),\n+        eventRecord,\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n+        Purpose.DEFERRED);\n+  }\n+\n+  public void publishTriggeredBoundaryEvent(final BpmnElementContext context) {\n+\n+    elementInstanceState.getDeferredRecords(context.getElementInstanceKey()).stream()\n+        .filter(record -> record.getValue().getBpmnElementType() == BpmnElementType.BOUNDARY_EVENT)\n+        .findFirst()\n+        .ifPresent(\n+            deferredRecord ->\n+                activateBoundaryEvent(context, deferredRecord.getKey(), deferredRecord.getValue()));\n+  }\n+\n+  private void activateBoundaryEvent(\n+      final BpmnElementContext context,\n+      final long elementInstanceKey,\n+      final WorkflowInstanceRecord eventRecord) {\n+\n+    streamWriter.appendNewEvent(\n+        elementInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, eventRecord);\n+\n+    stateBehavior.createElementInstanceInFlowScope(context, elementInstanceKey, eventRecord);\n+    stateBehavior.spawnToken(context);\n+  }\n+\n+  public <T extends ExecutableCatchEventSupplier> Either<Failure, Void> subscribeToEvents(\n+      final T element, final BpmnElementContext context) {\n+\n+    try {\n+      catchEventBehavior.subscribeToEvents(context.toStepContext(), element);\n+      return Either.right(null);\n+\n+    } catch (final MessageCorrelationKeyException e) {\n+      return Either.left(\n+          new Failure(\n+              e.getMessage(),\n+              ErrorType.EXTRACT_VALUE_ERROR,\n+              e.getContext().getVariablesScopeKey()));\n+\n+    } catch (final EvaluationException e) {\n+      return Either.left(\n+          new Failure(\n+              e.getMessage(), ErrorType.EXTRACT_VALUE_ERROR, context.getElementInstanceKey()));\n+    }\n+  }\n+\n+  public void unsubscribeFromEvents(final BpmnElementContext context) {\n+    catchEventBehavior.unsubscribeFromEvents(\n+        context.getElementInstanceKey(), context.toStepContext());\n+  }\n+\n+  public void publishTriggeredEventSubProcess(final BpmnElementContext context) {\n+    final var elementInstance = stateBehavior.getElementInstance(context);\n+\n+    if (isInterrupted(elementInstance)) {\n+      elementInstanceState.getDeferredRecords(context.getElementInstanceKey()).stream()\n+          .filter(record -> record.getKey() == elementInstance.getInterruptingEventKey())\n+          .filter(record -> record.getValue().getBpmnElementType() == BpmnElementType.SUB_PROCESS)\n+          .findFirst()\n+          .ifPresent(\n+              record -> {\n+                final var elementInstanceKey = record.getKey();\n+                final var interruptingRecord = record.getValue();\n+\n+                streamWriter.appendNewEvent(\n+                    elementInstanceKey,\n+                    WorkflowInstanceIntent.ELEMENT_ACTIVATING,\n+                    interruptingRecord);\n+\n+                stateBehavior.createChildElementInstance(\n+                    context, elementInstanceKey, interruptingRecord);\n+              });\n+    }\n+  }\n+\n+  private boolean isInterrupted(final ElementInstance elementInstance) {\n+    return elementInstance.getNumberOfActiveTokens() == 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODYxOA==", "bodyText": "Just asking:\nWouldn't it be possible to define the state machine once in a lifecycle processor.\nCurrently you need to check whether the transition is OK and also you always need to take the transition in the elementTypeProcessor implementations. But this lifecycle is always the same right?\nCould look like this:\nLifecycleProcessor {\n\n if (elementType == Activating)\n{\n  processors.get(elementType).onActivating(context)\n  transitionToActivated()\n}\nelse if (elementType == Completing)\n{\n  processors.get(elementType).onCompleting(context)\n  transitionToCompleted()\n}\n}", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424178618", "createdAt": "2020-05-13T05:21:18Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.metrics.WorkflowEngineMetrics;\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.WorkflowInstanceStateTransitionGuard;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowNode;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableSequenceFlow;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Function;\n+\n+public final class BpmnStateTransitionBehavior {\n+\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+      processorLookUp;\n+\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+  private final WorkflowEngineMetrics metrics;\n+\n+  public BpmnStateTransitionBehavior(\n+      final TypedStreamWriter streamWriter,\n+      final KeyGenerator keyGenerator,\n+      final BpmnStateBehavior stateBehavior,\n+      final WorkflowEngineMetrics metrics,\n+      final WorkflowInstanceStateTransitionGuard stateTransitionGuard,\n+      final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+          processorLookUp) {\n+    this.streamWriter = streamWriter;\n+    this.keyGenerator = keyGenerator;\n+    this.stateBehavior = stateBehavior;\n+    this.metrics = metrics;\n+    this.stateTransitionGuard = stateTransitionGuard;\n+    this.processorLookUp = processorLookUp;\n+  }\n+\n+  public void transitionToActivated(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_ACTIVATED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_ACTIVATED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+\n+    stateTransitionGuard.registerStateTransition(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODg3NQ==", "bodyText": "\ud83c\udf89", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424178875", "createdAt": "2020-05-13T05:22:23Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.metrics.WorkflowEngineMetrics;\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.WorkflowInstanceStateTransitionGuard;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowNode;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableSequenceFlow;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Function;\n+\n+public final class BpmnStateTransitionBehavior {\n+\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+      processorLookUp;\n+\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+  private final WorkflowEngineMetrics metrics;\n+\n+  public BpmnStateTransitionBehavior(\n+      final TypedStreamWriter streamWriter,\n+      final KeyGenerator keyGenerator,\n+      final BpmnStateBehavior stateBehavior,\n+      final WorkflowEngineMetrics metrics,\n+      final WorkflowInstanceStateTransitionGuard stateTransitionGuard,\n+      final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+          processorLookUp) {\n+    this.streamWriter = streamWriter;\n+    this.keyGenerator = keyGenerator;\n+    this.stateBehavior = stateBehavior;\n+    this.metrics = metrics;\n+    this.stateTransitionGuard = stateTransitionGuard;\n+    this.processorLookUp = processorLookUp;\n+  }\n+\n+  public void transitionToActivated(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_ACTIVATED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_ACTIVATED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+\n+    stateTransitionGuard.registerStateTransition(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+    metrics.elementInstanceActivated(context.getBpmnElementType());\n+  }\n+\n+  public void transitionToCompleting(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_COMPLETING)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_COMPLETING, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_COMPLETING);\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_COMPLETING);\n+  }\n+\n+  public void transitionToCompleted(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_COMPLETED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_COMPLETED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_COMPLETED);\n+\n+    stateTransitionGuard.registerStateTransition(context, WorkflowInstanceIntent.ELEMENT_COMPLETED);\n+    metrics.elementInstanceCompleted(context.getBpmnElementType());\n+  }\n+\n+  public void transitionToTerminating(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_TERMINATING)) {\n+      throw new IllegalStateTransitionException(\n+          WorkflowInstanceIntent.ELEMENT_TERMINATING, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_TERMINATING);\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_TERMINATING);\n+  }\n+\n+  public void transitionToTerminated(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_TERMINATED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_TERMINATED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_TERMINATED);\n+\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_TERMINATED);\n+    metrics.elementInstanceTerminated(context.getBpmnElementType());\n+  }\n+\n+  private void transitionTo(final BpmnElementContext context, final WorkflowInstanceIntent intent) {\n+    streamWriter.appendFollowUpEvent(\n+        context.getElementInstanceKey(), intent, context.getRecordValue());\n+  }\n+\n+  public void takeSequenceFlow(\n+      final BpmnElementContext context, final ExecutableSequenceFlow sequenceFlow) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN)) {\n+      throw new IllegalStateTransitionException(\n+          WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN, context);\n+    }\n+\n+    final var record =\n+        context\n+            .getRecordValue()\n+            .setElementId(sequenceFlow.getId())\n+            .setBpmnElementType(sequenceFlow.getElementType());\n+\n+    streamWriter.appendNewEvent(\n+        keyGenerator.nextKey(), WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN, record);\n+\n+    stateBehavior.spawnToken(context);\n+  }\n+\n+  public ElementInstance activateChildInstance(\n+      final BpmnElementContext context, final ExecutableFlowElement childElement) {\n+\n+    final var childInstanceRecord =\n+        context\n+            .getRecordValue()\n+            .setFlowScopeKey(context.getElementInstanceKey())\n+            .setElementId(childElement.getId())\n+            .setBpmnElementType(childElement.getElementType());\n+\n+    final var childInstanceKey = keyGenerator.nextKey();\n+\n+    streamWriter.appendNewEvent(\n+        childInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, childInstanceRecord);\n+\n+    stateBehavior.updateElementInstance(context, ElementInstance::spawnToken);\n+\n+    return stateBehavior.createChildElementInstance(context, childInstanceKey, childInstanceRecord);\n+  }\n+\n+  public <T extends ExecutableFlowNode> void takeOutgoingSequenceFlows(\n+      final T element, final BpmnElementContext context) {\n+\n+    final var outgoingSequenceFlows = element.getOutgoing();\n+    if (outgoingSequenceFlows.isEmpty()) {\n+      // behaves like an implicit end event\n+      onElementCompleted(element, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTA4Nw==", "bodyText": "I love it that you use our exception message pattern \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424179087", "createdAt": "2020-05-13T05:23:15Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.metrics.WorkflowEngineMetrics;\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.WorkflowInstanceStateTransitionGuard;\n+import io.zeebe.engine.processor.KeyGenerator;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.engine.processor.workflow.WorkflowInstanceLifecycle;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElement;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowNode;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableSequenceFlow;\n+import io.zeebe.engine.state.instance.ElementInstance;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.function.Function;\n+\n+public final class BpmnStateTransitionBehavior {\n+\n+  private final TypedStreamWriter streamWriter;\n+  private final KeyGenerator keyGenerator;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+      processorLookUp;\n+\n+  private final WorkflowInstanceStateTransitionGuard stateTransitionGuard;\n+  private final WorkflowEngineMetrics metrics;\n+\n+  public BpmnStateTransitionBehavior(\n+      final TypedStreamWriter streamWriter,\n+      final KeyGenerator keyGenerator,\n+      final BpmnStateBehavior stateBehavior,\n+      final WorkflowEngineMetrics metrics,\n+      final WorkflowInstanceStateTransitionGuard stateTransitionGuard,\n+      final Function<BpmnElementType, BpmnElementContainerProcessor<ExecutableFlowElement>>\n+          processorLookUp) {\n+    this.streamWriter = streamWriter;\n+    this.keyGenerator = keyGenerator;\n+    this.stateBehavior = stateBehavior;\n+    this.metrics = metrics;\n+    this.stateTransitionGuard = stateTransitionGuard;\n+    this.processorLookUp = processorLookUp;\n+  }\n+\n+  public void transitionToActivated(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_ACTIVATED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_ACTIVATED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+\n+    stateTransitionGuard.registerStateTransition(context, WorkflowInstanceIntent.ELEMENT_ACTIVATED);\n+    metrics.elementInstanceActivated(context.getBpmnElementType());\n+  }\n+\n+  public void transitionToCompleting(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_COMPLETING)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_COMPLETING, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_COMPLETING);\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_COMPLETING);\n+  }\n+\n+  public void transitionToCompleted(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_COMPLETED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_COMPLETED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_COMPLETED);\n+\n+    stateTransitionGuard.registerStateTransition(context, WorkflowInstanceIntent.ELEMENT_COMPLETED);\n+    metrics.elementInstanceCompleted(context.getBpmnElementType());\n+  }\n+\n+  public void transitionToTerminating(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_TERMINATING)) {\n+      throw new IllegalStateTransitionException(\n+          WorkflowInstanceIntent.ELEMENT_TERMINATING, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_TERMINATING);\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_TERMINATING);\n+  }\n+\n+  public void transitionToTerminated(final BpmnElementContext context) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.ELEMENT_TERMINATED)) {\n+      throw new IllegalStateTransitionException(WorkflowInstanceIntent.ELEMENT_TERMINATED, context);\n+    }\n+\n+    transitionTo(context, WorkflowInstanceIntent.ELEMENT_TERMINATED);\n+\n+    stateTransitionGuard.registerStateTransition(\n+        context, WorkflowInstanceIntent.ELEMENT_TERMINATED);\n+    metrics.elementInstanceTerminated(context.getBpmnElementType());\n+  }\n+\n+  private void transitionTo(final BpmnElementContext context, final WorkflowInstanceIntent intent) {\n+    streamWriter.appendFollowUpEvent(\n+        context.getElementInstanceKey(), intent, context.getRecordValue());\n+  }\n+\n+  public void takeSequenceFlow(\n+      final BpmnElementContext context, final ExecutableSequenceFlow sequenceFlow) {\n+    if (!WorkflowInstanceLifecycle.canTransition(\n+        context.getIntent(), WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN)) {\n+      throw new IllegalStateTransitionException(\n+          WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN, context);\n+    }\n+\n+    final var record =\n+        context\n+            .getRecordValue()\n+            .setElementId(sequenceFlow.getId())\n+            .setBpmnElementType(sequenceFlow.getElementType());\n+\n+    streamWriter.appendNewEvent(\n+        keyGenerator.nextKey(), WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN, record);\n+\n+    stateBehavior.spawnToken(context);\n+  }\n+\n+  public ElementInstance activateChildInstance(\n+      final BpmnElementContext context, final ExecutableFlowElement childElement) {\n+\n+    final var childInstanceRecord =\n+        context\n+            .getRecordValue()\n+            .setFlowScopeKey(context.getElementInstanceKey())\n+            .setElementId(childElement.getId())\n+            .setBpmnElementType(childElement.getElementType());\n+\n+    final var childInstanceKey = keyGenerator.nextKey();\n+\n+    streamWriter.appendNewEvent(\n+        childInstanceKey, WorkflowInstanceIntent.ELEMENT_ACTIVATING, childInstanceRecord);\n+\n+    stateBehavior.updateElementInstance(context, ElementInstance::spawnToken);\n+\n+    return stateBehavior.createChildElementInstance(context, childInstanceKey, childInstanceRecord);\n+  }\n+\n+  public <T extends ExecutableFlowNode> void takeOutgoingSequenceFlows(\n+      final T element, final BpmnElementContext context) {\n+\n+    final var outgoingSequenceFlows = element.getOutgoing();\n+    if (outgoingSequenceFlows.isEmpty()) {\n+      // behaves like an implicit end event\n+      onElementCompleted(element, context);\n+\n+    } else {\n+      outgoingSequenceFlows.forEach(sequenceFlow -> takeSequenceFlow(context, sequenceFlow));\n+    }\n+  }\n+\n+  public void onElementCompleted(\n+      final ExecutableFlowElement element, final BpmnElementContext childContext) {\n+\n+    final var flowScope = element.getFlowScope();\n+    final var flowScopeProcessor = processorLookUp.apply(flowScope.getElementType());\n+    final var flowScopeContext = stateBehavior.getFlowScopeContext(childContext);\n+\n+    flowScopeProcessor.onChildCompleted(flowScope, flowScopeContext, childContext);\n+  }\n+\n+  public void onElementTerminated(\n+      final ExecutableFlowElement element, final BpmnElementContext childContext) {\n+\n+    final var flowScope = element.getFlowScope();\n+    final var flowScopeProcessor = processorLookUp.apply(flowScope.getElementType());\n+    final var flowScopeContext = stateBehavior.getFlowScopeContext(childContext);\n+\n+    flowScopeProcessor.onChildTerminated(flowScope, flowScopeContext, childContext);\n+  }\n+\n+  private static final class IllegalStateTransitionException extends IllegalStateException {\n+\n+    private static final String MESSAGE =\n+        \"Expected to take transition to '%s' but element instance is in state '%s'. [context: %s]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTUzMA==", "bodyText": "Why we need that class? \ud83e\udd14", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424179530", "createdAt": "2020-05-13T05:24:56Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/TypesStreamWriterProxy.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedStreamWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import java.util.function.Consumer;\n+\n+public final class TypesStreamWriterProxy implements TypedStreamWriter {\n+\n+  private TypedStreamWriter writer;\n+\n+  public void wrap(final TypedStreamWriter writer) {\n+    this.writer = writer;\n+  }\n+\n+  @Override\n+  public void appendRejection(\n+      final TypedRecord<? extends UnpackedObject> command,\n+      final RejectionType type,\n+      final String reason) {\n+    writer.appendRejection(command, type, reason);\n+  }\n+\n+  @Override\n+  public void appendRejection(\n+      final TypedRecord<? extends UnpackedObject> command,\n+      final RejectionType type,\n+      final String reason,\n+      final Consumer<RecordMetadata> metadata) {\n+    writer.appendRejection(command, type, reason, metadata);\n+  }\n+\n+  @Override\n+  public void appendNewEvent(final long key, final Intent intent, final UnpackedObject value) {\n+    writer.appendNewEvent(key, intent, value);\n+  }\n+\n+  @Override\n+  public void appendFollowUpEvent(final long key, final Intent intent, final UnpackedObject value) {\n+    writer.appendFollowUpEvent(key, intent, value);\n+  }\n+\n+  @Override\n+  public void appendFollowUpEvent(\n+      final long key,\n+      final Intent intent,\n+      final UnpackedObject value,\n+      final Consumer<RecordMetadata> metadata) {\n+    writer.appendFollowUpEvent(key, intent, value, metadata);\n+  }\n+\n+  @Override\n+  public void configureSourceContext(final long sourceRecordPosition) {\n+    writer.configureSourceContext(sourceRecordPosition);\n+  }\n+\n+  @Override\n+  public void appendNewCommand(final Intent intent, final UnpackedObject value) {\n+    writer.appendNewCommand(intent, value);\n+  }\n+\n+  @Override\n+  public void appendFollowUpCommand(\n+      final long key, final Intent intent, final UnpackedObject value) {\n+    writer.appendFollowUpCommand(key, intent, value);\n+  }\n+\n+  @Override\n+  public void appendFollowUpCommand(\n+      final long key,\n+      final Intent intent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTc5OA==", "bodyText": "What is happening here?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424179798", "createdAt": "2020-05-13T05:25:47Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/MultiInstanceBodyProcessor.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.container;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableMultiInstanceBody;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.msgpack.spec.MsgPackHelper;\n+import io.zeebe.msgpack.spec.MsgPackReader;\n+import io.zeebe.msgpack.spec.MsgPackWriter;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.List;\n+import java.util.Optional;\n+import org.agrona.DirectBuffer;\n+import org.agrona.ExpandableArrayBuffer;\n+import org.agrona.MutableDirectBuffer;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class MultiInstanceBodyProcessor\n+    implements BpmnElementContainerProcessor<ExecutableMultiInstanceBody> {\n+\n+  private static final DirectBuffer NIL_VALUE = new UnsafeBuffer(MsgPackHelper.NIL);\n+  private static final DirectBuffer LOOP_COUNTER_VARIABLE = BufferUtil.wrapString(\"loopCounter\");\n+\n+  private final MutableDirectBuffer loopCounterVariableBuffer =\n+      new UnsafeBuffer(new byte[Long.BYTES + 1]);\n+  private final DirectBuffer loopCounterVariableView = new UnsafeBuffer(0, 0);\n+\n+  private final MsgPackReader variableReader = new MsgPackReader();\n+  private final MsgPackWriter variableWriter = new MsgPackWriter();\n+  private final ExpandableArrayBuffer variableBuffer = new ExpandableArrayBuffer();\n+  private final DirectBuffer resultBuffer = new UnsafeBuffer(0, 0);\n+\n+  private final ExpressionProcessor expressionBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final VariablesState variablesState;\n+\n+  public MultiInstanceBodyProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    variablesState = stateBehavior.getVariablesState();\n+    expressionBehavior = bpmnBehaviors.expressionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableMultiInstanceBody> getType() {\n+    return ExecutableMultiInstanceBody.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    // verify that the input collection variable is present and valid\n+    final Optional<List<DirectBuffer>> results = readInputCollectionVariable(element, context);\n+    if (results.isEmpty()) {\n+      return;\n+    }\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    final var loopCharacteristics = element.getLoopCharacteristics();\n+    final Optional<List<DirectBuffer>> inputCollection =\n+        readInputCollectionVariable(element, context);\n+    if (inputCollection.isEmpty()) {\n+      return;\n+    }\n+\n+    final var array = inputCollection.get();\n+    loopCharacteristics\n+        .getOutputCollection()\n+        .ifPresent(variableName -> initializeOutputCollection(context, variableName, array.size()));\n+\n+    if (array.isEmpty()) {\n+      // complete the multi-instance body immediately\n+      stateTransitionBehavior.transitionToCompleting(context);\n+      return;\n+    }\n+\n+    if (loopCharacteristics.isSequential()) {\n+      final var firstItem = array.get(0);\n+      createInnerInstance(element, context, firstItem);\n+\n+    } else {\n+      array.forEach(item -> createInnerInstance(element, context, item));\n+    }\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+\n+    element\n+        .getLoopCharacteristics()\n+        .getOutputCollection()\n+        .ifPresent(variableName -> stateBehavior.propagateVariable(context, variableName));\n+\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);\n+\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTMyOQ==", "bodyText": "Why we need to rewrite the collection?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424181329", "createdAt": "2020-05-13T05:30:44Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/MultiInstanceBodyProcessor.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.container;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableMultiInstanceBody;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.msgpack.spec.MsgPackHelper;\n+import io.zeebe.msgpack.spec.MsgPackReader;\n+import io.zeebe.msgpack.spec.MsgPackWriter;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.List;\n+import java.util.Optional;\n+import org.agrona.DirectBuffer;\n+import org.agrona.ExpandableArrayBuffer;\n+import org.agrona.MutableDirectBuffer;\n+import org.agrona.concurrent.UnsafeBuffer;\n+\n+public final class MultiInstanceBodyProcessor\n+    implements BpmnElementContainerProcessor<ExecutableMultiInstanceBody> {\n+\n+  private static final DirectBuffer NIL_VALUE = new UnsafeBuffer(MsgPackHelper.NIL);\n+  private static final DirectBuffer LOOP_COUNTER_VARIABLE = BufferUtil.wrapString(\"loopCounter\");\n+\n+  private final MutableDirectBuffer loopCounterVariableBuffer =\n+      new UnsafeBuffer(new byte[Long.BYTES + 1]);\n+  private final DirectBuffer loopCounterVariableView = new UnsafeBuffer(0, 0);\n+\n+  private final MsgPackReader variableReader = new MsgPackReader();\n+  private final MsgPackWriter variableWriter = new MsgPackWriter();\n+  private final ExpandableArrayBuffer variableBuffer = new ExpandableArrayBuffer();\n+  private final DirectBuffer resultBuffer = new UnsafeBuffer(0, 0);\n+\n+  private final ExpressionProcessor expressionBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final VariablesState variablesState;\n+\n+  public MultiInstanceBodyProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    variablesState = stateBehavior.getVariablesState();\n+    expressionBehavior = bpmnBehaviors.expressionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableMultiInstanceBody> getType() {\n+    return ExecutableMultiInstanceBody.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    // verify that the input collection variable is present and valid\n+    final Optional<List<DirectBuffer>> results = readInputCollectionVariable(element, context);\n+    if (results.isEmpty()) {\n+      return;\n+    }\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    final var loopCharacteristics = element.getLoopCharacteristics();\n+    final Optional<List<DirectBuffer>> inputCollection =\n+        readInputCollectionVariable(element, context);\n+    if (inputCollection.isEmpty()) {\n+      return;\n+    }\n+\n+    final var array = inputCollection.get();\n+    loopCharacteristics\n+        .getOutputCollection()\n+        .ifPresent(variableName -> initializeOutputCollection(context, variableName, array.size()));\n+\n+    if (array.isEmpty()) {\n+      // complete the multi-instance body immediately\n+      stateTransitionBehavior.transitionToCompleting(context);\n+      return;\n+    }\n+\n+    if (loopCharacteristics.isSequential()) {\n+      final var firstItem = array.get(0);\n+      createInnerInstance(element, context, firstItem);\n+\n+    } else {\n+      array.forEach(item -> createInnerInstance(element, context, item));\n+    }\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+\n+    element\n+        .getLoopCharacteristics()\n+        .getOutputCollection()\n+        .ifPresent(variableName -> stateBehavior.propagateVariable(context, variableName));\n+\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);\n+\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {}\n+\n+  private Optional<List<DirectBuffer>> readInputCollectionVariable(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+    final Expression inputCollection = element.getLoopCharacteristics().getInputCollection();\n+    return expressionBehavior.evaluateArrayExpression(inputCollection, context.toStepContext());\n+  }\n+\n+  private void createInnerInstance(\n+      final ExecutableMultiInstanceBody multiInstanceBody,\n+      final BpmnElementContext context,\n+      final DirectBuffer item) {\n+\n+    final var innerInstance =\n+        stateTransitionBehavior.activateChildInstance(\n+            context, multiInstanceBody.getInnerActivity());\n+\n+    // update loop counters\n+    final var bodyInstance = stateBehavior.getElementInstance(context);\n+    bodyInstance.incrementMultiInstanceLoopCounter();\n+    stateBehavior.updateElementInstance(bodyInstance);\n+\n+    innerInstance.setMultiInstanceLoopCounter(bodyInstance.getMultiInstanceLoopCounter());\n+    stateBehavior.updateElementInstance(innerInstance);\n+\n+    // set instance variables\n+    final var loopCharacteristics = multiInstanceBody.getLoopCharacteristics();\n+\n+    loopCharacteristics\n+        .getInputElement()\n+        .ifPresent(\n+            variableName ->\n+                variablesState.setVariableLocal(\n+                    innerInstance.getKey(), context.getWorkflowKey(), variableName, item));\n+\n+    // Output element expressions that are just a variable or nested property of a variable need to\n+    // be initialised with a nil-value. This makes sure that they are not written at a non-local\n+    // scope.\n+    loopCharacteristics\n+        .getOutputElement()\n+        .flatMap(Expression::getVariableName)\n+        .map(BufferUtil::wrapString)\n+        .ifPresent(\n+            variableName ->\n+                variablesState.setVariableLocal(\n+                    innerInstance.getKey(), context.getWorkflowKey(), variableName, NIL_VALUE));\n+\n+    variablesState.setVariableLocal(\n+        innerInstance.getKey(),\n+        context.getWorkflowKey(),\n+        LOOP_COUNTER_VARIABLE,\n+        wrapLoopCounter(innerInstance.getMultiInstanceLoopCounter()));\n+  }\n+\n+  private DirectBuffer wrapLoopCounter(final int loopCounter) {\n+    variableWriter.wrap(loopCounterVariableBuffer, 0);\n+\n+    variableWriter.writeInteger(loopCounter);\n+    final var length = variableWriter.getOffset();\n+\n+    loopCounterVariableView.wrap(loopCounterVariableBuffer, 0, length);\n+    return loopCounterVariableView;\n+  }\n+\n+  private void initializeOutputCollection(\n+      final BpmnElementContext context, final DirectBuffer variableName, final int size) {\n+\n+    variableWriter.wrap(variableBuffer, 0);\n+\n+    // initialize the array with nil\n+    variableWriter.writeArrayHeader(size);\n+    for (var i = 0; i < size; i++) {\n+      variableWriter.writeNil();\n+    }\n+\n+    final var length = variableWriter.getOffset();\n+\n+    stateBehavior.setLocalVariable(context, variableName, variableBuffer, 0, length);\n+  }\n+\n+  @Override\n+  public void onChildCompleted(\n+      final ExecutableMultiInstanceBody element,\n+      final BpmnElementContext flowScopeContext,\n+      final BpmnElementContext childContext) {\n+    final var loopCharacteristics = element.getLoopCharacteristics();\n+\n+    if (loopCharacteristics.isSequential()) {\n+\n+      final var inputCollectionVariable = readInputCollectionVariable(element, childContext);\n+      if (inputCollectionVariable.isEmpty()) {\n+        return;\n+      }\n+\n+      final var array = inputCollectionVariable.get();\n+      final var loopCounter =\n+          stateBehavior.getFlowScopeInstance(childContext).getMultiInstanceLoopCounter();\n+      if (loopCounter < array.size()) {\n+\n+        final var item = array.get(loopCounter);\n+        createInnerInstance(element, flowScopeContext, item);\n+      }\n+    }\n+\n+    final Optional<Boolean> updatedSuccessfully =\n+        loopCharacteristics\n+            .getOutputCollection()\n+            .map(variableName -> updateOutputCollection(element, childContext, variableName));\n+\n+    if (updatedSuccessfully.isPresent() && !updatedSuccessfully.get()) {\n+      // An incident was raised while updating the output collection, stop handling activity\n+      return;\n+    }\n+\n+    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n+      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n+    }\n+  }\n+\n+  @Override\n+  public void onChildTerminated(\n+      final ExecutableMultiInstanceBody element,\n+      final BpmnElementContext flowScopeContext,\n+      final BpmnElementContext childContext) {\n+\n+    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n+        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n+      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+\n+    } else {\n+      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+    }\n+  }\n+\n+  private boolean updateOutputCollection(\n+      final ExecutableMultiInstanceBody element,\n+      final BpmnElementContext childContext,\n+      final DirectBuffer variableName) {\n+\n+    final var bodyInstanceKey = childContext.getFlowScopeKey();\n+    final var loopCounter =\n+        stateBehavior.getElementInstance(childContext).getMultiInstanceLoopCounter();\n+\n+    final Optional<DirectBuffer> elementVariable = readOutputElementVariable(element, childContext);\n+    if (elementVariable.isEmpty()) {\n+      return false;\n+    }\n+\n+    // we need to read the output element variable before the current collection is read,\n+    // because readOutputElementVariable(Context) uses the same buffer as getVariableLocal\n+    // this could also be avoided by cloning the current collection, but that is slower.\n+    final var currentCollection = variablesState.getVariableLocal(bodyInstanceKey, variableName);\n+    final var updatedCollection = insertAt(currentCollection, loopCounter, elementVariable.get());\n+    variablesState.setVariableLocal(\n+        bodyInstanceKey, childContext.getWorkflowKey(), variableName, updatedCollection);\n+\n+    return true;\n+  }\n+\n+  private Optional<DirectBuffer> readOutputElementVariable(\n+      final ExecutableMultiInstanceBody element, final BpmnElementContext context) {\n+    final var expression = element.getLoopCharacteristics().getOutputElement().orElseThrow();\n+    return expressionBehavior.evaluateAnyExpression(expression, context.toStepContext());\n+  }\n+\n+  private DirectBuffer insertAt(\n+      final DirectBuffer array, final int index, final DirectBuffer element) {\n+\n+    variableReader.wrap(array, 0, array.capacity());\n+    variableReader.readArrayHeader();\n+    variableReader.skipValues((long) index - 1L);\n+\n+    final var offsetBefore = variableReader.getOffset();\n+    variableReader.skipValue();\n+    final var offsetAfter = variableReader.getOffset();\n+\n+    variableWriter.wrap(variableBuffer, 0);\n+    variableWriter.writeRaw(array, 0, offsetBefore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTU1OA==", "bodyText": "What happens in these cases?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424181558", "createdAt": "2020-05-13T05:31:32Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/container/SubProcessProcessor.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.container;\n+\n+import io.zeebe.engine.nwe.BpmnElementContainerProcessor;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableFlowElementContainer;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+\n+public final class SubProcessProcessor\n+    implements BpmnElementContainerProcessor<ExecutableFlowElementContainer> {\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+\n+  public SubProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+  }\n+\n+  @Override\n+  public void onChildCompleted(\n+      final ExecutableFlowElementContainer element,\n+      final BpmnElementContext flowScopeContext,\n+      final BpmnElementContext childContext) {\n+\n+    // TODO (saig0): consume token before calling,\n+    //  this can be done when the rest of this processor is implemented\n+    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n+      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n+    }\n+  }\n+\n+  @Override\n+  public void onChildTerminated(\n+      final ExecutableFlowElementContainer element,\n+      final BpmnElementContext flowScopeContext,\n+      final BpmnElementContext childContext) {\n+\n+    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n+        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n+      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+\n+    } else {\n+      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+    }\n+  }\n+\n+  @Override\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjYzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (element.getOutgoing().size() == 1 && element.getOutgoing().get(0).getCondition() == null) {\n          \n          \n            \n                if (hasOneOutgoingWithoutCondition(element.getOutgoing()) {", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424182631", "createdAt": "2020-05-13T05:35:14Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/nwe/gateway/ExclusiveGatewayProcessor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.gateway;\n+\n+import static io.zeebe.util.buffer.BufferUtil.bufferAsString;\n+\n+import io.zeebe.el.Expression;\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnDeferredRecordsBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.processor.Failure;\n+import io.zeebe.engine.processor.workflow.ExpressionProcessor;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableExclusiveGateway;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableSequenceFlow;\n+import io.zeebe.engine.state.instance.IndexedRecord;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceRecord;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.ErrorType;\n+import io.zeebe.util.Either;\n+\n+public final class ExclusiveGatewayProcessor\n+    implements BpmnElementProcessor<ExecutableExclusiveGateway> {\n+\n+  private static final String NO_OUTGOING_FLOW_CHOSEN_ERROR =\n+      \"Expected at least one condition to evaluate to true, or to have a default flow\";\n+\n+  private final WorkflowInstanceRecord record = new WorkflowInstanceRecord();\n+\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnDeferredRecordsBehavior deferredRecordsBehavior;\n+  private final ExpressionProcessor expressionBehavior;\n+\n+  public ExclusiveGatewayProcessor(final BpmnBehaviors behaviors) {\n+    expressionBehavior = behaviors.expressionBehavior();\n+    incidentBehavior = behaviors.incidentBehavior();\n+    stateBehavior = behaviors.stateBehavior();\n+    deferredRecordsBehavior = behaviors.deferredRecordsBehavior();\n+    stateTransitionBehavior = behaviors.stateTransitionBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableExclusiveGateway> getType() {\n+    return ExecutableExclusiveGateway.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+    if (element.getOutgoing().isEmpty()) {\n+      // there are no flows to take: the gateway is an implicit end for the flow scope\n+      stateTransitionBehavior.transitionToActivated(context);\n+      return;\n+    }\n+\n+    // find outgoing sequence flow with fulfilled condition or the default\n+    findSequenceFlowToTake(element, context)\n+        .ifRightOrLeft(\n+            sequenceFlow -> {\n+              stateTransitionBehavior.transitionToActivated(context);\n+\n+              // defer sequence flow taken, as it will only be taken when the gateway is completed\n+              record.wrap(context.getRecordValue());\n+              record.setElementId(sequenceFlow.getId());\n+              record.setBpmnElementType(BpmnElementType.SEQUENCE_FLOW);\n+              deferredRecordsBehavior.deferNewRecord(\n+                  context,\n+                  context.getElementInstanceKey(),\n+                  record,\n+                  WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN);\n+            },\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+    stateTransitionBehavior.transitionToCompleting(context);\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+\n+    deferredRecordsBehavior.getDeferredRecords(context).stream()\n+        .filter(r -> r.hasState(WorkflowInstanceIntent.SEQUENCE_FLOW_TAKEN))\n+        .findFirst()\n+        .map(r -> getOutgoingSequenceFlow(element, context, r))\n+        .ifPresentOrElse(\n+            sequenceFlow -> stateTransitionBehavior.takeSequenceFlow(context, sequenceFlow),\n+            () -> stateTransitionBehavior.onElementCompleted(element, context));\n+\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+    stateTransitionBehavior.transitionToTerminated(context);\n+  }\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+\n+    incidentBehavior.resolveIncidents(context);\n+\n+    stateTransitionBehavior.onElementTerminated(element, context);\n+\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeInstance(context);\n+  }\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+    throw new UnsupportedOperationException(\n+        String.format(\n+            \"expected to handle occurred event on exclusive gateway, but events should not occur on exclusive gateway. [context: %s]\",\n+            context.toString()));\n+  }\n+\n+  private ExecutableSequenceFlow getOutgoingSequenceFlow(\n+      final ExecutableExclusiveGateway element,\n+      final BpmnElementContext context,\n+      final IndexedRecord record) {\n+\n+    final var sequenceFlowId = record.getValue().getElementIdBuffer();\n+\n+    return element.getOutgoing().stream()\n+        .filter(sequenceFlow -> sequenceFlow.getId().equals(sequenceFlowId))\n+        .findFirst()\n+        .orElseThrow(\n+            () ->\n+                new IllegalStateException(\n+                    String.format(\n+                        \"Expected sequence flow with id '%s' but not found. [context: %s]\",\n+                        bufferAsString(sequenceFlowId), context)));\n+  }\n+\n+  private Either<Failure, ExecutableSequenceFlow> findSequenceFlowToTake(\n+      final ExecutableExclusiveGateway element, final BpmnElementContext context) {\n+\n+    if (element.getOutgoing().size() == 1 && element.getOutgoing().get(0).getCondition() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NDQ4Ng==", "bodyText": "why we need a long here?", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#discussion_r424184486", "createdAt": "2020-05-13T05:41:43Z", "author": {"login": "Zelldon"}, "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/handlers/multiinstance/MultiInstanceBodyCompletedHandler.java", "diffHunk": "@@ -112,7 +114,7 @@ private DirectBuffer insertAt(\n \n     variableReader.wrap(array, 0, array.capacity());\n     variableReader.readArrayHeader();\n-    variableReader.skipValues(index - 1);\n+    variableReader.skipValues((long) index - 1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d7ccb67f648eadd71bb1cc5c70bd60fe7f81a3"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1395c12a5c4d148eeda1f0b00018c27efb8687dd", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1395c12a5c4d148eeda1f0b00018c27efb8687dd", "committedDate": "2020-05-15T13:12:29Z", "message": "chore(engine): introduce new bpmn processing\n\nIncludes new implementation for:\n\n- service task\n- exclusive gateway\n- multi instance\n- boundary event\n- sub process\n\nThis is a combination of 68 commits.\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(engine): try implement exclusive gateway processor\n\nchore(engine): use incidentbehavior\n\nchore(broker): wip\n\nchore(broker): integrate the new BPMN element processor\n\nchore(broker): merging\n\nchore(broker): removing TODOs :)\n\nchore(broker): fix stream writer proxy\n\n* configure event output in context\n\nchore(broker): move state transition in the service task processor\n\n* process service task: terminating successfully\n\nchore(broker): fighting with the step guard\n\nwip\n\nfix(engine): fix token consumption or gw\n\nchore(broker): configure side-effect in context\n\n* fix incident creation\n* handle exception in service task processor\n\nchore(broker): fix incident creation and resolving\n\nchore(broker): fix multi instance behavior\n\nchore(broker): activate exclusive gateway only if no incident\n\nchore(broker): create incident with the correct variable scope\n\nchore(broker): fix code style\n\nchore(broker): fix code style\n\nchore(broker): add missing licence headers\n\nchore(engine): add test to cancel proces with indicent on OR gateway\n\nchore(engine): implement exclusive gateway processor onTerminating\n\nchore(engine): implement onTerminated for or gateway\n\nchore(engine): enable service task completed processor\n\nchore(engine): enable service task completing processor\n\nchore(engine): add test for terminating service task\n\nand improve the similar or gateway test\n\nchore(engine): implement onTerminated for service task processor\n\nchore(engine): fix failing tests after onTerminated implementation\n\nchore(engine): apply exclusive gateway processor also for implicit end\n\nfor example when there are no outgoing sequence flows, or when there is\njust a single one without a condition.\n\nchore(engine): add multi-instance body processor\n\nchore(engine): enable multi-instance activating processor\n\n* increase the stability of the multi-instance test\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): enable multi-instance completing processor\n\nchore(engine): remove explicit state updates on transition\n\nchore(engine): implement onEvent for servicetask processor\n\nchore(engine): handle completing in container processor\n\n* remove explicit state updates on transition\n* extract taking outgoing sequence flows\n\nchore(engine): add license headers :)\n\nchore(engine): add todo\n\nchore(engine): extent Either with additinal consumer methods\n\nchore(engine): verify valid state transitions\n\nchore(engine): clean up\n\n* terminate flow scope in container processor\n* clean up state behavior\n* be more explicit when completing an exclusive gateway\n* be more strict on publishing deferred records\n* extract BPMN element processors\n\nchore(engine): update metrics on writing new events\n\nchore(engine): extent Either with flatMap method\n\nchore(engine): use either to evaluate boolean expression\n\nchore(engine): add JavaDoc for processor interfaces\n\nchore(engine): clean up exclusive gateway processor\n\nchore(engine): extract boundary event behavior\n\n* bundle event subscription behavior in new class\n* be more explicit when consuming deferred records\n\nchore(engine): subscribe to events returns an either\n\nchore(engine): extract variable mapping behavior and apply either type\n\nchore(engine): add missing class file header\n\nchore(engine): moved common behavior\n\n* make it easier to get the inner activity of a multi-instance activity\n\nchore(engine): use existing state transition checks\n\nchore(engine): apply pair review\n\nchore(engine): resolve sonar issues\n\nchore(engine): add missing class file header\n\nchore(engine): extract state transition guard\n\n* create new class to check state transitions before processing an event\n* register state transition while writing the follow-up event\n\nchore(engine): remove unnecessary logging\n\nchore(engine): improve comment\n\nchore(engine): expand the Either documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d41f066ccb0f93cd34c5a416bb9ac2b09ffb657d", "author": {"user": {"login": "korthout", "name": "Nico Korthout"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/d41f066ccb0f93cd34c5a416bb9ac2b09ffb657d", "committedDate": "2020-05-14T16:36:36Z", "message": "chore(engine): expand the Either documentation"}, "afterCommit": {"oid": "1395c12a5c4d148eeda1f0b00018c27efb8687dd", "author": {"user": {"login": "saig0", "name": "Philipp Ossler"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1395c12a5c4d148eeda1f0b00018c27efb8687dd", "committedDate": "2020-05-15T13:12:29Z", "message": "chore(engine): introduce new bpmn processing\n\nIncludes new implementation for:\n\n- service task\n- exclusive gateway\n- multi instance\n- boundary event\n- sub process\n\nThis is a combination of 68 commits.\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(broker): wip\n\nchore(engine): try implement exclusive gateway processor\n\nchore(engine): use incidentbehavior\n\nchore(broker): wip\n\nchore(broker): integrate the new BPMN element processor\n\nchore(broker): merging\n\nchore(broker): removing TODOs :)\n\nchore(broker): fix stream writer proxy\n\n* configure event output in context\n\nchore(broker): move state transition in the service task processor\n\n* process service task: terminating successfully\n\nchore(broker): fighting with the step guard\n\nwip\n\nfix(engine): fix token consumption or gw\n\nchore(broker): configure side-effect in context\n\n* fix incident creation\n* handle exception in service task processor\n\nchore(broker): fix incident creation and resolving\n\nchore(broker): fix multi instance behavior\n\nchore(broker): activate exclusive gateway only if no incident\n\nchore(broker): create incident with the correct variable scope\n\nchore(broker): fix code style\n\nchore(broker): fix code style\n\nchore(broker): add missing licence headers\n\nchore(engine): add test to cancel proces with indicent on OR gateway\n\nchore(engine): implement exclusive gateway processor onTerminating\n\nchore(engine): implement onTerminated for or gateway\n\nchore(engine): enable service task completed processor\n\nchore(engine): enable service task completing processor\n\nchore(engine): add test for terminating service task\n\nand improve the similar or gateway test\n\nchore(engine): implement onTerminated for service task processor\n\nchore(engine): fix failing tests after onTerminated implementation\n\nchore(engine): apply exclusive gateway processor also for implicit end\n\nfor example when there are no outgoing sequence flows, or when there is\njust a single one without a condition.\n\nchore(engine): add multi-instance body processor\n\nchore(engine): enable multi-instance activating processor\n\n* increase the stability of the multi-instance test\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): clean up multi-instance activating processor\n\nchore(engine): enable multi-instance completing processor\n\nchore(engine): remove explicit state updates on transition\n\nchore(engine): implement onEvent for servicetask processor\n\nchore(engine): handle completing in container processor\n\n* remove explicit state updates on transition\n* extract taking outgoing sequence flows\n\nchore(engine): add license headers :)\n\nchore(engine): add todo\n\nchore(engine): extent Either with additinal consumer methods\n\nchore(engine): verify valid state transitions\n\nchore(engine): clean up\n\n* terminate flow scope in container processor\n* clean up state behavior\n* be more explicit when completing an exclusive gateway\n* be more strict on publishing deferred records\n* extract BPMN element processors\n\nchore(engine): update metrics on writing new events\n\nchore(engine): extent Either with flatMap method\n\nchore(engine): use either to evaluate boolean expression\n\nchore(engine): add JavaDoc for processor interfaces\n\nchore(engine): clean up exclusive gateway processor\n\nchore(engine): extract boundary event behavior\n\n* bundle event subscription behavior in new class\n* be more explicit when consuming deferred records\n\nchore(engine): subscribe to events returns an either\n\nchore(engine): extract variable mapping behavior and apply either type\n\nchore(engine): add missing class file header\n\nchore(engine): moved common behavior\n\n* make it easier to get the inner activity of a multi-instance activity\n\nchore(engine): use existing state transition checks\n\nchore(engine): apply pair review\n\nchore(engine): resolve sonar issues\n\nchore(engine): add missing class file header\n\nchore(engine): extract state transition guard\n\n* create new class to check state transitions before processing an event\n* register state transition while writing the follow-up event\n\nchore(engine): remove unnecessary logging\n\nchore(engine): improve comment\n\nchore(engine): expand the Either documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNjM4MTk1", "url": "https://github.com/camunda-cloud/zeebe/pull/4370#pullrequestreview-412638195", "createdAt": "2020-05-15T13:15:49Z", "commit": {"oid": "1395c12a5c4d148eeda1f0b00018c27efb8687dd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2855, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}