{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNTg5MzIx", "number": 4685, "title": "chore(util): introduce spec-compliant Stackdriver Log4J2 layout", "bodyText": "Description\nThis PR refactors the StackdriverJSONLayout into a spec-compliant StackdriverLayout, as described in the following documentation:\n\nLogEntry\njsonPayload special fields\nError report formatting\n\nIt also makes ZbLogger location aware, allowing each LogEvent passed through Log4J to have the correct source location computed. Atomix's ContextualLogger will now extend ZbLogger in order to also inherit those properties, ensuring every event is logged with the right source.\nThe layout is fully backwards compatible, with several properties marked for deprecation, notably: logger, and thread, which were previously top-level keys of the jsonPayload, but should be part of the context. The idea here is that top-level keys should be purely those expected by Stackdriver, and everything else can be delegated to the context map.\nTo better integrate with GCP's Error Reporting tool, the layout can be configured with two attributes: serviceName and serviceVersion. Errors will be aggregated by these two dimensions; by default, the distribution log4j2.xml will map the environment variables ZEEBE_LOG_STACKDRIVER_SERVICENAME and ZEEBE_LOG_STACKDRIVER_SERVICEVERSION to the following system properties, log.stackdriver.serviceName and log.stackdriver.serviceVersion - users can use either to configure the layout, with the system property taking precedence over the environment variable (arguable as we typically don't do this, but it is more consistent with Log4J2).\nAt the moment, anything logged at the error level - with or without an exception - will be reported in the above tool. I find it useful, but we can discuss this decision.\nRelated issues\ncloses #4624\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-06-09T07:24:27Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4685", "merged": true, "mergeCommit": {"oid": "4a977486a6a15dc60e44914e456eb87d35fa2730"}, "closed": true, "closedAt": "2020-06-10T15:25:25Z", "author": {"login": "npepinpe"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpiI4ZgFqTQyNjk1NzQ0NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcp7DryABqjM0MzAxMTU4Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2OTU3NDQ0", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#pullrequestreview-426957444", "createdAt": "2020-06-09T09:26:54Z", "commit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyNjo1NFrOGhA4Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDoxNlrOGhB6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MDYyMw==", "bodyText": "I'm not sure whether we normally have a strong ordering in our dependencies, but I think it's a good idea to keep internal dependencies at the top of the dependencies list.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437270623", "createdAt": "2020-06-09T09:26:54Z", "author": {"login": "korthout"}, "path": "atomix/utils/pom.xml", "diffHunk": "@@ -49,6 +49,11 @@\n       <groupId>org.slf4j</groupId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>zeebe-util</artifactId>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3MjA4MA==", "bodyText": "I would assume it works fine, but does this newline (and indentation) cause any problems to the pattern?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437272080", "createdAt": "2020-06-09T09:29:13Z", "author": {"login": "korthout"}, "path": "dist/src/main/config/log4j2.xml", "diffHunk": "@@ -3,7 +3,12 @@\n \n   <Properties>\n     <Property name=\"log.path\">${sys:app.home}/logs</Property>\n-    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level %logger{36} - %msg%n</Property>\n+    <Property name=\"log.pattern\">%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{actor-name}] [%t] %-5level\n+      %logger{36} - %msg%n", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTA2Nw==", "bodyText": "What does FQCN stand for?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437275067", "createdAt": "2020-06-09T09:33:47Z", "author": {"login": "korthout"}, "path": "atomix/utils/src/main/java/io/atomix/utils/logging/ContextualLogger.java", "diffHunk": "@@ -16,16 +16,18 @@\n  */\n package io.atomix.utils.logging;\n \n+import io.zeebe.util.ZbLogger;\n import org.slf4j.Logger;\n import org.slf4j.Marker;\n \n /** Contextual logger. */\n-public class ContextualLogger extends DelegatingLogger {\n+public class ContextualLogger extends ZbLogger {\n   private static final String SEPARATOR = \" - \";\n+  private static final String FQCN = ContextualLogger.class.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjUyOA==", "bodyText": "These should write message at level tests would be a good case for parameterized. But since you also have other tests you'd need to use junit5 I think. If you want to have a go at junit5, this could be a good chance. Otherwise, I can also see why you wouldn't want to spend more time on this. In any case, the behaviour is already tested.", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286528", "createdAt": "2020-06-09T09:52:40Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Njg4Ng==", "bodyText": "why -1?", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437286886", "createdAt": "2020-06-09T09:53:18Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NzQyOA==", "bodyText": "I like that you test for this! \ud83d\udc4d", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#discussion_r437287428", "createdAt": "2020-06-09T09:54:16Z", "author": {"login": "korthout"}, "path": "util/src/test/java/io/zeebe/util/logging/StackdriverLayoutTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util.logging;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.zeebe.util.LogUtil;\n+import io.zeebe.util.logging.stackdriver.Severity;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntry;\n+import io.zeebe.util.logging.stackdriver.StackdriverLogEntryBuilder;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.core.Layout;\n+import org.apache.logging.log4j.core.Logger;\n+import org.apache.logging.log4j.core.appender.OutputStreamAppender;\n+import org.apache.logging.log4j.core.impl.ThrowableProxy;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.assertj.core.api.JUnitSoftAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.slf4j.LoggerFactory;\n+\n+public final class StackdriverLayoutTest {\n+  private static final org.slf4j.Logger LOGGER =\n+      LoggerFactory.getLogger(StackdriverLayoutTest.class);\n+  private static final ObjectReader OBJECT_READER = new ObjectMapper().reader();\n+  private static final String SERVICE = \"test-service\";\n+  private static final String VERSION = \"test-version\";\n+\n+  @Rule public JUnitSoftAssertions softly = new JUnitSoftAssertions();\n+\n+  private Logger logger;\n+  private PipedInputStream source;\n+  private PipedOutputStream sink;\n+  private OutputStreamAppender appender;\n+\n+  @Before\n+  public void before() throws IOException {\n+    sink = new PipedOutputStream();\n+    source = new PipedInputStream(512 * 1024);\n+    logger = (Logger) LogManager.getLogger();\n+\n+    final var layout =\n+        StackdriverLayout.newBuilder().setServiceName(SERVICE).setServiceVersion(VERSION).build();\n+    appender = createAndStartAppender(layout, sink);\n+    logger.addAppender(appender);\n+\n+    sink.connect(source);\n+    logger.setLevel(Level.DEBUG);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    try {\n+      source.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close source input stream\", e);\n+    }\n+\n+    try {\n+      sink.close();\n+    } catch (final IOException e) {\n+      LOGGER.error(\"Failed to close sink output stream\", e);\n+    }\n+\n+    logger.removeAppender(appender);\n+  }\n+\n+  @Test\n+  public void shouldWriteTraceMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.TRACE);\n+\n+    // when\n+    logger.trace(\"Trace message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteDebugMessages() throws IOException {\n+    // given\n+    logger.setLevel(Level.DEBUG);\n+\n+    // when\n+    logger.debug(\"Debug message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.DEBUG.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteInfoMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.INFO.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteWarningMessage() throws IOException {\n+    // given\n+    logger.setLevel(Level.WARN);\n+\n+    // when\n+    logger.warn(\"Info message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"severity\", Severity.WARNING.name());\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithoutException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    logger.error(\"Error message {}\", 1);\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message 1\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .hasEntrySatisfying(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY,\n+                        reportLocation ->\n+                            softly\n+                                .assertThat(reportLocation)\n+                                .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                                .containsEntry(\"file\", source.getFileName())\n+                                .containsEntry(\"function\", source.getMethodName())\n+                                .containsEntry(\"line\", source.getLineNumber() - 1)))\n+        .doesNotContainKey(\"exception\");\n+  }\n+\n+  @Test\n+  public void shouldWriteErrorMessageWithException() throws IOException {\n+    // given\n+    logger.setLevel(Level.ERROR);\n+\n+    // when\n+    final var exception = new ThrowableProxy(new IllegalStateException(\"Failed\"));\n+    logger.error(\"Error message\", exception.getThrowable());\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"severity\", Severity.ERROR.name())\n+        .containsEntry(\"message\", \"Error message\")\n+        .containsEntry(\"@type\", StackdriverLogEntry.ERROR_REPORT_TYPE)\n+        .containsEntry(\"exception\", exception.getExtendedStackTraceAsString())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .doesNotContainKey(\n+                        StackdriverLogEntryBuilder.ERROR_REPORT_LOCATION_CONTEXT_KEY));\n+  }\n+\n+  @Test\n+  public void shouldContainFormattedMessage() throws IOException {\n+    // given\n+    final var expectedMessage = \"This is an ultra message\";\n+\n+    // when\n+    logger.info(\"This is an {} message\", \"ultra\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly.assertThat(jsonMap).containsEntry(\"message\", expectedMessage);\n+  }\n+\n+  @Test\n+  public void shouldContainTime() throws IOException {\n+    // given\n+    final var lowerBound = Instant.now();\n+\n+    // when\n+    logger.info(\"This is a message\");\n+\n+    // then\n+    final var upperBound = Instant.now();\n+    final var jsonMap = readLoggedEvent();\n+    final var timestampSeconds = ((Number) jsonMap.get(\"timestampSeconds\")).longValue();\n+    final var timestampNanos = ((Number) jsonMap.get(\"timestampNanos\")).longValue();\n+\n+    softly\n+        .assertThat(timestampSeconds)\n+        .isBetween(lowerBound.getEpochSecond(), upperBound.getEpochSecond());\n+    softly\n+        .assertThat(timestampNanos)\n+        .isBetween((long) lowerBound.getNano(), (long) upperBound.getNano());\n+  }\n+\n+  @Test\n+  public void shouldTerminateAllEntriesWithALineSeparator() throws IOException {\n+    // given\n+    final var lineSeparator = System.lineSeparator();\n+\n+    // when\n+    logger.info(\"Should be terminated with a line separator\");\n+\n+    // then\n+    final var rawOutput = source.readNBytes(source.available());\n+    softly.assertThat(new String(rawOutput)).endsWith(lineSeparator);\n+  }\n+\n+  @Test\n+  public void shouldContainSourceLocation() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+    final var stackTrace = new IllegalStateException(\"\").getStackTrace();\n+    final var source = stackTrace[0];\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"logging.googleapis.com/sourceLocation\",\n+            sourceLocation ->\n+                softly\n+                    .assertThat(sourceLocation)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"file\", source.getFileName())\n+                    .containsEntry(\"function\", source.getMethodName())\n+                    .containsEntry(\"line\", source.getLineNumber() - 1));\n+  }\n+\n+  @Test\n+  public void shouldContainServiceContext() throws IOException {\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"serviceContext\",\n+            serviceContext ->\n+                softly\n+                    .assertThat(serviceContext)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"service\", SERVICE)\n+                    .containsEntry(\"version\", VERSION));\n+  }\n+\n+  @Test\n+  public void shouldContainContext() throws IOException {\n+    // given\n+    final var expectedContext = Map.of(\"foo\", \"bar\", \"baz\", \"boz\");\n+\n+    // when\n+    LogUtil.doWithMDC(expectedContext, () -> logger.info(\"Message\"));\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsAllEntriesOf(expectedContext));\n+  }\n+\n+  @Test\n+  public void shouldContainThreadInfo() throws IOException {\n+    // given\n+    final var currentThread = Thread.currentThread();\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"thread\", currentThread.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"threadName\", currentThread.getName())\n+                    .containsEntry(\n+                        \"threadId\",\n+                        (int) currentThread.getId()) // Jackson will parse small numbers as integers\n+                    .containsEntry(\"threadPriority\", currentThread.getPriority()));\n+  }\n+\n+  @Test\n+  public void shouldContainLogger() throws IOException {\n+    // given\n+    logger.setLevel(Level.INFO);\n+\n+    // when\n+    logger.info(\"Message\");\n+\n+    // then\n+    final var jsonMap = readLoggedEvent();\n+    softly\n+        .assertThat(jsonMap)\n+        .containsEntry(\"logger\", logger.getName())\n+        .hasEntrySatisfying(\n+            \"context\",\n+            context ->\n+                softly\n+                    .assertThat(context)\n+                    .asInstanceOf(InstanceOfAssertFactories.MAP)\n+                    .containsEntry(\"loggerName\", logger.getName()));\n+  }\n+\n+  @Deprecated(since = \"0.24.0\", forRemoval = true)\n+  @Test\n+  public void shouldBeBackwardsCompatibleWithStackdriverJSONLayout() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a1d3a7950a3a3a561d4d2ae70949f63ec6ed96c"}, "originalPosition": 358}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3OTU1MTA5", "url": "https://github.com/camunda-cloud/zeebe/pull/4685#pullrequestreview-427955109", "createdAt": "2020-06-10T11:20:05Z", "commit": {"oid": "0f03d55c7ddb21e256892dca7ed0ed18dd804a63"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6a6840c64c6f8be279268d4a871e8288d19b19", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3e6a6840c64c6f8be279268d4a871e8288d19b19", "committedDate": "2020-06-10T15:04:17Z", "message": "chore(util): introduce StackdriverLayout\n\n- adds a Stackdriver log4j2 layout, configurable via a layout plugin\n  builder\n- supports setting severity, context, source location, and the error\n  report type format\n- make ZbLogger location aware; if the delegate logger given to ZbLogger\n  is location aware, then ZbLogger will properly pass the correct logger\n  FQCN (itself) to ensure that the LogEvent source location is properly\n  computed"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90dc3b3bc8535d65a20c9dcd4af8bc262d900c00", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/90dc3b3bc8535d65a20c9dcd4af8bc262d900c00", "committedDate": "2020-06-10T14:08:36Z", "message": "chore(util): fix report location"}, "afterCommit": {"oid": "3e6a6840c64c6f8be279268d4a871e8288d19b19", "author": {"user": {"login": "npepinpe", "name": "Nicolas Pepin-Perreault"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/3e6a6840c64c6f8be279268d4a871e8288d19b19", "committedDate": "2020-06-10T15:04:17Z", "message": "chore(util): introduce StackdriverLayout\n\n- adds a Stackdriver log4j2 layout, configurable via a layout plugin\n  builder\n- supports setting severity, context, source location, and the error\n  report type format\n- make ZbLogger location aware; if the delegate logger given to ZbLogger\n  is location aware, then ZbLogger will properly pass the correct logger\n  FQCN (itself) to ensure that the LogEvent source location is properly\n  computed"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2748, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}