{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzkxMjM3", "number": 219, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNjoxN1rODnkw9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0MToyNlrODnntvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIzNDE0OnYy", "diffSide": "RIGHT", "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNjoxN1rOF1p9uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDoyNzoyMlrOF1uOWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjM5NQ==", "bodyText": "s/withing/within", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391806395", "createdAt": "2020-03-12T18:16:17Z", "author": {"login": "ssheng"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -646,8 +648,10 @@ public void run(final SimpleCallback callback)\n           return;\n         }\n \n-        _lifecycle.create(new Callback<T>()\n-        {\n+        // Lets not trust the _lifecycle to timely return a response here.\n+        // Embedding the callback inside a timeout callback (ObjectCreationTimeoutCallback)\n+        // to force a response withing creationTimeout deadline to reclaim the object slot in the pool", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642144b82c48b317830e69732b5366e0547a864b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3NjE4NA==", "bodyText": "This is taken care in the recent push", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391876184", "createdAt": "2020-03-12T20:27:22Z", "author": {"login": "nizarm"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -646,8 +648,10 @@ public void run(final SimpleCallback callback)\n           return;\n         }\n \n-        _lifecycle.create(new Callback<T>()\n-        {\n+        // Lets not trust the _lifecycle to timely return a response here.\n+        // Embedding the callback inside a timeout callback (ObjectCreationTimeoutCallback)\n+        // to force a response withing creationTimeout deadline to reclaim the object slot in the pool", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjM5NQ=="}, "originalCommit": {"oid": "642144b82c48b317830e69732b5366e0547a864b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODQxMzAzOnYy", "diffSide": "RIGHT", "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOToxMjoxMVrOF1rwxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDowMTozOFrOF1tT4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNTg0Ng==", "bodyText": "This looks like a duplicate of TimeoutCallback. Can you just reuse that?", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391835846", "createdAt": "2020-03-12T19:12:11Z", "author": {"login": "cx-super"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -816,6 +831,40 @@ public long getTime()\n     }\n   }\n \n+  private class ObjectCreationTimeoutCallback implements Callback<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642144b82c48b317830e69732b5366e0547a864b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2MTIxOA==", "bodyText": "I wanted to throw a retry exception since it is connection related. I have refactored TimeoutCallback to accommodate this need. Removed the redundant  ObjectCreationTimeoutCallback", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391861218", "createdAt": "2020-03-12T20:01:38Z", "author": {"login": "nizarm"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -816,6 +831,40 @@ public long getTime()\n     }\n   }\n \n+  private class ObjectCreationTimeoutCallback implements Callback<T>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNTg0Ng=="}, "originalCommit": {"oid": "642144b82c48b317830e69732b5366e0547a864b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODY3NTY3OnYy", "diffSide": "RIGHT", "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDoyNjoxNFrOF1uMkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDozNjoyMVrOF1ueQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3NTczMA==", "bodyText": "Why is this moved down?", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391875730", "createdAt": "2020-03-12T20:26:14Z", "author": {"login": "ssheng"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -698,17 +709,24 @@ public void onError(final Throwable e)\n                 LOG.error(\"Encountered error while invoking error waiter callback\", ex);\n               }\n             }\n+\n+            // Now after cancelling all the pending tasks, lets make sure to back off on the creation\n+            _rateLimiter.incrementPeriod();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MDI1Ng==", "bodyText": "call to this method '_rateLimiter.incrementPeriod()' will schedule the next pending task for object creation execution before the current thread get a chance to execute cancelPendingTasks. So by moving this down after cancelPendingTasks - we make sure that the rate limiter only submit new requests after the failure.", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391880256", "createdAt": "2020-03-12T20:36:21Z", "author": {"login": "nizarm"}, "path": "r2-core/src/main/java/com/linkedin/r2/transport/http/client/AsyncPoolImpl.java", "diffHunk": "@@ -698,17 +709,24 @@ public void onError(final Throwable e)\n                 LOG.error(\"Encountered error while invoking error waiter callback\", ex);\n               }\n             }\n+\n+            // Now after cancelling all the pending tasks, lets make sure to back off on the creation\n+            _rateLimiter.incrementPeriod();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3NTczMA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODcxNzQxOnYy", "diffSide": "RIGHT", "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0MToyNlrOF1unbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMjozODowNlrOF1yQ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA==", "bodyText": "Do we have guarantee that cause() is not null?", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391882604", "createdAt": "2020-03-12T20:41:26Z", "author": {"login": "ssheng"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTI3NQ==", "bodyText": "Yes if it is not instance of SslHandshakeCompletionEvent.SUCCESS - it is guaranteed to have cause() in it.\nhttps://github.com/netty/netty/blob/00afb19d7a37de21b35ce4f6cb3fa7f74809f2ab/handler/src/main/java/io/netty/handler/ssl/SslHandshakeCompletionEvent.java\nBut yea - it make sense to not depend on this implementation detail and I will add a null check.", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391885275", "createdAt": "2020-03-12T20:47:20Z", "author": {"login": "nizarm"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzODIxOA==", "bodyText": "Let's add a comment here then", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391938218", "createdAt": "2020-03-12T22:25:00Z", "author": {"login": "FreCap"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzODQ2OQ==", "bodyText": "Shouldn't this also be a retriable exception?", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391938469", "createdAt": "2020-03-12T22:25:39Z", "author": {"login": "FreCap"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0MjI2NQ==", "bodyText": "Thank you. good point. I will address this in the next release as I already merged the pull request and Identity do not leverage retry exception.", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391942265", "createdAt": "2020-03-12T22:37:41Z", "author": {"login": "nizarm"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0MjM5MA==", "bodyText": "@FreCap  - please let me know if you have any other concerns !", "url": "https://github.com/linkedin/rest.li/pull/219#discussion_r391942390", "createdAt": "2020-03-12T22:38:06Z", "author": {"login": "nizarm"}, "path": "r2-netty/src/main/java/com/linkedin/r2/transport/http/client/common/ChannelPoolLifecycle.java", "diffHunk": "@@ -118,19 +118,24 @@ public void create(final Callback<Channel> channelCallback)\n         @Override\n         public void userEventTriggered(ChannelHandlerContext ctx, Object evt)\n         {\n-          if(evt == SslHandshakeCompletionEvent.SUCCESS){\n+          if(evt == SslHandshakeCompletionEvent.SUCCESS)\n+          {\n             channelCallback.onSuccess(c);\n             c.pipeline().remove(CHANNELPOOL_SSL_CALLBACK_HANDLER);\n           }\n+          else if (evt instanceof SslHandshakeCompletionEvent)\n+          {\n+            Throwable sslException = ((SslHandshakeCompletionEvent) evt).cause();\n+            onError(channelCallback, sslException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjYwNA=="}, "originalCommit": {"oid": "390ff61e8fe9d5ffd86d92955fa5bc5ebcf751de"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 626, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}