{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2OTM0OTQ0", "number": 378, "title": "Add JMX monitors for RelativeLoadBalancerStrategy", "bodyText": "Adding a couple of JMX monitors for relative load balancer strategy, including\n\nStandard Deviation, average absolute deviation, median absolute deviation and max absolute deviation of cluster latency.\nNumber of unhealthy hosts\nNumber of hosts in quarantine\nTotal points in the hash ring", "createdAt": "2020-08-12T18:26:21Z", "url": "https://github.com/linkedin/rest.li/pull/378", "merged": true, "mergeCommit": {"oid": "b61b7e4208ec1ee9a9cf22e6449f2776cab41919"}, "closed": true, "closedAt": "2020-08-13T22:07:39Z", "author": {"login": "rickzx"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-PpeiAH2gAyNDY2OTM0OTQ0OmRiNDQwZWVlMTI5OWE3OGQyNWZiODE4Yjk2YTRiNTIwMzRkZmQ1MmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-mJ98AFqTQ2NzExMTU3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/db440eee1299a78d25fb818b96a4b52034dfd52e", "committedDate": "2020-08-12T18:23:16Z", "message": "Add JMX monitors for RelativeLoadBalancerStrategy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjMyODg1", "url": "https://github.com/linkedin/rest.li/pull/378#pullrequestreview-466232885", "createdAt": "2020-08-12T20:04:13Z", "commit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDowNDoxNFrOG_wiLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDozMzowMVrOG_xeUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw==", "bodyText": "Is there a way to get the average of all requests in stead of the average of all hosts? If host A gets 100 requests and host B gets 10 requests, we probably want (100 * latencyA + 10 * latencyB) / 110 instead of (latencyA + latencyB) / 2. That will be consistent to how to calculate the cluster average", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469508653", "createdAt": "2020-08-12T20:04:14Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDE1NQ==", "bodyText": "BTW you can get avgClusterLatency from PartitionStats in PartitionData, we can probably see if we can reuse PartitionStats, because it's also used for metrics emitting purpose", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469510155", "createdAt": "2020-08-12T20:07:13Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMTk4OA==", "bodyText": "On a second thought, I started thinking about for the max deviation, we probably care more about the ones that is greater than the average, if a host has 0 latency, it may impact this max absolute deviation. Should we not use absolute?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469521988", "createdAt": "2020-08-12T20:31:02Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    double variance = weightedLatencies.stream()\n+        .map(latency -> Math.pow(latency - avgLatency, 2))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return Math.sqrt(variance);\n+  }\n+\n+  @Override\n+  public double getLatencyAverageAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getLatencyMedianAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double medianLatency = getMedian(weightedLatencies);\n+\n+    List<Double> medianAbsolutes = weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - medianLatency))\n+        .collect(Collectors.toList());\n+\n+    return getMedian(medianAbsolutes);\n+  }\n+\n+  @Override\n+  public double getLatencyMaxAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw==", "bodyText": "Is it possible that a host does not get any traffic so the latency is 0, will it be counted here?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469522723", "createdAt": "2020-08-12T20:31:55Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyNDA0OA==", "bodyText": "Can we add some unit test on this to cover some different cases?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469524048", "createdAt": "2020-08-12T20:33:01Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/63e53a37e3e525e022c1f464a360e213bbf6d468", "committedDate": "2020-08-13T16:53:16Z", "message": "Remove some absolute deviation monitors. Add new relative factor monitors. Add unit tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "110dedd13bf649c2ac4553607ece76f955a2ab35", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/110dedd13bf649c2ac4553607ece76f955a2ab35", "committedDate": "2020-08-13T16:38:24Z", "message": "Remove some absolute deviation monitors. Add new relative factor monitors. Add unit tests"}, "afterCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/63e53a37e3e525e022c1f464a360e213bbf6d468", "committedDate": "2020-08-13T16:53:16Z", "message": "Remove some absolute deviation monitors. Add new relative factor monitors. Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d27b19c3f915045d5540c3965bbf1f180407a08", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/5d27b19c3f915045d5540c3965bbf1f180407a08", "committedDate": "2020-08-13T17:40:17Z", "message": "Filter out clusters not receving traffic when calculating deviations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzMzEy", "url": "https://github.com/linkedin/rest.li/pull/378#pullrequestreview-466983312", "createdAt": "2020-08-13T17:28:22Z", "commit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzoyODoyM1rOHAV1MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzo0MDozNFrOHAWgrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDExOTcyOA==", "bodyText": "Wondering how do you plan to implement this in container? Do you plan to go with multiple percentile relative factors?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470119728", "createdAt": "2020-08-13T17:28:23Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    return calculateStandardDeviation(stateMap.keySet());\n+  }\n+\n+  @Override\n+  public double getLatencyMeanAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    return stateMap.keySet().stream()\n+        .map(trackerClient -> Math.abs(StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getAboveAverageLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    Set<TrackerClient> aboveAvgClients = stateMap.keySet().stream()\n+        .filter(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) > avgLatency)\n+        .collect(Collectors.toSet());\n+\n+    return calculateStandardDeviation(aboveAvgClients);\n+  }\n+\n+  @Override\n+  public double getMaxLatencyRelativeFactor()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+    long maxLatency = stateMap.keySet().stream()\n+        .map(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()))\n+        .mapToLong(Long::longValue)\n+        .max()\n+        .orElse(0L);\n+\n+    return avgLatency == 0 ? 0 : maxLatency / avgLatency;\n+  }\n+\n+  @Override\n+  public double getNthPercentileLatencyRelativeFactor(double pct)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzEzMw==", "bodyText": "As we discussed offline, I think it's fair to remove mean, since the calculation is a bit more complicated, also it did not provide too much additional value", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470123133", "createdAt": "2020-08-13T17:32:06Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    return calculateStandardDeviation(stateMap.keySet());\n+  }\n+\n+  @Override\n+  public double getLatencyMeanAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzMDg2MA==", "bodyText": "Let's also have a unit test where the call count and latency for some of the hosts are 0.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470130860", "createdAt": "2020-08-13T17:40:34Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/test/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmxTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.relative.PartitionState;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientMockHelper;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.Test;\n+\n+import static org.easymock.EasyMock.anyInt;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class RelativeLoadBalancerStrategyJmxTest {\n+  private RelativeLoadBalancerStrategyJmx mockRelativeLoadBalancerStrategyJmx(List<TrackerClient> trackerClients)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientsMap = new HashMap<>();\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      trackerClientsMap.put(trackerClient, new TrackerClientState(1, 1));\n+    }\n+\n+    RelativeLoadBalancerStrategy strategy = Mockito.mock(RelativeLoadBalancerStrategy.class);\n+    PartitionState state = Mockito.mock(PartitionState.class);\n+    Mockito.when(state.getTrackerClientStateMap()).thenReturn(trackerClientsMap);\n+    Mockito.when(strategy.getPartitionState(anyInt())).thenReturn(state);\n+\n+    return new RelativeLoadBalancerStrategyJmx(strategy);\n+  }\n+\n+  @Test\n+  public void testLatencyDeviation()\n+  {\n+    List<TrackerClient> trackerClientsEqual = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 200L), Arrays.asList(100L, 100L), Arrays.asList(0, 0));\n+\n+    RelativeLoadBalancerStrategyJmx jmx = mockRelativeLoadBalancerStrategyJmx(trackerClientsEqual);\n+    assertEquals(jmx.getLatencyStandardDeviation(), 0.0);\n+    assertEquals(jmx.getLatencyMeanAbsoluteDeviation(), 0.0);\n+    assertEquals(jmx.getAboveAverageLatencyStandardDeviation(), 0.0);\n+\n+    List<TrackerClient> trackerClientsDiverse1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10),\n+        Arrays.asList(100L, 150L, 200L), Arrays.asList(50L, 75L, 100L), Arrays.asList(0, 0, 0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c64c2a09ca428c1fefaa770460665d533f5eb1c", "author": {"user": {"login": "rickzx", "name": "Rick Zhou"}}, "url": "https://github.com/linkedin/rest.li/commit/2c64c2a09ca428c1fefaa770460665d533f5eb1c", "committedDate": "2020-08-13T17:59:23Z", "message": "Fix minor rounding issues when calculating cluster average"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTExNTc5", "url": "https://github.com/linkedin/rest.li/pull/378#pullrequestreview-467111579", "createdAt": "2020-08-13T20:36:40Z", "commit": {"oid": "2c64c2a09ca428c1fefaa770460665d533f5eb1c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4606, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}