{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDgwMzYw", "number": 214, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTowOToyOFrODl-7Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1NjowNVrODl_KjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU0OTE0OnYy", "diffSide": "RIGHT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTowOToyOFrOFzLjTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTowOToyOFrOFzLjTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMDk1OA==", "bodyText": "I suggest you move this field and its corresponding setter near the top of the inner class. It would be easier to read.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389210958", "createdAt": "2020-03-07T01:09:28Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(null, Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());\n+      addResolver(resolver);\n+    }\n     _classLoader = classLoader;\n   }\n-\n-  private String getDataSchemaResourcePath(String schemaName)\n+  /**\n+   * Construct a new instance that uses the specified {@link ClassLoader}.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver(ClassLoader)} instead\n+   * @param classLoader provides the {@link ClassLoader}.\n+   */\n+  @Deprecated\n+  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n   {\n-    return InternalConstants.PEGASUS_DIR_IN_JAR + \"/\" + schemaName.replace('.', '/') + DEFAULT_EXTENSION;\n+    this(classLoader);\n   }\n \n-  @Override\n-  protected NamedDataSchema locateDataSchema(String schemaName, StringBuilder errorMessageBuilder)\n+  private class SingleFormatClasspathSchemaResolver extends DefaultDataSchemaResolver\n   {\n-    NamedDataSchema schema = null;\n-    final String schemaResourcePath = getDataSchemaResourcePath(schemaName);\n-    try (InputStream stream = _classLoader.getResourceAsStream(schemaResourcePath))\n+    /**\n+     * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+     */\n+    public SingleFormatClasspathSchemaResolver(DataSchemaParserFactory parserFactory)\n+    {\n+      super(parserFactory);\n+    }\n+\n+    private String getDataSchemaResourcePath(String schemaName)\n     {\n-      if (stream == null)\n+      return InternalConstants.PEGASUS_DIR_IN_JAR + \"/\" + schemaName.replace('.', '/') + _extension;\n+    }\n+\n+    @Override\n+    protected NamedDataSchema locateDataSchema(String schemaName, StringBuilder errorMessageBuilder)\n+    {\n+      NamedDataSchema schema = null;\n+      final String schemaResourcePath = getDataSchemaResourcePath(schemaName);\n+      try (InputStream stream = _classLoader.getResourceAsStream(schemaResourcePath))\n       {\n-        errorMessageBuilder.append(String.format(\"Unable to find data schema file \\\"%s\\\" in classpath.\", schemaResourcePath));\n+        if (stream != null)\n+        {\n+          DataSchemaLocation location = new FileDataSchemaLocation(new File(schemaResourcePath));\n+          schema = parse(stream, location, schemaName, errorMessageBuilder);\n+        }\n       }\n-      else\n+      catch (IOException e)\n       {\n-        DataSchemaLocation location = new FileDataSchemaLocation(new File(schemaResourcePath));\n-        schema = parse(stream, location, schemaName, errorMessageBuilder);\n+        errorMessageBuilder.append(String.format(\"Failed to read/close data schema file \\\"%s\\\" in classpath: \\\"%s\\\"\", schemaResourcePath, e.getMessage()));\n       }\n+      return schema;\n     }\n-    catch (IOException e)\n+\n+    void setExtension(String extension)\n     {\n-      errorMessageBuilder.append(String.format(\"Failed to read/close data schema file \\\"%s\\\" in classpath: \\\"%s\\\"\", schemaResourcePath, e.getMessage()));\n+      this._extension = extension;\n     }\n-    return schema;\n-  }\n \n-  private final ClassLoader _classLoader;\n+    private String _extension = SchemaParser.FILE_EXTENSION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU1NDM0OnYy", "diffSide": "LEFT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMToxNToyNVrOFzLmaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo0NzozNFrOFzL13Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTc1NQ==", "bodyText": "This class no longer extends DefaultDataSchemaResolver. Are you sure you're not removing any default functionality it had before?", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389211755", "createdAt": "2020-03-07T01:15:25Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzE1MQ==", "bodyText": "Since this delegates to the SingleFormat resolver (inner class) which extends the Default resolver, there shouldn't be any regression.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389213151", "createdAt": "2020-03-07T01:25:58Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTc1NQ=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTcwOQ==", "bodyText": "Ah, that's right. It's interesting how the relationship of the multi-format resolvers with the default resolver logic is more \"has-a\" than \"is-a\". Reminds me of CS class...", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389215709", "createdAt": "2020-03-07T01:47:34Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTc1NQ=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU1Njc2OnYy", "diffSide": "RIGHT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/AbstractMultiFormatDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMToxNzozNVrOFzLnug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTozNjozNFrOFzLwow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjA5MA==", "bodyText": "How is this different from current MultiFormatDataSchemaResolver (https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/resolver/MultiFormatDataSchemaResolver.java)?", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389212090", "createdAt": "2020-03-07T01:17:35Z", "author": {"login": "mchen07"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/AbstractMultiFormatDataSchemaResolver.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2015 Coursera Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.linkedin.data.schema.resolver;\n+\n+import com.linkedin.data.schema.DataSchemaLocation;\n+import com.linkedin.data.schema.DataSchemaParserFactory;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.Name;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.SchemaParser;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.grammar.PdlSchemaParserFactory;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Combines multiple file format specific resolvers (and respective file format specific parsers)\n+ * into a single resolver.\n+ *\n+ * E.g. a resolver for the \".pdsc\" file format and the \".pdl\" file format, each with their\n+ * own file format specific parsers, can be combined into a single resolver able to look up\n+ * schemas of either file format.\n+ */\n+public class AbstractMultiFormatDataSchemaResolver implements DataSchemaResolver", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjcwNA==", "bodyText": "Based on my understanding, he wanted to add similar logic to ClasspathResourceDataSchemaResolver, so it makes more sense to add the shared logic in a common abstract class.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389212704", "createdAt": "2020-03-07T01:22:26Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/AbstractMultiFormatDataSchemaResolver.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2015 Coursera Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.linkedin.data.schema.resolver;\n+\n+import com.linkedin.data.schema.DataSchemaLocation;\n+import com.linkedin.data.schema.DataSchemaParserFactory;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.Name;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.SchemaParser;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.grammar.PdlSchemaParserFactory;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Combines multiple file format specific resolvers (and respective file format specific parsers)\n+ * into a single resolver.\n+ *\n+ * E.g. a resolver for the \".pdsc\" file format and the \".pdl\" file format, each with their\n+ * own file format specific parsers, can be combined into a single resolver able to look up\n+ * schemas of either file format.\n+ */\n+public class AbstractMultiFormatDataSchemaResolver implements DataSchemaResolver", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjA5MA=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjk5Mg==", "bodyText": "Correct, refactored the existing resolver to extract the common logic to abstract class. Forgot to make it abstract, will do it.\nThe existing multi-format resolver is the file based one.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389212992", "createdAt": "2020-03-07T01:24:50Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/AbstractMultiFormatDataSchemaResolver.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2015 Coursera Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.linkedin.data.schema.resolver;\n+\n+import com.linkedin.data.schema.DataSchemaLocation;\n+import com.linkedin.data.schema.DataSchemaParserFactory;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.Name;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.SchemaParser;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.grammar.PdlSchemaParserFactory;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Combines multiple file format specific resolvers (and respective file format specific parsers)\n+ * into a single resolver.\n+ *\n+ * E.g. a resolver for the \".pdsc\" file format and the \".pdl\" file format, each with their\n+ * own file format specific parsers, can be combined into a single resolver able to look up\n+ * schemas of either file format.\n+ */\n+public class AbstractMultiFormatDataSchemaResolver implements DataSchemaResolver", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjA5MA=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNDM3MQ==", "bodyText": "Never mind, I found out when I read through to the end.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389214371", "createdAt": "2020-03-07T01:36:34Z", "author": {"login": "mchen07"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/AbstractMultiFormatDataSchemaResolver.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2015 Coursera Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.linkedin.data.schema.resolver;\n+\n+import com.linkedin.data.schema.DataSchemaLocation;\n+import com.linkedin.data.schema.DataSchemaParserFactory;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.Name;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.SchemaParser;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.grammar.PdlSchemaParserFactory;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Combines multiple file format specific resolvers (and respective file format specific parsers)\n+ * into a single resolver.\n+ *\n+ * E.g. a resolver for the \".pdsc\" file format and the \".pdl\" file format, each with their\n+ * own file format specific parsers, can be combined into a single resolver able to look up\n+ * schemas of either file format.\n+ */\n+public class AbstractMultiFormatDataSchemaResolver implements DataSchemaResolver", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjA5MA=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU4NTA1OnYy", "diffSide": "RIGHT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1MjowNVrOFzL3ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNDoxNToyOFrOFzMffA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjE2Mw==", "bodyText": "why do we need this setter exposed? Should constructor handle this automatically?", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389216163", "createdAt": "2020-03-07T01:52:05Z", "author": {"login": "mchen07"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(null, Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjcwNg==", "bodyText": "+1", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389216706", "createdAt": "2020-03-07T01:57:35Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(null, Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjE2Mw=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIyNjM2NA==", "bodyText": "Fixed, this was remnant of an alternate implementation I started with. Cleaned it now.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389226364", "createdAt": "2020-03-07T04:15:28Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(null, Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjE2Mw=="}, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU4NTUyOnYy", "diffSide": "RIGHT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1Mjo1OVrOFzL36g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1Mjo1OVrOFzL36g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjIzNA==", "bodyText": "I may prefer that we make this final, and initialized in constructor and hide setter for this.", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389216234", "createdAt": "2020-03-07T01:52:59Z", "author": {"login": "mchen07"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,106 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(null, Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());\n+      addResolver(resolver);\n+    }\n     _classLoader = classLoader;\n   }\n-\n-  private String getDataSchemaResourcePath(String schemaName)\n+  /**\n+   * Construct a new instance that uses the specified {@link ClassLoader}.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver(ClassLoader)} instead\n+   * @param classLoader provides the {@link ClassLoader}.\n+   */\n+  @Deprecated\n+  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n   {\n-    return InternalConstants.PEGASUS_DIR_IN_JAR + \"/\" + schemaName.replace('.', '/') + DEFAULT_EXTENSION;\n+    this(classLoader);\n   }\n \n-  @Override\n-  protected NamedDataSchema locateDataSchema(String schemaName, StringBuilder errorMessageBuilder)\n+  private class SingleFormatClasspathSchemaResolver extends DefaultDataSchemaResolver\n   {\n-    NamedDataSchema schema = null;\n-    final String schemaResourcePath = getDataSchemaResourcePath(schemaName);\n-    try (InputStream stream = _classLoader.getResourceAsStream(schemaResourcePath))\n+    /**\n+     * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+     */\n+    public SingleFormatClasspathSchemaResolver(DataSchemaParserFactory parserFactory)\n+    {\n+      super(parserFactory);\n+    }\n+\n+    private String getDataSchemaResourcePath(String schemaName)\n     {\n-      if (stream == null)\n+      return InternalConstants.PEGASUS_DIR_IN_JAR + \"/\" + schemaName.replace('.', '/') + _extension;\n+    }\n+\n+    @Override\n+    protected NamedDataSchema locateDataSchema(String schemaName, StringBuilder errorMessageBuilder)\n+    {\n+      NamedDataSchema schema = null;\n+      final String schemaResourcePath = getDataSchemaResourcePath(schemaName);\n+      try (InputStream stream = _classLoader.getResourceAsStream(schemaResourcePath))\n       {\n-        errorMessageBuilder.append(String.format(\"Unable to find data schema file \\\"%s\\\" in classpath.\", schemaResourcePath));\n+        if (stream != null)\n+        {\n+          DataSchemaLocation location = new FileDataSchemaLocation(new File(schemaResourcePath));\n+          schema = parse(stream, location, schemaName, errorMessageBuilder);\n+        }\n       }\n-      else\n+      catch (IOException e)\n       {\n-        DataSchemaLocation location = new FileDataSchemaLocation(new File(schemaResourcePath));\n-        schema = parse(stream, location, schemaName, errorMessageBuilder);\n+        errorMessageBuilder.append(String.format(\"Failed to read/close data schema file \\\"%s\\\" in classpath: \\\"%s\\\"\", schemaResourcePath, e.getMessage()));\n       }\n+      return schema;\n     }\n-    catch (IOException e)\n+\n+    void setExtension(String extension)\n     {\n-      errorMessageBuilder.append(String.format(\"Failed to read/close data schema file \\\"%s\\\" in classpath: \\\"%s\\\"\", schemaResourcePath, e.getMessage()));\n+      this._extension = extension;\n     }\n-    return schema;\n-  }\n \n-  private final ClassLoader _classLoader;\n+    private String _extension = SchemaParser.FILE_EXTENSION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbd331a402e0e3ae6c6e35e111d0693f4812a57e"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTU4Nzk3OnYy", "diffSide": "RIGHT", "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1NjowNVrOFzL5KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1NjowNVrOFzL5KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjU1Mw==", "bodyText": "one last nit: move to below constructor (Edit: just remove, as per Min's suggestion)", "url": "https://github.com/linkedin/rest.li/pull/214#discussion_r389216553", "createdAt": "2020-03-07T01:56:05Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/resolver/ClasspathResourceDataSchemaResolver.java", "diffHunk": "@@ -33,61 +34,107 @@\n  *\n  * @author Min Chen\n  */\n-public class ClasspathResourceDataSchemaResolver extends DefaultDataSchemaResolver\n+public class ClasspathResourceDataSchemaResolver extends AbstractMultiFormatDataSchemaResolver\n {\n   /**\n    * The default file name extension is \".pdsc\".\n+   * @deprecated Do not use.\n    */\n+  @Deprecated\n   public static final String DEFAULT_EXTENSION = SchemaParser.FILE_EXTENSION;\n \n+  private final ClassLoader _classLoader;\n+\n+\n   /**\n    * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n    */\n+  public ClasspathResourceDataSchemaResolver()\n+  {\n+    this(Thread.currentThread().getContextClassLoader());\n+  }\n+\n+  /**\n+   * Construct a new instance that uses the {@link Thread#getContextClassLoader()} for the current thread.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver()} instead\n+   */\n+  @Deprecated\n   public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory)\n   {\n-    super(parserFactory);\n-    _classLoader = Thread.currentThread().getContextClassLoader();\n+    this(Thread.currentThread().getContextClassLoader());\n   }\n \n   /**\n    * Construct a new instance that uses the specified {@link ClassLoader}.\n    *\n    * @param classLoader provides the {@link ClassLoader}.\n    */\n-  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n+  public ClasspathResourceDataSchemaResolver(ClassLoader classLoader)\n   {\n-    super(parserFactory);\n+    for (DataSchemaParserFactory parserForFormat: BUILTIN_FORMAT_PARSER_FACTORIES)\n+    {\n+      SingleFormatClasspathSchemaResolver resolver = new SingleFormatClasspathSchemaResolver(parserForFormat);\n+      resolver.setExtension(\".\" + parserForFormat.getLanguageExtension());\n+      addResolver(resolver);\n+    }\n     _classLoader = classLoader;\n   }\n \n-  private String getDataSchemaResourcePath(String schemaName)\n+  /**\n+   * Construct a new instance that uses the specified {@link ClassLoader}.\n+   *\n+   * @deprecated The parserFactory is not needed as this class now uses builtin parsers. Use\n+   * {@link #ClasspathResourceDataSchemaResolver(ClassLoader)} instead\n+   * @param classLoader provides the {@link ClassLoader}.\n+   */\n+  @Deprecated\n+  public ClasspathResourceDataSchemaResolver(SchemaParserFactory parserFactory, ClassLoader classLoader)\n   {\n-    return InternalConstants.PEGASUS_DIR_IN_JAR + \"/\" + schemaName.replace('.', '/') + DEFAULT_EXTENSION;\n+    this(classLoader);\n   }\n \n-  @Override\n-  protected NamedDataSchema locateDataSchema(String schemaName, StringBuilder errorMessageBuilder)\n+  private class SingleFormatClasspathSchemaResolver extends DefaultDataSchemaResolver\n   {\n-    NamedDataSchema schema = null;\n-    final String schemaResourcePath = getDataSchemaResourcePath(schemaName);\n-    try (InputStream stream = _classLoader.getResourceAsStream(schemaResourcePath))\n+    private String _extension = SchemaParser.FILE_EXTENSION;\n+\n+    void setExtension(String extension)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a730cdce2622d766abf054e92542c6c0d02c2669"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 617, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}