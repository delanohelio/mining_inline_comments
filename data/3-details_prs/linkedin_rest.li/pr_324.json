{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxMjgwMjg3", "number": 324, "title": "Added annotation processor introduction", "bodyText": "This needs to be published after #314", "createdAt": "2020-06-08T17:09:40Z", "url": "https://github.com/linkedin/rest.li/pull/324", "merged": true, "mergeCommit": {"oid": "6cf8e13f6f441443bebba5c9d3b8820657c0f9ef"}, "closed": true, "closedAt": "2020-06-25T23:03:44Z", "author": {"login": "junchuanwang"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpTmCLgH2gAyNDMxMjgwMjg3OmY3NGZkMDJhYTA5ZjU4MjU5M2JjNDBhNjliZDE2YzM3ODc5NTBmMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcu226VgH2gAyNDMxMjgwMjg3OmExZDAwOTNkZjkxMmE3ZGExOTA5YWQwMDk5NTUyNjc1ODk2YWUyMmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/f74fd02aa09f582593bc40a69bd16c3787950f33", "committedDate": "2020-06-08T17:06:43Z", "message": "Added annotation processor introduction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDUwNTQ1", "url": "https://github.com/linkedin/rest.li/pull/324#pullrequestreview-426450545", "createdAt": "2020-06-08T17:16:03Z", "commit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzoxNjowM1rOGgoMBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzoxNjowM1rOGgoMBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2NjA1Mw==", "bodyText": "Can we add a content table here?", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r436866053", "createdAt": "2020-06-08T17:16:03Z", "author": {"login": "nickibi"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NjI3Njc3", "url": "https://github.com/linkedin/rest.li/pull/324#pullrequestreview-427627677", "createdAt": "2020-06-10T00:10:55Z", "commit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDoxMDo1NVrOGhgkQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo0MzozMVrOGhhFWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4OTc2MQ==", "bodyText": "Should we use \"pegasus schemas\" instead of Rest.Li?\nPegasus schemas can be used without rest.li framework and the annotation can still be applied", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437789761", "createdAt": "2020-06-10T00:10:55Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4OTg4NA==", "bodyText": "annotate -> Annotation", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437789884", "createdAt": "2020-06-10T00:11:15Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4OTkxOQ==", "bodyText": "annotation", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437789919", "createdAt": "2020-06-10T00:11:24Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MDAyMg==", "bodyText": "Remove this line( redundant) or better say: \"The data_classifcation annotation is specified at record level\"", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437790022", "createdAt": "2020-06-10T00:11:48Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MDM0MA==", "bodyText": "\"are able to add annotations to schema\" -> are able to add annotations using @ syntax to schema", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437790340", "createdAt": "2020-06-10T00:12:58Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MTQ0OQ==", "bodyText": "Keep all text in third person, so avoid \"we\" \"you\" etc.\nWe let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n->\nThe Rest.Li framework did not provide specification on how these annotations should be interpreted and if was left to the user to add logic for interpreting them.\n(Written syntax and read as properties are specified by framework)", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437791449", "createdAt": "2020-06-10T00:16:55Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MTc4Nw==", "bodyText": "Do not start a new section with \"But\", try to re-word this similar to my suggestion above.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437791787", "createdAt": "2020-06-10T00:18:00Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MjYxMQ==", "bodyText": "\"inherited from the  parent record.\"\nDon't say re-use.. inherited is the right work.\nAnd we don't allow inhertiance other than from records. righ?", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437792611", "createdAt": "2020-06-10T00:20:56Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MzM3NQ==", "bodyText": "The // is visible in doc. check.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437793375", "createdAt": "2020-06-10T00:23:48Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5MzQxOA==", "bodyText": "same for //", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437793418", "createdAt": "2020-06-10T00:23:56Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5Mzg1Nw==", "bodyText": "some 's are not formatted correctly.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437793857", "createdAt": "2020-06-10T00:25:40Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NDExMw==", "bodyText": "imambigous -> unambiguous\nAlso use third person:\nWe call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\nThis processing step .. is called \"resolution\" and the final value is \"resolved\" value.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437794113", "createdAt": "2020-06-10T00:26:40Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NDYyNg==", "bodyText": "\"annotations is\" -> \"annotations are\"", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437794626", "createdAt": "2020-06-10T00:28:30Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NDk1NQ==", "bodyText": "inambigously -> unambiguously", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437794955", "createdAt": "2020-06-10T00:29:52Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTU1OA==", "bodyText": "Needs rewording.\nSuggestion: \" The above usage is very common at LinkedIn so an implementation of annotation processing based on this behavior is provided as part of annotation framework\"", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437795558", "createdAt": "2020-06-10T00:32:17Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTc2NQ==", "bodyText": "Introducing Visitor without explaining what it is. I suggest moving the references to PathSpecBaseVisitor to a later seciton.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437795765", "createdAt": "2020-06-10T00:33:13Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTk2Mg==", "bodyText": "reesolved -> resolved", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437795962", "createdAt": "2020-06-10T00:34:02Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NjY3NA==", "bodyText": "You need to clean up this section.\nNot all schemas are recursive.\nAlso even without recursion in schemas, there are scenarios where you need differnt resolved Properties. Eg, a record used as two fields with different overrides.", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437796674", "createdAt": "2020-06-10T00:37:09Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5Njk1OA==", "bodyText": "Should this example show different resolved values for Employee::id field?", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437796958", "createdAt": "2020-06-10T00:38:23Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.\n+\n+For an example schema:\n+\n+```pdl\n+record Employee {\n+  id: long\n+  supervisor: Employee\n+}\n+```\n+\n+Its memory presentation is as followed:\n+<center>\n+<b>DataSchema Example</b><br><img src=\"{{ 'assets/images/DataSchema_with_resolvedProperties.png' | relative_url }}\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NzA0NA==", "bodyText": "Add links for the classes referenced", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437797044", "createdAt": "2020-06-10T00:38:44Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.\n+\n+For an example schema:\n+\n+```pdl\n+record Employee {\n+  id: long\n+  supervisor: Employee\n+}\n+```\n+\n+Its memory presentation is as followed:\n+<center>\n+<b>DataSchema Example</b><br><img src=\"{{ 'assets/images/DataSchema_with_resolvedProperties.png' | relative_url }}\" />\n+</center>\n+\n+The SchemaAnnotationProcessor will process `DataSchema` using `DataSchemaRichContextTraverser` and resolve the annotation for fields in the schemas.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NzMzNQ==", "bodyText": "extra quote for SchemaVisitor\noroginal -> original\nComment about immutable not very clear. Can you add more details?", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437797335", "createdAt": "2020-06-10T00:39:46Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.\n+\n+For an example schema:\n+\n+```pdl\n+record Employee {\n+  id: long\n+  supervisor: Employee\n+}\n+```\n+\n+Its memory presentation is as followed:\n+<center>\n+<b>DataSchema Example</b><br><img src=\"{{ 'assets/images/DataSchema_with_resolvedProperties.png' | relative_url }}\" />\n+</center>\n+\n+The SchemaAnnotationProcessor will process `DataSchema` using `DataSchemaRichContextTraverser` and resolve the annotation for fields in the schemas.\n+\n+\n+<center>\n+<b>Sequence Diagram</b><br><img src=\"{{ 'assets/images/AnnotationProcessor_UML_sequence_diagram.png' | relative_url }}\"  />\n+</center>\n+\n+The `DataSchemaRichContextTraverser` travsers the data schema and in turn calls an implementation of `SchemaVisitor`. It is the `SchemaVisitor`' that resolves the annotations for fields in the schemas, based on the context provided by the `DataSchemaRichContextTraverser`. `SchemaVisitor` may also create copy of original data schema if the oroginal data schema needs to be immutable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5ODE3NA==", "bodyText": "Maybe adding a table or a flow chart to pick the approach would be nicer.\nAnnotation based on pathspec based overriding -> create new handler\nAnnotation based on pathspec with custom traversal -> override visitor and create handler\nAnnotation not using pathspec based overriding -> create visitor and handler", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437798174", "createdAt": "2020-06-10T00:43:17Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.\n+\n+For an example schema:\n+\n+```pdl\n+record Employee {\n+  id: long\n+  supervisor: Employee\n+}\n+```\n+\n+Its memory presentation is as followed:\n+<center>\n+<b>DataSchema Example</b><br><img src=\"{{ 'assets/images/DataSchema_with_resolvedProperties.png' | relative_url }}\" />\n+</center>\n+\n+The SchemaAnnotationProcessor will process `DataSchema` using `DataSchemaRichContextTraverser` and resolve the annotation for fields in the schemas.\n+\n+\n+<center>\n+<b>Sequence Diagram</b><br><img src=\"{{ 'assets/images/AnnotationProcessor_UML_sequence_diagram.png' | relative_url }}\"  />\n+</center>\n+\n+The `DataSchemaRichContextTraverser` travsers the data schema and in turn calls an implementation of `SchemaVisitor`. It is the `SchemaVisitor`' that resolves the annotations for fields in the schemas, based on the context provided by the `DataSchemaRichContextTraverser`. `SchemaVisitor` may also create copy of original data schema if the oroginal data schema needs to be immutable.\n+\n+If the overriding of annotations are specified using the `PathSpec` syntax, the `PathSpecBaseVisitor` and `SchemaHandler` class are implemented for such use case. If a user want to implement their own logic, one should look for reimplementing the `SchemaVisitor`, or extending `PathSpecBaseVisitor`, or simply implement `SchemaHandler`\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5ODIzMg==", "bodyText": "ook -> look", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r437798232", "createdAt": "2020-06-10T00:43:31Z", "author": {"login": "karthikbalasub"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use \n+we provided `PathSpecBaseVisitor`. \n+\n+It assumes \\\\\n+(1) All *overrides* to the fields are specified using PathSpecs to the fields. \\\\\n+(2) All *overrides* are applied on fields, not on the record\n+\n+For more examples regarding the syntax, one can read the java doc from `PathSpecBaseVisitor`.//<insert Link about > and the test cases //<insert Link about >\n+\n+\n+One can seek to extend this case to adapt to their own use cases. Please see next section regarding what class to extend to fit the best use cases.\n+\n+## Use the schema annotation processor\n+We have created a paradigm of processing Rest.Li schema annotations and wrapped them into `com.linkedin.data.schema.annotation` package.\n+First thing to understand is that `DataSchema` object internally is stored recursively. We added `resolvedProperties` attribute, in order to store the final reesolved annotation.\n+\n+For an example schema:\n+\n+```pdl\n+record Employee {\n+  id: long\n+  supervisor: Employee\n+}\n+```\n+\n+Its memory presentation is as followed:\n+<center>\n+<b>DataSchema Example</b><br><img src=\"{{ 'assets/images/DataSchema_with_resolvedProperties.png' | relative_url }}\" />\n+</center>\n+\n+The SchemaAnnotationProcessor will process `DataSchema` using `DataSchemaRichContextTraverser` and resolve the annotation for fields in the schemas.\n+\n+\n+<center>\n+<b>Sequence Diagram</b><br><img src=\"{{ 'assets/images/AnnotationProcessor_UML_sequence_diagram.png' | relative_url }}\"  />\n+</center>\n+\n+The `DataSchemaRichContextTraverser` travsers the data schema and in turn calls an implementation of `SchemaVisitor`. It is the `SchemaVisitor`' that resolves the annotations for fields in the schemas, based on the context provided by the `DataSchemaRichContextTraverser`. `SchemaVisitor` may also create copy of original data schema if the oroginal data schema needs to be immutable.\n+\n+If the overriding of annotations are specified using the `PathSpec` syntax, the `PathSpecBaseVisitor` and `SchemaHandler` class are implemented for such use case. If a user want to implement their own logic, one should look for reimplementing the `SchemaVisitor`, or extending `PathSpecBaseVisitor`, or simply implement `SchemaHandler`\n+\n+<center>\n+<b>Class Diagram</b><br><img src=\"{{ 'assets/images/AnnotationProcessor_UML_class_diagram.png' | relative_url }}\"  />\n+</center>\n+\n+\n+\n+\n+For more, please ook at the test cases. <insert-me-the-link>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDE5MDAy", "url": "https://github.com/linkedin/rest.li/pull/324#pullrequestreview-429419002", "createdAt": "2020-06-12T02:17:15Z", "commit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjoxNzoxNVrOGi041Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjo0MzowNlrOGi1QFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3MTI4NQ==", "bodyText": "I think you meant to update this to Schema Annotation Processing", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439171285", "createdAt": "2020-06-12T02:17:15Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3MTQ1Nw==", "bodyText": "I notice that you strictly refer to Rest.li as \"Rest.Li\", I'd suggest doing a search-and-replace to change all instances of \"Rest.Li\" to \"Rest.li\"", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439171457", "createdAt": "2020-06-12T02:18:00Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3MjYwMA==", "bodyText": "nits:\n\nbe inherited -> to be inherited\nfrom upper level -> from the upper level", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439172600", "createdAt": "2020-06-12T02:22:36Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3Mjk1NQ==", "bodyText": "The way you say \"schema writers\" sounds impersonal and almost implies that the \"writers\" are Java Writer classes. I would say \"authors\"", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439172955", "createdAt": "2020-06-12T02:24:06Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3Mzc3MA==", "bodyText": "What does the first sentence mean? It sounds like you're saying support was and still is currently limited. Also, I'd recommend not presenting information about features as a story detailing the old support and the new support. This will confuse new users; why does it matter to them that support used to be one way, but now it's another way? It doesn't provide much of a value for users to know that we previously didn't support this. That's my opinion.\nnits:\n\nlet the user chooses -> let the user choose\nhow they want to interpret -> how they want it to be interpreted\nno preferrabled way -> no preferable ways\nwritten, read and interpreted -> written, read, and interpreted", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439173770", "createdAt": "2020-06-12T02:27:30Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDk0OA==", "bodyText": "nit: field be overridden -> field to be overridden", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439174948", "createdAt": "2020-06-12T02:32:40Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDk5OA==", "bodyText": "nit: too much whitespace", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439174998", "createdAt": "2020-06-12T02:32:50Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTg5OA==", "bodyText": "nits:\n\nexamples shows -> examples show\noverrides gives -> overrides give\nto the schema annotations -> to schema annotations\nhow those annotations can be read -> how those annotations are read\nimambiguous -> unambiguous\nuser's rules -> the user's rules\ncall such value \"resolved\" value -> call this value the \"resolved\" value", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439175898", "createdAt": "2020-06-12T02:36:55Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NjU4OQ==", "bodyText": "nits:\n\ninheritted -> inherited\nFirst sentence is a run-on sentence.\nExtra space at the beginning of the second sentence.\ninterested annotations -> relevant annotations or applicable annotations\nplugin-ing -> plugging in\nuser's own logic -> the user's logic\nand save the -> and saving the\nback to corresponding DataSchema -> back to the corresponding DataSchema", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439176589", "createdAt": "2020-06-12T02:40:14Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NzE1NQ==", "bodyText": "nits:\n\ndo denote -> to denote\nthe field we are overriding is -> that the field being overridden is\nassociate relations -> define relationships or define associations\nspecifcy -> specifcy\nto the child fields -> to child fields", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439177155", "createdAt": "2020-06-12T02:42:42Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NzIzOQ==", "bodyText": "nit: Linkedin -> LinkedIn", "url": "https://github.com/linkedin/rest.li/pull/324#discussion_r439177239", "createdAt": "2020-06-12T02:43:06Z", "author": {"login": "evanw555"}, "path": "src/annotation_processor.md", "diffHunk": "@@ -0,0 +1,149 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /annotation_processor\n+excerpt: Documentation of using annotation processor in Rest.Li\n+---\n+\n+# Annotation Processor\n+This sections introduces a generic schema annotation processing tool in Rest.Li. Before reading this, it is recommended to be familiar with the concept of PathSpec in Rest.Li. [Insert link here]\n+\n+## Annotating Rest.Li Schemas\n+In Rest.Li, schema writers are able to add annotations to schema fields or the schema itself.\n+\n+**Example**: annotate on the schema fields\n+```pdl\n+record UserPersonallyIdentifiableInformation {\n+  @data_classification = \"MEDIUM\"\n+  firstName: string,\n+  @data_classification = \"MEDIUM\"\n+  lastName: string,\n+  @data_classification = \"LOW\"\n+  userId: long,\n+  @data_classification = \"HIGH\"\n+  socialSecurityNumber: string,\n+}\n+```\n+\n+**Example**: annotate directly on the schema\n+```pdl\n+@data_classification = \"HIGH\"\n+record UserPersonallyIdentifiableInformation {\n+  firstName: string,\n+  lastName: string,\n+  userId: long,\n+  socialSecurityNumber: string,\n+}\n+```\n+Note that these annotations are on the schema level.\n+\n+The support that Rest.Li provided for processing annotation in Rest.Li schema has been quite limited. These annotations in above examples are later stored as a `DataSchema`'s class attribute called \"property\". Just as the example shows, both field and the DataSchema can have this \"property\". We let the user chooses where they want to have the schema annotated and how they want to interpret. There were no preferrabled way regarding how annotation should be written, read and interpreted.\n+\n+## Inherit and override schema annotations\n+But Rest.Li users found it useful to process annotations during schema processing. One use case is to introduce \"inheritance\" and \"overrides\" to annotations so those annotations can be dynamically processed in the way user defines, when for example the schemas were reused. This gives annotation extensibility and adds to schema reusability.\n+\n+Here are examples:\n+Example case 1: Users might want the annotation of a field be inherited. The fields can reuse the annotations from upper level.\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, we might find both `visitedUrls` and `visitedUserProfiles` have `persistencePolicyInDays` annotated as 30.\n+//<inheritance example>\n+\n+Example case 2: Users might want the annotation of a field be overriden. Override is where the annotation on a field or a schema might get updated when other annotations assign it another value.\n+//<override example>\n+```pdl\n+@persistencePolicyInDays = 30\n+record  UserVisitRecord {\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  visitedUserProfiles: array[UserRecord]\n+}\n+```\n+Reading from the schema, a user might find the field `visitedUserProfiles`s `persistencePolicyInDays` annotation is 30 but `visitedUrls`'s `persistencePolicyInDays` annotation has value 10, which overrides the original value inherited(which was 30).\n+\n+\n+Example case 3:  Override might also happen when some annotation needs to be updated by another value assigned from another annotation location\n+```pdl\n+record UserVisitRecord {\n+  //...\n+  @persistencePolicyInDays = 365\n+  recycledChatHistories: array[chat]\n+\n+  @persistencePolicyInDays = 10\n+  visitedUrls: array[URL]\n+  //...\n+}\n+\n+record EnterpriseUserRecord {\n+  userName: UserName\n+  //...\n+  @persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}\n+  visitRecord: UserVisitRecord\n+  //...\n+}\n+```\n+In this example, schema `EnterpriseUserRecord` reused `UserVisitRecord` and its annotation in the field `visitRecord`, but it overrides the annotation value of `recycledChatHistories`.\n+\n+\n+All above examples shows that inheritance and overrides gives more extensibility to the schema annotations. Users should be free to define their own rules regarding how those annotations can be read. There should be an imambigous annotation value for the fields after user's rules are applied. We call this processing step to figure out the eventual value of a field or schema's annotation \"resolution\" and we call such value \"resolved\" value.\n+\n+What is more, users could have their own customized logic to process the annotations and define the custom behavior when annotations is overriden or inheritted, and even have the flexibility to set a customized resolved value by calling another local function or remote procedure.  The need for such extensibility gives the motivation for Annotation Processor. We aim to build a tool that can process annotations during schema resolution, process all interested annotations by plugin-ing user's own logic and save the \"resolved\" value back to corresponding DataSchema.\n+\n+### A common application of overriding annotation using PathSpec\n+In the above `EnterpriseUserRecord` example, we use `@persistencePolicyInDays = {\"/recycledChatHistories\" : 3650}` do denote the field we are overriding is `recycledChatHistories`. This is basically using PathSpec to reference the field or child schema that needs to be overriden. PathSpec <insert-linke-here> can be used as a path to associate relations between fields among nested schemas. Users can use PathSpec to inambigously specifcy all the paths to the child fields that they want to override.\n+\n+\n+In Linkedin, such usage is so common that we want to use ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f74fd02aa09f582593bc40a69bd16c3787950f33"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae27d657ed37ee70a64773d1e221668e88de897e", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/ae27d657ed37ee70a64773d1e221668e88de897e", "committedDate": "2020-06-18T17:51:40Z", "message": "Address comments and proof-read"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7880c1044d569c63ab23dc2ca29ba10126aacdbb", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/7880c1044d569c63ab23dc2ca29ba10126aacdbb", "committedDate": "2020-06-19T19:52:01Z", "message": "Some edits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NjI1MTgz", "url": "https://github.com/linkedin/rest.li/pull/324#pullrequestreview-435625183", "createdAt": "2020-06-23T09:53:59Z", "commit": {"oid": "7880c1044d569c63ab23dc2ca29ba10126aacdbb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDQ5ODAy", "url": "https://github.com/linkedin/rest.li/pull/324#pullrequestreview-436049802", "createdAt": "2020-06-23T18:31:33Z", "commit": {"oid": "7880c1044d569c63ab23dc2ca29ba10126aacdbb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1d0093df912a7da1909ad0099552675896ae22c", "author": {"user": {"login": "junchuanwang", "name": "Junchuan Wang"}}, "url": "https://github.com/linkedin/rest.li/commit/a1d0093df912a7da1909ad0099552675896ae22c", "committedDate": "2020-06-25T23:01:27Z", "message": "Merge branch 'gh-pages-source' into gh-pages-source_annotation_processor_wiki"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4840, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}