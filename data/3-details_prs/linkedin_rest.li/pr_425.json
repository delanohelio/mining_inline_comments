{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMTYyNDQ4", "number": 425, "title": "Add checkPegasusSchemaSnapshotTask", "bodyText": "checkPegasusSchemaSnapshotTask is used to check the pegasus schema's compatibility.\nThe check is based on the snapshots(.pdl files) which are generated in generatePegasusSchemaSnapshotTask.", "createdAt": "2020-09-24T03:43:29Z", "url": "https://github.com/linkedin/rest.li/pull/425", "merged": true, "mergeCommit": {"oid": "b9bdd1f5a304b931571ac266c0babf19c2377cb2"}, "closed": true, "closedAt": "2020-09-30T16:07:55Z", "author": {"login": "nickibi"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMDBJvABqjM4MDM4NTc5ODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdN-abhABqjM4MjUwOTY4OTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45e903bff5e12f6c8a8ffd2dbafc3172ab06a72f", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/45e903bff5e12f6c8a8ffd2dbafc3172ab06a72f", "committedDate": "2020-09-24T03:42:37Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/849f5a16a92eb014628d6e9085f5293301e2a3aa", "committedDate": "2020-09-24T15:34:59Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE1Mzc0", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-496115374", "createdAt": "2020-09-25T05:14:58Z", "commit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToxNDo1OFrOHX1P5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToxNDo1OFrOHX1P5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ==", "bodyText": "Is it worth to also add CompatibilityLevel.OFF and CompatibilityLevel.IGNORE?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494751719", "createdAt": "2020-09-25T05:14:58Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE2MjE3", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-496116217", "createdAt": "2020-09-25T05:17:58Z", "commit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToxNzo1OFrOHX1Syw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToxNzo1OFrOHX1Syw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MjQ1OQ==", "bodyText": "I think it might be better to abstract test input out from the test logic.\nOne example is the \"BirthInfo\"", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494752459", "createdAt": "2020-09-25T05:17:58Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n+    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n+  }\n+\n+  @Test\n+  public void testIncompatiblePegasusSchemaSnapshot()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE3MzA5", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-496117309", "createdAt": "2020-09-25T05:21:24Z", "commit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyMToyNFrOHX1Wig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyMToyNFrOHX1Wig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQxOA==", "bodyText": "How about just final String compatableLevel", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494753418", "createdAt": "2020-09-25T05:21:24Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE4MjQy", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-496118242", "createdAt": "2020-09-25T05:24:38Z", "commit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyNDozOFrOHX1Zzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyNDozOFrOHX1Zzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDI1NA==", "bodyText": "Would it be cleaner if the action checkPegasusSchemaCompatibility return the InfoMap directly?\nI mean : not use the check to have another call to get the info.\nThe reason being, if we not return info map directly, they are sort of internal state in the checker, that means you will need to get the info map before you can use the check to check again.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494754254", "createdAt": "2020-09-25T05:24:38Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE5ODE2", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-496119816", "createdAt": "2020-09-25T05:29:41Z", "commit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyOTo0MVrOHX1fZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyOTo0MVrOHX1fZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTY4NQ==", "bodyText": "We can try to use StringJoiner to replace StringBuilder, that will make this code a bit cleaner because we don't have to add delimiter every time when a element is appended.\nYou can have it this way\nStringJoiner joiner = new StringJoiner(\"|\", \"<\", \">\");\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -> joiner.add(elem));\nreturn joiner.toString();", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494755685", "createdAt": "2020-09-25T05:29:41Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker.getInfoMap().createSummary();\n+\n+    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n+    {\n+      _logger.info(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  public CompatibilityInfoMap getInfoMap()\n+  {\n+    return _infoMap;\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   */\n+  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");\n+    for (CompatibilityLevel compatLevel : CompatibilityLevel.values())\n+    {\n+      options.append(compatLevel.name().toLowerCase()).append(\"|\");\n+    }\n+    options.replace(options.length() - 1, options.length(), \">\");\n+\n+    return options.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 277}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/849f5a16a92eb014628d6e9085f5293301e2a3aa", "committedDate": "2020-09-24T15:34:59Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "65a379ceaed8dde2e093cc2997848e715b99c139", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/65a379ceaed8dde2e093cc2997848e715b99c139", "committedDate": "2020-09-26T01:31:11Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65a379ceaed8dde2e093cc2997848e715b99c139", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/65a379ceaed8dde2e093cc2997848e715b99c139", "committedDate": "2020-09-26T01:31:11Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "committedDate": "2020-09-26T04:07:23Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MTE5MTU1", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-497119155", "createdAt": "2020-09-27T22:43:45Z", "commit": {"oid": "c39cd375d947a7f098acc730cfba3b4eb67e5fbf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "committedDate": "2020-09-26T04:07:23Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/678478fea424515a1a53489198c7036c9262d441", "committedDate": "2020-09-27T23:43:28Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MTI5MjM3", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-497129237", "createdAt": "2020-09-28T00:19:51Z", "commit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMDoxOTo1MVrOHYrU3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMToxNTo1M1rOHYrzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzcyNw==", "bodyText": "Please add a better description.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495637727", "createdAt": "2020-09-28T00:19:51Z", "author": {"login": "karthikbalasub"}, "path": "CHANGELOG.md", "diffHunk": "@@ -13,6 +13,7 @@ When updating the changelog, remember to be very clear about what behavior has c\n and what APIs have changed, if applicable.\n \n ## [Unreleased]\n+- Add `checkPegasusSchemaSnapshot` task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzk1MQ==", "bodyText": "Please add a one line comment on what each of these constants are used for.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495637951", "createdAt": "2020-09-28T00:21:51Z", "author": {"login": "karthikbalasub"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +541,9 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDM1NA==", "bodyText": "Is this java process expecting the list of files to compare as the input? If so, please add to the help message.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640354", "createdAt": "2020-09-28T00:41:12Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw==", "bodyText": "Why should we print the summary twice if \"report\" is enabled?\nIs printing to stdout the best option? Can we write this to a file instead?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640673", "createdAt": "2020-09-28T00:43:41Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ==", "bodyText": "Is this the best way to take inputs for this checker? Can we just take the root directory and iterate over the files?\nThe reason I'm asking is that for PDL files, the number of files is going to be large and would exceed the cmd line limit.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640901", "createdAt": "2020-09-28T00:45:16Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTAzNA==", "bodyText": "nit: previousSchema or prevSchema", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641034", "createdAt": "2020-09-28T00:46:13Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTk0NA==", "bodyText": "I don't think this is the correct impact. We just have to these files as added. Similar to how the ChangedFileReportTask works.\nAlso, add this only after current schema is parsed correctly?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641944", "createdAt": "2020-09-28T00:51:51Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MjMzMA==", "bodyText": "Again, this is just a backwards incompatible change. It can break any client using this schema at build time, not just old readers.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495642330", "createdAt": "2020-09-28T00:54:25Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzgyMQ==", "bodyText": "It seems odd that you need to create a resolver for each file. Do you want to process the same schema multiple times if it is referenced by other schemas? Consider this scenario:\nPrev:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\nf2: float\n}\nCurrent:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\n// f2 deleted\n}\nNow will the error be reported once for B.pdl or twice, for both A.pdl and B.pdl?\nI know we report the error multiple times for resource compatibility checking, but do you think that is the best options for schema checker also?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495643821", "createdAt": "2020-09-28T01:05:03Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA==", "bodyText": "Not used anywhere?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645240", "createdAt": "2020-09-28T01:13:52Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java", "diffHunk": "@@ -166,6 +166,21 @@ public String createSummary()\n     return summaryMessage.toString();\n   }\n \n+  public String createPegasusSchemaSummary()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTYxMw==", "bodyText": "unused?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645613", "createdAt": "2020-09-28T01:15:53Z", "author": {"login": "karthikbalasub"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+import com.linkedin.pegasus.gradle.IOUtil;\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.PegasusPlugin;\n+import com.linkedin.pegasus.gradle.SharedFileUtils;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;\n+  private File _summaryTarget = new File(getProject().getBuildDir(), \"reports/checkPegasusSchema/summary.txt\");\n+\n   @TaskAction\n   public void checkPegasusSnapshot()\n   {\n-    // TODO: implement CheckPegasusSnapshotTask\n+    getLogger().info(\"Checking pegasus schema compatibility ...\");\n+    List<String> argFiles = new ArrayList<>();\n+    argFiles.addAll(SharedFileUtils.findMatchingFiles(PegasusPlugin.PDL_FILE_SUFFIX,\n+        getProject().fileTree(_currentSnapshotDirectory), getProject().fileTree(_previousSnapshotDirectory), false));\n+    if (argFiles.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    FileCollection pathedCodegenClasspath;\n+    try\n+    {\n+      pathedCodegenClasspath = PathingJarUtil.generatePathingJar(getProject(), getName(),\n+          _codegenClasspath, false);\n+    }\n+    catch (IOException e)\n+    {\n+      throw new GradleException(\"Error occurred generating pathing JAR.\", e);\n+    }\n+\n+    CompatibilityLogChecker logChecker = new CompatibilityLogChecker();\n+    getProject().javaexec(javaExecSpec ->\n+    {\n+      javaExecSpec.setMain(\"com.linkedin.restli.tools.snapshot.check.PegasusSchemaSnapshotCompatibilityChecker\");\n+      javaExecSpec.setClasspath(pathedCodegenClasspath);\n+      javaExecSpec.args(\"--compatLevel\", _compatibilityLevel);\n+      javaExecSpec.args(\"--compatMode\", _compatibilityMode);\n+      javaExecSpec.args(\"--report\");\n+      javaExecSpec.args(argFiles);\n+      javaExecSpec.setStandardOutput(logChecker);\n+    });\n+\n+    IOUtil.writeText(_summaryTarget, logChecker.getWholeText());\n+\n+    if (!logChecker.isModelCompatible())\n+    {\n+      throw new GradleException(\"See output for \" + getPath() + \". Summary written to \"\n+          + _summaryTarget.getAbsolutePath());\n+    }\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getCurrentSnapshotDirectory()\n+  {\n+    return _currentSnapshotDirectory;\n   }\n \n+  public void setCurrentSnapshotDirectory(File currentSnapshotDirectory)\n+  {\n+    _currentSnapshotDirectory = currentSnapshotDirectory;\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getPreviousSnapshotDirectory()\n+  {\n+    return _previousSnapshotDirectory;\n+  }\n+\n+  public void setPreviousSnapshotDirectory(File previousSnapshotDirectory)\n+  {\n+    _previousSnapshotDirectory = previousSnapshotDirectory;\n+  }\n+\n+  @Input\n+  public String getCompatibilityLevel()\n+  {\n+    return _compatibilityLevel;\n+  }\n+\n+  public void setCompatibilityLevel(String compatibilityLevel)\n+  {\n+    _compatibilityLevel = compatibilityLevel;\n+  }\n+\n+  @Input\n+  public String getCompatibilityMode()\n+  {\n+    return _compatibilityMode;\n+  }\n+\n+  public void setCompatibilityMode(String compatibilityMode)\n+  {\n+    _compatibilityMode = compatibilityMode;\n+  }\n+\n+  @Classpath\n+  public FileCollection getCodegenClasspath()\n+  {\n+    return _codegenClasspath;\n+  }\n+\n+  public void setCodegenClasspath(FileCollection codegenClasspath)\n+  {\n+    _codegenClasspath = codegenClasspath;\n+  }\n+\n+  @Input\n+  public boolean isExtensionSchema()\n+  {\n+    return _isExtensionSchema;\n+  }\n+\n+  public void setExtensionSchema(boolean isExtensionSchema)\n+  {\n+    _isExtensionSchema = isExtensionSchema;\n+  }\n+\n+  @Classpath\n+  public FileCollection getHandlerJarPath()\n+  {\n+    return _handlerJarPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441"}, "originalPosition": 184}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "678478fea424515a1a53489198c7036c9262d441", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/678478fea424515a1a53489198c7036c9262d441", "committedDate": "2020-09-27T23:43:28Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "committedDate": "2020-09-28T22:07:18Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "committedDate": "2020-09-28T22:07:18Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/e8cff132df27dc0936309023946b483d09cf9112", "committedDate": "2020-09-28T22:16:02Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MzIzNjYw", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-498323660", "createdAt": "2020-09-29T10:22:10Z", "commit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMDoyMjoxMFrOHZmdwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMToxNjo0M1rOHZoQ2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNjY1Nw==", "bodyText": "Suggestion: would be good to refactor this and move these config constants to FileCompatibilityType(String configName) Enum", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496606657", "createdAt": "2020-09-29T10:22:10Z", "author": {"login": "aman1309"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +539,12 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYyODk2Ng==", "bodyText": "since we might use pdl for idl's in 3.0 or for any other future usecase, recommend using 'FileCompatibilityType' instead of boolean flag.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496628966", "createdAt": "2020-09-29T11:03:26Z", "author": {"login": "aman1309"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMDMxMw==", "bodyText": "can we unit test for gradle tasks?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496630313", "createdAt": "2020-09-29T11:05:54Z", "author": {"login": "aman1309"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -1449,23 +1460,43 @@ protected void configurePegasusSchemaSnapshotGeneration(Project project, SourceS\n   {\n     File schemaDir = isExtensionSchema? project.file(getExtensionSchemaPath(project, sourceSet))\n         : project.file(getDataSchemaPath(project, sourceSet));\n+\n     Path publishablePegasusSchemaSnapshotDir = project.getBuildDir().toPath().resolve(sourceSet.getName() +\n             (isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT));\n \n     Task generatePegasusSchemaSnapshot = generatePegasusSchemaSnapshot(project, sourceSet,\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT, schemaDir,\n         publishablePegasusSchemaSnapshotDir.toFile(), isExtensionSchema);\n \n+    File pegasusSchemaSnapshotDir = project.file(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n+        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+    pegasusSchemaSnapshotDir.mkdirs();\n+\n     Task checkSchemaSnapshot = project.getTasks().create(sourceSet.getTaskName(\"check\",\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT),\n         CheckPegasusSnapshotTask.class, task ->\n         {\n           task.dependsOn(generatePegasusSchemaSnapshot);\n-          // TODO: update CheckPegasusSnapshotTask\n-        });\n+          task.setCurrentSnapshotDirectory(publishablePegasusSchemaSnapshotDir.toFile());\n+          task.setPreviousSnapshotDirectory(pegasusSchemaSnapshotDir);\n+          task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n+              .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n+              .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n+          task.setCompatibilityLevel(isExtensionSchema ?\n+              PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n+              :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n+          task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n+              PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n+          task.setExtensionSchema(isExtensionSchema);\n+          task.setHandlerJarPath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION));\n \n-    File pegasusSchemaSnapshotDir = new File(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n-        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+          task.onlyIf(t ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMTQwMw==", "bodyText": "lets print option value and exception trace also.\nSame for other places.", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496631403", "createdAt": "2020-09-29T11:07:56Z", "author": {"login": "aman1309"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNjEyMg==", "bodyText": "here, CompatibilityLevel.OFF should also not parse the schemas. can we add assert on method calls?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496636122", "createdAt": "2020-09-29T11:16:43Z", "author": {"login": "aman1309"}, "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}, "originalCommit": {"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa"}, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8cff132df27dc0936309023946b483d09cf9112", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/e8cff132df27dc0936309023946b483d09cf9112", "committedDate": "2020-09-28T22:16:02Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "02a5f62be184d2095e9036247e3532f365edeb34", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/02a5f62be184d2095e9036247e3532f365edeb34", "committedDate": "2020-09-29T15:57:44Z", "message": "Add checkPegasusSchemaSnapshotTask"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02a5f62be184d2095e9036247e3532f365edeb34", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/02a5f62be184d2095e9036247e3532f365edeb34", "committedDate": "2020-09-29T15:57:44Z", "message": "Add checkPegasusSchemaSnapshotTask"}, "afterCommit": {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "committedDate": "2020-09-29T16:15:48Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NzIxMjA3", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-498721207", "createdAt": "2020-09-29T17:30:19Z", "commit": {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzozMDoxOVrOHZ5WvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0ODowOVrOHZ6BUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjE1Nw==", "bodyText": "the Key should include the path or atleast the package (namespace)? what if there are two schemas with the same name in a module?\nAlso add a unit test for this case", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496916157", "createdAt": "2020-09-29T17:30:19Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzA1Nw==", "bodyText": "should be prevFilesMap\nIs there a unit test to handle this case?", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496927057", "createdAt": "2020-09-29T17:48:09Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e"}, "originalPosition": 301}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "committedDate": "2020-09-29T16:15:48Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}, "afterCommit": {"oid": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/03c0e0e7db8db22d16618c58e117bafbbfa111b8", "committedDate": "2020-09-29T23:38:34Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/03c0e0e7db8db22d16618c58e117bafbbfa111b8", "committedDate": "2020-09-29T23:38:34Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}, "afterCommit": {"oid": "64e32c96a570d57853c8759bd7647904d05f8157", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/64e32c96a570d57853c8759bd7647904d05f8157", "committedDate": "2020-09-30T00:03:18Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MjU4OTk0", "url": "https://github.com/linkedin/rest.li/pull/425#pullrequestreview-499258994", "createdAt": "2020-09-30T09:44:12Z", "commit": {"oid": "64e32c96a570d57853c8759bd7647904d05f8157"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64e32c96a570d57853c8759bd7647904d05f8157", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/64e32c96a570d57853c8759bd7647904d05f8157", "committedDate": "2020-09-30T00:03:18Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}, "afterCommit": {"oid": "205b990c053a124cce887f07cf7916434a805221", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/205b990c053a124cce887f07cf7916434a805221", "committedDate": "2020-09-30T15:09:38Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "205b990c053a124cce887f07cf7916434a805221", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/205b990c053a124cce887f07cf7916434a805221", "committedDate": "2020-09-30T15:09:38Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}, "afterCommit": {"oid": "107af4472c44c1da1e2c6fe53f46519b7cec81f1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/107af4472c44c1da1e2c6fe53f46519b7cec81f1", "committedDate": "2020-09-30T15:18:15Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "committedDate": "2020-09-30T15:20:52Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "107af4472c44c1da1e2c6fe53f46519b7cec81f1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/107af4472c44c1da1e2c6fe53f46519b7cec81f1", "committedDate": "2020-09-30T15:18:15Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}, "afterCommit": {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "committedDate": "2020-09-30T15:20:52Z", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\"."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4677, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}