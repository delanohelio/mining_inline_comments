{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NDYzNTk5", "number": 264, "title": "DarkCluster schema changes: adding multiplierStrategyList and transportClientProperties", "bodyText": "Adding multiplierStrategyList and transportClientProperties for dark clusters.\nmultiplierStrategyList - this is a list instead of a single value to decoupling adding a new strategy from the rollout. Esp in large services or where a client side dispatching mechanism is chosen, this will allow the new strategy to be picked up as its available, instead of requiring all dark clients to be upgraded first before turning it on. This is a lesson learned from when DegraderLoadBalancerStrategyName was deprecated in favor of DegraderLoadBalancerStrategyList for the same reason.\nThere are two strategies: RELATIVE_TRAFFIC and CONSTANT_QPS. only RELATIVE_TRAFFIC is implemented so far. The Javadocs in the corresponding classes have more details on how those strategies work.\ntransportClientProperties - by specifying the transportClientProperties, and having them make their way into the dark service transportClientProperties, the d2 client will automatically use these properties.\nBecause transportClientProperties has it's own Converter and uses different keys for serialization than what the pegasus object (D2TransportClientProperties) uses, I had to make a change away from using the pegasus object (DarkClusterConfigMap) in both the in-mem and serialized-for-zookeeper representation. Map<String, Object> is the new serialized form, and the DarkClusterConfigMap can still be used in-mem. I tried to minimize the changes required by adding a method accessDarkClusters (which won't be used by Jackson) to do the conversion for users expecting a DarkClusterConfigMap. This also has the benefit of not exposing the underlying Map for threadsafety.\nAfter approval, I will initiate schema review.", "createdAt": "2020-04-21T06:19:26Z", "url": "https://github.com/linkedin/rest.li/pull/264", "merged": true, "mergeCommit": {"oid": "d36724e1dee35cfc55601057293018037c26ee83"}, "closed": true, "closedAt": "2020-04-28T21:15:25Z", "author": {"login": "davidhoa"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ7YKngBqjMyNTgxMjc1OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccKf0ZABqjMyODIxNDMxNDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8abc3ce0275601f7e972e5acab5a23e79c01faa", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/b8abc3ce0275601f7e972e5acab5a23e79c01faa", "committedDate": "2020-04-21T06:17:48Z", "message": "DarkCluster schema changes to add multiplierStrategyList and transportClientProperties"}, "afterCommit": {"oid": "9ef5448a157b528ba7f1be3fa0b2cdf217ab5e54", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/9ef5448a157b528ba7f1be3fa0b2cdf217ab5e54", "committedDate": "2020-04-21T22:24:20Z", "message": "rebase and incorporate pdsc->pdl migration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Nzk1NjI2", "url": "https://github.com/linkedin/rest.li/pull/264#pullrequestreview-397795626", "createdAt": "2020-04-22T02:14:44Z", "commit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjoxNDo0NFrOGJgNMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMzo0MzoyMVrOGJh7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw==", "bodyText": "Curious why this is prioritized order instead of single element? When would a strategy be unavailable other than this initial inconsistent stage when we have schema defined for constant qps but no code impl?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412618033", "createdAt": "2020-04-22T02:14:44Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg==", "bodyText": "Multiplier is implementation specific. Can we use DarkClusterStrategy?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412618916", "createdAt": "2020-04-22T02:17:20Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyMjI5Mg==", "bodyText": "How about\nThis strategy aims to maintain a proportional amount of incoming QPS at the host level between the source and dark clusters.\nConfigured with \"multiplier\". For example a multiplier of 1 would mean the average incoming QPS for a source host equals that of a dark host. A multiplier of 2 means on average a dark host will receive 2x more traffic than a source host.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412622292", "createdAt": "2020-04-22T02:27:14Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw==", "bodyText": "I think we can leave out this strategy for when it's actually implemented in a future RB.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412624573", "createdAt": "2020-04-22T02:34:23Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw==", "bodyText": "What's the status on implementing dispatcherOutboundTargetRate? Can we remove these configs if no plans to implement anytime soon? I'd rather introduce a cleaner approach to Constant QPS than what we have in dark canary now.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412625933", "createdAt": "2020-04-22T02:38:26Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ==", "bodyText": "Can we keep this old behavior of using Jackson to serialize everything and selectively replace each transport properties with output of TransportClientPropertiesConverter?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412633715", "createdAt": "2020-04-22T03:02:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg==", "bodyText": "this will never be reached because of previous \"darkClusterConfig.getMultiplier() > 0\"", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642252", "createdAt": "2020-04-22T03:30:24Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjY0Mg==", "bodyText": "This else statement return breaks the use of strategy list since it will never iterate past the first element. but also made a previous comment on not using a list.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642642", "createdAt": "2020-04-22T03:31:32Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MzY2NQ==", "bodyText": "I think it would be a lot cleaner if we had the implementations themselves handle these edge cases rather than manually returning NoOpDarkClusterStrategy. In this case always return new RelativeTrafficMultiplierDarkClusterStrategy but since the multiplier is <= 0 then no requests will be sent out.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412643665", "createdAt": "2020-04-22T03:34:42Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjMzMQ==", "bodyText": "Prefer using switch/case for clarity.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412646331", "createdAt": "2020-04-22T03:43:21Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else\n+        {\n+          // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n+          return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.\n+    return new NoOpDarkClusterStrategy();\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTk0MDYw", "url": "https://github.com/linkedin/rest.li/pull/264#pullrequestreview-398594060", "createdAt": "2020-04-22T21:13:51Z", "commit": {"oid": "3fef3d5500ce3cad56d7e482a07aa3aa96c4ed14"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMToxMzo1MVrOGKMGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjoyMzowMVrOGKOTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzI4Nw==", "bodyText": "I think backwards incompatibility is fine because only we're consuming it. Cleaner approach is using an implementation that guarantees target QPS so we only need 1 config and not \"dispatcherOutboundMaxRate\".", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413337287", "createdAt": "2020-04-22T21:13:51Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MDI1Nw==", "bodyText": "I see, can we include this explanation to the doc?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413370257", "createdAt": "2020-04-22T22:16:58Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MDcyOQ==", "bodyText": "Why do you prefer DarkClusterStrategyType over DarkClusterStrategy? I don't think the Type is necessary here.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413370729", "createdAt": "2020-04-22T22:17:52Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzExNg==", "bodyText": "Sure, and for the doc what about\nThis strategy will try to maintain a certain queries per second to the entire dark cluster.\nConfigured with \"dispatcherOutboundTargetRate\".", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413373116", "createdAt": "2020-04-22T22:22:34Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzMwMQ==", "bodyText": "ok", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413373301", "createdAt": "2020-04-22T22:23:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3fef3d5500ce3cad56d7e482a07aa3aa96c4ed14", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/3fef3d5500ce3cad56d7e482a07aa3aa96c4ed14", "committedDate": "2020-04-22T05:26:49Z", "message": "address Chris' review comments."}, "afterCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/65ab2577596c9527dc65e2eb9ebf1db000ec613a", "committedDate": "2020-04-23T20:44:48Z", "message": "additional comment changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDUwNjAw", "url": "https://github.com/linkedin/rest.li/pull/264#pullrequestreview-399450600", "createdAt": "2020-04-23T20:27:38Z", "commit": {"oid": "3fef3d5500ce3cad56d7e482a07aa3aa96c4ed14"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoyNzozOFrOGK6uFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDozMzowMFrOGK66tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMTAxNA==", "bodyText": "we discussed offline. We will leave it as is, and consider deprecating it later if not needed. To remove it would require a major version bump of pegasus, which is undesirable if it can be avoided.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414101014", "createdAt": "2020-04-23T20:27:38Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMTE0Mg==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414101142", "createdAt": "2020-04-23T20:27:51Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMzY2Ng==", "bodyText": "as discussed, DarkClusterStrategy can't be used because we already have a java class named that. We decided on DarkClusterStrategyName instead.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414103666", "createdAt": "2020-04-23T20:32:00Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDI0Ng==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414104246", "createdAt": "2020-04-23T20:33:00Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDYxNjk3", "url": "https://github.com/linkedin/rest.li/pull/264#pullrequestreview-399461697", "createdAt": "2020-04-23T20:44:06Z", "commit": {"oid": "3fef3d5500ce3cad56d7e482a07aa3aa96c4ed14"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0NDowNlrOGK7U3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNToyN1rOGK-CQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMDk0MQ==", "bodyText": "Discussed offline, will leave as is and deprecate later in needed.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414110941", "createdAt": "2020-04-23T20:44:06Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMTM5NQ==", "bodyText": "Discussed offline, will use DarkClusterStrategyName .", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414111395", "createdAt": "2020-04-23T20:44:50Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMzU0NQ==", "bodyText": "rename to DarkClusterStrategyPrioritizedList?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414113545", "createdAt": "2020-04-23T20:48:35Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,16 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies. This is a list to support adding new strategies and having the strategy users\n+   * pick it up as they upgrade code versions, versus waiting for all strategy users to upgrade first. This is the same reason\n+   * DegraderLoadBalancerStrategyName was replaced by DegraderLoadBalancerStrategyList.\n+   */\n+  multiplierStrategyList: array[DarkClusterStrategyName] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExNDQ5MQ==", "bodyText": "Please also explain when a strategy may not be available here as well.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414114491", "createdAt": "2020-04-23T20:50:13Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterStrategyName.pdl", "diffHunk": "@@ -0,0 +1,20 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA==", "bodyText": "make the naming uniform - I think these are fine:\nDEFAULT_MULTIPLIER\nDEFAULT_DISPATCHER....", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414119984", "createdAt": "2020-04-23T20:59:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMDc1MA==", "bodyText": "instead of a comment here can we add a description to the javadoc of converter method in TransportClientPropertiesConverter?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414120750", "createdAt": "2020-04-23T21:00:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTE0Mw==", "bodyText": "not necessary here, let's remove", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139143", "createdAt": "2020-04-23T21:33:20Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTgyOQ==", "bodyText": "can remove here too. I don't think converter needs to do anything special to be resilient since it's just a string anyway.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139829", "createdAt": "2020-04-23T21:34:45Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST))\n+      {\n+        DataList dataList = new DataList();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> strategyList = (List<String>)props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST);\n+        dataList.addAll(strategyList);\n+\n+        // note that unknown strategyTypes can be added here. This can happen for new strategies as they are rolling\n+        // out, or for bad strategy types. The converter and client code should be resilient to these.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MDc2MQ==", "bodyText": "Is this necessary? Can we remove? no one is using this config yet anyway", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414140761", "createdAt": "2020-04-23T21:36:26Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQ2OA==", "bodyText": "Can you include a class-level javadoc explaining how everything here is what is stored in zk, etc to prevent running into this issue again?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414141468", "createdAt": "2020-04-23T21:37:51Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -38,7 +41,7 @@\n   private final Set<URI> _bannedUris;\n   @Deprecated\n   private final List<String>          _prioritizedSchemes;\n-  private final DarkClusterConfigMap _darkClusters;\n+  private final Map<String, Object> _darkClusters;\n   private final boolean              _delegated;\n \n   public ClusterProperties(String clusterName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0Njc2Mg==", "bodyText": "I thought I left a comment about this but I don't see it, weird. Anyway can we keep this constructor and do a conversion from  DarkClusterConfigMap to Map<String, Object> instead?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414146762", "createdAt": "2020-04-23T21:48:08Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -95,9 +102,17 @@ public ClusterProperties(String clusterName,\n       DarkClusterConfigMap darkClusters)\n   {\n     this(clusterName, prioritizedSchemes, properties, bannedUris, partitionProperties, sslSessionValidationStrings,\n-        darkClusters, false);\n+        (Map<String, Object>)null, false);\n   }\n \n+  /**\n+   * @deprecated Use the constructor that uses a Map instead of DarkClusterConfigMap. Using this object is not flexible enough to hold\n+   * transportClientProperties, because {@link com.linkedin.d2.balancer.config.TransportClientPropertiesConverter} uses different\n+   * keys in it's serialization than how Jackson would serialize D2TransportClientProperties. That is problematic since ClusterProperties\n+   * already should have had all necessary conversions done, but in this case the pegasus objects don't have a mechanism to allow the conversions.\n+   * The solution is to use a Map<String, Object> to pass in the darkClusters.\n+   */\n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0ODY1Mw==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414148653", "createdAt": "2020-04-23T21:51:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/PropertyKeys.java", "diffHunk": "@@ -179,6 +179,8 @@\n   public static final String DARK_CLUSTER_MULTIPLIER = \"multiplier\";\n   public static final String DARK_CLUSTER_OUTBOUND_TARGET_RATE = \"dispatcherOutboundTargetRate\";\n   public static final String DARK_CLUSTER_OUTBOUND_MAX_RATE = \"dispatcherOutboundMaxRate\";\n+  public static final String DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST = \"multiplierStrategyList\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDQ0Nw==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150447", "createdAt": "2020-04-23T21:55:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDYzNQ==", "bodyText": "use public static variable", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150635", "createdAt": "2020-04-23T21:55:46Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.RELATIVE_TRAFFIC);\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.CONSTANT_QPS);\n+    DarkClusterConfig config = new DarkClusterConfig()\n+      .setMultiplierStrategyList(multiplierStrategyTypeArray);\n+\n+    configMap.put(DARK_CLUSTER_KEY, config);\n+\n+    // these are defaults that will be set if the fields are missing.\n+    config.setMultiplier(0.0f);\n+    config.setDispatcherOutboundTargetRate(0);\n+    config.setDispatcherOutboundMaxRate(Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjU5Ng==", "bodyText": "Can we use the static variables defined in ClusterProperties? Or move those variables to a more appropriate class?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414152596", "createdAt": "2020-04-23T21:59:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA==", "bodyText": "I'm still a fan of exposing an API in DarkClusterStrategy#isValidConfig that the factory can just call into for each strategy type :)\nThat way everything is self-contained in each impl and the factory doesn't need to know these details.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154754", "createdAt": "2020-04-23T22:04:17Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDgyMA==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154820", "createdAt": "2020-04-23T22:04:24Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTI3MQ==", "bodyText": "not necessary since we return no op strategy at end anyway.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155271", "createdAt": "2020-04-23T22:05:20Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTMyOA==", "bodyText": "can remove comment", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155328", "createdAt": "2020-04-23T22:05:27Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTAzODM3", "url": "https://github.com/linkedin/rest.li/pull/264#pullrequestreview-402103837", "createdAt": "2020-04-28T18:30:07Z", "commit": {"oid": "8c658f260aa0e998def24eb171a69d906bb05382"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMDowN1rOGNhehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMDowN1rOGNhehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMzE1Nw==", "bodyText": "-> strategyNameArray", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r416833157", "createdAt": "2020-04-28T18:30:07Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +50,78 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDarkClusterStrategyPrioritizedList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getDarkClusterStrategyPrioritizedList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c658f260aa0e998def24eb171a69d906bb05382"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f03534c676b6ef8ddd2ab77191461c10061cf3e7", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/f03534c676b6ef8ddd2ab77191461c10061cf3e7", "committedDate": "2020-04-28T21:09:30Z", "message": "DarkCluster schema changes to add multiplierStrategyList and transportClientProperties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe10402c5f9432af01d11242d53e0c1da8ef0581", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/fe10402c5f9432af01d11242d53e0c1da8ef0581", "committedDate": "2020-04-28T21:09:30Z", "message": "rebase and incorporate pdsc->pdl migration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c87196224f9d5adf926c2f08cab689ebc59a92c", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/6c87196224f9d5adf926c2f08cab689ebc59a92c", "committedDate": "2020-04-28T21:09:30Z", "message": "add multiplierStrategy unit tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8564f6244ae8e56b753b451138f935d21f09516b", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/8564f6244ae8e56b753b451138f935d21f09516b", "committedDate": "2020-04-28T21:09:30Z", "message": "address Chris' review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba59835537ee2f0a0e14986ea207ecf4a9a74fdb", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/ba59835537ee2f0a0e14986ea207ecf4a9a74fdb", "committedDate": "2020-04-28T21:09:30Z", "message": "additional comment changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8b6d7ad9d607241803249f7b29ee3ad5ebef44f", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/a8b6d7ad9d607241803249f7b29ee3ad5ebef44f", "committedDate": "2020-04-28T21:09:30Z", "message": "renames"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd65b511aa66ab276371de33c386b285a1c5327", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/efd65b511aa66ab276371de33c386b285a1c5327", "committedDate": "2020-04-28T21:09:30Z", "message": "clean up code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "committedDate": "2020-04-28T21:09:31Z", "message": "minor naming change"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c658f260aa0e998def24eb171a69d906bb05382", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/8c658f260aa0e998def24eb171a69d906bb05382", "committedDate": "2020-04-27T18:42:20Z", "message": "clean up code."}, "afterCommit": {"oid": "b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "committedDate": "2020-04-28T21:09:31Z", "message": "minor naming change"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4750, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}