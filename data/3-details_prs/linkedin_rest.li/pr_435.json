{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MjIzODE0", "number": 435, "title": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility", "bodyText": "Extend checkPegasusSchemaSnapshot task to be enable to check schema annotation compatibility, if SchemaAnnotationHandler is provided.\n\nUpdate SchemaAnnotationHandler interface to have new api - annotationCompatibilityCheck, which can be used to check the custom annotation compatibility check\nCreate a new SchemaVisitor - AnnotationCheckResolvedPropertiesVisitor, which is to get a map of node in a schema to it's resolvedProperties. It can be used to check the annotation compatibility for olderResolvedProperties and newerResolvedProperties.\nAnnotationCompatibilityChecker which leverages the annotation processor to check the compatibilities of annotation changes.\n\nTest:\nUnit tests\nManual test in sample repos.", "createdAt": "2020-10-03T06:13:54Z", "url": "https://github.com/linkedin/rest.li/pull/435", "merged": true, "mergeCommit": {"oid": "74121d54a156824aa2c7db15ade34e8852b1ea08"}, "closed": true, "closedAt": "2020-10-12T20:30:00Z", "author": {"login": "nickibi"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdO0k4DgBqjM4MzYyNzg4NTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdR5ZGQgBqjM4NjgwNTk4Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12121e1ae5fd2ad991c8060df8a5fa4b7942ef73", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/12121e1ae5fd2ad991c8060df8a5fa4b7942ef73", "committedDate": "2020-10-03T06:12:10Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check annotation compatibility, if SchemaAnnotationHandler is provided"}, "afterCommit": {"oid": "c1a6e704f456feb841361258034c4ca6c76c93fb", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/c1a6e704f456feb841361258034c4ca6c76c93fb", "committedDate": "2020-10-03T06:00:19Z", "message": "Add annotation compatibility check in checkPegasusSnapshotTask"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2a92c114064a2638304c0863fdbe05fed74b9c4", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/a2a92c114064a2638304c0863fdbe05fed74b9c4", "committedDate": "2020-10-03T06:40:24Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check annotation compatibility, if SchemaAnnotationHandler is provided"}, "afterCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/5be9a547810b7caa3627c8b8911bed07704b99ae", "committedDate": "2020-10-03T06:52:23Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzkzNzA0", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501793704", "createdAt": "2020-10-05T07:45:16Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0NToxNlrOHcQ9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0NToxNlrOHcQ9Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM5OTk5OQ==", "bodyText": "Can you rename this variable so it can be consistent with other naming (I see three naming, enclosingUnionMember, UnionMember, unionDataMember)", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499399999", "createdAt": "2020-10-05T07:45:16Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionDataMember = context.getEnclosingUnionMember();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzk0MDQ0", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501794044", "createdAt": "2020-10-05T07:45:44Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0NTo0NFrOHcQ-Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0NTo0NFrOHcQ-Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA==", "bodyText": "Same here, there are two paths in context, you can rename it to pathSpecToSchema", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499400254", "createdAt": "2020-10-05T07:45:44Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionDataMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionDataMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzk3MTQ4", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501797148", "createdAt": "2020-10-05T07:49:43Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0OTo0M1rOHcRHQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo0OTo0M1rOHcRHQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMjU2Mg==", "bodyText": "If we make it default method, that means every handler will return a AnnotationCompatibilityResult. Is there a way to tell whether or not this check happened? How can we distinguish the two cases", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499402562", "createdAt": "2020-10-05T07:49:43Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,93 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzk3OTEz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501797913", "createdAt": "2020-10-05T07:50:42Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MDo0MlrOHcRJhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MDo0MlrOHcRJhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzE0MA==", "bodyText": "Similar to my other comment, maybe we can add a flag to tell whether this check has been conducted or not.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499403140", "createdAt": "2020-10-05T07:50:42Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,93 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzk4OTIz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501798923", "createdAt": "2020-10-05T07:51:58Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MTo1OVrOHcRMeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MTo1OVrOHcRMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMzg5Ng==", "bodyText": "How does the handler handle these Else branch cases?  Maybe add some brief comments", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499403896", "createdAt": "2020-10-05T07:51:59Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODAwMDI4", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501800028", "createdAt": "2020-10-05T07:53:31Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MzozMVrOHcRPzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNzo1MzozMVrOHcRPzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwNDc1MA==", "bodyText": "similarly, perhaps add some comments here", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499404750", "createdAt": "2020-10-05T07:53:31Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+            {\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty\n+                  = olderResolvedPropertiesMap.get(pathSpec);\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> newerCheckContextAndResolvedProperty\n+                  = newerResolvedPropertiesMap.get(pathSpec);\n+\n+              Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+              Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+              if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(annotationNamespace))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA2NjE2", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501806616", "createdAt": "2020-10-05T08:00:34Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMDozNVrOHcRimQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMDozNVrOHcRimQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwOTU2MQ==", "bodyText": "Add log before throwing exception", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499409561", "createdAt": "2020-10-05T08:00:35Z", "author": {"login": "junchuanwang"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if olderResolvedPropertiesMap and newerResolvedPropertiesMap contain same pathSpec,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler: handlers)\n+    {\n+      olderResolvedPropertiesMap.entrySet().stream().forEach(e ->\n+          {\n+            String annotationNamespace = handler.getAnnotationNamespace();\n+            PathSpec pathSpec = e.getKey();\n+            if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+            {\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty\n+                  = olderResolvedPropertiesMap.get(pathSpec);\n+              Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> newerCheckContextAndResolvedProperty\n+                  = newerResolvedPropertiesMap.get(pathSpec);\n+\n+              Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+              Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+              if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(annotationNamespace))\n+              {\n+                AnnotationCompatibilityResult result = handler.annotationCompatibilityCheck(olderResolvedProperties,\n+                    newerResolvedProperties, olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+                results.add(result);\n+              }\n+            }\n+          });\n+    }\n+    return results;\n+  }\n+\n+  private static Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> getNodeToResolvedProperties(\n+      SchemaAnnotationProcessor.SchemaAnnotationProcessResult result)\n+  {\n+    AnnotationCheckResolvedPropertiesVisitor visitor = new AnnotationCheckResolvedPropertiesVisitor();\n+    DataSchemaRichContextTraverser traverser = new DataSchemaRichContextTraverser(visitor);\n+    traverser.traverse(result.getResultSchema());\n+    return visitor.getNodeToResolvedPropertiesMap();\n+  }\n+\n+  private static SchemaAnnotationProcessor.SchemaAnnotationProcessResult processSchemaAnnotation(DataSchema dataSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult result =\n+        SchemaAnnotationProcessor.process(handlers, dataSchema, new SchemaAnnotationProcessor.AnnotationProcessOption());\n+    // If any of the nameDataSchema failed to be processed, throw exception\n+    if (result.hasError())\n+    {\n+      String schemaName = ((NamedDataSchema) dataSchema).getFullName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA3MTQ0", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501807144", "createdAt": "2020-10-05T08:01:19Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMToxOVrOHcRl6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMToxOVrOHcRl6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMDQxMQ==", "bodyText": "not throwing exception", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499410411", "createdAt": "2020-10-05T08:01:19Z", "author": {"login": "junchuanwang"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA3MjIy", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501807222", "createdAt": "2020-10-05T08:01:25Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMToyNlrOHcRmZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMToyNlrOHcRmZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMDUzNQ==", "bodyText": "same, not throwing exception", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499410535", "createdAt": "2020-10-05T08:01:26Z", "author": {"login": "junchuanwang"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());\n+      }\n+    }\n+\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathUrls.toArray(new URL[handlerJarPathUrls.size()]),\n+        getClass().getClassLoader());\n+\n+    try\n+    {\n+      _handlerClassNames = SchemaAnnotationHandlerClassUtil.getAnnotationHandlerClassNames(_handlerJarPath, classLoader, getProject());\n+    }\n+    catch (IOException e)\n+    {\n+      new GradleException(\"Annotation compatibility check: could not get annotation handler class name. \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA3Nzg3", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501807787", "createdAt": "2020-10-05T08:02:09Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMjowOVrOHcRpsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMjowOVrOHcRpsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMTM3Nw==", "bodyText": "The logic is still similar to ValidateSchemaAnnotationTask, do you think we can extract the common part to not repeat yourself? Later if we change the enforcement of expected number of hanlders per module, we don't need to change on two places", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499411377", "createdAt": "2020-10-05T08:02:09Z", "author": {"login": "junchuanwang"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -173,4 +190,53 @@ public void setHandlerJarPath(FileCollection handlerJarPath)\n   {\n     _handlerJarPath = handlerJarPath;\n   }\n+\n+  private boolean hasSchemaAnnotationHandler()\n+  {\n+    int expectedHandlersNumber = ((DefaultConfiguration) _handlerJarPath).getAllDependencies().size();\n+    // skip if no handlers configured\n+    if (expectedHandlersNumber == 0)\n+    {\n+      getLogger().info(\"no schema annotation handlers configured for schema annotation compatibility check\");\n+      return false;\n+    }\n+\n+    List<URL> handlerJarPathUrls = new ArrayList<>();\n+\n+    for (File f : _handlerJarPath)\n+    {\n+      try\n+      {\n+        handlerJarPathUrls.add(f.toURI().toURL());\n+      }\n+      catch (MalformedURLException e)\n+      {\n+        new GradleException(\"Annotation compatibility check: could not get schema annotation handler jar \" + f.getName() + \" to url. \" + e.getMessage());\n+      }\n+    }\n+\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathUrls.toArray(new URL[handlerJarPathUrls.size()]),\n+        getClass().getClassLoader());\n+\n+    try\n+    {\n+      _handlerClassNames = SchemaAnnotationHandlerClassUtil.getAnnotationHandlerClassNames(_handlerJarPath, classLoader, getProject());\n+    }\n+    catch (IOException e)\n+    {\n+      new GradleException(\"Annotation compatibility check: could not get annotation handler class name. \" + e.getMessage());\n+    }\n+\n+    // For now, every schema annotation handler should be in its own module", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODA4NDYx", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501808461", "createdAt": "2020-10-05T08:03:06Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMzowN1rOHcRtrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODowMzowN1rOHcRtrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxMjM5OQ==", "bodyText": "I will recommend to use longer name here, --handlerJarPath and handlerClassName. We don't need to be concise for this particular use case, but need to be explicit (for example later do a code search would be easier)", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499412399", "createdAt": "2020-10-05T08:03:07Z", "author": {"login": "junchuanwang"}, "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -76,6 +84,15 @@ public void checkPegasusSnapshot()\n       javaExecSpec.args(\"--report\", reportOutput);\n       javaExecSpec.args(_previousSnapshotDirectory);\n       javaExecSpec.args(_currentSnapshotDirectory);\n+      if (_isExtensionSchema)\n+      {\n+        javaExecSpec.args(\"--extensionSchema\");\n+      }\n+      else if(hasSchemaAnnotationHandler())\n+      {\n+        javaExecSpec.args(\"--jarPath\", _handlerJarPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODE2OTA3", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501816907", "createdAt": "2020-10-05T08:14:48Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoxNDo0OFrOHcSGaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoxNDo0OFrOHcSGaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxODcyOA==", "bodyText": "These code is still a lot similar to SchemaAnnotationValidatorCmdLineApp, should DRY", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499418728", "createdAt": "2020-10-05T08:14:48Z", "author": {"login": "junchuanwang"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -345,4 +402,53 @@ private static void help()\n     }\n     return null;\n   }\n+\n+  private static List<SchemaAnnotationHandler> getAnnotationHandlers(String handlerJarPaths, String classNames)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODIyOTc3", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501822977", "createdAt": "2020-10-05T08:22:47Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMjo0N1rOHcSWug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMjo0N1rOHcSWug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMjkwNg==", "bodyText": "Can you also post example error message to this PR ? like your local test?\nOtherwise I was expecting to see it from some unit test.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499422906", "createdAt": "2020-10-05T08:22:47Z", "author": {"login": "junchuanwang"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityReport.java", "diffHunk": "@@ -55,11 +55,27 @@ public String createReport()\n         .map(it -> \"[MD-I]:\" + it)\n         .collect(Collectors.joining(\"\\n\"));\n \n+    String annotationCompat = \"\";\n+    String annotationIncompat = \"\";\n+    String annotationIsCompat = \"\";\n+    if(_infoMap.getAnnotationInfo(CompatibilityInfo.Level.INCOMPATIBLE).size() > 0 || _infoMap.getAnnotationInfo(CompatibilityInfo.Level.COMPATIBLE).size() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODIzNzAy", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501823702", "createdAt": "2020-10-05T08:23:43Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMzo0M1rOHcSY0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyMzo0M1rOHcSY0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyMzQ0MA==", "bodyText": "Just a thought: Unlike other message, Annotation incompatible  message doesn't have a message placeholder and description, which actually made it more difficult to be code-searched", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499423440", "createdAt": "2020-10-05T08:23:43Z", "author": {"login": "junchuanwang"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/idlcheck/CompatibilityInfo.java", "diffHunk": "@@ -65,7 +65,9 @@\n     PAGING_ADDED(Level.COMPATIBLE, \"Method added paging support\"),\n     PAGING_REMOVED(Level.INCOMPATIBLE, \"Method removed paging support\"),\n     SERVICE_ERROR_ADDED(Level.INCOMPATIBLE, \"Service error \\\"%s\\\" now applies\"),\n-    SERVICE_ERROR_REMOVED(Level.COMPATIBLE, \"Service error \\\"%s\\\" no longer applies\");\n+    SERVICE_ERROR_REMOVED(Level.COMPATIBLE, \"Service error \\\"%s\\\" no longer applies\"),\n+    BREAK_OLD_CLIENTS(Level.INCOMPATIBLE, \"Deleting an schema is incompatible change, it breaks old clients\"),\n+    ANNOTATION_INCOMPATIBLE_CHANGE(Level.INCOMPATIBLE, \"%s\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODI3OTg2", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-501827986", "createdAt": "2020-10-05T08:29:14Z", "commit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyOToxNFrOHcSlYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwODoyOToxNFrOHcSlYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjY1OQ==", "bodyText": "I didn't understand why there is any other error message for annotation other than ANNOTATION_INCOMPATIBLE_CHANGE ?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r499426659", "createdAt": "2020-10-05T08:29:14Z", "author": {"login": "junchuanwang"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java", "diffHunk": "@@ -296,4 +303,49 @@ public boolean addAll(CompatibilityInfoMap other)\n     }\n     return true;\n   }\n+\n+  public void addAnnotation(CompatibilityMessage message)\n+  {\n+    final CompatibilityInfo.Type infoType;\n+    CompatibilityInfo info;\n+    String infoMessage = String.format(message.getFormat(), message.getArgs());\n+\n+    if (message.isError())\n+    {\n+      switch (message.getImpact())\n+      {\n+        case BREAKS_NEW_READER:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_NEW_READER;\n+          break;\n+        case BREAKS_OLD_READER:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_OLD_READER;\n+          break;\n+        case BREAKS_NEW_AND_OLD_READERS:\n+          infoType = CompatibilityInfo.Type.TYPE_BREAKS_NEW_AND_OLD_READERS;\n+          break;\n+        case ANNOTATION_INCOMPATIBLE_CHANGE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/5be9a547810b7caa3627c8b8911bed07704b99ae", "committedDate": "2020-10-03T06:52:23Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "a61c0f7337e1db8f07bd46b3b863509270efbc70", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/a61c0f7337e1db8f07bd46b3b863509270efbc70", "committedDate": "2020-10-06T03:38:55Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a61c0f7337e1db8f07bd46b3b863509270efbc70", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/a61c0f7337e1db8f07bd46b3b863509270efbc70", "committedDate": "2020-10-06T03:38:55Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/ccc2767fc56e8017cf019b4c5484b907c451b73f", "committedDate": "2020-10-06T19:58:58Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjIzODEz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504223813", "createdAt": "2020-10-07T20:03:09Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDowMzoxMFrOHeDeJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDowMzoxMFrOHeDeJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NjE5Ng==", "bodyText": "Sorry for late review,\nA consideration for this function is to make it readable, and reusable.\nWould it be possible if we can use some string formatted json to represent the all the datamap or properties.\nAnd use something like DataMapUtil's function to read those json formated string to dataMap objects?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501276196", "createdAt": "2020-10-07T20:03:10Z", "author": {"login": "BrianPin"}, "path": "data/src/test/java/com/linkedin/data/schema/compatibility/TestAnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.PegasusSchemaAnnotationHandlerImpl;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestAnnotationCompatibilityChecker\n+{\n+  @Test(dataProvider = \"annotationCompatibilityCheckTestData\")\n+  public void testCheckCompatibility(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers, List<SchemaAnnotationHandler.AnnotationCompatibilityResult> expectedResults)\n+  {\n+    List<SchemaAnnotationHandler.AnnotationCompatibilityResult> results = AnnotationCompatibilityChecker\n+        .getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+    Assert.assertEquals(results.size(), expectedResults.size());\n+    for (int i = 0; i < results.size(); i++)\n+    {\n+      Assert.assertEquals(results.get(i).isCheckAnnotation(), expectedResults.get(i).isCheckAnnotation());\n+      Assert.assertEquals(results.get(i).getMessages().size(), expectedResults.get(i).getMessages().size());\n+      List<CompatibilityMessage> actualCompatibilityMessage = (List<CompatibilityMessage>) results.get(i).getMessages();\n+      List<CompatibilityMessage> expectCompatibilityMessage = (List<CompatibilityMessage>) expectedResults.get(i).getMessages();\n+      for (int j = 0; j < actualCompatibilityMessage.size(); j++)\n+      {\n+        Assert.assertEquals(actualCompatibilityMessage.get(j).toString(), expectCompatibilityMessage.get(j).toString());\n+      }\n+    }\n+  }\n+\n+  @DataProvider\n+  private Object[][] annotationCompatibilityCheckTestData()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjY1Mjkz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504265293", "createdAt": "2020-10-07T21:03:11Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowMzoxMVrOHeFcMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowMzoxMVrOHeFcMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwODQ2NQ==", "bodyText": "Maybe document on why?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501308465", "createdAt": "2020-10-07T21:03:11Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjY2ODcx", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504266871", "createdAt": "2020-10-07T21:05:35Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowNTozNVrOHeFg7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowNTozNVrOHeFg7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwOTY3OQ==", "bodyText": "style convention?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501309679", "createdAt": "2020-10-07T21:05:35Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());\n+\n+    Pair<AnnotationCheckContext, Map<String, Object>> annotationContextAndResolvedProperties =\n+        new ImmutablePair<>(annotationCheckContext, resolvedProperties);\n+\n+    _nodeToResolvedPropertiesMap.put(\n+          new PathSpec(context.getSchemaPathSpec()), annotationContextAndResolvedProperties);\n+  }\n+\n+  @Override\n+  public VisitorContext getInitialVisitorContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjY4MDgx", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504268081", "createdAt": "2020-10-07T21:07:33Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowNzozM1rOHeFkjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTowNzozM1rOHeFkjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxMDYwNg==", "bodyText": "Maybe we can move this statement that generates the annotationContextAndResolvedProperties object into the next line where it is the only place that it is being used?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501310606", "createdAt": "2020-10-07T21:07:33Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());\n+\n+    Pair<AnnotationCheckContext, Map<String, Object>> annotationContextAndResolvedProperties =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjc0MjYx", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504274261", "createdAt": "2020-10-07T21:17:25Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToxNzoyNVrOHeF3Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToxNzoyNVrOHeF3Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxNTM1NQ==", "bodyText": "This function name seems confusing, in the comment it is meant for annotation check not the schema itself", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501315355", "createdAt": "2020-10-07T21:17:25Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaCompatibility(DataSchema olderSchema, DataSchema newerSchema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjc3NzUx", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504277751", "createdAt": "2020-10-07T21:23:12Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToyMzoxMlrOHeGB-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToyMzoxMlrOHeGB-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxODEzNg==", "bodyText": "Maybe we can have a new interface that specifically deals compatibility check.\nMy reason being the action to check compatibility maybe not needed for every schema annotation handler, so we create a new interface the inherit schema annotation handler, to add some more specific functions to schema annotation handler.\nThat way, you don't worry about using default here, and leave original schemaAnnotationHandler some flexibility.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501318136", "createdAt": "2020-10-07T21:23:12Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/ccc2767fc56e8017cf019b4c5484b907c451b73f", "committedDate": "2020-10-06T19:58:58Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "committedDate": "2020-10-08T00:21:24Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/02f29fbb9df487038110acc27eefaf9c6cbbd2c4", "committedDate": "2020-10-08T00:21:24Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/16887f070340eb82ba9d3b3f4427b9f566b5f32d", "committedDate": "2020-10-08T00:26:31Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzYzMDQ4", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504363048", "createdAt": "2020-10-08T00:57:23Z", "commit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mzg0MDk0", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504384094", "createdAt": "2020-10-08T02:15:04Z", "commit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MTA4MjMz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504108233", "createdAt": "2020-10-07T17:26:51Z", "commit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNzoyNjo1MVrOHd99pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwODoyMjo0MlrOHeTRoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NTk1Nw==", "bodyText": "I prefer method names to start with a verb: doSomething..\nSo rename this to \"checkCompatibility\" ? \"annotation\" is implied by context.\nSpace between String, Object", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501185957", "createdAt": "2020-10-07T17:26:51Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NjIzMg==", "bodyText": "CompatibilityCheckContext?\nAnnotation is implied by context.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501186232", "createdAt": "2020-10-07T17:27:19Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NzAyOQ==", "bodyText": "Add javadoc on these methods.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501187029", "createdAt": "2020-10-07T17:28:39Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NzQwMg==", "bodyText": "remove extra line", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501187402", "createdAt": "2020-10-07T17:29:19Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()\n+    {\n+      return _checkAnnotation;\n+    }\n+\n+    public void setCheckAnnotation(boolean checkAnnotation)\n+    {\n+      _checkAnnotation = checkAnnotation;\n+    }\n+\n+    public AnnotationCompatibilityResult()\n+    {\n+      _messages = new MessageList<CompatibilityMessage>();\n+    }\n+\n+    @Override\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4ODM1Nw==", "bodyText": "It looks like the only way to add messages is by doing getMessages().add(..). It feels odd, why not add a method \"addMessage(...)\" to this class?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501188357", "createdAt": "2020-10-07T17:30:46Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)\n+    {\n+      _pathToSchema = pathToSchema.toArray(new String[0]);\n+    }\n+  }\n+\n+  /**\n+   * AnnotationCompatibilityResult\n+   * it contains a list of {@link CompatibilityMessage}\n+   * CompatibilityMessage describes the change is compatible or not\n+   */\n+  class AnnotationCompatibilityResult implements CompatibilityResult\n+  {\n+    private final MessageList<CompatibilityMessage> _messages;\n+\n+    private boolean _checkAnnotation = false;\n+\n+    public boolean isCheckAnnotation()\n+    {\n+      return _checkAnnotation;\n+    }\n+\n+    public void setCheckAnnotation(boolean checkAnnotation)\n+    {\n+      _checkAnnotation = checkAnnotation;\n+    }\n+\n+    public AnnotationCompatibilityResult()\n+    {\n+      _messages = new MessageList<CompatibilityMessage>();\n+    }\n+\n+    @Override\n+\n+    public Collection<CompatibilityMessage> getMessages() {\n+      return _messages;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccc2767fc56e8017cf019b4c5484b907c451b73f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MzcxMg==", "bodyText": "Document the syntax of this parameter.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501473712", "createdAt": "2020-10-08T06:21:33Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -87,7 +97,22 @@\n         .withLongOpt(\"report\")\n         .hasArg()\n         .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .isRequired()\n         .create(\"report\"));\n+    _options.addOption(OptionBuilder.withArgName(\"annotation_handler_jarPaths\")\n+        .withLongOpt(\"handlerJarPath\")\n+        .hasArgs()\n+        .withDescription(\"path of the jars which contains the annotation handlers\")\n+        .create(\"jar\"));\n+    _options.addOption(OptionBuilder.withArgName(\"handler-classNames\")\n+        .withLongOpt(\"handlerClassName\")\n+        .hasArgs()\n+        .withDescription(\"class names of the handlers\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDAzMw==", "bodyText": "document that this is a boolean flag.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474033", "createdAt": "2020-10-08T06:22:24Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -87,7 +97,22 @@\n         .withLongOpt(\"report\")\n         .hasArg()\n         .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .isRequired()\n         .create(\"report\"));\n+    _options.addOption(OptionBuilder.withArgName(\"annotation_handler_jarPaths\")\n+        .withLongOpt(\"handlerJarPath\")\n+        .hasArgs()\n+        .withDescription(\"path of the jars which contains the annotation handlers\")\n+        .create(\"jar\"));\n+    _options.addOption(OptionBuilder.withArgName(\"handler-classNames\")\n+        .withLongOpt(\"handlerClassName\")\n+        .hasArgs()\n+        .withDescription(\"class names of the handlers\")\n+        .create(\"className\"));\n+    _options.addOption(OptionBuilder.withArgName(\"extensionSchema\")\n+        .withLongOpt(\"extensionSchema\")\n+        .withDescription(\"Check pegasus extension schema annotation\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDE0Ng==", "bodyText": "also check if the value is true?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474146", "createdAt": "2020-10-08T06:22:38Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NDc4MA==", "bodyText": "Quit the checker if there is an error.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501474780", "createdAt": "2020-10-08T06:24:34Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))\n+    {\n+      _checkExtensionSchemaAnnotation = true;\n+    }\n+\n+    if (cl.hasOption(\"jar\") && cl.hasOption(\"className\"))\n+    {\n+     String handlerJarPaths = cl.getOptionValue(\"jar\");\n+     String classNames = cl.getOptionValue(\"className\");\n+     try\n+     {\n+       _handlers = ClassJarPathUtil.getAnnotationHandlers(handlerJarPaths, classNames);\n+     }\n+     catch (IllegalStateException e)\n+     {\n+       _logger.error(\"Error while doing schema compatibility check, could not get SchemaAnnotationHandler classes: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTA5OQ==", "bodyText": "I don't think you need this flag, just use !_handlers.isEmpty() when needed.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501475099", "createdAt": "2020-10-08T06:25:20Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -153,6 +178,27 @@ public static void main(String[] args) throws Exception\n       compatMode = CompatibilityOptions.Mode.SCHEMA;\n     }\n \n+    if(cl.hasOption('e'))\n+    {\n+      _checkExtensionSchemaAnnotation = true;\n+    }\n+\n+    if (cl.hasOption(\"jar\") && cl.hasOption(\"className\"))\n+    {\n+     String handlerJarPaths = cl.getOptionValue(\"jar\");\n+     String classNames = cl.getOptionValue(\"className\");\n+     try\n+     {\n+       _handlers = ClassJarPathUtil.getAnnotationHandlers(handlerJarPaths, classNames);\n+     }\n+     catch (IllegalStateException e)\n+     {\n+       _logger.error(\"Error while doing schema compatibility check, could not get SchemaAnnotationHandler classes: \" + e.getMessage());\n+     }\n+\n+      _checkPegasusSchemaAnnotation = _handlers.size() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3NTQ3Ng==", "bodyText": "Instead of doing this separately, just add the handler for extension annotation to the _handlers list.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501475476", "createdAt": "2020-10-08T06:26:18Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -230,6 +276,24 @@ public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSc\n       result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n     }\n \n+    if (_checkPegasusSchemaAnnotation)\n+    {\n+      List<SchemaAnnotationHandler.AnnotationCompatibilityResult> annotationCompatibilityResults =\n+          AnnotationCompatibilityChecker.checkPegasusSchemaAnnotation(preSchema, currSchema, _handlers);\n+      for (SchemaAnnotationHandler.AnnotationCompatibilityResult annotationResult: annotationCompatibilityResults)\n+      {\n+        if (!annotationResult.getMessages().isEmpty())\n+        {\n+          annotationResult.getMessages().forEach(message -> _infoMap.addAnnotation(message));\n+        }\n+      }\n+    }\n+\n+    if (_checkExtensionSchemaAnnotation)\n+    {\n+      //TODO: extension schema annotation check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3Njc4MA==", "bodyText": "Include the original exception e in the new exception.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501476780", "createdAt": "2020-10-08T06:29:45Z", "author": {"login": "karthikbalasub"}, "path": "restli-tools/src/main/java/com/linkedin/restli/internal/tools/ClassJarPathUtil.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.linkedin.restli.internal.tools;\n+\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This utility is used to get Java classes based on the provided class jar paths\n+ *\n+ * @author Yingjie\n+ */\n+public class ClassJarPathUtil\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ClassJarPathUtil.class);\n+  private static final String DEFAULT_PATH_SEPARATOR = File.pathSeparator;\n+\n+  /**\n+   * A helper method which is used to get the SchemaAnnotationHandler classes based on the given handlerJarPaths and class names\n+   * @param handlerJarPaths\n+   * @param classNames\n+   * @return a list of SchemaAnnotationHandler classes. List<SchemaAnnotationHandler>\n+   * @throws IllegalStateException if it could not instantiate the given class.\n+   */\n+  public static List<SchemaAnnotationHandler> getAnnotationHandlers(String handlerJarPaths, String classNames) throws IllegalStateException\n+  {\n+    List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n+    ClassLoader classLoader = new URLClassLoader(parsePaths(handlerJarPaths)\n+        .stream()\n+        .map(str ->\n+        {\n+          try\n+          {\n+            return Paths.get(str).toUri().toURL();\n+          }\n+          catch (Exception e)\n+          {\n+            _logger.error(\"Parsing class jar path URL {} parsing failed\", str, e);\n+          }\n+          return null;\n+        }).filter(Objects::nonNull).toArray(URL[]::new));\n+\n+    for (String className: parsePaths(classNames))\n+    {\n+      try\n+      {\n+        Class<?> handlerClass = Class.forName(className, false, classLoader);\n+        SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n+        handlers.add(handler);\n+      }\n+      catch (Exception e)\n+      {\n+        throw new IllegalStateException(\"Error instantiating class: \" + className + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMDM4Mg==", "bodyText": "The first line is redundant. Document that this is a utility class to help with annotation compatibility checking.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501500382", "createdAt": "2020-10-08T07:22:06Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMTc4MA==", "bodyText": "link to the method in annotation handler.\nI think there is some repetition in this doc. Can you simplify it?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501501780", "createdAt": "2020-10-08T07:24:35Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMjIxOA==", "bodyText": "compatibilities -> compatibility", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501502218", "createdAt": "2020-10-08T07:25:26Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMjM1OQ==", "bodyText": "process -> Process\nolderSchema -> prevSchema\nnewerSchema -> currentSchema\n(to keep the naming consistent everywhere)", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501502359", "createdAt": "2020-10-08T07:25:41Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwMzUxNA==", "bodyText": "remove if you are not adding any documentation.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501503514", "createdAt": "2020-10-08T07:27:56Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNDQyMQ==", "bodyText": "just use e.getValue() to avoid a map lookup.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501504421", "createdAt": "2020-10-08T07:29:35Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjAzNw==", "bodyText": "This logic feels odd. Did you consider adding a method on the handler directly?\neg, boolean implementsCompatibilityChecking()", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501522037", "createdAt": "2020-10-08T08:00:42Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjcxMA==", "bodyText": "or the field was deleted.\nThe logic here would be simple if you returned the empty resolveProperties instead if removing it (in AnnotationCheckResolvedPropertiesVisitor)\nSo the only case to handle is deleted field. At this point, does it make sense to do annotation compatibility checking? Would the schema compatibility checking be enough?", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501522710", "createdAt": "2020-10-08T08:01:56Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNDAyNg==", "bodyText": "this duplication can be avoided if we added a method on the handler to check.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501524026", "createdAt": "2020-10-08T08:04:17Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNTQyNQ==", "bodyText": "either because newer schema aded new annotations or added new field with annotations", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501525425", "createdAt": "2020-10-08T08:06:27Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+        }\n+      }\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : newerResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+            newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(e.getKey());\n+        Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+        if (newerResolvedProperties.containsKey(annotationNamespace))\n+        {\n+          // newerResolvedPropertiesMap has a PathSpec which the olderResolvedPropertiesMap does not have,\n+          // it could be either newer schema add new annotations or adding new field with annotations, pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyODkwMg==", "bodyText": "How would the compatibility checker differentiate between a new field(compatible) vs adding new annotations(may not be compatible)?\nI think we should invoke the checker only for new annotations. And for new fields skip annotation checking?\nOr, send empty context/map for the case where new annotations were added. and use null when a new field was added.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501528902", "createdAt": "2020-10-08T08:12:13Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  Schema Annotation compatibility checker\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the annotationCompatibilityCheck method which provide in the SchemaAnnotationHandler\n+ *  by user to do the annotation compatibility check.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibilities\n+   * process olderSchema and newerSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param olderSchema\n+   * @param newerSchema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema olderSchema, DataSchema newerSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult olderSchemaResult = processSchemaAnnotation(olderSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult newerSchemaResult = processSchemaAnnotation(newerSchema, handlers);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> olderResolvedPropertiesMap\n+        = getNodeToResolvedProperties(olderSchemaResult);\n+    Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> newerResolvedPropertiesMap\n+        = getNodeToResolvedProperties(newerSchemaResult);\n+\n+    return getCompatibilityResult(olderResolvedPropertiesMap, newerResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   * @param olderResolvedPropertiesMap\n+   * @param newerResolvedPropertiesMap\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> olderResolvedPropertiesMap, Map<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext,\n+      Map<String, Object>>> newerResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : olderResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>> olderCheckContextAndResolvedProperty =\n+            olderResolvedPropertiesMap.get(pathSpec);\n+        Map<String, Object> olderResolvedProperties = olderCheckContextAndResolvedProperty.getValue();\n+\n+        if (newerResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If older schema node and newer schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to further check.\n+          Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+              newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+\n+          // If olderResolvedProperties or newerResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check\n+          if (olderResolvedProperties.containsKey(annotationNamespace) || newerResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, newerResolvedProperties,\n+                    olderCheckContextAndResolvedProperty.getKey(), newerCheckContextAndResolvedProperty.getKey());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+          newerResolvedPropertiesMap.remove(pathSpec);\n+        }\n+        else\n+        {\n+          if (olderResolvedProperties.containsKey(annotationNamespace))\n+          {\n+            // olderResolvedPropertiesMap has a PathSpec which the newResolvedPropertiesMap does not have,\n+            // it could be either newer schema removed annotation or the field is not existed, pass\n+            // an empty newerResolvedPropertiesMap and empty newerAnnotationContext to the annotation check.\n+            AnnotationCompatibilityResult result =\n+                handler.annotationCompatibilityCheck(olderResolvedProperties, new HashMap<>(),\n+                    olderCheckContextAndResolvedProperty.getKey(), new SchemaAnnotationHandler.AnnotationCheckContext());\n+            if (!result.isCheckAnnotation())\n+            {\n+              _log.info(\"There is no implementation of annotationCompatibilityCheck in SchemaAnnotationHandler: \"\n+                  + handler.getClass().getName());\n+              break;\n+            }\n+            results.add(result);\n+          }\n+        }\n+      }\n+      for (Map.Entry<PathSpec, Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>> e : newerResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        Pair<SchemaAnnotationHandler.AnnotationCheckContext, Map<String, Object>>\n+            newerCheckContextAndResolvedProperty = newerResolvedPropertiesMap.get(e.getKey());\n+        Map<String, Object> newerResolvedProperties = newerCheckContextAndResolvedProperty.getValue();\n+        if (newerResolvedProperties.containsKey(annotationNamespace))\n+        {\n+          // newerResolvedPropertiesMap has a PathSpec which the olderResolvedPropertiesMap does not have,\n+          // it could be either newer schema add new annotations or adding new field with annotations, pass\n+          // an empty olderResolvedPropertiesMap and empty olderAnnotationContext to the annotation check.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyOTc1OQ==", "bodyText": "Leave the empty resolvedProperties for fields without any annotation. It would simplify the compatibility checking logic.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501529759", "createdAt": "2020-10-08T08:13:41Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    // Skip execute when order is POST_ORDER to avoid traverse same node twice.\n+    // Only execute this callback when order is PRE_ORDER.\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties == null || resolvedProperties.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUzMzk0OA==", "bodyText": "I think a better solution would be to update CompatibiliyMessage to accept PathSpec and convert to array if needed.\nThen you can re-use the PathSpec in the map key below and avoid creating a new array for every node.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501533948", "createdAt": "2020-10-08T08:20:46Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCheckContext;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<AnnotationCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+    Map<String, Object> resolvedProperties = currentSchema.getResolvedProperties();\n+    if (resolvedProperties.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    RecordDataSchema.Field schemaField = context.getEnclosingField();\n+    UnionDataSchema.Member unionDataMember = context.getEnclosingUnionMember();\n+\n+    AnnotationCheckContext annotationCheckContext = new AnnotationCheckContext();\n+\n+    annotationCheckContext.setDataSchema(currentSchema);\n+    annotationCheckContext.setSchemaField(schemaField);\n+    annotationCheckContext.setUnionMember(unionDataMember);\n+    annotationCheckContext.setPathToSchema(context.getSchemaPathSpec());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQwMDI1NA=="}, "originalCommit": {"oid": "5be9a547810b7caa3627c8b8911bed07704b99ae"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUzNTEzNg==", "bodyText": "add extra newline between methods.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r501535136", "createdAt": "2020-10-08T08:22:42Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,105 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param olderResolvedProperties the older resolvedProperties\n+   * @param newerResolvedProperties the newer resolvedProperties\n+   * @param olderContext the older annotationCheck context\n+   * @param newerContext the newer annotationCheck context\n+   * @return AnnotationCompatibilityResult\n+   */\n+  default AnnotationCompatibilityResult annotationCompatibilityCheck(Map<String,Object> olderResolvedProperties, Map<String, Object> newerResolvedProperties,\n+      AnnotationCheckContext olderContext, AnnotationCheckContext newerContext)\n+  {\n+    return new AnnotationCompatibilityResult();\n+  }\n+\n+  /**\n+   * AnnotationCheckContext which contains metadata information:\n+   * dataSchema, schemaField, unionMember and pathToSchema.\n+   */\n+  class AnnotationCheckContext\n+  {\n+    DataSchema _dataSchema;\n+    RecordDataSchema.Field _schemaField;\n+    UnionDataSchema.Member _unionMember;\n+    String[] _pathToSchema;\n+\n+    public DataSchema getDataSchema()\n+    {\n+      return _dataSchema;\n+    }\n+    public void setDataSchema(DataSchema recordDataSchema)\n+    {\n+      _dataSchema = recordDataSchema;\n+    }\n+\n+    public RecordDataSchema.Field getSchemaField()\n+    {\n+      return _schemaField;\n+    }\n+    public void setSchemaField(RecordDataSchema.Field schemaField)\n+    {\n+      _schemaField = schemaField;\n+    }\n+\n+    public UnionDataSchema.Member getUnionMember()\n+    {\n+     return _unionMember;\n+    }\n+    public void setUnionMember(UnionDataSchema.Member unionMember)\n+    {\n+      _unionMember = unionMember;\n+    }\n+    public String[] getPathToSchema()\n+    {\n+      return _pathToSchema;\n+    }\n+    public void setPathToSchema(ArrayDeque<String> pathToSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NjA5NzM0", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-504609734", "createdAt": "2020-10-08T09:47:02Z", "commit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16887f070340eb82ba9d3b3f4427b9f566b5f32d", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/16887f070340eb82ba9d3b3f4427b9f566b5f32d", "committedDate": "2020-10-08T00:26:31Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "committedDate": "2020-10-09T16:38:21Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/0ca641fdf7b43beaaeed6bb6cb4790d6c6246db1", "committedDate": "2020-10-09T16:38:21Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "41566fdd40c9fda177ad21b58026a54fc1780776", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/41566fdd40c9fda177ad21b58026a54fc1780776", "committedDate": "2020-10-09T16:41:09Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41566fdd40c9fda177ad21b58026a54fc1780776", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/41566fdd40c9fda177ad21b58026a54fc1780776", "committedDate": "2020-10-09T16:41:09Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/ddc665f8ee2ea507409b1974e02c21beaea70e66", "committedDate": "2020-10-09T16:42:34Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDg3NDA4", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-506087408", "createdAt": "2020-10-10T10:36:59Z", "commit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQxMDozNjo1OVrOHffAXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQxMDo1OTo1NVrOHffIww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTkwMw==", "bodyText": "You could refactor this logic to a utility method:\nchooseProperties(preferredProperties, fallbackProperties)", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502775903", "createdAt": "2020-10-10T10:36:59Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/AnnotationCheckResolvedPropertiesVisitor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import java.util.ArrayDeque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+/**\n+ * This visitor is used to get node in schema to it's resolvedProperties.\n+ * The nodesToResolvedPropertiesMap will be used for schema annotation compatibility check\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCheckResolvedPropertiesVisitor implements SchemaVisitor\n+{\n+  private Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> _nodeToResolvedPropertiesMap = new HashMap<>();\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n+  {\n+    // Skip execute when order is POST_ORDER to avoid traverse the same node twice.\n+    // Only execute this callback when order is PRE_ORDER.\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    DataSchema currentSchema = context.getCurrentSchema();\n+\n+    ArrayDeque<String> pathToSchema = context.getSchemaPathSpec().clone();\n+    pathToSchema.addFirst(((NamedDataSchema)context.getTopLevelSchema()).getName());\n+    PathSpec pathSpec = new PathSpec(pathToSchema);\n+\n+    CompatibilityCheckContext compatibilityCheckContext = new CompatibilityCheckContext();\n+\n+    compatibilityCheckContext.setCurrentDataSchema(currentSchema);\n+    compatibilityCheckContext.setSchemaField(context.getEnclosingField());\n+    compatibilityCheckContext.setUnionMember(context.getEnclosingUnionMember());\n+    compatibilityCheckContext.setPathSpecToSchema(pathSpec);\n+\n+    // If there is no resolvedProperties but properties, used the properties for annotation check.\n+    Map<String, Object> properties;\n+    if (context.getEnclosingField() != null)\n+    {\n+      RecordDataSchema.Field field = context.getEnclosingField();\n+      if (field.getResolvedProperties().isEmpty())\n+      {\n+        properties = field.getProperties();\n+      }\n+      else\n+      {\n+        properties = field.getResolvedProperties();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTk4MA==", "bodyText": "Reword the doc to not be specific about compatibility check.\nThis is a visitor to use when override is not needed. compatibility is one such usecase.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502775980", "createdAt": "2020-10-10T10:38:14Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/IdentitySchemaVisitor.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+\n+\n+/**\n+ * This SchemaVisitor is used to not traverse the data schema.\n+ * Users may want to use Schema Annotation Processor framework to do annotation compatibility check,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjA2MA==", "bodyText": "Add a comment why this is needed", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776060", "createdAt": "2020-10-10T10:38:53Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/IdentitySchemaVisitor.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.annotation;\n+\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+\n+\n+/**\n+ * This SchemaVisitor is used to not traverse the data schema.\n+ * Users may want to use Schema Annotation Processor framework to do annotation compatibility check,\n+ * but they do need to override the annotations, they can use this visitor in the handler to skip annotation overriding.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class IdentitySchemaVisitor implements SchemaVisitor\n+{\n+\n+  @Override\n+  public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order) {\n+    // skip post order traverse\n+    if (order == DataSchemaTraverse.Order.POST_ORDER)\n+    {\n+      return;\n+    }\n+\n+    if (context.getParentSchema() == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjE5NQ==", "bodyText": "nit: implementsCheckCompatibility", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776195", "createdAt": "2020-10-10T10:40:16Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementCheckCompatibility()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjI1Nw==", "bodyText": "implement -> implements.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776257", "createdAt": "2020-10-10T10:40:49Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjMxOQ==", "bodyText": "Users -> Subclasses\ncould -> should", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776319", "createdAt": "2020-10-10T10:41:28Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjcwOQ==", "bodyText": "This is odd, you shouldn't use static variables to store state. See my comment below", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776709", "createdAt": "2020-10-10T10:45:12Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationProcessor.java", "diffHunk": "@@ -51,6 +51,9 @@\n {\n   private static final Logger LOG = LoggerFactory.getLogger(SchemaAnnotationProcessor.class);\n \n+\n+  private static boolean _skipValidateProcessResult = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NjkyMQ==", "bodyText": "Don't do this. Instead have the actual implementation in this method, based on the input arg. The other method should call this with \"false\" for skipValidateProcessResult.\nnit: I personally prefer not to use negative for boolean params. So suggest using validateProcessResult as the arg and switch the condiation.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502776921", "createdAt": "2020-10-10T10:47:12Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationProcessor.java", "diffHunk": "@@ -125,36 +128,71 @@ public static SchemaAnnotationProcessResult process(List<SchemaAnnotationHandler\n       return processResult;\n     }\n \n-    // validate\n-    boolean hasValidationError = false;\n-    for (SchemaAnnotationHandler schemaAnnotationHandler: handlers)\n+    if (!_skipValidateProcessResult)\n     {\n-      LOG.debug(\"DEBUG:  starting validating using \\\"{}\\\" handler\", schemaAnnotationHandler.getAnnotationNamespace());\n-      SchemaAnnotationValidationVisitor validationVisitor = new SchemaAnnotationValidationVisitor(schemaAnnotationHandler);\n-      DataSchemaRichContextTraverser traverserBase = new DataSchemaRichContextTraverser(validationVisitor);\n-      try {\n-        traverserBase.traverse(processResult.getResultSchema());\n-      }\n-      catch (Exception e)\n+      // validate\n+      boolean hasValidationError = false;\n+      for (SchemaAnnotationHandler schemaAnnotationHandler: handlers)\n       {\n-        throw new IllegalStateException(String.format(\"Annotation validation failed in \\\"%s\\\" handler.\",\n-                                                      schemaAnnotationHandler.getAnnotationNamespace()), e);\n-      }\n-      SchemaVisitorTraversalResult handlerTraverseResult = validationVisitor.getSchemaVisitorTraversalResult();\n-      if (!handlerTraverseResult.isTraversalSuccessful())\n-      {\n-        hasValidationError = true;\n-        String errorMsgs = handlerTraverseResult.formatToErrorMessage();\n-        errorMsgBuilder.append(String.format(\"Annotation validation process failed in \\\"%s\\\" handler. \\n\",\n-                                             schemaAnnotationHandler.getAnnotationNamespace()));\n-        errorMsgBuilder.append(errorMsgs);\n+        LOG.debug(\"DEBUG:  starting validating using \\\"{}\\\" handler\", schemaAnnotationHandler.getAnnotationNamespace());\n+        SchemaAnnotationValidationVisitor validationVisitor = new SchemaAnnotationValidationVisitor(schemaAnnotationHandler);\n+        DataSchemaRichContextTraverser traverserBase = new DataSchemaRichContextTraverser(validationVisitor);\n+        try {\n+          traverserBase.traverse(processResult.getResultSchema());\n+        }\n+        catch (Exception e)\n+        {\n+          throw new IllegalStateException(String.format(\"Annotation validation failed in \\\"%s\\\" handler.\",\n+              schemaAnnotationHandler.getAnnotationNamespace()), e);\n+        }\n+        SchemaVisitorTraversalResult handlerTraverseResult = validationVisitor.getSchemaVisitorTraversalResult();\n+        if (!handlerTraverseResult.isTraversalSuccessful())\n+        {\n+          hasValidationError = true;\n+          String errorMsgs = handlerTraverseResult.formatToErrorMessage();\n+          errorMsgBuilder.append(String.format(\"Annotation validation process failed in \\\"%s\\\" handler. \\n\",\n+              schemaAnnotationHandler.getAnnotationNamespace()));\n+          errorMsgBuilder.append(errorMsgs);\n+        }\n       }\n+      processResult.setValidationSuccess(!hasValidationError);\n+      processResult.setErrorMsgs(errorMsgBuilder.toString());\n+    }\n+    else\n+    {\n+      processResult.setValidationSuccess(true);\n     }\n-    processResult.setValidationSuccess(!hasValidationError);\n-    processResult.setErrorMsgs(errorMsgBuilder.toString());\n+\n     return processResult;\n   }\n \n+  /**\n+   * This function creates  {@link DataSchemaRichContextTraverser} and use it to wrap {@link SchemaVisitor} to visit the {@link DataSchema}\n+   *\n+   * Note {@link SchemaAnnotationHandler}'s #resolve() and #validate() function are supposed to be called by {@link SchemaVisitor}\n+   *\n+   * For the given {@link DataSchema}, it will first invoke each {@link SchemaAnnotationHandler#resolve}\n+   * by using the {@link SchemaVisitor} returned by {@link SchemaAnnotationHandler#getVisitor()}\n+   *\n+   * then it uses {@link SchemaAnnotationValidationVisitor} to invoke each {@link SchemaAnnotationHandler#validate} to validate resolved schema annotation.\n+   * users would skip this validation, by passing skipValidateProcessResult as true;\n+   *\n+   * It will abort in case of unexpected exceptions.\n+   * Otherwise will aggregate error messages after all handlers' processing, to the final {@link SchemaAnnotationProcessResult}\n+   *\n+   * @param handlers the handlers that can resolve the annotation on the dataSchema and validate them\n+   * @param dataSchema the dataSchema to be processed\n+   * @param options additional options to help schema annotation processing\n+   * @param skipValidateProcessResult If it is true, skip validate {@link SchemaAnnotationValidationVisitor} .\n+   * @return result after process\n+   */\n+  public static SchemaAnnotationProcessResult process(List<SchemaAnnotationHandler> handlers,\n+      DataSchema dataSchema, AnnotationProcessOption options, boolean skipValidateProcessResult)\n+  {\n+    _skipValidateProcessResult = skipValidateProcessResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzIxMQ==", "bodyText": "I just realized this wouldn't work if there are multiple handlers. When the first handler is processed, it would remove all pathSpecs from the resolved properties map.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502777211", "createdAt": "2020-10-10T10:50:23Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the {@link SchemaAnnotationHandler#checkCompatibility} method.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibility\n+   * Process prevSchema and currSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param prevSchema previous data schema\n+   * @param currSchema current data schema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema prevSchema, DataSchema currSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult prevSchemaResult = processSchemaAnnotation(prevSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult currSchemaResult = processSchemaAnnotation(currSchema, handlers);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> prevResolvedPropertiesMap\n+        = getNodeToResolvedProperties(prevSchemaResult);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> currResolvedPropertiesMap\n+        = getNodeToResolvedProperties(currSchemaResult);\n+\n+    return getCompatibilityResult(prevResolvedPropertiesMap, currResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   */\n+  static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> prevResolvedPropertiesMap, Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> currResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      if(!handler.implementCheckCompatibility())\n+      {\n+        _log.info(\"There is no implementation of checkCompatibility method in SchemaAnnotationHandler: \"\n+            + handler.getClass().getName());\n+        continue;\n+      }\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      for (Map.Entry<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> e : prevResolvedPropertiesMap\n+          .entrySet())\n+      {\n+        PathSpec pathSpec = e.getKey();\n+        Pair<CompatibilityCheckContext, Map<String, Object>> prevCheckContextAndResolvedProperty = e.getValue();\n+        Map<String, Object> prevResolvedProperties = prevCheckContextAndResolvedProperty.getValue();\n+\n+        if (currResolvedPropertiesMap.containsKey(pathSpec))\n+        {\n+          // If previous schema node and current schema node have the same pathSpec,\n+          // they may or may not contain the same annotation namespace as SchemaAnnotationHandler, we need to check further.\n+          Pair<CompatibilityCheckContext, Map<String, Object>>\n+              currCheckContextAndResolvedProperty = currResolvedPropertiesMap.get(pathSpec);\n+          Map<String, Object> currResolvedProperties = currCheckContextAndResolvedProperty.getValue();\n+\n+          // If prevResolvedProperties or currResolvedProperties contains the same namespace as the provided SchemaAnnotationHandler,\n+          // we do the annotation check.\n+          if (prevResolvedProperties.containsKey(annotationNamespace) || currResolvedProperties.containsKey(\n+              annotationNamespace))\n+          {\n+            AnnotationCompatibilityResult result =\n+                handler.checkCompatibility(prevResolvedProperties, currResolvedProperties,\n+                    prevCheckContextAndResolvedProperty.getKey(), currCheckContextAndResolvedProperty.getKey());\n+            results.add(result);\n+          }\n+          currResolvedPropertiesMap.remove(pathSpec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NzkwMg==", "bodyText": "Add a test with multiple handlers", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502777902", "createdAt": "2020-10-10T10:57:50Z", "author": {"login": "karthikbalasub"}, "path": "data/src/test/java/com/linkedin/data/schema/compatibility/TestAnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.TestUtil;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.IdentitySchemaVisitor;\n+import com.linkedin.data.schema.annotation.PegasusSchemaAnnotationHandlerImpl;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaVisitor;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestAnnotationCompatibilityChecker\n+{\n+  private final static String ANNOTATION_NAMESPACE = \"bar\";\n+  private final static String ANNOTATION_FIELD_NAME = \"foo\";\n+\n+  @Test(dataProvider = \"annotationCompatibilityCheckTestData\")\n+  public void testCheckCompatibility(String prevSchemaFile, String currSchemaFile, List<SchemaAnnotationHandler> handlers, List<AnnotationCompatibilityResult> expectedResults)\n+      throws IOException\n+  {\n+    DataSchema prevSchema = TestUtil.dataSchemaFromPdlInputStream(getClass().getResourceAsStream(prevSchemaFile));\n+    DataSchema currSchema = TestUtil.dataSchemaFromPdlInputStream(getClass().getResourceAsStream(currSchemaFile));\n+    List<AnnotationCompatibilityResult> results = AnnotationCompatibilityChecker\n+        .checkPegasusSchemaAnnotation(prevSchema, currSchema, handlers);\n+    Assert.assertEquals(results.size(), expectedResults.size());\n+    for (int i = 0; i < results.size(); i++)\n+    {\n+      Assert.assertEquals(results.get(i).getMessages().size(), expectedResults.get(i).getMessages().size());\n+      List<CompatibilityMessage> actualCompatibilityMessage = (List<CompatibilityMessage>) results.get(i).getMessages();\n+      List<CompatibilityMessage> expectCompatibilityMessage = (List<CompatibilityMessage>) expectedResults.get(i).getMessages();\n+      for (int j = 0; j < actualCompatibilityMessage.size(); j++)\n+      {\n+        Assert.assertEquals(actualCompatibilityMessage.get(j).toString(), expectCompatibilityMessage.get(j).toString());\n+      }\n+    }\n+  }\n+\n+  @DataProvider\n+  private Object[][] annotationCompatibilityCheckTestData() throws IOException {\n+    // Set up expected result: both previous schema and current schema contain the same PathSpecs.\n+    CompatibilityCheckContext checkContext = generateAnnotationCheckContext(new PathSpec(\"TestSchema1/field1\"));\n+    CompatibilityCheckContext checkContext1 = generateAnnotationCheckContext(new PathSpec(\"TestSchema1/field2\"));\n+\n+    AnnotationCompatibilityResult expectResultWithCompatibleChange1 = generateExpectResult(new CompatibilityMessage(checkContext.getPathSpecToSchema(),\n+      CompatibilityMessage.Impact.ANNOTATION_COMPATIBLE_CHANGE,\n+        \"Updating annotation field \\\"%s\\\" value is backward compatible change\", ANNOTATION_FIELD_NAME));\n+    AnnotationCompatibilityResult expectResultWithInCompatibleChange1 = generateExpectResult(new CompatibilityMessage(checkContext1.getPathSpecToSchema(),\n+        CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+        \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+\n+    // Set up expected result: only previous schema contains the resolvedProperty with the same annotation namespace as SchemaAnnotationHandler\n+    CompatibilityCheckContext checkContext2 = generateAnnotationCheckContext(new PathSpec(\"TestSchema2/field1\"));\n+\n+    AnnotationCompatibilityResult expectResult2 = generateExpectResult(new CompatibilityMessage(checkContext2.getPathSpecToSchema(),\n+      CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE,\n+        \"Adding new annotation \\\"%s\\\" is backward compatible change\", ANNOTATION_NAMESPACE));\n+\n+    // Set up expected result: only current schema contains the resolvedProperty with the same annotation namespace as SchemaAnnotationHandler\n+    CompatibilityCheckContext checkContext3 = generateAnnotationCheckContext(new PathSpec(\"TestSchema3/field1\"));\n+    AnnotationCompatibilityResult expectResult3 = generateExpectResult(new CompatibilityMessage(checkContext3.getPathSpecToSchema(),\n+        CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+\n+    return new Object[][]\n+        {\n+            {\n+                \"previousSchema/TestSchema1.pdl\",\n+                \"currentSchema/TestSchema1.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Arrays.asList(expectResultWithCompatibleChange1, expectResultWithInCompatibleChange1)\n+            },\n+            {\n+                \"previousSchema/TestSchema2.pdl\",\n+                \"currentSchema/TestSchema2.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Collections.singletonList(expectResult2)\n+            },\n+            {\n+                \"previousSchema/TestSchema3.pdl\",\n+                \"currentSchema/TestSchema3.pdl\",\n+                generateSchemaAnnotationHandlers(),\n+                Collections.singletonList(expectResult3)\n+            }\n+        };\n+  }\n+\n+  private List<SchemaAnnotationHandler> generateSchemaAnnotationHandlers()\n+  {\n+    SchemaAnnotationHandler testHandler = new PegasusSchemaAnnotationHandlerImpl(ANNOTATION_NAMESPACE)\n+    {\n+      @Override\n+      public String getAnnotationNamespace()\n+      {\n+        return ANNOTATION_NAMESPACE;\n+      }\n+\n+      @Override\n+      public boolean implementCheckCompatibility()\n+      {\n+        return true;\n+      }\n+\n+      @Override\n+      public SchemaVisitor getVisitor()\n+      {\n+        return new IdentitySchemaVisitor();\n+      }\n+\n+      @Override\n+      public AnnotationCompatibilityResult checkCompatibility(Map<String,Object> prevResolvedProperties, Map<String, Object> currResolvedProperties,\n+          CompatibilityCheckContext prevContext, CompatibilityCheckContext currContext)\n+      {\n+        AnnotationCompatibilityResult result = new AnnotationCompatibilityResult();\n+\n+        if (prevResolvedProperties.get(ANNOTATION_NAMESPACE) == null)\n+        {\n+          if (prevContext.getPathSpecToSchema() != null)\n+          {\n+            result.getMessages().add(new CompatibilityMessage(currContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Adding new annotation \\\"%s\\\" is backward compatible change\", ANNOTATION_NAMESPACE));\n+          }\n+        }\n+        else if (currResolvedProperties.get(ANNOTATION_NAMESPACE) == null)\n+        {\n+          if (currContext.getPathSpecToSchema() != null)\n+          {\n+            result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"Deleting existed annotation \\\"%s\\\" is backward incompatible change\", ANNOTATION_NAMESPACE));\n+          }\n+        }\n+        else\n+        {\n+          DataMap prev = (DataMap) prevResolvedProperties.get(ANNOTATION_NAMESPACE);\n+          DataMap curr = (DataMap) currResolvedProperties.get(ANNOTATION_NAMESPACE);\n+          if (prev.containsKey(ANNOTATION_FIELD_NAME) && !curr.containsKey(ANNOTATION_FIELD_NAME))\n+          {\n+            result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                CompatibilityMessage.Impact.ANNOTATION_INCOMPATIBLE_CHANGE, \"remove annotation field \\\"%s\\\" is backward incompatible change\", ANNOTATION_FIELD_NAME));\n+          }\n+          if (prev.containsKey(ANNOTATION_FIELD_NAME) && curr.containsKey(ANNOTATION_FIELD_NAME))\n+          {\n+            if (prev.get(ANNOTATION_FIELD_NAME) != curr.get(ANNOTATION_FIELD_NAME))\n+            {\n+              result.getMessages().add(new CompatibilityMessage(prevContext.getPathSpecToSchema(),\n+                  CompatibilityMessage.Impact.ANNOTATION_COMPATIBLE_CHANGE, \"Updating annotation field \\\"%s\\\" value is backward compatible change\", ANNOTATION_FIELD_NAME));\n+            }\n+          }\n+        }\n+        return result;\n+      }\n+    };\n+    return Collections.singletonList(testHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3ODA1MQ==", "bodyText": "Document the values to expect for different scenarios:\nField present, annotation deleted.\nField deleted\nField present, annotations added\nField added.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r502778051", "createdAt": "2020-10-10T10:59:55Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,113 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implement the checkCompatibility method.\n+   * @return false by default. Users could override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementCheckCompatibility()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Check annotations changes are compatible or not\n+   *\n+   * @param prevResolvedProperties the older resolvedProperties\n+   * @param currResolvedProperties the newer resolvedProperties\n+   * @param prevContext the older annotationCheck context\n+   * @param currContext the newer annotationCheck context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddc665f8ee2ea507409b1974e02c21beaea70e66", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/ddc665f8ee2ea507409b1974e02c21beaea70e66", "committedDate": "2020-10-09T16:42:34Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "committedDate": "2020-10-12T00:31:34Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MzE0ODcz", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-506314873", "createdAt": "2020-10-12T06:08:55Z", "commit": {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwNjowODo1NlrOHfwMHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwNzozMzoxNlrOHfyVlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA1NzQzNg==", "bodyText": "Also add a note to override implementsCheckCompatibility to return true.", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503057436", "createdAt": "2020-10-12T06:08:56Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -144,6 +149,121 @@ default SchemaVisitor getVisitor()\n     return new PathSpecBasedSchemaAnnotationVisitor(this);\n   }\n \n+  /**\n+   * This method is used to indicate whether the schema annotation handler implements the checkCompatibility method.\n+   * @return false by default. Subclasses should override this method to return true, if they implement the checkCompatibility method.\n+   */\n+  default boolean implementsCheckCompatibility()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Check annotations changes are compatible or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5MjYyOA==", "bodyText": "This might be a problem for large schemas. Did you consider reversing the loops?\nremove handlers that don't implement compatibility\n\nforeach entry in prevResolvedProperties:\n  foreach hander:\n     check(entry)\n     remove path from currProperties\nforeach entry in currProperties\n   foreach handler:\n      check(entry)", "url": "https://github.com/linkedin/rest.li/pull/435#discussion_r503092628", "createdAt": "2020-10-12T07:33:16Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/compatibility/AnnotationCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.data.schema.compatibility;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.annotation.DataSchemaRichContextTraverser;\n+import com.linkedin.data.schema.annotation.AnnotationCheckResolvedPropertiesVisitor;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.CompatibilityCheckContext;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler.AnnotationCompatibilityResult;\n+import com.linkedin.data.schema.annotation.SchemaAnnotationProcessor;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ *  The annotation compatibility check is part of the annotation processing framework.\n+ *  If users use annotation processor to resolve properties,\n+ *  they may also provide a annotation compatibility method to define the way to check annotation's compatibility.\n+ *  In this checker, it will call the {@link SchemaAnnotationHandler#checkCompatibility} method.\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class AnnotationCompatibilityChecker\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(AnnotationCompatibilityChecker.class);\n+\n+  /**\n+   * Check the pegasus schema annotation compatibility\n+   * Process prevSchema and currSchema in the SchemaAnnotationProcessor to get the resolved result with resolvedProperties.\n+   * then using the resolvedProperties to do the annotation compatibility check.\n+   * @param prevSchema previous data schema\n+   * @param currSchema current data schema\n+   * @param handlers SchemaAnnotationHandler list\n+   * @return List<AnnotationCompatibilityResult>\n+   */\n+  public static List<AnnotationCompatibilityResult> checkPegasusSchemaAnnotation(DataSchema prevSchema, DataSchema currSchema,\n+      List<SchemaAnnotationHandler> handlers)\n+  {\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult prevSchemaResult = processSchemaAnnotation(prevSchema, handlers);\n+    SchemaAnnotationProcessor.SchemaAnnotationProcessResult currSchemaResult = processSchemaAnnotation(currSchema, handlers);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> prevResolvedPropertiesMap\n+        = getNodeToResolvedProperties(prevSchemaResult);\n+    Map<PathSpec, Pair<CompatibilityCheckContext, Map<String, Object>>> currResolvedPropertiesMap\n+        = getNodeToResolvedProperties(currSchemaResult);\n+\n+    return getCompatibilityResult(prevResolvedPropertiesMap, currResolvedPropertiesMap, handlers);\n+  }\n+\n+  /**\n+   * Iterate the nodeToResolverPropertiesMap, if a node's resolvedProperty contains the same annotationNamespace as SchemaAnnotationHandler,\n+   * calling annotationCompatibilityCheck api which is provided in the SchemaAnnotationHandler to do the annotation compatibility check.\n+   */\n+  private static List<AnnotationCompatibilityResult> getCompatibilityResult(Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> prevResolvedPropertiesMap, Map<PathSpec, Pair<CompatibilityCheckContext,\n+      Map<String, Object>>> currResolvedPropertiesMap, List<SchemaAnnotationHandler> handlers)\n+  {\n+    List<AnnotationCompatibilityResult> results = new ArrayList<>();\n+    for (SchemaAnnotationHandler handler : handlers)\n+    {\n+      if (!handler.implementsCheckCompatibility())\n+      {\n+        _log.info(\"There is no implementation of checkCompatibility method in SchemaAnnotationHandler: \"\n+            + handler.getClass().getName());\n+        continue;\n+      }\n+      String annotationNamespace = handler.getAnnotationNamespace();\n+      Map<PathSpec, Pair<CompatibilityCheckContext,\n+          Map<String, Object>>> copyOfCurrResolvedPropertiesMap = new HashMap<>(currResolvedPropertiesMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916"}, "originalPosition": 89}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/a2a9f07a39bd88233cb5bc9599d3743dc0e41916", "committedDate": "2020-10-12T00:31:34Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "adca844268dc749b46c6df5836d0ce60b19f6fe4", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/adca844268dc749b46c6df5836d0ce60b19f6fe4", "committedDate": "2020-10-12T18:03:22Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2ODMxOTEw", "url": "https://github.com/linkedin/rest.li/pull/435#pullrequestreview-506831910", "createdAt": "2020-10-12T18:24:44Z", "commit": {"oid": "adca844268dc749b46c6df5836d0ce60b19f6fe4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c80fbca209b17c600412ad9bbe6b45a45cd53145", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/c80fbca209b17c600412ad9bbe6b45a45cd53145", "committedDate": "2020-10-12T19:43:22Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "adca844268dc749b46c6df5836d0ce60b19f6fe4", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/adca844268dc749b46c6df5836d0ce60b19f6fe4", "committedDate": "2020-10-12T18:03:22Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}, "afterCommit": {"oid": "c80fbca209b17c600412ad9bbe6b45a45cd53145", "author": {"user": {"login": "nickibi", "name": "Yingjie Bi"}}, "url": "https://github.com/linkedin/rest.li/commit/c80fbca209b17c600412ad9bbe6b45a45cd53145", "committedDate": "2020-10-12T19:43:22Z", "message": "Extend checkPegasusSchemaSnapshot task to be able to check schema annotation compatibility, if SchemaAnnotationHandler is provided."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4692, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}