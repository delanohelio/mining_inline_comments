{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MTk5MTA2", "number": 357, "title": "Provide a default symbol table provider implementation", "bodyText": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services", "createdAt": "2020-07-29T05:17:19Z", "url": "https://github.com/linkedin/rest.li/pull/357", "merged": true, "mergeCommit": {"oid": "7ee39e6e1c99a28a0c600d9220f3a0dcbb239ea3"}, "closed": true, "closedAt": "2020-07-30T05:12:54Z", "author": {"login": "karthikrg"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5k7fwABqjM1OTc0NTU5MjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc53Z6jgBqjM2MDE4Njc2Mzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0704ceb13d4884d78e0d35cb28bd8ac63e8bce58", "author": {"user": {"login": "li-kramgopa", "name": null}}, "url": "https://github.com/linkedin/rest.li/commit/0704ceb13d4884d78e0d35cb28bd8ac63e8bce58", "committedDate": "2020-07-29T05:16:05Z", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services"}, "afterCommit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30", "author": {"user": {"login": "li-kramgopa", "name": null}}, "url": "https://github.com/linkedin/rest.li/commit/8f476a83e4d918538c7f6db1f6b3448b85421a30", "committedDate": "2020-07-29T06:20:57Z", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTY4NjI4", "url": "https://github.com/linkedin/rest.li/pull/357#pullrequestreview-457968628", "createdAt": "2020-07-29T23:36:51Z", "commit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozNjo1MVrOG5N4bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozNjo1MVrOG5N4bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTQ1NQ==", "bodyText": "minor: Do you think there will be usecase to inject local symbol table? If so consider adding an API to do that.", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462649455", "createdAt": "2020-07-29T23:36:51Z", "author": {"login": "karthikbalasub"}, "path": "data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.codec.symbol;\n+\n+import com.linkedin.data.ByteString;\n+import com.linkedin.data.codec.ProtobufDataCodec;\n+import java.net.HttpURLConnection;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Collections;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDefaultSymbolTableProvider\n+{\n+  private final String _symbolTableName = \"https://someservice:100|tableName\";\n+  private final SymbolTable _symbolTable = new InMemorySymbolTable(_symbolTableName, Collections.singletonList(\"test\"));\n+\n+  @Test\n+  public void testRemoteSymbolTableSuccess() throws Exception\n+  {\n+    ByteString serializedTable = SymbolTableSerializer.toByteString(DefaultSymbolTableProvider.CODEC, _symbolTable);\n+\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(200);\n+    when(connection.getInputStream()).thenReturn(serializedTable.asInputStream());\n+\n+    SymbolTable remoteTable = provider.getSymbolTable(_symbolTableName);\n+    verify(connection).setRequestProperty(eq(\"Accept\"), eq(ProtobufDataCodec.DEFAULT_HEADER));\n+\n+    // Verify table is deserialized correctly.\n+    Assert.assertEquals(_symbolTable, remoteTable);\n+\n+    // Mock out the network to throw exceptions on any interactions.\n+    doThrow(new RuntimeException()).when(provider).openConnection(anyString());\n+\n+    // Verify that table is in cache by retrieving it again.\n+    Assert.assertEquals(provider.getSymbolTable(\"tableName\"), remoteTable);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableMalformedUrl()\n+  {\n+    String symbolTableName = \"https\\\\someservice:100|tableName\";\n+    new DefaultSymbolTableProvider().getSymbolTable(symbolTableName);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableErrorResponseCode() throws Exception\n+  {\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(500);\n+    provider.getSymbolTable(_symbolTableName);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableParsingFailure() throws Exception\n+  {\n+    ByteString serializedTable = ByteString.unsafeWrap(\"random\".getBytes());\n+\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(200);\n+    when(connection.getInputStream()).thenReturn(serializedTable.asInputStream());\n+\n+    provider.getSymbolTable(_symbolTableName);\n+    verify(connection).setRequestProperty(eq(\"Accept\"), eq(ProtobufDataCodec.DEFAULT_HEADER));\n+  }\n+\n+  @Test\n+  public void testLocalSymbolTableSuccess()\n+  {\n+    DefaultSymbolTableProvider provider = new DefaultSymbolTableProvider();\n+    // Inject the table into the local cache.\n+    provider._cache.put(\"tableName\", _symbolTable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDAwNzU1", "url": "https://github.com/linkedin/rest.li/pull/357#pullrequestreview-458000755", "createdAt": "2020-07-30T01:20:53Z", "commit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToyMDo1M1rOG5PqKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToyMDo1M1rOG5PqKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3ODU2OQ==", "bodyText": "minor: disconnect finally since this is only one use.", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462678569", "createdAt": "2020-07-30T01:20:53Z", "author": {"login": "aman1309"}, "path": "data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.codec.symbol;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.linkedin.data.codec.ProtobufCodecOptions;\n+import com.linkedin.data.codec.ProtobufDataCodec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A default {@link SymbolTableProvider} implementation that doesn't use symbol tables for requests/responses of its\n+ * own, but is able to retrieve remote symbol tables to decode responses from other services\n+ */\n+public class DefaultSymbolTableProvider implements SymbolTableProvider\n+{\n+  /**\n+   * Metadata extractor\n+   */\n+  private static final SymbolTableMetadataExtractor METADATA_EXTRACTOR = new SymbolTableMetadataExtractor();\n+\n+  /**\n+   * Accept header\n+   */\n+  private static final String ACCEPT_HEADER = \"Accept\";\n+\n+  /**\n+   * Logger.\n+   */\n+  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultSymbolTableProvider.class.getSimpleName());\n+\n+  /**\n+   * Codec\n+   */\n+  static final ProtobufDataCodec CODEC =\n+      new ProtobufDataCodec(new ProtobufCodecOptions.Builder().setEnableASCIIOnlyStrings(true).build());\n+\n+  /**\n+   * Path from which symbol tables are served by remote Rest.li services.\n+   */\n+  public static final String SYMBOL_TABLE_URI_PATH = \"symbolTable\";\n+\n+  /**\n+   * Cache storing mapping from symbol table name to symbol table.\n+   */\n+  final Cache<String, SymbolTable> _cache;\n+\n+  /**\n+   * Constructor\n+   */\n+  DefaultSymbolTableProvider()\n+  {\n+    _cache = Caffeine.newBuilder().maximumSize(1000).build();\n+  }\n+\n+  @Override\n+  public SymbolTable getSymbolTable(String symbolTableName)\n+  {\n+    try\n+    {\n+      SymbolTableMetadata metadata = METADATA_EXTRACTOR.extractMetadata(symbolTableName);\n+      String serverNodeUri = metadata.getServerNodeUri();\n+      String tableName = metadata.getSymbolTableName();\n+      boolean isRemote = metadata.isRemote();\n+\n+      // First check the cache.\n+      SymbolTable symbolTable = _cache.getIfPresent(tableName);\n+      if (symbolTable != null)\n+      {\n+        return symbolTable;\n+      }\n+\n+      // If this is not a remote table, and we didn't find it in the cache, cry foul.\n+      if (!isRemote)\n+      {\n+        throw new IllegalStateException(\"Unable to fetch symbol table with name: \" + symbolTableName);\n+      }\n+\n+      // Ok, we didn't find it in the cache, let's go query the service the table was served from.\n+      String url = serverNodeUri + \"/\" + SYMBOL_TABLE_URI_PATH + \"/\" + tableName;\n+      HttpURLConnection connection = openConnection(url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8facd74bc7be0cb4a5478ef325401b643547af76", "author": {"user": {"login": "li-kramgopa", "name": null}}, "url": "https://github.com/linkedin/rest.li/commit/8facd74bc7be0cb4a5478ef325401b643547af76", "committedDate": "2020-07-30T03:52:14Z", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30", "author": {"user": {"login": "li-kramgopa", "name": null}}, "url": "https://github.com/linkedin/rest.li/commit/8f476a83e4d918538c7f6db1f6b3448b85421a30", "committedDate": "2020-07-29T06:20:57Z", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services"}, "afterCommit": {"oid": "8facd74bc7be0cb4a5478ef325401b643547af76", "author": {"user": {"login": "li-kramgopa", "name": null}}, "url": "https://github.com/linkedin/rest.li/commit/8facd74bc7be0cb4a5478ef325401b643547af76", "committedDate": "2020-07-30T03:52:14Z", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4890, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}