{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNjQ1MDQ2", "number": 310, "title": "[Relative Load Balancing] D2 relative strategy update health score", "bodyText": "Implement the new relative load balance strategy. The overall logics are similar to the original degrader load balancer logics, we would like to call out several major logic changes:\n\nIn each update interval, the update is now scheduled by a single-thread executor service. However, there is one exception, if a partition is not initialized or if the uris in one partition changed, we will still update the partition state synchronously.\nIn the new implementation, each host have 1 state for each partition. It used to be one DegraderImpl object for different partitions if one host is in multiple partitions. However, in the new implementation, we changed to track each partition individually. A host can be \"degraded\" in one partition but in perfect health condition in another partition.\nWe used to us lowLatency as the quarantine latency, now we change to use clusterAvgLatency * lowFactor as the quarantine latency, it will be a more dynamic number.\n\nIn terms of the code structure, main logics are in RelativeStateUpdater, QuarantineManager and ClientSelectorImpl.\nThe unit tests will be added in next iteration.", "createdAt": "2020-05-27T06:49:06Z", "url": "https://github.com/linkedin/rest.li/pull/310", "merged": true, "mergeCommit": {"oid": "64b23ce747897262455edd57de7d8cff47e2dfa6"}, "closed": true, "closedAt": "2020-07-13T17:16:05Z", "author": {"login": "rachelhanhan"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclS4k1AH2gAyNDIzNjQ1MDQ2OjdiZTBhZDIyMGFmMjExMjY4NTBkMTFkODgxM2IzNDEzZGRjYmExYTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0kfwogFqTQ0NzQzNDk0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7be0ad220af21126850d11d8813b3413ddcba1a4", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/7be0ad220af21126850d11d8813b3413ddcba1a4", "committedDate": "2020-05-27T06:01:22Z", "message": "[Relative Load Balancing][Not ready for review] Update the health score of tracker clients"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/861078ce308f85d1cc12a253ee7adb5e8786ff53", "committedDate": "2020-05-27T06:36:34Z", "message": "[Relative Load Balancing][Not ready for review] Update doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "committedDate": "2020-05-29T07:46:06Z", "message": "Added quarantine implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTM1MDU2", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-420535056", "createdAt": "2020-05-28T22:25:36Z", "commit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyNTozNlrOGcI1Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo0NTowOVrOGdT8yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODAxMA==", "bodyText": "prefer\nMIN_HEALTH_SCORE\nMAX_HEALTH_SCORE\nSLOW_START_INITIAL_HEALTH_SCORE (can remove comment)", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432158010", "createdAt": "2020-05-28T22:25:36Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODM5OQ==", "bodyText": "prefer not using comments unless absolutely necessary. Instead we should improve naming, etc. In this case I think the variable name is clear enough.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432158399", "createdAt": "2020-05-28T22:26:41Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDEyMQ==", "bodyText": "This line should go into the lock so it's only created once.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432160121", "createdAt": "2020-05-28T22:31:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MTExMg==", "bodyText": "We want a blocking lock here instead. And another if !_partitionLoadBalancerStateMap.containsKey(partitionId) check so we don't initialize more than once.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432161112", "createdAt": "2020-05-28T22:34:33Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDMwOA==", "bodyText": "Prefer updateState and put request usage in the javadoc.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432164308", "createdAt": "2020-05-28T22:44:25Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTgwOA==", "bodyText": "Add javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432171808", "createdAt": "2020-05-28T23:07:11Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MjM4OQ==", "bodyText": "Comment unnecessary", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432172389", "createdAt": "2020-05-28T23:09:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2Njg5Nw==", "bodyText": "comment unnecessary", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433366897", "createdAt": "2020-06-01T17:03:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2Nzg1NA==", "bodyText": "Should this be setting the TrackerClients in _partitionLoadBalancerStateMap instead of passing them directly?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433367854", "createdAt": "2020-06-01T17:05:44Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2OTcxNA==", "bodyText": "I prefer using value directly instead of Optional", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433369714", "createdAt": "2020-06-01T17:09:29Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NTA0Mw==", "bodyText": "I'd rather keep decision making in this class instead of TrackerClientState since this is very similar to what Degrader was doing.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433385043", "createdAt": "2020-06-01T17:38:17Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          trackerClientStateMap.remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineMap().remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineHistory().remove(trackerClient);\n+          partitionLoadBalancerState.getRecoveryMap().remove(trackerClient);\n+        }\n+      }\n+    }\n+\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionId);\n+\n+    // Update cluster generation id if it's changed\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      _partitionLoadBalancerStateMap.get(partitionId).setClusterGenerationId(maybeClusterGenerationId.get());\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, int partitionId)\n+  {\n+    // Snap stats for each tracker client, we want to get snap the stats because they can change any time during we calculate the new health score\n+    long sumAvgLatency = 0;\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getLatestCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      sumAvgLatency += Math.round(latestCallStats.getCallTimeStats().getAverage());\n+    }\n+    long clusterAvgLatency = sumAvgLatency / trackerClients.size();\n+    partitionLoadBalancerState.setClusterAvgLatency(clusterAvgLatency);\n+\n+    // Update health score\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = latestCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount();\n+        double errorRate = TrackerClientState.getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long latency = Math.round(latestCallStats.getCallTimeStats().getAverage());\n+        // If it is an existing tracker client\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+        if (TrackerClientState.isUnhealthy(trackerClientState, clusterAvgLatency, callCount, latency, errorRate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4Njk0NA==", "bodyText": "Calculating cluster avg latency is not this simple. See rfc for formula.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433386944", "createdAt": "2020-06-01T17:41:48Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          trackerClientStateMap.remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineMap().remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineHistory().remove(trackerClient);\n+          partitionLoadBalancerState.getRecoveryMap().remove(trackerClient);\n+        }\n+      }\n+    }\n+\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionId);\n+\n+    // Update cluster generation id if it's changed\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      _partitionLoadBalancerStateMap.get(partitionId).setClusterGenerationId(maybeClusterGenerationId.get());\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, int partitionId)\n+  {\n+    // Snap stats for each tracker client, we want to get snap the stats because they can change any time during we calculate the new health score\n+    long sumAvgLatency = 0;\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getLatestCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      sumAvgLatency += Math.round(latestCallStats.getCallTimeStats().getAverage());\n+    }\n+    long clusterAvgLatency = sumAvgLatency / trackerClients.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODE2MQ==", "bodyText": "maybe ServerHealthState instead?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433388161", "createdAt": "2020-06-01T17:44:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientState.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+\n+\n+/**\n+ * Keeps the state of each tracker client for a partition\n+ */\n+public class TrackerClientState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODc0NQ==", "bodyText": "redundant. also does this class need to know if it's healthy or not? Shouldn't the state updater calculate that and use it? Why temporarily store in this class?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433388745", "createdAt": "2020-06-01T17:45:09Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientState.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+\n+\n+/**\n+ * Keeps the state of each tracker client for a partition\n+ */\n+public class TrackerClientState {\n+  private int _callCount;\n+  // TODO: update adjusted min call count\n+  private int _adjustedMinCallCount;\n+  private double _healthScore;\n+  private boolean _isUnhealthy;\n+  private boolean _isHealthy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aafeb5c256b073798f2e033b522db0893a7acbb", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/1aafeb5c256b073798f2e033b522db0893a7acbb", "committedDate": "2020-06-03T05:36:07Z", "message": "Added quarantine and state updater logic, the code roughly covers the major logics in load balancer in this version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe72d543894820a617b9ea59cf8c2dead6f81a45", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/fe72d543894820a617b9ea59cf8c2dead6f81a45", "committedDate": "2020-06-04T23:41:33Z", "message": "Added minor changes including: stateListener interface, getRing synchorous execution and some logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "614689cc01d45d62c61bc792a7b083658ced2769", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/614689cc01d45d62c61bc792a7b083658ced2769", "committedDate": "2020-06-09T05:10:08Z", "message": "Change to async update state for cluster change, also changed quarantine latency calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "committedDate": "2020-06-10T04:41:55Z", "message": "Added error regex handling and some other minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4138ce76b0c13130c96b4b343a2120ace31a459", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/d4138ce76b0c13130c96b4b343a2120ace31a459", "committedDate": "2020-06-13T01:37:41Z", "message": "Added unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MTQ0MDM4", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-429144038", "createdAt": "2020-06-11T17:39:02Z", "commit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "state": "COMMENTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozOTowMlrOGinyfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1ODowNVrOGj8z6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NjY3MA==", "bodyText": "use public static string defined in RelativeLoadBalancerStrategy.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438956670", "createdAt": "2020-06-11T17:39:02Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/D2ClientBuilder.java", "diffHunk": "@@ -506,6 +507,10 @@ public D2ClientBuilder setD2JmxManagerPrefix(String d2JmxManagerPrefix)\n     loadBalancerStrategyFactories.putIfAbsent(\"degraderV3\", degraderStrategyFactoryV3);\n     loadBalancerStrategyFactories.putIfAbsent(\"degraderV2_1\", degraderStrategyFactoryV3);\n \n+    final RelativeLoadBalancerStrategyFactory relativeLoadBalancerStrategyFactory = new RelativeLoadBalancerStrategyFactory(\n+        _config._executorService, _config.healthCheckOperations, Collections.emptyList(), _config.eventEmitter);\n+    loadBalancerStrategyFactories.putIfAbsent(\"relative\", relativeLoadBalancerStrategyFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NTE4Nw==", "bodyText": "I'd rather use a Predicate instead of this null pattern.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438965187", "createdAt": "2020-06-11T17:49:37Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -81,6 +87,23 @@ public TrackerClientImpl(URI uri, Map<Integer, PartitionData> partitionDataMap,\n     _transportClient = transportClient;\n     _callTracker = new CallTrackerImpl(interval, clock);\n     _errorStatusPattern = errorStatusPattern;\n+    _errorStatusRanges = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDExMQ==", "bodyText": "finish javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438980111", "createdAt": "2020-06-11T18:12:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector\n+{\n+  /**\n+   * @param request\n+   * @param requestContext\n+   * @param ring\n+   * @param trackerClients\n+   * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDE1OQ==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438980159", "createdAt": "2020-06-11T18:12:29Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector\n+{\n+  /**\n+   * @param request\n+   * @param requestContext\n+   * @param ring\n+   * @param trackerClients\n+   * @return\n+   */\n+  @Nullable\n+  TrackerClient getTrackerClient(Request request, RequestContext requestContext, Ring<URI> ring,\n+      Map<URI, TrackerClient> trackerClients);\n+\n+  HashFunction<Request> getRequestHashFunction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjI1MA==", "bodyText": "thoughts on renaming to StateUpdateListener?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982250", "createdAt": "2020-06-11T18:16:26Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/PartitionLoadBalancerStateListener.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.strategies.relative.PartitionRelativeLoadBalancerState;\n+\n+\n+/**\n+ * The listener that listens to the change of a partition in relative load balancer\n+ */\n+public interface PartitionLoadBalancerStateListener<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjYwMA==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982600", "createdAt": "2020-06-11T18:17:06Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/StateUpdater.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * Update the state of a strategy periodically\n+ */\n+public interface StateUpdater\n+{\n+  /**\n+   * Update the state of the strategy from a new incoming request\n+   * The actual update will only be performed if there is any change in cluster hosts or during initialization.\n+   * Otherwise, the state is updated by the executor service based on fixed intervals, this method will invoke no operation internally\n+   *\n+   * @param trackerClients The potential tracker clients to choose from\n+   * @param partitionId The partition id of the request\n+   * @param clusterGenerationId The id that identifies a unique set of uris in the current cluster\n+   */\n+  void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId);\n+\n+  Ring<URI> getRing(int partitionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjgyMw==", "bodyText": "expand", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982823", "createdAt": "2020-06-11T18:17:31Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NDcxMw==", "bodyText": "a", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438984713", "createdAt": "2020-06-11T18:21:05Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = trackerClients.get(targetHostUri);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick a one from the tracker clients passed from the request if there is no one selected from the ring\n+      trackerClient = trackerClients.values().stream().findAny().orElse(null);\n+      warn(LOG, \"Did not find a valid client from the ring, picked {} instead\", trackerClient.getUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NTE4Ng==", "bodyText": "check if possible", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438985186", "createdAt": "2020-06-11T18:22:05Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = trackerClients.get(targetHostUri);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick a one from the tracker clients passed from the request if there is no one selected from the ring\n+      trackerClient = trackerClients.values().stream().findAny().orElse(null);\n+      warn(LOG, \"Did not find a valid client from the ring, picked {} instead\", trackerClient.getUri());\n+    }\n+\n+    addToExcludedHosts(trackerClient, requestContext);\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromRing(Request request,\n+                                                 RequestContext requestContext,\n+                                                 Ring<URI> ring,\n+                                                 Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (ring == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MzIzMA==", "bodyText": "thoughts on RelativeLoadBalancerState or PartitionedRelativeLoadBalancerState?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439063230", "createdAt": "2020-06-11T20:49:48Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2Mzc4NQ==", "bodyText": "a", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439063785", "createdAt": "2020-06-11T20:51:00Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState\n+{\n+  private final int _partitionId;\n+  private final Lock _lock;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionRelativeLoadBalancerState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDE4Mg==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439064182", "createdAt": "2020-06-11T20:51:42Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState\n+{\n+  private final int _partitionId;\n+  private final Lock _lock;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionRelativeLoadBalancerState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Lock lock, List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _lock = lock;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  private PartitionRelativeLoadBalancerState(int partitionId, Lock lock, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _lock = lock;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionRelativeLoadBalancerState copy()\n+  {\n+    return new PartitionRelativeLoadBalancerState(this.getPartitionId(),\n+        this.getLock(),\n+        this.getRingFactory(),\n+        this.getPointsPerWeight(),\n+        new HashSet<>(this.getRecoveryTrackerClients()),\n+        this.getClusterGenerationId(),\n+        new HashMap<>(this.getQuarantineMap()),\n+        new HashMap<>(this.getQuarantineHistory()),\n+        new HashMap<>(this.getTrackerClientStateMap()),\n+        this.getListeners());\n+  }\n+\n+  public Lock getLock()\n+  {\n+    return _lock;\n+  }\n+\n+  public int getPartitionId()\n+  {\n+    return _partitionId;\n+  }\n+\n+  public long getClusterGenerationId() {\n+    return _clusterGenerationId;\n+  }\n+\n+  public Map<TrackerClient, TrackerClientState> getTrackerClientStateMap()\n+  {\n+    return _trackerClientStateMap;\n+  }\n+\n+  public Set<TrackerClient> getTrackerClients()\n+  {\n+    return _trackerClientStateMap.keySet();\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineMap()\n+  {\n+    return _quarantineMap;\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineHistory()\n+  {\n+    return _quarantineHistory;\n+  }\n+\n+  public Set<TrackerClient> getRecoveryTrackerClients()\n+  {\n+    return _recoveryTrackerClients;\n+  }\n+\n+  public RingFactory<URI> getRingFactory()\n+  {\n+    return _ringFactory;\n+  }\n+\n+  public Ring<URI> getRing() {\n+    return _ring;\n+  }\n+\n+  public void setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+  }\n+\n+  public Map<URI, Integer> getPointsMap()\n+  {\n+    return _pointsMap;\n+  }\n+\n+  public void resetRing()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTIwOQ==", "bodyText": "MIN_SERVER_WEIGHT?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439065209", "createdAt": "2020-06-11T20:53:59Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjAzNg==", "bodyText": "extract out", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439082036", "createdAt": "2020-06-11T21:33:05Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjA5NQ==", "bodyText": "javadoc and make more concise -> \"Limit the number of hosts to enable quarantine and prevent too many connections to be made at once when the downstream cluster is large.\"", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439082095", "createdAt": "2020-06-11T21:33:13Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzI1OQ==", "bodyText": "is this the right place to do this?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083259", "createdAt": "2020-06-11T21:36:06Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4Mzg1OA==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083858", "createdAt": "2020-06-11T21:37:28Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzkzNA==", "bodyText": "remove comments and below", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083934", "createdAt": "2020-06-11T21:37:39Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NDE5Mw==", "bodyText": "necessary?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439084193", "createdAt": "2020-06-11T21:38:18Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTQxNw==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439085417", "createdAt": "2020-06-11T21:41:33Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTYzMQ==", "bodyText": "else if new line", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439085631", "createdAt": "2020-06-11T21:42:07Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NzgwNA==", "bodyText": "move to method level", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439087804", "createdAt": "2020-06-11T21:47:28Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4ODg3Nw==", "bodyText": "a", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439088877", "createdAt": "2020-06-11T21:48:55Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null) {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        } else {\n+          LOG.error(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4OTU3MA==", "bodyText": "check necessary?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439089570", "createdAt": "2020-06-11T21:49:55Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null) {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        } else {\n+          LOG.error(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double clientWeight, Set<TrackerClient> recoverySet,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5MDU4OA==", "bodyText": "-1 instead of 0", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439090588", "createdAt": "2020-06-11T21:51:13Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerMonitorEventEmitter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.event.D2MonitorEventEmitter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.util.clock.Clock;\n+\n+\n+/**\n+ * Adapter for emitting D2 events from {@link RelativeStateUpdater}.\n+ */\n+public class RelativeLoadBalancerMonitorEventEmitter implements PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>\n+{\n+  private final D2MonitorEventEmitter _d2MonitorEventEmitter;\n+\n+  public RelativeLoadBalancerMonitorEventEmitter(D2MonitorEventEmitter d2MonitorEventEmitter)\n+  {\n+    _d2MonitorEventEmitter = d2MonitorEventEmitter;\n+  }\n+\n+  public void onUpdate(PartitionRelativeLoadBalancerState state)\n+  {\n+    // Please note that cluster level drop is deprecated in the relative load balancer, so there is no cluster level dropped calls and drop level", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5MDg5MA==", "bodyText": "remove", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439090890", "createdAt": "2020-06-11T21:51:41Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  /// We should probably directly use the interface name instead of the Impl name, because we should only access the public methods", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDUwMw==", "bodyText": "maybe too tight. 1.4/1.3?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440340503", "createdAt": "2020-06-15T17:41:21Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDk0MQ==", "bodyText": "why 0", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440340941", "createdAt": "2020-06-15T17:42:12Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;\n+  private static final double DEFAULT_HIGH_ERROR_RATE = 1.1;\n+  private static final double DEFAULT_LOW_ERROR_RATE = 1.1;\n+  private static final int DEFAULT_MIN_CALL_COUNT = 1;\n+  private static final double DEFAULT_INITIAL_HEALTH_SCORE = 1.0;\n+  private static final double DEFAULT_SLOW_START_THRESHOLD = 0.0;\n+  private static final HttpStatusCodeRangeArray DEFAULT_ERROR_STATUS_FILTER =\n+      new HttpStatusCodeRangeArray(new HttpStatusCodeRange().setLowerBound(500).setUpperBound(599));\n+  private static final long DEFAULT_EMITTING_INTERVAL_MS = 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTMzOQ==", "bodyText": "same thing defined in Relative...Strategy", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440341339", "createdAt": "2020-06-15T17:42:59Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -62,6 +65,8 @@\n {\n   public static final String DEFAULT_ERROR_STATUS_REGEX = \"(5..)\";\n   public static final Pattern DEFAULT_ERROR_STATUS_PATTERN = Pattern.compile(DEFAULT_ERROR_STATUS_REGEX);\n+  public static final List<HttpStatusCodeRange> DEFAULT_ERROR_STATUS_RANGES = Arrays.asList(new HttpStatusCodeRange()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NTQwMQ==", "bodyText": "consider adding this to API so you don't need to cast to call this.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440345401", "createdAt": "2020-06-15T17:50:25Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Njk4MA==", "bodyText": "concurrency concern", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440346980", "createdAt": "2020-06-15T17:53:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionRelativeLoadBalancerState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      emitMonitorEvents(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionRelativeLoadBalancerState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          partitionRelativeLoadBalancerState.removeTrackerClient(trackerClient);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avglatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          } else {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        } else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      } else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionRelativeLoadBalancerState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * (callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * (outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void emitMonitorEvents(PartitionRelativeLoadBalancerState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    Lock lock = new ReentrantLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Nzc4NQ==", "bodyText": "should we tryLock here?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440347785", "createdAt": "2020-06-15T17:54:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0OTY3NA==", "bodyText": "rename to generic", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440349674", "createdAt": "2020-06-15T17:58:05Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionRelativeLoadBalancerState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      emitMonitorEvents(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionRelativeLoadBalancerState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          partitionRelativeLoadBalancerState.removeTrackerClient(trackerClient);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avglatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          } else {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        } else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      } else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionRelativeLoadBalancerState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * (callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * (outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void emitMonitorEvents(PartitionRelativeLoadBalancerState state)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed"}, "originalPosition": 305}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "committedDate": "2020-06-16T23:13:55Z", "message": "Addressed review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTQ2NTA5", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-433546509", "createdAt": "2020-06-18T18:34:40Z", "commit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "state": "COMMENTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozNDo0MFrOGl7eQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo1NTowM1rOGmBgMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNDg5OQ==", "bodyText": "minor - can move out getErrorStatusRanges() call", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442424899", "createdAt": "2020-06-18T18:34:40Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientFactory.java", "diffHunk": "@@ -176,18 +175,38 @@ private static Pattern getErrorStatusPattern(String loadBalancerStrategyName, Se\n     return errorPattern;\n   }\n \n+  private static List<HttpStatusCodeRange> getErrorStatusRanges(ServiceProperties serviceProperties)\n+  {\n+    if (serviceProperties.getRelativeStrategyProperties() == null\n+        || serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter() == null)\n+    {\n+      return RelativeLoadBalancerStrategyFactory.DEFAULT_ERROR_STATUS_FILTER;\n+    }\n+    return serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter();\n+  }\n+\n   private static TrackerClientImpl createTrackerClientImpl(URI uri,\n                                                            UriProperties uriProperties,\n                                                            ServiceProperties serviceProperties,\n                                                            String loadBalancerStrategyName,\n                                                            TransportClient transportClient,\n                                                            Clock clock)\n   {\n+    TrackerClientImpl.ErrorStatusMatch errorStatusRangeMatch = (status) -> {\n+      for(HttpStatusCodeRange statusCodeRange : getErrorStatusRanges(serviceProperties))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMDgzOQ==", "bodyText": "javadoc\nErrorStatusMatcher?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442430839", "createdAt": "2020-06-18T18:45:48Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -280,21 +290,21 @@ private boolean isServerError(Throwable throwable)\n       RestException restException = (RestException) throwable;\n       if (restException.getResponse() != null)\n       {\n-        return matchErrorStatus(restException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(restException.getResponse().getStatus());\n       }\n     }\n     else if (throwable instanceof StreamException)\n     {\n       StreamException streamException = (StreamException) throwable;\n       if (streamException.getResponse() != null)\n       {\n-        return matchErrorStatus(streamException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(streamException.getResponse().getStatus());\n       }\n     }\n     return false;\n   }\n \n-  private boolean matchErrorStatus(int status) {\n-    return _errorStatusPattern.matcher(Integer.toString(status)).matches();\n+  public interface ErrorStatusMatch {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNTQ1Nw==", "bodyText": "I think we should still add to excluded hosts at the very end here. let's discuss", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442435457", "createdAt": "2020-06-18T18:54:21Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzODcwNA==", "bodyText": "discuss here too", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442438704", "createdAt": "2020-06-18T19:00:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromTarget(URI targetHostUri, RequestContext requestContext, Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient = trackerClients.get(targetHostUri);\n+\n+    if (trackerClient == null)\n+    {\n+      LOG.warn(\"No client found for \", targetHostUri, \". Target host specified is no longer part of cluster\");\n+    }\n+    else\n+    {\n+      // if this flag is set to be true, that means affinity routing is preferred but backup requests are still acceptable\n+      Boolean otherHostAcceptable = KeyMapper.TargetHostHints.getRequestContextOtherHostAcceptable(requestContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzOTI1OA==", "bodyText": "RelativeEventEmitter?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442439258", "createdAt": "2020-06-18T19:00:57Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/MonitorEventEmitter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.event.D2MonitorEventEmitter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.util.clock.Clock;\n+\n+\n+/**\n+ * Adapter for emitting D2 events from {@link RelativeStateUpdater}.\n+ */\n+public class MonitorEventEmitter implements PartitionStateUpdateListener<PartitionState>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MDk4MA==", "bodyText": "call other constructor", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442440980", "createdAt": "2020-06-18T19:04:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MTU0OQ==", "bodyText": "is this used?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442441549", "createdAt": "2020-06-18T19:05:29Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, HealthCheck> healthCheckMap,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _healthCheckMap = healthCheckMap;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionState copy()\n+  {\n+    return new PartitionState(this.getPartitionId(),\n+        this.getRingFactory(),\n+        this.getPointsPerWeight(),\n+        new HashSet<>(this.getRecoveryTrackerClients()),\n+        this.getClusterGenerationId(),\n+        new HashMap<>(this.getQuarantineMap()),\n+        new HashMap<>(this.getQuarantineHistory()),\n+        new HashMap<>(this.getHealthCheckMap()),\n+        new HashMap<>(this.getTrackerClientStateMap()),\n+        this.getListeners());\n+  }\n+\n+  public int getPartitionId()\n+  {\n+    return _partitionId;\n+  }\n+\n+  public long getClusterGenerationId()\n+  {\n+    return _clusterGenerationId;\n+  }\n+\n+  public Map<TrackerClient, TrackerClientState> getTrackerClientStateMap()\n+  {\n+    return _trackerClientStateMap;\n+  }\n+\n+  public Set<TrackerClient> getTrackerClients()\n+  {\n+    return _trackerClientStateMap.keySet();\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineMap()\n+  {\n+    return _quarantineMap;\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineHistory()\n+  {\n+    return _quarantineHistory;\n+  }\n+\n+  public Map<TrackerClient, HealthCheck> getHealthCheckMap()\n+  {\n+    return _healthCheckMap;\n+  }\n+\n+  public Set<TrackerClient> getRecoveryTrackerClients()\n+  {\n+    return _recoveryTrackerClients;\n+  }\n+\n+  public RingFactory<URI> getRingFactory()\n+  {\n+    return _ringFactory;\n+  }\n+\n+  public Ring<URI> getRing()\n+  {\n+    return _ring;\n+  }\n+\n+  public void setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+  }\n+\n+  public Map<URI, Integer> getPointsMap()\n+  {\n+    return _pointsMap;\n+  }\n+\n+  /**\n+   * Reset the hash ring using the latest tracker clients and points map\n+   */\n+  public void resetRing()\n+  {\n+    Set<TrackerClient> trackerClients = _trackerClientStateMap.keySet();\n+    Map<URI, CallTracker> callTrackerMap = Collections.unmodifiableMap(trackerClients.stream()\n+        .collect(Collectors.toMap(TrackerClient::getUri, TrackerClient::getCallTracker)));\n+    _pointsMap = _trackerClientStateMap.entrySet().stream()\n+        .collect(Collectors.toMap(entry -> entry.getKey().getUri(),\n+            entry -> (int) Math.round(entry.getValue().getHealthScore() * entry.getKey().getPartitionWeight(_partitionId) * _pointsPerWeight)));\n+    _ring = _ringFactory.createRing(_pointsMap, callTrackerMap);\n+  }\n+\n+  public void setPartitionStats(double avgClusterLatency, long clusterCallCount, long clusterErrorCount)\n+  {\n+    _partitionStats = new PartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  public PartitionStats getPartitionStats()\n+  {\n+    return _partitionStats;\n+  }\n+\n+  public List<PartitionStateUpdateListener<PartitionState>> getListeners()\n+  {\n+    return Collections.unmodifiableList(_listeners);\n+  }\n+\n+  public void removeTrackerClient(TrackerClient trackerClient)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MzMxNQ==", "bodyText": "-> QUARANTINE_MIN_REENTRY_TIME_MS", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442443315", "createdAt": "2020-06-18T19:09:10Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NDU2Mg==", "bodyText": "do you think state should be consolidated instead of split between here and partitionstate?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442444562", "createdAt": "2020-06-18T19:11:38Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MjkxOQ==", "bodyText": "doesnt need to be a separate method", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442452919", "createdAt": "2020-06-18T19:28:19Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjI1OQ==", "bodyText": "handleSingleClientInRecovery?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442466259", "createdAt": "2020-06-18T19:51:51Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjgzMA==", "bodyText": "is this check necesary", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442466830", "createdAt": "2020-06-18T19:52:58Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3Njk0Mg==", "bodyText": "when would points not be 0 if it's already in quarantine?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442476942", "createdAt": "2020-06-18T20:12:59Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjgzOA==", "bodyText": "imo the LBQ should have this logic internally \"(_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS\" instead of making user decide.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442482838", "createdAt": "2020-06-18T20:25:34Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NDg5Mw==", "bodyText": "isQuarantined", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442484893", "createdAt": "2020-06-18T20:29:55Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        }\n+        else\n+        {\n+          LOG.warn(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double serverWeight, Set<TrackerClient> recoverySet,\n+      PartitionState oldPartitionState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT)\n+    {\n+      // Enroll the client to recovery set if the health score dropped to 0, but zookeeper does not set the client weight to be 0\n+      trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      if (!recoverySet.contains(trackerClient))\n+      {\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+\n+    // Also enroll new client into the recovery set if fast recovery and slow start are both enabled\n+    if (!recoverySet.contains(trackerClient)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NTg4OA==", "bodyText": "debug? or rate limit", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442485888", "createdAt": "2020-06-18T20:32:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        }\n+        else\n+        {\n+          LOG.warn(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double serverWeight, Set<TrackerClient> recoverySet,\n+      PartitionState oldPartitionState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT)\n+    {\n+      // Enroll the client to recovery set if the health score dropped to 0, but zookeeper does not set the client weight to be 0\n+      trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      if (!recoverySet.contains(trackerClient))\n+      {\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+\n+    // Also enroll new client into the recovery set if fast recovery and slow start are both enabled\n+    if (!recoverySet.contains(trackerClient)\n+        && !oldPartitionState.getTrackerClients().contains(trackerClient)\n+        && _fastRecoveryEnabled\n+        && _slowStartEnabled)\n+    {\n+      recoverySet.add(trackerClient);\n+    }\n+  }\n+\n+  private class HealthCheckCallBack<None> implements Callback<None>\n+  {\n+    @Override\n+    public void onError(Throwable e)\n+    {\n+      if (!_quarantineEnabled.get())\n+      {\n+        _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+      }\n+    }\n+\n+    @Override\n+    public void onSuccess(None result)\n+    {\n+      if (tryEnableQuarantine())\n+      {\n+        LOG.info(\"Quarantine is enabled for service {}\", _serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NzMzMQ==", "bodyText": "say exposed for testing", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442487331", "createdAt": "2020-06-18T20:35:08Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  private final StateUpdater _stateUpdater;\n+  private final ClientSelector _clientSelector;\n+\n+  public RelativeLoadBalancerStrategy(StateUpdater stateUpdater,\n+                                      ClientSelector clientSelector)\n+  {\n+    _stateUpdater = stateUpdater;\n+    _clientSelector = clientSelector;\n+  }\n+\n+  @Override\n+  public String getName()\n+  {\n+    return RELATIVE_LOAD_BALANCER_STRATEGY_NAME;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        long clusterGenerationId,\n+                                        int partitionId,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (trackerClients == null || trackerClients.size() == 0)\n+    {\n+      LOG.warn(\"getTrackerClient called with null/empty trackerClients, so returning null\");\n+      return null;\n+    }\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    Ring<URI> ring = getRing(clusterGenerationId, partitionId, trackerClients);\n+    return _clientSelector.getTrackerClient(request, requestContext, ring, trackerClients);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Ring<URI> getRing(long clusterGenerationId, int partitionId, Map<URI, TrackerClient> trackerClients)\n+  {\n+    Ring<URI> ring = _stateUpdater.getRing(partitionId);\n+    if (ring == null)\n+    {\n+      // If there is no existing ring, we update the partition first\n+      _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    }\n+    return _stateUpdater.getRing(partitionId);\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4Nzk1NA==", "bodyText": "move to constructor and allow caller to inject.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442487954", "createdAt": "2020-06-18T20:36:19Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  public static final int DEFAULT_MIN_CALL_COUNT = 1;\n+  public static final double DEFAULT_INITIAL_HEALTH_SCORE = 1.0;\n+  public static final double DEFAULT_SLOW_START_THRESHOLD = 0.0;\n+  public static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;\n+  public static final HttpStatusCodeRangeArray DEFAULT_ERROR_STATUS_FILTER =\n+      new HttpStatusCodeRangeArray(new HttpStatusCodeRange().setLowerBound(500).setUpperBound(599));\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.3;\n+  private static final double DEFAULT_HIGH_ERROR_RATE = 1.1;\n+  private static final double DEFAULT_LOW_ERROR_RATE = 1.1;\n+  private static final long DEFAULT_EMITTING_INTERVAL_MS = 0L;\n+  private static final boolean DEFAULT_ENABLE_FAST_RECOVERY = false;\n+  // Default quarantine properties\n+  public static final double DEFAULT_QUARANTINE_MAX_PERCENT = 0.0;\n+  private static final HttpMethod DEFAULT_HTTP_METHOD = HttpMethod.OPTIONS;\n+  // Default ring properties\n+  private static final int DEFAULT_POINTS_PER_WEIGHT = 100;\n+\n+\n+  private final ScheduledExecutorService _executorService;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _stateListenerFactories;\n+  private final EventEmitter _eventEmitter;\n+  private final Clock _clock;\n+\n+  public RelativeLoadBalancerStrategyFactory(ScheduledExecutorService executorService, HealthCheckOperations healthCheckOperations,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> stateListenerFactories, EventEmitter eventEmitter)\n+  {\n+    _executorService = executorService;\n+    _healthCheckOperations = healthCheckOperations;\n+    _stateListenerFactories = stateListenerFactories;\n+    _eventEmitter = (eventEmitter == null) ? new NoopEventEmitter() : eventEmitter;\n+    _clock = SystemClock.instance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5Mzg0Mg==", "bodyText": "runnable necessary?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442493842", "createdAt": "2020-06-18T20:48:22Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NjA1MQ==", "bodyText": "use LogUtil.debug. in fact it's probably good practice to user logutil for every log call we make in this pr.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442496051", "createdAt": "2020-06-18T20:53:02Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDMyNg==", "bodyText": "can put in try block too", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442500326", "createdAt": "2020-06-18T21:01:40Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    PartitionState partitionState = new PartitionState(partitionId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDgxNQ==", "bodyText": "will they ever be null?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442500815", "createdAt": "2020-06-18T21:02:34Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTIyOQ==", "bodyText": "this is also called during initialize so \"when there is a cluster uris change.\" is not accurate. would be good to summarize the update steps here.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442501229", "createdAt": "2020-06-18T21:03:29Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMzY4OA==", "bodyText": "updateRing?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442503688", "createdAt": "2020-06-18T21:08:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNDMzMg==", "bodyText": "will this be null? seems better to do a comparison w/ old vs new and not present vs null.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442504332", "createdAt": "2020-06-18T21:10:13Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODQwMg==", "bodyText": "can call this within updateHealthScoreAndState to slim down thisi method even more", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442508402", "createdAt": "2020-06-18T21:18:57Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTczMw==", "bodyText": "getErrorRate more accurate", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442511733", "createdAt": "2020-06-18T21:26:14Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMzY5Ng==", "bodyText": "Can we separate out set up from actual test to reduce duplicate code and make tests slimmer? In a @BeforeMethod", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442523696", "createdAt": "2020-06-18T21:55:03Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Mocks mocks = new Mocks();\n+    Request request = Mockito.mock(Request.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjM4MzMy", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-433638332", "createdAt": "2020-06-18T20:52:23Z", "commit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo1MjoyM1rOGl_zBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzowMzo0MVrOGmC49A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NTc0OA==", "bodyText": "Understood what you're doing here, but curious why -- isn't current regex cover all the cases? Why do we need to define errorSatusRanges?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442495748", "createdAt": "2020-06-18T20:52:23Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientFactory.java", "diffHunk": "@@ -176,18 +175,38 @@ private static Pattern getErrorStatusPattern(String loadBalancerStrategyName, Se\n     return errorPattern;\n   }\n \n+  private static List<HttpStatusCodeRange> getErrorStatusRanges(ServiceProperties serviceProperties)\n+  {\n+    if (serviceProperties.getRelativeStrategyProperties() == null\n+        || serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter() == null)\n+    {\n+      return RelativeLoadBalancerStrategyFactory.DEFAULT_ERROR_STATUS_FILTER;\n+    }\n+    return serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter();\n+  }\n+\n   private static TrackerClientImpl createTrackerClientImpl(URI uri,\n                                                            UriProperties uriProperties,\n                                                            ServiceProperties serviceProperties,\n                                                            String loadBalancerStrategyName,\n                                                            TransportClient transportClient,\n                                                            Clock clock)\n   {\n+    TrackerClientImpl.ErrorStatusMatch errorStatusRangeMatch = (status) -> {\n+      for(HttpStatusCodeRange statusCodeRange : getErrorStatusRanges(serviceProperties))\n+      {\n+        if (status >= statusCodeRange.getLowerBound() && status <= statusCodeRange.getUpperBound())\n+        {\n+          return true;\n+        }\n+      }\n+      return false;\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQxMw==", "bodyText": "How about just use Predicate?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442498413", "createdAt": "2020-06-18T20:57:47Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -280,21 +290,21 @@ private boolean isServerError(Throwable throwable)\n       RestException restException = (RestException) throwable;\n       if (restException.getResponse() != null)\n       {\n-        return matchErrorStatus(restException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(restException.getResponse().getStatus());\n       }\n     }\n     else if (throwable instanceof StreamException)\n     {\n       StreamException streamException = (StreamException) throwable;\n       if (streamException.getResponse() != null)\n       {\n-        return matchErrorStatus(streamException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(streamException.getResponse().getStatus());\n       }\n     }\n     return false;\n   }\n \n-  private boolean matchErrorStatus(int status) {\n-    return _errorStatusPattern.matcher(Integer.toString(status)).matches();\n+  public interface ErrorStatusMatch {\n+    boolean isError(int status);\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNjMxMw==", "bodyText": "if 'fromTarget' returns null (ie the given host is not in the list), should we retry with a host from Ring?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442506313", "createdAt": "2020-06-18T21:14:25Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY2NA==", "bodyText": "I'm trying to think how/when this will happen, because iterating through the trackerClients takes longer time. Guess it's safe because this happens rarely.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442510664", "createdAt": "2020-06-18T21:23:50Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromTarget(URI targetHostUri, RequestContext requestContext, Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient = trackerClients.get(targetHostUri);\n+\n+    if (trackerClient == null)\n+    {\n+      LOG.warn(\"No client found for \", targetHostUri, \". Target host specified is no longer part of cluster\");\n+    }\n+    else\n+    {\n+      // if this flag is set to be true, that means affinity routing is preferred but backup requests are still acceptable\n+      Boolean otherHostAcceptable = KeyMapper.TargetHostHints.getRequestContextOtherHostAcceptable(requestContext);\n+      if (otherHostAcceptable != null && otherHostAcceptable)\n+      {\n+        addToExcludedHosts(trackerClient, requestContext);\n+      }\n+    }\n+    return trackerClient;\n+  }\n+\n+  private TrackerClient getTrackerClientFromRing(Request request,\n+                                                 RequestContext requestContext,\n+                                                 Ring<URI> ring,\n+                                                 Map<URI, TrackerClient> trackerClients)\n+  {\n+    Set<URI> excludedUris = LoadBalancerStrategy.ExcludedHostHints.getRequestContextExcludedHosts(requestContext) == null\n+        ? new HashSet<>()\n+        : LoadBalancerStrategy.ExcludedHostHints.getRequestContextExcludedHosts(requestContext);\n+    int hashCode = _requestHashFunction.hash(request);\n+    URI uri = ring.get(hashCode);\n+\n+    TrackerClient trackerClient = trackerClients.get(uri);\n+\n+    if (trackerClient == null || excludedUris.contains(uri))\n+    {\n+      // Find next available URI.\n+      Iterator<URI> ringIterator = ring.getIterator(hashCode);\n+\n+      while (ringIterator.hasNext())\n+      {\n+        uri = ringIterator.next();\n+        trackerClient = trackerClients.get(uri);\n+\n+        if (trackerClient != null && !excludedUris.contains(uri))\n+        {\n+          break;\n+        }\n+      }\n+      trackerClient = null;\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick one from the tracker clients passed from the request if the ring is completely out of date", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA==", "bodyText": "shallowCopy?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442517074", "createdAt": "2020-06-18T21:38:30Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, HealthCheck> healthCheckMap,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _healthCheckMap = healthCheckMap;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionState copy()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODk4Mg==", "bodyText": "So if an application just grab ring for their use case (ie only use getRing), it is possible the state will never be updated if ring is not null?\nWe may consider to always invoke #updateState here. #getTrackerClient needs to get ring anyway.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442528982", "createdAt": "2020-06-18T22:08:41Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  private final StateUpdater _stateUpdater;\n+  private final ClientSelector _clientSelector;\n+\n+  public RelativeLoadBalancerStrategy(StateUpdater stateUpdater,\n+                                      ClientSelector clientSelector)\n+  {\n+    _stateUpdater = stateUpdater;\n+    _clientSelector = clientSelector;\n+  }\n+\n+  @Override\n+  public String getName()\n+  {\n+    return RELATIVE_LOAD_BALANCER_STRATEGY_NAME;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        long clusterGenerationId,\n+                                        int partitionId,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (trackerClients == null || trackerClients.size() == 0)\n+    {\n+      LOG.warn(\"getTrackerClient called with null/empty trackerClients, so returning null\");\n+      return null;\n+    }\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    Ring<URI> ring = getRing(clusterGenerationId, partitionId, trackerClients);\n+    return _clientSelector.getTrackerClient(request, requestContext, ring, trackerClients);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Ring<URI> getRing(long clusterGenerationId, int partitionId, Map<URI, TrackerClient> trackerClients)\n+  {\n+    Ring<URI> ring = _stateUpdater.getRing(partitionId);\n+    if (ring == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzYzMQ==", "bodyText": "Not necessarily bit savings, but we can lock by partitionId.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442533631", "createdAt": "2020-06-18T22:22:25Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    PartitionState partitionState = new PartitionState(partitionId,\n+            new DelegatingRingFactory<>(_relativeStrategyProperties.getRingProperties()),\n+            _relativeStrategyProperties.getRingProperties().getPointsPerWeight(),\n+            _listenerFactories.stream().map(factory -> factory.create(partitionId)).collect(Collectors.toList()));\n+\n+    _lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzU5Nw==", "bodyText": "For the fixed-schedule update, if another update triggered by clusterVersion happens in the middle, it is possible that we do not have sufficient data to adjust the pointsMap. Do we need to do something? I can think of:\n\ncancel next update and reschedule a new time (complicated).\nSet some threshold so that if it does not meet, we do not calculate a new healthScore. How to pick the threshold though is hard though (this is becomes variable intervals).", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442543597", "createdAt": "2020-06-18T22:54:10Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA==", "bodyText": "This interface really is LoadBalancerStrategy was targeted to do. Maybe we can combine them?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442546420", "createdAt": "2020-06-18T23:03:41Z", "author": {"login": "cx-super"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/45bb2989b15e0032c732be703262ca777b97568b", "committedDate": "2020-06-23T06:36:24Z", "message": "Addressed PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTc3Nzk2", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-436177796", "createdAt": "2020-06-23T21:39:44Z", "commit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "committedDate": "2020-06-24T00:39:46Z", "message": "Added some minor fixes including\n1. Removed unnecessary call triggered by concurrent cluster change requests\n2. Change \"toString\" implementation to make log more readable\n3. Other changes in unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDQ3MzI0", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-436047324", "createdAt": "2020-06-23T18:28:04Z", "commit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "state": "COMMENTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODozMzo0MFrOGn1qgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMDo0MlrOGoi9_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNjg4Mg==", "bodyText": "I'm a fan of adding javadoc that links to the actual class\n\"Test for {@link ClientSelector}.\"", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444426882", "createdAt": "2020-06-23T18:33:40Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTc0OA==", "bodyText": "move out any shared code; make tests as slim as possible. the only logic should be specific to what you're actually testing.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444429748", "createdAt": "2020-06-23T18:38:59Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTMwMQ==", "bodyText": "good practice to write the error message in the asserts too.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444431301", "createdAt": "2020-06-23T18:41:35Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, URI_1);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient.getUri(), URI_1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODE5OA==", "bodyText": "add test for ring and clients only partially out of sync\nand for partial exclusion\nassert that Client added to excluded hosts", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444438198", "createdAt": "2020-06-23T18:53:53Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, URI_1);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient.getUri(), URI_1);\n+  }\n+\n+  @Test\n+  public void testGetTargetHostNotFound() throws URISyntaxException {\n+    URI newUri = new URI(\"new_uri\");\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, newUri);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient, null);\n+  }\n+\n+  @Test\n+  public void testGetHostFromRing()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertTrue(DEFAULT_TRACKER_CLIENT_MAP.containsKey(trackerClient.getUri()));\n+  }\n+\n+  @Test\n+  public void testAllClientsExcluded()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_1);\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_2);\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_3);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient, null);\n+  }\n+\n+  @Test\n+  public void testRingAndHostInconsistency() throws URISyntaxException {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    URI newUri = new URI(\"new_uri\");\n+    TrackerClient newTrackerClient = Mockito.mock(TrackerClient.class);\n+    Mockito.when(newTrackerClient.getUri()).thenReturn(newUri);\n+    Map<URI, TrackerClient> newTrackerClientMap = new HashMap<>();\n+    newTrackerClientMap.put(newUri, newTrackerClient);\n+\n+    // Ring and the tracker clients are completely off so that they do not have any overlap\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, newTrackerClientMap);\n+    assertEquals(trackerClient, newTrackerClient);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODg2OA==", "bodyText": "should mock the ring so we can more easily test some of the cases suggested below", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444438868", "createdAt": "2020-06-23T18:55:03Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg==", "bodyText": "PartitionStateBuilder?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444519242", "createdAt": "2020-06-23T21:28:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/PartitionStateDataBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * The helper class that builds an object of {@link PartitionState}\n+ */\n+public class PartitionStateDataBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNTY2NA==", "bodyText": "Is this only for tests? Can we move to test directory?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444525664", "createdAt": "2020-06-23T21:43:13Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/PartitionStateDataBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * The helper class that builds an object of {@link PartitionState}\n+ */\n+public class PartitionStateDataBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg=="}, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNjAwOQ==", "bodyText": "should probably make this method idempotent", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444526009", "createdAt": "2020-06-23T21:44:09Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/PartitionStateDataBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * The helper class that builds an object of {@link PartitionState}\n+ */\n+public class PartitionStateDataBuilder {\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final int DEFAULT_POINTS_PER_WEIGHT = 100;\n+\n+  private final RingFactory<URI> _ringFactory;\n+  private long _clusterGenerationId;\n+  private Set<TrackerClient> _recoveryTrackerClients = new HashSet<>();\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap = new HashMap<>();\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap = new HashMap<>();\n+\n+  PartitionStateDataBuilder(RingFactory<URI> ringFactory)\n+  {\n+    _ringFactory = ringFactory;\n+    _clusterGenerationId = 0;\n+  }\n+\n+  PartitionStateDataBuilder setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+    return this;\n+  }\n+\n+  PartitionStateDataBuilder setTrackerClientStateMap(List<TrackerClient> trackerClients,\n+      List<Double> healthScores, List<TrackerClientState.HealthState> healthStates, List<Integer> callCountList,\n+      double initialHealthScore, int minCallCount)\n+  {\n+    if (trackerClients.size() != healthScores.size() || trackerClients.size() != healthStates.size() || trackerClients.size() != callCountList.size())\n+    {\n+      throw new IllegalArgumentException(\"The size of the tracker client and health scores have to match!\");\n+    }\n+    for (int index = 0; index < trackerClients.size(); index ++)\n+    {\n+      TrackerClientState trackerClientState = new TrackerClientState(initialHealthScore, minCallCount);\n+      trackerClientState.setHealthScore(healthScores.get(index));\n+      trackerClientState.setHealthState(healthStates.get(index));\n+      trackerClientState.setCallCount(callCountList.get(index));\n+      _trackerClientStateMap.put(trackerClients.get(index), trackerClientState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNjQ4NQ==", "bodyText": "Use SettableClock", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444526485", "createdAt": "2020-06-23T21:44:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyOTUxMw==", "bodyText": "2020", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444529513", "createdAt": "2020-06-23T21:51:26Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MjM3NQ==", "bodyText": "why mocking 2 in these tests?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445142375", "createdAt": "2020-06-24T20:08:33Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MzcyMQ==", "bodyText": "put in assert message instead of comment here and everywhere else", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445143721", "createdAt": "2020-06-24T20:11:18Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTk5NA==", "bodyText": "javadoc", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445145994", "createdAt": "2020-06-24T20:15:55Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientMockHelper.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.stats.LongStats;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.CallTrackerImpl;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+\n+import static org.mockito.Matchers.anyInt;\n+\n+\n+/**\n+ * The helper class that builds quick mock of {@link TrackerClient}\n+ */\n+public class TrackerClientMockHelper {\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      Mockito.when(trackerClient.getCallTracker()).thenReturn(new CallTrackerImpl(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS));\n+      Mockito.when(trackerClient.getUri()).thenReturn(uri);\n+      Mockito.when(trackerClient.getPartitionWeight(anyInt())).thenReturn(1.0);\n+      trackerClients.add(trackerClient);\n+    }\n+    return trackerClients;\n+  }\n+\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients, List<Integer> callCountList,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NjA1OQ==", "bodyText": "indentation", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445146059", "createdAt": "2020-06-24T20:16:03Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientMockHelper.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.stats.LongStats;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.CallTrackerImpl;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+\n+import static org.mockito.Matchers.anyInt;\n+\n+\n+/**\n+ * The helper class that builds quick mock of {@link TrackerClient}\n+ */\n+public class TrackerClientMockHelper {\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      Mockito.when(trackerClient.getCallTracker()).thenReturn(new CallTrackerImpl(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS));\n+      Mockito.when(trackerClient.getUri()).thenReturn(uri);\n+      Mockito.when(trackerClient.getPartitionWeight(anyInt())).thenReturn(1.0);\n+      trackerClients.add(trackerClient);\n+    }\n+    return trackerClients;\n+  }\n+\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients, List<Integer> callCountList,\n+      List<Integer> outstandingCallCountList, List<Long> latencyList, List<Long> outstandingLatencyList,\n+      List<Integer> errorCountList) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      CallTracker callTracker = Mockito.mock(CallTracker.class);\n+      LongStats longStats = new LongStats(callCountList.get(index), latencyList.get(index), 0, 0, 0, 0, 0, 0, 0);\n+      Map<ErrorType, Integer> errorTypeCounts = new HashMap<>();\n+      errorTypeCounts.put(ErrorType.SERVER_ERROR, errorCountList.get(index));\n+\n+      CallTrackerImpl.CallTrackerStats callStats = new CallTrackerImpl.CallTrackerStats(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+      0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODA1Mg==", "bodyText": "kind of hard to read these blocks. maybe organize them in individual lines? and use [] instead of Arrays.asList?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445148052", "createdAt": "2020-06-24T20:19:58Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODM3Nw==", "bodyText": "reference constant", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445148377", "createdAt": "2020-06-24T20:20:35Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setQuarantineMap(existingQuarantineMap)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (quarantineCheckResult)\n+    {\n+      // If quarantine check passed, verify the tracker client is put into recovery map, and the initial recovery rate is 0.01\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertEquals(state.getRecoveryTrackerClients().size(), 1);\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), 0.01);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0OTY3Mg==", "bodyText": "could probably just use 1 dataprovider named \"truefalse\" or \"enable\"", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445149672", "createdAt": "2020-06-24T20:23:05Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setQuarantineMap(existingQuarantineMap)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (quarantineCheckResult)\n+    {\n+      // If quarantine check passed, verify the tracker client is put into recovery map, and the initial recovery rate is 0.01\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertEquals(state.getRecoveryTrackerClients().size(), 1);\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), 0.01);\n+    } else\n+    {\n+      // Otherwise, the client stays in the quarantine map\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+    }\n+  }\n+\n+  @DataProvider(name = \"quarantineCheckResult\")\n+  Object[][] getQuarantineCheckResult()\n+  {\n+    return new Object[][]\n+        {\n+            {true},\n+            {false}\n+        };\n+  }\n+\n+  @Test(dataProvider = \"trackerClientState\")\n+  public void testFastRecoveryInRecoveryMap(int callCount, TrackerClientState.HealthState healthState, double healthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, true);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Set<TrackerClient> recoverySet = new HashSet<>();\n+    recoverySet.add(trackerClients.get(0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(healthScore, 0.6, 0.6),\n+            Arrays.asList(healthState, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(callCount, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setRecoveryClients(recoverySet)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (callCount <= RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+    {\n+      // Verify the health score doubled\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), healthScore * 2);\n+      assertTrue(state.getRecoveryTrackerClients().contains(trackerClients.get(0)));\n+    } else if (healthState != TrackerClientState.HealthState.UNHEALTHY && healthScore <= QuarantineManager.FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      // Verify the health score keeps the same, and the client is still in recovery map\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), healthScore);\n+      assertTrue(state.getRecoveryTrackerClients().contains(trackerClients.get(0)));\n+    } else\n+    {\n+      // Verify the client comes out of recovery map\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClientState\")\n+  Object[][] getTrackerClientStates()\n+  {\n+    return new Object[][]\n+        {\n+            {0, TrackerClientState.HealthState.NEUTRAL, 0.01},\n+            {15, TrackerClientState.HealthState.UNHEALTHY, 0.01},\n+            {15, TrackerClientState.HealthState.UNHEALTHY, 0.6},\n+            {15, TrackerClientState.HealthState.HEALTHY, 0.01}\n+        };\n+  }\n+\n+  @Test(dataProvider = \"enableFastRecovery\")\n+  public void testEnrollNewClientInRecoveryMap(boolean fastRecoveryEnabled) throws URISyntaxException\n+  {\n+    setup(0.5, true, fastRecoveryEnabled);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState oldState = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),\n+            Collections.emptyList(), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+    PartitionState newState = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(0.01, 0.01),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(newState, oldState, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (fastRecoveryEnabled)\n+    {\n+      assertEquals(newState.getRecoveryTrackerClients().size(), 2);\n+    } else\n+    {\n+      assertTrue(newState.getRecoveryTrackerClients().isEmpty());\n+    }\n+  }\n+\n+  @DataProvider(name = \"enableFastRecovery\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bb2989b15e0032c732be703262ca777b97568b"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDMwMQ==", "bodyText": "is this line necessary? it's a void method anyway.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445160301", "createdAt": "2020-06-24T20:43:37Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTkyMQ==", "bodyText": "test concurrency too", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445161921", "createdAt": "2020-06-24T20:46:43Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzU2Ng==", "bodyText": "is factory passed in ever not a \"new DistributionNonDiscreteRingFactory\"? can we just hide that in the Builder?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445163566", "createdAt": "2020-06-24T20:49:54Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTI5MA==", "bodyText": "better if we verify that w ecreated a new partition state than that executor was called.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445165290", "createdAt": "2020-06-24T20:53:10Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzEzNw==", "bodyText": "instead of 80 can we do heathypoints - downStep?", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445167137", "createdAt": "2020-06-24T20:56:43Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Nzk5Mw==", "bodyText": "what is small call count", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445167993", "createdAt": "2020-06-24T20:58:29Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);\n+  }\n+\n+  @Test\n+  public void testUpdateMultiplePartitions()\n+  {\n+    /**\n+     * There are 2 partitions, and 4 tracker clients in total.\n+     * Partition 0 contains tracker client 1,2,3\n+     * Partition 1 contains tracker client 3,4\n+     * TrackerClient 3 will be unhealthy in partition 0, but not in partition 1\n+     */\n+    List<TrackerClient> trackerClients1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+    List<TrackerClient> trackerClients2 = TrackerClientMockHelper.mockTrackerClients(1,\n+        Arrays.asList(20), Arrays.asList(10), Arrays.asList(1000L),\n+        Arrays.asList(600L), Arrays.asList(0));\n+    trackerClients2.add(trackerClients1.get(2));\n+\n+    PartitionState state1 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients1, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+    PartitionState state2 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients2, Arrays.asList(1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(0, state1);\n+    partitionLoadBalancerStateMap.put(1, state2);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    URI overlapUri = trackerClients1.get(2).getUri();\n+\n+    // Verify the host has 80 points in partition 0, 100 points in partition 1\n+    assertEquals(partitionLoadBalancerStateMap.get(0).getPointsMap().get(overlapUri).intValue(), 80);\n+    assertEquals(partitionLoadBalancerStateMap.get(1).getPointsMap().get(overlapUri).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterUrisChange()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 220L, 1000L),\n+        Arrays.asList(100L, 110L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    // New tracker clients set only contains 2 out of 3 tracker clients from the old state\n+    Set<TrackerClient> newTrackerClientSet = new HashSet<>();\n+    newTrackerClientSet.add(trackerClients.get(0));\n+    newTrackerClientSet.add(trackerClients.get(1));\n+    _stateUpdater.updateStateForPartition(newTrackerClientSet, DEFAULT_PARTITION_ID, state, 1L);\n+\n+    // Verify there are only 2 URIs in the points map\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    assertEquals(pointsMap.size(), 2);\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"trackerClients\")\n+  public void testHealthScoreDropByLatency(List<TrackerClient> trackerClients, double highLatencyFactor,\n+      double highErrorRate, boolean expectToDropHealthScore)\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties()\n+            .setRelativeLatencyHighThresholdFactor(highLatencyFactor).setHighErrorRate(highErrorRate),\n+        partitionLoadBalancerStateMap);\n+    _stateUpdater.updateState();\n+\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    if (!expectToDropHealthScore)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      // Experiment 1 dropped because of latency, experiment 2 dropped because of outstanding latency\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 80);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClients\")\n+  Object[][] getTrackerClients()\n+  {\n+    List<Long> defaultLatencyList = Arrays.asList(100L, 100L, 100L);\n+    List<Long> defaultOutstandingLatencyList = Arrays.asList(20L, 20L, 20L);\n+    List<Integer> defaultCallCountList = Arrays.asList(20, 20, 20);\n+    List<Integer> defaultOutstandingCountList = Arrays.asList(10, 10, 10);\n+    List<Integer> defaultErrorCountList = Arrays.asList(0, 0, 0);\n+    double defaultHighLatencyFactor = 1.2;\n+    double defaultHighErrorRate = 0.2;\n+    int numTrackerClients = 3;\n+    return new Object[][]\n+        {\n+            // Test with different latency and outstanding latencies\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(200L, 220L, 200L), Arrays.asList(100L, 110L, 100L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 120L, 115L), Arrays.asList(20L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(100L, 120L, 115L), Arrays.asList(1000L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 500L, 600L), Arrays.asList(900L, 700L, 800L), defaultErrorCountList), 1.5, defaultHighErrorRate, false},\n+\n+            // Test with different error count and error rates\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, 0.09, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, 0.3, false}\n+        };\n+  }\n+\n+  @Test\n+  public void testSmallCallCount()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTE1MQ==", "bodyText": "add test that verifies the executor is scheduled to run updateState periodically.", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445169151", "createdAt": "2020-06-24T21:00:42Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);\n+  }\n+\n+  @Test\n+  public void testUpdateMultiplePartitions()\n+  {\n+    /**\n+     * There are 2 partitions, and 4 tracker clients in total.\n+     * Partition 0 contains tracker client 1,2,3\n+     * Partition 1 contains tracker client 3,4\n+     * TrackerClient 3 will be unhealthy in partition 0, but not in partition 1\n+     */\n+    List<TrackerClient> trackerClients1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+    List<TrackerClient> trackerClients2 = TrackerClientMockHelper.mockTrackerClients(1,\n+        Arrays.asList(20), Arrays.asList(10), Arrays.asList(1000L),\n+        Arrays.asList(600L), Arrays.asList(0));\n+    trackerClients2.add(trackerClients1.get(2));\n+\n+    PartitionState state1 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients1, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+    PartitionState state2 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients2, Arrays.asList(1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(0, state1);\n+    partitionLoadBalancerStateMap.put(1, state2);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    URI overlapUri = trackerClients1.get(2).getUri();\n+\n+    // Verify the host has 80 points in partition 0, 100 points in partition 1\n+    assertEquals(partitionLoadBalancerStateMap.get(0).getPointsMap().get(overlapUri).intValue(), 80);\n+    assertEquals(partitionLoadBalancerStateMap.get(1).getPointsMap().get(overlapUri).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterUrisChange()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 220L, 1000L),\n+        Arrays.asList(100L, 110L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    // New tracker clients set only contains 2 out of 3 tracker clients from the old state\n+    Set<TrackerClient> newTrackerClientSet = new HashSet<>();\n+    newTrackerClientSet.add(trackerClients.get(0));\n+    newTrackerClientSet.add(trackerClients.get(1));\n+    _stateUpdater.updateStateForPartition(newTrackerClientSet, DEFAULT_PARTITION_ID, state, 1L);\n+\n+    // Verify there are only 2 URIs in the points map\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    assertEquals(pointsMap.size(), 2);\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"trackerClients\")\n+  public void testHealthScoreDropByLatency(List<TrackerClient> trackerClients, double highLatencyFactor,\n+      double highErrorRate, boolean expectToDropHealthScore)\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties()\n+            .setRelativeLatencyHighThresholdFactor(highLatencyFactor).setHighErrorRate(highErrorRate),\n+        partitionLoadBalancerStateMap);\n+    _stateUpdater.updateState();\n+\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    if (!expectToDropHealthScore)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      // Experiment 1 dropped because of latency, experiment 2 dropped because of outstanding latency\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 80);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClients\")\n+  Object[][] getTrackerClients()\n+  {\n+    List<Long> defaultLatencyList = Arrays.asList(100L, 100L, 100L);\n+    List<Long> defaultOutstandingLatencyList = Arrays.asList(20L, 20L, 20L);\n+    List<Integer> defaultCallCountList = Arrays.asList(20, 20, 20);\n+    List<Integer> defaultOutstandingCountList = Arrays.asList(10, 10, 10);\n+    List<Integer> defaultErrorCountList = Arrays.asList(0, 0, 0);\n+    double defaultHighLatencyFactor = 1.2;\n+    double defaultHighErrorRate = 0.2;\n+    int numTrackerClients = 3;\n+    return new Object[][]\n+        {\n+            // Test with different latency and outstanding latencies\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(200L, 220L, 200L), Arrays.asList(100L, 110L, 100L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 120L, 115L), Arrays.asList(20L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(100L, 120L, 115L), Arrays.asList(1000L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 500L, 600L), Arrays.asList(900L, 700L, 800L), defaultErrorCountList), 1.5, defaultHighErrorRate, false},\n+\n+            // Test with different error count and error rates\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, 0.09, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, 0.3, false}\n+        };\n+  }\n+\n+  @Test\n+  public void testSmallCallCount()\n+  {\n+    int minCallCount = 10;\n+    // One client has high latency but small call count\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(5, 20, 20), Arrays.asList(0, 0, 0), Arrays.asList(1000L, 300L, 300L),\n+        Arrays.asList(100L, 200L, 200L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(5, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE, minCallCount)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties().setMinCallCount(minCallCount),\n+        partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify the host with high latency still has 100 points\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"slowStartThreshold\")\n+  public void testHealthScoreRecover(double currentHealthScore, double slowStartThreshold)\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(0, 0, 0), Arrays.asList(300L, 300L, 300L),\n+        Arrays.asList(200L, 200L, 200L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(currentHealthScore, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties().setSlowStartThreshold(slowStartThreshold),\n+        partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    if (slowStartThreshold == RelativeLoadBalancerStrategyFactory.DEFAULT_SLOW_START_THRESHOLD)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 5);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else if (currentHealthScore == 0.0)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 1);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else if (currentHealthScore == 0.1)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 20);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 30);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"slowStartThreshold\")\n+  Object[][] getSlowStartThreshold()\n+  {\n+    return new Object[][]\n+        {\n+            {0.0, 0.0},\n+            {0.0, 0.2},\n+            {0.1, 0.2},\n+            {0.25, 0.2}\n+        };\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "originalPosition": 359}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDA2MDk4", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-437006098", "createdAt": "2020-06-24T21:05:22Z", "commit": {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "675cd6c14188f699b77b40985463e50fd9db4bb1", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/675cd6c14188f699b77b40985463e50fd9db4bb1", "committedDate": "2020-07-01T08:04:53Z", "message": "Fixed unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d415acb6667e27eab4f0096fb1b5919667c57b9", "author": {"user": {"login": "rachelhanhan", "name": "Ruxin Han"}}, "url": "https://github.com/linkedin/rest.li/commit/1d415acb6667e27eab4f0096fb1b5919667c57b9", "committedDate": "2020-07-01T08:16:33Z", "message": "Error message update in unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDM0OTQx", "url": "https://github.com/linkedin/rest.li/pull/310#pullrequestreview-447434941", "createdAt": "2020-07-13T17:01:25Z", "commit": {"oid": "1d415acb6667e27eab4f0096fb1b5919667c57b9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4815, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}