{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NjY3MDk4", "number": 339, "title": "Add PathSpecSet: a set of PathSpecSet with support for full projection", "bodyText": "The PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "createdAt": "2020-06-23T15:58:44Z", "url": "https://github.com/linkedin/rest.li/pull/339", "merged": true, "mergeCommit": {"oid": "faac9fd13a8911b90adc4cd4125818447c0c8104"}, "closed": true, "closedAt": "2021-02-09T22:57:09Z", "author": {"login": "GuiForget"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdE__mOgBqjM3MjExMjQ3MjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd4i2WiABqjQzMTE1NzQ1MDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1e7c37663100a3644024c74e8f160f3a9f64f1b", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/b1e7c37663100a3644024c74e8f160f3a9f64f1b", "committedDate": "2020-09-02T18:03:11Z", "message": "Add new tests for MaskCreator"}, "afterCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/5c96e81dbe52a18bfae0084f36d3346de45e11ca", "committedDate": "2020-09-02T18:05:39Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzcyMjA5", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-484372209", "createdAt": "2020-09-08T17:58:30Z", "commit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1ODozMFrOHOoI_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1ODozMFrOHOoI_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTc3Mg==", "bodyText": "braces on new line?", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485099772", "createdAt": "2020-09-08T17:58:30Z", "author": {"login": "BrianPin"}, "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java", "diffHunk": "@@ -57,6 +57,23 @@ public static MaskTree createPositiveMask(Collection<PathSpec> paths)\n     return createMaskTree(paths, MaskOperation.POSITIVE_MASK_OP);\n   }\n \n+  /**\n+   * Create a positive mask for the given set.\n+   *\n+   * @param pathSpecSet the set that should be in the mask\n+   * @return a {@link MaskTree}\n+   */\n+  public static MaskTree createPositiveMask(PathSpecSet pathSpecSet)\n+  {\n+    if (pathSpecSet.isFullProjection()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzcyNDkw", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-484372490", "createdAt": "2020-09-08T17:58:53Z", "commit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1ODo1M1rOHOoJzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1ODo1M1rOHOoJzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTk4MQ==", "bodyText": "braces on new line?", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485099981", "createdAt": "2020-09-08T17:58:53Z", "author": {"login": "BrianPin"}, "path": "data-transform/src/test/java/com/linkedin/data/transform/filter/TestMaskCreation.java", "diffHunk": "@@ -370,4 +372,34 @@ public void testComposingNegativeMaskWithPositiveSubmasks() throws IOException\n     mask.addOperation(new PathSpec(\"a\"), MaskOperation.NEGATIVE_MASK_OP);\n     Assert.assertEquals(mask.toString(), \"{a=0}\");\n   }\n+\n+  @Test(dataProvider = \"pathSpecSetProvider\")\n+  public void testPositiveMaskWithPathSpecSet(PathSpecSet input, MaskTree expected) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MTczNjgy", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-485173682", "createdAt": "2020-09-09T16:02:54Z", "commit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjowMjo1NFrOHPOd-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjowMjo1NFrOHPOd-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyNzczOQ==", "bodyText": "Might as well add copy-right file headers?", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485727739", "createdAt": "2020-09-09T16:02:54Z", "author": {"login": "BrianPin"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MTc0NDI0", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-485174424", "createdAt": "2020-09-09T16:03:41Z", "commit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MzI3NDA4", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-485327408", "createdAt": "2020-09-09T19:17:37Z", "commit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOToxNzozOFrOHPWLOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTozMDowNlrOHPWpyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NDAxMA==", "bodyText": "remove the _ prefix (not the convention followed in this project)", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485854010", "createdAt": "2020-09-09T19:17:38Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1OTU5Nw==", "bodyText": "initialize size to parent path size + child path size", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485859597", "createdAt": "2020-09-09T19:27:06Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder) {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection) {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs) {\n+    if (pathSpecs.isEmpty()) {\n+      return empty();\n+    } else {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs) {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty() {\n+    return _EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection() {\n+    return _FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray() {\n+    if (_fullProjection) {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder() {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs() {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty() {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection() {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec) {\n+    if (_fullProjection) {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"bar\"\n+   *     },\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"baz\"\n+   *     }\n+   *   ]\n+   * }\n+   *\n+   * {\n+   *   \"type\": \"Zing\"\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"Foo\",\n+   *       \"name\": \"foo\"\n+   *     }\n+   *   ]\n+   * }\n+   * </pre>\n+   *\n+   * If you want to only fetch the \"bar\" field from a \"Zing\" record you might make a {@link PathSpecSet} like this:\n+   * {@code PathSpecSet.of(Zing.fields().foo().bar()}.\n+   *\n+   * However, suppose you already have a {@link PathSpecSet} from the perspective of \"Foo\" but need a\n+   * {@link PathSpecSet} for your \"Zing\" downstream.  This method make this easy:\n+   * {@code\n+   *   PathSpecSet fooPathSpecSet = PathSpecSet.of(Foo.fields().bar());\n+   *   PathSpecSet zingPathSpecSet = fooPathSpecSet.copyWithScope(Zing.fields().foo());\n+   *\n+   *   zingPathSpecSet.equals(PathSpecSet.of(Zing.fields().foo().bar()); // true\n+   * }\n+   *\n+   * If you scope an empty {@link PathSpecSet} it remains empty.\n+   *\n+   * @param parent the parent {@link PathSpec} to use when scoping the contained {@link PathSpec}s\n+   * @return a new {@link PathSpecSet} that is scoped to the new parent\n+   */\n+  public PathSpecSet copyWithScope(PathSpec parent) {\n+    if (this.isFullProjection()) {\n+      return PathSpecSet.of(parent);\n+    }\n+\n+    if (this.isEmpty()) {\n+      return PathSpecSet.empty();\n+    }\n+\n+    Builder builder = newBuilder();\n+\n+    this.getPathSpecs().stream()\n+        .map(childPathSpec -> {\n+          ArrayList<String> list = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MTgzNA==", "bodyText": "This should check for the prefix or any parent of the perfix, right?", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485861834", "createdAt": "2020-09-09T19:30:06Z", "author": {"login": "karthikbalasub"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder) {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection) {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs) {\n+    if (pathSpecs.isEmpty()) {\n+      return empty();\n+    } else {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs) {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty() {\n+    return _EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection() {\n+    return _FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray() {\n+    if (_fullProjection) {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder() {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs() {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty() {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection() {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec) {\n+    if (_fullProjection) {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"bar\"\n+   *     },\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"baz\"\n+   *     }\n+   *   ]\n+   * }\n+   *\n+   * {\n+   *   \"type\": \"Zing\"\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"Foo\",\n+   *       \"name\": \"foo\"\n+   *     }\n+   *   ]\n+   * }\n+   * </pre>\n+   *\n+   * If you want to only fetch the \"bar\" field from a \"Zing\" record you might make a {@link PathSpecSet} like this:\n+   * {@code PathSpecSet.of(Zing.fields().foo().bar()}.\n+   *\n+   * However, suppose you already have a {@link PathSpecSet} from the perspective of \"Foo\" but need a\n+   * {@link PathSpecSet} for your \"Zing\" downstream.  This method make this easy:\n+   * {@code\n+   *   PathSpecSet fooPathSpecSet = PathSpecSet.of(Foo.fields().bar());\n+   *   PathSpecSet zingPathSpecSet = fooPathSpecSet.copyWithScope(Zing.fields().foo());\n+   *\n+   *   zingPathSpecSet.equals(PathSpecSet.of(Zing.fields().foo().bar()); // true\n+   * }\n+   *\n+   * If you scope an empty {@link PathSpecSet} it remains empty.\n+   *\n+   * @param parent the parent {@link PathSpec} to use when scoping the contained {@link PathSpec}s\n+   * @return a new {@link PathSpecSet} that is scoped to the new parent\n+   */\n+  public PathSpecSet copyWithScope(PathSpec parent) {\n+    if (this.isFullProjection()) {\n+      return PathSpecSet.of(parent);\n+    }\n+\n+    if (this.isEmpty()) {\n+      return PathSpecSet.empty();\n+    }\n+\n+    Builder builder = newBuilder();\n+\n+    this.getPathSpecs().stream()\n+        .map(childPathSpec -> {\n+          ArrayList<String> list = new ArrayList<>();\n+          list.addAll(parent.getPathComponents());\n+          list.addAll(childPathSpec.getPathComponents());\n+          return list;\n+        })\n+        .map(PathSpec::new)\n+        .forEach(builder::add);\n+\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where only {@link PathSpec}s that are prefixed with the input {@link PathSpec} are retained.\n+   *\n+   * Additionally, the prefix is removed for the retained {@link PathSpec}s.\n+   *\n+   * Here are some examples showing the functionality:\n+   *\n+   * {@code\n+   *   // This PathSpecSet is empty because no PathSpecs originally contained start with \"abc\"\n+   *   PathSpecSet emptyPathSpecSet = PathSpecSet.of(Foo.fields().bar().baz()).copyAndRemovePrefix(Foo.fields().abc());\n+   *\n+   *   // This PathSpecSet is full because it contains the entire prefix PathSpec\n+   *   PathSpecSet fullPathSpecSet = PathSpecSet.of(Foo.fields().bar()).copyAndRemovePrefix(Foo.fields().bar())\n+   *\n+   *   // The following \"equals\" evaluates to true\n+   *   PathSpecSet prefixRemovedPathSpecSet = PathSpecSet.of(Foo.fields().bar().baz(), Foo.fields().bar().abc()).copyAndRemovePrefix(Foo.fields().bar());\n+   *   prefixRemovedPathSpecSet.equals(PathSpecSet.of(new PathSpec(\"baz\"), new PathSpec(\"abc\")));\n+   * }\n+   *\n+   * @param prefix the {@link PathSpec} prefix to use when retaining {@link PathSpec}s.\n+   * @return a {@link PathSpecSet} with elements starting with the input {@link PathSpec} prefix\n+   */\n+  public PathSpecSet copyAndRemovePrefix(PathSpec prefix) {\n+    if (isFullProjection() || isEmpty()) {\n+      // full or empty projections stay the same\n+      return this;\n+    }\n+\n+    // if we contain the exact prefix PathSpec, it should be a full projection\n+    if (getPathSpecs().contains(prefix)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca"}, "originalPosition": 267}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1131d209d75f8233a795ea11c3a7b357343a43b", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/d1131d209d75f8233a795ea11c3a7b357343a43b", "committedDate": "2020-10-16T18:48:00Z", "message": "Merge remote-tracking branch 'origin/master' into path_spec_set"}, "afterCommit": {"oid": "2784abab006e8f2c2c90925e51cb37131fa8bac6", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/2784abab006e8f2c2c90925e51cb37131fa8bac6", "committedDate": "2020-10-16T22:00:15Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2784abab006e8f2c2c90925e51cb37131fa8bac6", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/2784abab006e8f2c2c90925e51cb37131fa8bac6", "committedDate": "2020-10-16T22:00:15Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}, "afterCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/2c810667d15d73cfc38840fb82fc27a5c2caaf41", "committedDate": "2020-11-03T20:23:38Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDUzOTQ2", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-541453946", "createdAt": "2020-12-01T02:59:22Z", "commit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMjo1OToyMlrOH8WRkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNDo0Mzo1OFrOH8X_ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MTU1Mw==", "bodyText": "nit: write records in PDL, not PDSC", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533041553", "createdAt": "2020-12-01T02:59:22Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet\n+{\n+  private final static PathSpecSet EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder)\n+  {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection)\n+  {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs)\n+  {\n+    if (pathSpecs.isEmpty())\n+    {\n+      return empty();\n+    }\n+    else\n+    {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs)\n+  {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder()\n+  {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty()\n+  {\n+    return EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection()\n+  {\n+    return FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray()\n+  {\n+    if (_fullProjection)\n+    {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder()\n+  {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs()\n+  {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty()\n+  {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection()\n+  {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec)\n+  {\n+    if (_fullProjection)\n+    {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODE2OQ==", "bodyText": "For all javadocs in this class, I'd suggest providing examples using the serialized pathspec syntax (e.g. /foo/bar, /foo) for clarity, especially in more complicated examples (e.g. copy with scope, remove prefix)", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068169", "createdAt": "2020-12-01T04:38:15Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODIxMg==", "bodyText": "Should say 2020", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068212", "createdAt": "2020-12-01T04:38:23Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODQzNQ==", "bodyText": "typo: explicitly", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068435", "createdAt": "2020-12-01T04:39:14Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODg1MA==", "bodyText": "nit: capitalize as \"Rest.li\"", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068850", "createdAt": "2020-12-01T04:40:29Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA==", "bodyText": "I'm skeptical about using the terminology \"full projection\", as PathSpecs are not inherently tied to Rest.li projections (that's just one application). However, one could make the argument that the term \"projection\" is a generic term and isn't implying that it's used for Rest.li projections. What do you think?\nI'm also curious to know how a \"full projection\" PathSpecSet is used. Do you have an example of one use case?", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533069668", "createdAt": "2020-12-01T04:43:58Z", "author": {"login": "evanw555"}, "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet\n+{\n+  private final static PathSpecSet EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/2c810667d15d73cfc38840fb82fc27a5c2caaf41", "committedDate": "2020-11-03T20:23:38Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}, "afterCommit": {"oid": "6cc0dd2594300283d740d6baeb249a5c5d420d4a", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/6cc0dd2594300283d740d6baeb249a5c5d420d4a", "committedDate": "2020-12-12T21:15:54Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6cc0dd2594300283d740d6baeb249a5c5d420d4a", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/6cc0dd2594300283d740d6baeb249a5c5d420d4a", "committedDate": "2020-12-12T21:15:54Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}, "afterCommit": {"oid": "f01b84828e3ab6423be107a45b9839bb89edeccc", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/f01b84828e3ab6423be107a45b9839bb89edeccc", "committedDate": "2021-02-08T19:53:34Z", "message": "Rename fullProjection -> allInclusive"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2OTMwMDI3", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-586930027", "createdAt": "2021-02-09T19:33:14Z", "commit": {"oid": "f01b84828e3ab6423be107a45b9839bb89edeccc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3MDI1OTkz", "url": "https://github.com/linkedin/rest.li/pull/339#pullrequestreview-587025993", "createdAt": "2021-02-09T21:27:07Z", "commit": {"oid": "4f07284af246a11d4c5f95b042dcf16c73366da0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45e706af8e947978e2372cd38ecfd62c31b8a34e", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/45e706af8e947978e2372cd38ecfd62c31b8a34e", "committedDate": "2021-02-09T21:32:55Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f07284af246a11d4c5f95b042dcf16c73366da0", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/4f07284af246a11d4c5f95b042dcf16c73366da0", "committedDate": "2021-02-09T20:31:53Z", "message": "Add entry to changelog"}, "afterCommit": {"oid": "45e706af8e947978e2372cd38ecfd62c31b8a34e", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/45e706af8e947978e2372cd38ecfd62c31b8a34e", "committedDate": "2021-02-09T21:32:55Z", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4861, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}