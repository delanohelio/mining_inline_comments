{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNjI1MjA4", "number": 196, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoyMjowN1rODjj9jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowOToxNFrODjsmmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjE1OTUxOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoyMjowN1rOFvcH4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMTowODowNFrOFvhO4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4ODE2MQ==", "bodyText": "Should we provide an example of deprecation which doesn't have any string value?", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385288161", "createdAt": "2020-02-27T18:22:07Z", "author": {"login": "nickibi"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as\n+optional using the `optional` keyword. An optional field may be present or\n+absent in the in-memory data structure or serialized data.\n+\n+In the generated client bindings, pegasus provides has[Field] methods(eg,\n+`hasBirthDay()`) to determine if an optional field is present.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+}\n+```\n+The above example defines the `birthDay` field as optional.\n+\n+#### Record fields may have default values.\n+Pegasus supports specifying default values for fields. Though the definition\n+language allows default values for both required and optional fields, it is\n+recommended to use default values only for required fields.\n+\n+The default value for a field is expressed as a JSON value confirming to the\n+type of the field.\n+\n+In Pegasus generated bindings, the get[Field] accessors will return the value of\n+the field it is present or the default value from the schema if the field is\n+absent. The bindings also provide a specialized get accessor that allows the\n+caller to specify whether the default value or null should be returned when an\n+absent field is accessed.\n+\n+See [GetMode](https://linkedin.github.io/rest.li/java_binding#getmode) for more\n+details on accessing optional fields and default values.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import org.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+}\n+```\n+The above example defines a boolean field `isActive`, which has a default value\n+`true`.\n+\n+### Inlined schemas\n+In pegasus, records and other named schemas need not be top-level schemas. They\n+can be inlined within other record schemas.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+`Address` record in the above example is inlined. It inherits the namespace of\n+the parent record `User`, making its fully qualified name `com.example.models.Address`.\n+\n+* Namespace of inline types can be specified/overriden by defining a Namespace\n+surrounding the inlined type.\n+* The default value of fields using inlined types can be expressed using its\n+serialized JSON representation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+  address: {\n+    namespace com.example.models.address\n+\n+    record Address {\n+      state: string\n+      zipCode: string\n+    }\n+  } = {\n+    \"state\": \"CA\",\n+    \"zipCode\": \"12345\"\n+  }\n+}\n+```\n+***Note:*** If a record or a named schema is referenced by other schemas, it should\n+be a top-level schema. Referencing in-line schemas outside the schema in which\n+they are defined is not allowed.\n+\n+### Doc Strings\n+\n+Pegasus types and fields may be documented using \u201cdoc strings\u201d following the\n+Java style comments.\n+* Comments using `/** */` syntax are treated as schema documentation. They will\n+be included in the in-memory representation and the generated binding classes.\n+* Comments using `/* */` or `//` syntax are allowed but not treated as schema\n+documentation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+/**\n+ * A record representing an user in the system.\n+ */\n+record User {\n+  /** First name of the user */\n+  firstName: string\n+\n+  /** User's birth day */\n+  birthDay: optional Date\n+\n+  // TODO: Can this be an enum?\n+  /** Status of the user. */\n+  isActive: boolean = true\n+}\n+```\n+\n+### Deprecation\n+Pegasus supports marking types or fields as deprecated by adding `@deprecated`\n+annotation. The deprecation details from the schema will be carried over to the\n+bindings generated in  different languages.\n+In Java language, the classes, getter and setter methods generated for\n+deprecated types will be marked as deprecated.\n+\n+It is recommended to specify a string describing the reason for deprecation and\n+the alternative as the value for the `@deprecated` annotation.\n+\n+Deprecate a field:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+\n+  @deprecated = \"Use birthDay instead.\"\n+  birthYear: int\n+\n+  birthDay: Date  \n+}\n+```\n+Deprecate a record:\n+```pdl\n+namespace com.example.models\n+\n+@deprecated = \"Use Person type instead.\"\n+record User {\n+  firstName: string\n+}\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3MTg3Mw==", "bodyText": "I went back and forth on this: Should this doc provide examples for all supported features?.\nI finally decided to skip some features that are not recommended and have better alternative.\nThis was one of them. Another example is specifying default for optional field.", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385371873", "createdAt": "2020-02-27T21:08:04Z", "author": {"login": "karthikbalasub"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as\n+optional using the `optional` keyword. An optional field may be present or\n+absent in the in-memory data structure or serialized data.\n+\n+In the generated client bindings, pegasus provides has[Field] methods(eg,\n+`hasBirthDay()`) to determine if an optional field is present.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+}\n+```\n+The above example defines the `birthDay` field as optional.\n+\n+#### Record fields may have default values.\n+Pegasus supports specifying default values for fields. Though the definition\n+language allows default values for both required and optional fields, it is\n+recommended to use default values only for required fields.\n+\n+The default value for a field is expressed as a JSON value confirming to the\n+type of the field.\n+\n+In Pegasus generated bindings, the get[Field] accessors will return the value of\n+the field it is present or the default value from the schema if the field is\n+absent. The bindings also provide a specialized get accessor that allows the\n+caller to specify whether the default value or null should be returned when an\n+absent field is accessed.\n+\n+See [GetMode](https://linkedin.github.io/rest.li/java_binding#getmode) for more\n+details on accessing optional fields and default values.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import org.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+}\n+```\n+The above example defines a boolean field `isActive`, which has a default value\n+`true`.\n+\n+### Inlined schemas\n+In pegasus, records and other named schemas need not be top-level schemas. They\n+can be inlined within other record schemas.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+`Address` record in the above example is inlined. It inherits the namespace of\n+the parent record `User`, making its fully qualified name `com.example.models.Address`.\n+\n+* Namespace of inline types can be specified/overriden by defining a Namespace\n+surrounding the inlined type.\n+* The default value of fields using inlined types can be expressed using its\n+serialized JSON representation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: optional Date\n+  isActive: boolean = true\n+  address: {\n+    namespace com.example.models.address\n+\n+    record Address {\n+      state: string\n+      zipCode: string\n+    }\n+  } = {\n+    \"state\": \"CA\",\n+    \"zipCode\": \"12345\"\n+  }\n+}\n+```\n+***Note:*** If a record or a named schema is referenced by other schemas, it should\n+be a top-level schema. Referencing in-line schemas outside the schema in which\n+they are defined is not allowed.\n+\n+### Doc Strings\n+\n+Pegasus types and fields may be documented using \u201cdoc strings\u201d following the\n+Java style comments.\n+* Comments using `/** */` syntax are treated as schema documentation. They will\n+be included in the in-memory representation and the generated binding classes.\n+* Comments using `/* */` or `//` syntax are allowed but not treated as schema\n+documentation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+/**\n+ * A record representing an user in the system.\n+ */\n+record User {\n+  /** First name of the user */\n+  firstName: string\n+\n+  /** User's birth day */\n+  birthDay: optional Date\n+\n+  // TODO: Can this be an enum?\n+  /** Status of the user. */\n+  isActive: boolean = true\n+}\n+```\n+\n+### Deprecation\n+Pegasus supports marking types or fields as deprecated by adding `@deprecated`\n+annotation. The deprecation details from the schema will be carried over to the\n+bindings generated in  different languages.\n+In Java language, the classes, getter and setter methods generated for\n+deprecated types will be marked as deprecated.\n+\n+It is recommended to specify a string describing the reason for deprecation and\n+the alternative as the value for the `@deprecated` annotation.\n+\n+Deprecate a field:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+\n+  @deprecated = \"Use birthDay instead.\"\n+  birthYear: int\n+\n+  birthDay: Date  \n+}\n+```\n+Deprecate a record:\n+```pdl\n+namespace com.example.models\n+\n+@deprecated = \"Use Person type instead.\"\n+record User {\n+  firstName: string\n+}\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4ODE2MQ=="}, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjE3MjAyOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoyNTo0OVrOFvcPzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzo1NjowMVrOFvlSFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MDE4OQ==", "bodyText": "Pegasus should start with capital letter? If yes, please fix other places as well.", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385290189", "createdAt": "2020-02-27T18:25:49Z", "author": {"login": "nickibi"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxNjU1MA==", "bodyText": "This is a good question. I can never decide which way it is tbh", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385316550", "createdAt": "2020-02-27T19:15:02Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MDE4OQ=="}, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3MDYxOQ==", "bodyText": "I'm considering to update based on this rule:\n\nUse \"Pegasus\" when the doc is talking about the Pegasus framework.\nUse \"pegasus\" otherwise, eg, pegasus file, pegasus schema.\n\nWhat do you think?", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385370619", "createdAt": "2020-02-27T21:05:06Z", "author": {"login": "karthikbalasub"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MDE4OQ=="}, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODIyOQ==", "bodyText": "Decided to use \"Pegasus\" everywhere", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385438229", "createdAt": "2020-02-27T23:56:01Z", "author": {"login": "karthikbalasub"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthDay`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthDay` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In pegasus, a field is required unless the field is explicitly declared as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MDE4OQ=="}, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM0NTg4OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxODozMFrOFvd-JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxODozMFrOFvd-JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxODQzNw==", "bodyText": "Please be careful when using links. Our documentation is weird because every path starts with /rest.li/. I'm assuming this is correct, but there's a possibility /rest.li/pdl_syntax would be the correct answer. Only saying this because I've had problems before with how links work locally vs on gh-pages", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385318437", "createdAt": "2020-02-27T19:18:30Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM1NTUyOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMTozMlrOFveEag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzo1NjoxNFrOFvlSaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDA0Mg==", "bodyText": "nit: the Rest.li framework\nGenerally, it should always be referred to as the Rest.li framework or just Rest.li. Referring to it as Rest.li framework sounds awkward.\nAlso, the convention for capitalization seems to be Rest.li. I'd suggest doing a search-and-replace on rest.li, restli, Restli, RestLi to Rest.li", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385320042", "createdAt": "2020-02-27T19:21:32Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzODMxMw==", "bodyText": "Done", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385438313", "createdAt": "2020-02-27T23:56:14Z", "author": {"login": "karthikbalasub"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDA0Mg=="}, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM1ODMyOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMjoyNFrOFveGMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyMjoyNFrOFveGMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDQ5OQ==", "bodyText": "typo: seem-less -> seamless", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385320499", "createdAt": "2020-02-27T19:22:24Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM2Nzk1OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyNTowMlrOFveMGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyNTowMlrOFveMGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMjAwOQ==", "bodyText": "link is broken: #primitive-type -> #primitive-types", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385322009", "createdAt": "2020-02-27T19:25:02Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM4MTYxOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyODo1NFrOFveUgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyODo1NFrOFveUgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNDE2MA==", "bodyText": "The fields can be primitive types, enums, unions, maps, arrays or other records\n\nThis seems oddly specific and some may take it literally. No typerefs or fixed types? I'd suggest just saying primitive types, maps, arrays, other records, or any other valid Pegasus type (something along those lines)", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385324160", "createdAt": "2020-02-27T19:28:54Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjM4NDU2OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyOTo1MFrOFveWbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToyOTo1MFrOFveWbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNDY1NQ==", "bodyText": "nit: birthDay -> birthday. Change all references", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385324655", "createdAt": "2020-02-27T19:29:50Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1105 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: \"/pdl_syntax\"\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using rest.li and handles seem-less serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-type), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays or other records.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthDay: Date", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "936566fb595595d742d8cc51d0a69f07ed0ba4d8"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU2Mzc2OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNDo1OTozN1rOFvpi2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNDo1OTozN1rOFvpi2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODA1Ng==", "bodyText": "This link isn't rendering properly. I think it's the space between the two components.", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385508056", "createdAt": "2020-02-28T04:59:37Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1106 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: /pdl_syntax\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+the Rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using Rest.li and handles seemless serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-types), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using Pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays, other records or any valid Pegasus\n+type.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthday`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthday` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In Pegasus, a field is required unless the field is explicitly declared as\n+optional using the `optional` keyword. An optional field may be present or\n+absent in the in-memory data structure or serialized data.\n+\n+In the generated client bindings, Pegasus provides has[Field] methods(eg,\n+`hasBirthDay()`) to determine if an optional field is present.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+}\n+```\n+The above example defines the `birthday` field as optional.\n+\n+#### Record fields may have default values.\n+Pegasus supports specifying default values for fields. Though the definition\n+language allows default values for both required and optional fields, it is\n+recommended to use default values only for required fields.\n+\n+The default value for a field is expressed as a JSON value confirming to the\n+type of the field.\n+\n+In Pegasus generated bindings, the get[Field] accessors will return the value of\n+the field it is present or the default value from the schema if the field is\n+absent. The bindings also provide a specialized get accessor that allows the\n+caller to specify whether the default value or null should be returned when an\n+absent field is accessed.\n+\n+See [GetMode](https://linkedin.github.io/rest.li/java_binding#getmode) for more\n+details on accessing optional fields and default values.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import org.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+}\n+```\n+The above example defines a boolean field `isActive`, which has a default value\n+`true`.\n+\n+### Inlined schemas\n+In Pegasus, records and other named schemas need not be top-level schemas. They\n+can be inlined within other record schemas.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+`Address` record in the above example is inlined. It inherits the namespace of\n+the parent record `User`, making its fully qualified name `com.example.models.Address`.\n+\n+* Namespace of inline types can be specified/overriden by defining a Namespace\n+surrounding the inlined type.\n+* The default value of fields using inlined types can be expressed using its\n+serialized JSON representation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: {\n+    namespace com.example.models.address\n+\n+    record Address {\n+      state: string\n+      zipCode: string\n+    }\n+  } = {\n+    \"state\": \"CA\",\n+    \"zipCode\": \"12345\"\n+  }\n+}\n+```\n+***Note:*** If a record or a named schema is referenced by other schemas, it should\n+be a top-level schema. Referencing in-line schemas outside the schema in which\n+they are defined is not allowed.\n+\n+### Doc Strings\n+\n+Pegasus types and fields may be documented using \u201cdoc strings\u201d following the\n+Java style comments.\n+* Comments using `/** */` syntax are treated as schema documentation. They will\n+be included in the in-memory representation and the generated binding classes.\n+* Comments using `/* */` or `//` syntax are allowed but not treated as schema\n+documentation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+/**\n+ * A record representing an user in the system.\n+ */\n+record User {\n+  /** First name of the user */\n+  firstName: string\n+\n+  /** User's birth day */\n+  birthday: optional Date\n+\n+  // TODO: Can this be an enum?\n+  /** Status of the user. */\n+  isActive: boolean = true\n+}\n+```\n+\n+### Deprecation\n+Pegasus supports marking types or fields as deprecated by adding `@deprecated`\n+annotation. The deprecation details from the schema will be carried over to the\n+bindings generated in  different languages.\n+In Java language, the classes, getter and setter methods generated for\n+deprecated types will be marked as deprecated.\n+\n+It is recommended to specify a string describing the reason for deprecation and\n+the alternative as the value for the `@deprecated` annotation.\n+\n+Deprecate a field:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+\n+  @deprecated = \"Use birthday instead.\"\n+  birthYear: int\n+\n+  birthday: Date  \n+}\n+```\n+Deprecate a record:\n+```pdl\n+namespace com.example.models\n+\n+@deprecated = \"Use Person type instead.\"\n+record User {\n+  firstName: string\n+}\n+```\n+\n+See [Enum documentation and deprecation](#enum-documentation-and-deprecation)\n+for details on deprecating enum symbols.\n+\n+### Including fields\n+Pegasus records support including fields from one or more other records. When\n+a record is included, all its fields will be included in the current record. It\n+does not include any other attribute of the other record.\n+\n+Includes are transitive, if record A includes record B and record B includes\n+record C, record A contains all the fields declared in record A, record B and\n+record C.\n+\n+The value of the \u201cinclude\u201d attribute should be a list of records or typerefs of\n+records. It is an error to specify non-record types in this list.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp {\n+  firstName: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A common record to represent audit stamps.\n+ */\n+record AuditStamp {\n+  /** Time in milliseconds since epoch when this record was created */\n+  createdAt: long\n+\n+  /** Time in milliseconds since epoch when this record was last updated */\n+  updatedAt: long\n+}\n+```\n+\n+Includes feature allows including fields from multiple records.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/** A common record for specifying version tags of a record */\n+record VersionTag {\n+  versionTag: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp, VersionTag {\n+  firstName: string\n+}\n+```\n+\n+***Note:*** Record inclusion does not imply inheritance, it is merely a\n+convenience to reduce duplication when writing schemas.\n+\n+\n+## Primitive Types\n+The above examples already introduced `int`, `long`, `string` and `boolean`\n+primitive types that are supported by Pegasus.\n+The full list of supported Pegasus primitive types are: `int`, `long`, `float`,\n+`double`, `boolean`, `string` and `bytes`.\n+\n+The actual types used for the primitives depends on the language specific\n+binding implementation. For details on Java bindings for Pegasus primitives, see\n+[Primitive Types] (https://linkedin.github.io/rest.li/java_binding#primitive-types)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43affac2537955fedb2bbd8aae014ad6d8651b9"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU2ODU0OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowMzoyMVrOFvpldw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowMzoyMVrOFvpldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwODcyNw==", "bodyText": "nit: I think it looks nicer if you escape references to characters. e.g. \"/\" -> /, dot (.) -> (.)\nAlso, add a space between \"name\" and \"(FQN)\" on line 48", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385508727", "createdAt": "2020-02-28T05:03:21Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1106 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: /pdl_syntax\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+the Rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using Rest.li and handles seemless serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-types), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43affac2537955fedb2bbd8aae014ad6d8651b9"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU3MTcyOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowNTo1NFrOFvpnSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowNTo1NFrOFvpnSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTE5NQ==", "bodyText": "This excerpt is used as the description text in the search functionality, so keep that in mind here. Something like \"Documentation of pegasus schemas and specification of the PDL syntax.\"", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385509195", "createdAt": "2020-02-28T05:05:54Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1106 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: /pdl_syntax\n+excerpt: Rest.li PDL Schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43affac2537955fedb2bbd8aae014ad6d8651b9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU3NDg3OnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowODo0NFrOFvppPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowODo0NFrOFvppPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTY5NA==", "bodyText": "nit: Should Import be pluralized? It looks like you made it singular for a reason. I see it the same as \"Properties\". If you do update it, make sure to update the TOC link.", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385509694", "createdAt": "2020-02-28T05:08:44Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1106 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: /pdl_syntax\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+the Rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using Rest.li and handles seemless serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-types), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using Pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays, other records or any valid Pegasus\n+type.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthday`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthday` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In Pegasus, a field is required unless the field is explicitly declared as\n+optional using the `optional` keyword. An optional field may be present or\n+absent in the in-memory data structure or serialized data.\n+\n+In the generated client bindings, Pegasus provides has[Field] methods(eg,\n+`hasBirthDay()`) to determine if an optional field is present.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+}\n+```\n+The above example defines the `birthday` field as optional.\n+\n+#### Record fields may have default values.\n+Pegasus supports specifying default values for fields. Though the definition\n+language allows default values for both required and optional fields, it is\n+recommended to use default values only for required fields.\n+\n+The default value for a field is expressed as a JSON value confirming to the\n+type of the field.\n+\n+In Pegasus generated bindings, the get[Field] accessors will return the value of\n+the field it is present or the default value from the schema if the field is\n+absent. The bindings also provide a specialized get accessor that allows the\n+caller to specify whether the default value or null should be returned when an\n+absent field is accessed.\n+\n+See [GetMode](https://linkedin.github.io/rest.li/java_binding#getmode) for more\n+details on accessing optional fields and default values.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import org.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+}\n+```\n+The above example defines a boolean field `isActive`, which has a default value\n+`true`.\n+\n+### Inlined schemas\n+In Pegasus, records and other named schemas need not be top-level schemas. They\n+can be inlined within other record schemas.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+`Address` record in the above example is inlined. It inherits the namespace of\n+the parent record `User`, making its fully qualified name `com.example.models.Address`.\n+\n+* Namespace of inline types can be specified/overriden by defining a Namespace\n+surrounding the inlined type.\n+* The default value of fields using inlined types can be expressed using its\n+serialized JSON representation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: {\n+    namespace com.example.models.address\n+\n+    record Address {\n+      state: string\n+      zipCode: string\n+    }\n+  } = {\n+    \"state\": \"CA\",\n+    \"zipCode\": \"12345\"\n+  }\n+}\n+```\n+***Note:*** If a record or a named schema is referenced by other schemas, it should\n+be a top-level schema. Referencing in-line schemas outside the schema in which\n+they are defined is not allowed.\n+\n+### Doc Strings\n+\n+Pegasus types and fields may be documented using \u201cdoc strings\u201d following the\n+Java style comments.\n+* Comments using `/** */` syntax are treated as schema documentation. They will\n+be included in the in-memory representation and the generated binding classes.\n+* Comments using `/* */` or `//` syntax are allowed but not treated as schema\n+documentation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+/**\n+ * A record representing an user in the system.\n+ */\n+record User {\n+  /** First name of the user */\n+  firstName: string\n+\n+  /** User's birth day */\n+  birthday: optional Date\n+\n+  // TODO: Can this be an enum?\n+  /** Status of the user. */\n+  isActive: boolean = true\n+}\n+```\n+\n+### Deprecation\n+Pegasus supports marking types or fields as deprecated by adding `@deprecated`\n+annotation. The deprecation details from the schema will be carried over to the\n+bindings generated in  different languages.\n+In Java language, the classes, getter and setter methods generated for\n+deprecated types will be marked as deprecated.\n+\n+It is recommended to specify a string describing the reason for deprecation and\n+the alternative as the value for the `@deprecated` annotation.\n+\n+Deprecate a field:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+\n+  @deprecated = \"Use birthday instead.\"\n+  birthYear: int\n+\n+  birthday: Date  \n+}\n+```\n+Deprecate a record:\n+```pdl\n+namespace com.example.models\n+\n+@deprecated = \"Use Person type instead.\"\n+record User {\n+  firstName: string\n+}\n+```\n+\n+See [Enum documentation and deprecation](#enum-documentation-and-deprecation)\n+for details on deprecating enum symbols.\n+\n+### Including fields\n+Pegasus records support including fields from one or more other records. When\n+a record is included, all its fields will be included in the current record. It\n+does not include any other attribute of the other record.\n+\n+Includes are transitive, if record A includes record B and record B includes\n+record C, record A contains all the fields declared in record A, record B and\n+record C.\n+\n+The value of the \u201cinclude\u201d attribute should be a list of records or typerefs of\n+records. It is an error to specify non-record types in this list.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp {\n+  firstName: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A common record to represent audit stamps.\n+ */\n+record AuditStamp {\n+  /** Time in milliseconds since epoch when this record was created */\n+  createdAt: long\n+\n+  /** Time in milliseconds since epoch when this record was last updated */\n+  updatedAt: long\n+}\n+```\n+\n+Includes feature allows including fields from multiple records.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/** A common record for specifying version tags of a record */\n+record VersionTag {\n+  versionTag: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp, VersionTag {\n+  firstName: string\n+}\n+```\n+\n+***Note:*** Record inclusion does not imply inheritance, it is merely a\n+convenience to reduce duplication when writing schemas.\n+\n+\n+## Primitive Types\n+The above examples already introduced `int`, `long`, `string` and `boolean`\n+primitive types that are supported by Pegasus.\n+The full list of supported Pegasus primitive types are: `int`, `long`, `float`,\n+`double`, `boolean`, `string` and `bytes`.\n+\n+The actual types used for the primitives depends on the language specific\n+binding implementation. For details on Java bindings for Pegasus primitives, see\n+[Primitive Types] (https://linkedin.github.io/rest.li/java_binding#primitive-types)\n+\n+Primitive types cannot be named (except through [typerefs](#typerefs)) and thus\n+cannot be defined as top-level schemas.\n+\n+Some examples showing how different primitive fields can be defined and the\n+syntax for specifying default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+## Enum Type\n+\n+Enums, as the name suggests contains an enumeration of symbols. Enums are named\n+schemas and can be defined as top-level schema or inlined.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+enum UserStatus {\n+  ACTIVE\n+  SUSPENDED\n+  INACTIVE\n+}\n+```\n+\n+Enums can be referenced by name in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus\n+}\n+```\n+\n+Enums can also be defined inline:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus\n+  suspendedReason: enum StatusReason {\n+    FLAGGED_BY_SPAM_CHECK\n+    REPORTED_BY_ADMIN\n+  }\n+}\n+```\n+\n+### Enum documentation and deprecation\n+Doc comments and deprecation can be added directly to individual enum symbols.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * Defines the states of a user in the system.\n+ */\n+enum UserStatus {\n+  /**\n+   * Represents an active user.\n+   */\n+  ACTIVE\n+\n+  /**\n+   * Represents user suspended for some reason.\n+   */\n+  SUSPENDED\n+\n+  /**\n+   * Represents an user who had deleted/inactivated their account.\n+   */\n+  @deprecated = \"Use INACTIVE for users pending deletion. Deleted users should not be in system\"\n+  DELETED\n+\n+  /**\n+   * Represents users requested for deletion and in the process of being deleted.\n+   */\n+   INACTIVE\n+}\n+```\n+\n+### Enum defaults\n+\n+To specify the default value for an enum field, use the string representation of\n+the enum symbol to set as default.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus = \"ACTIVE\"\n+  suspendedReason: enum StatusReason {\n+    FLAGGED_BY_SPAM_CHECK\n+    REPORTED_BY_ADMIN\n+  } = \"FLAGGED_BY_SPAM_CHECK\"\n+}\n+```\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a homogeneous collection of \"items\" type. Arrays\n+are ordered, as in the items in an array have specific ordering and the ordering\n+will be honored when the data is serialized, sent over the wire and\n+de-serialized.\n+\n+Some examples below for defining arrays and default values for them.\n+Primitive arrays:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```pdl\n+namespace com.example.models\n+\n+record SuspendedUsersReport {\n+  users: array[User]\n+  reasons: array[SuspendReason]\n+}\n+```\n+\n+Record or Enum arrays with default values:\n+```pdl\n+namespace com.example.models\n+\n+record SuspendedUsersReport {\n+  users: array[User] = [{ \"firstName\": \"Joker\" }, { \"firstName\": \"Darth\"}]\n+  reasons: array[SuspendReason] = [\"FLAGGED_BY_SPAM_CHECK\"]\n+}\n+```\n+\n+## Map Type\n+\n+Maps are defined with a key type and a value type. The value type can be any\n+valid PDL type, but currently `string` is the only supported key type. Entries\n+in a Map are not ordered and the order can change when the data is\n+serialized/deserialized.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Maps with complex values:\n+```pdl\n+namespace com.example.models\n+\n+record UserReport {\n+  /** Users grouped by their status. Key is the string representation of status enum */\n+  usersByStatus: map[string, array[User]]\n+\n+  /**\n+   * Count of users grouped by firstName and then by status.\n+   * First level key is the firstName of users.\n+   * Second level key is the string representation of status.\n+   */\n+  countByFirstNameAndStatus: map[string, map[string, int]]\n+}\n+```\n+\n+## Union Type\n+Union is a powerful way to model data that can be of different types at\n+different scenarios. Record fields that have this behavior can be defined as a\n+Union type with the expected value types as its members.\n+\n+A union type may be defined with any number of member types. Member type can be\n+primitive, record, enum, map or array. Unions are not allowed as members inside\n+an union.\n+\n+The fully qualified member type names also serve as the \u201cmember keys\u201d (also\n+called as \u201cunion tags\u201d), and identify which union member type data holds. These\n+are used to represent which member is present when the data is serialized.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record Account {\n+  /**\n+   * Owner of this account. Accounts can be owned either by a single User or an\n+   * user group.\n+   */\n+  owner: union[User, UserGroup]\n+}\n+```\n+\n+The above example defines an `owner` field that can either be an User or an\n+UserGroup.\n+\n+Union with default value:\n+\n+```pdl\n+namespace com.example.models\n+\n+record Account {\n+  /**\n+   * Owner of this account. Accounts can be owned either by a single User or an\n+   * user group.\n+   * By default, All your accounts are belong to CATS.\n+   */\n+  owner: union[User, UserGroup] = { \"com.example.models.User\": { \"firstName\": \"CATS\" }}\n+}\n+```\n+\n+Types can be declared inline within a union definition:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus = \"ACTIVE\"\n+  statusReason: union [\n+    enum ActiveReason {\n+      NEVER_SUSPENDED\n+      SUSPENSION_CLEARED\n+    }\n+    enum SuspendReason {\n+      FLAGGED_BY_SPAM_CHECK\n+      REPORTED_BY_ADMIN\n+    }\n+    enum InactiveReason {\n+      USER_REQUESTED_DELETION\n+      REQUESTED_BY_ADMIN\n+    }\n+  ] = { \"com.example.models.ActiveReason\": \"NEVER_SUSPENDED\" }\n+}\n+```\n+\n+### Union with aliases\n+***Note:*** _Union with aliases is a recent feature in the Pegasus schema\n+*language and it might not be fully supported in non-java languages. Please\n+*check the [support level](/rest.li/multi_language_compatibility_matrix) on all\n+*languages you intend to use before using aliases_\n+\n+Union members can optionally be given an alias. Aliases can be used to create\n+unions with members of the same type or to give better naming for union members.\n+\n+Union with aliases is required for cases where the union contains multiple\n+members that are:\n+* of same primitive type\n+* of same named complex type\n+* arrays of same or different item types\n+* maps of same or different value types\n+* typerefs dereferenced to same type\n+\n+Such unions must specify an unique alias for each member in the union\n+definition. When an alias is specified, it acts as the member\u2019s discriminator\n+unlike the member type name on the standard unions defined above.\n+\n+Aliased unions are defined as:\n+```pdl\n+union [alias: type, /* ... */]\n+```\n+There are few constraints that must be taken in consideration while specifying\n+aliases for union members,\n+\n+1. Aliases must be unique for each member in a union definition.\n+2. Aliases must be specified for either all or none of the members in a union\n+definition.\n+3. Aliases cannot be specified for `null` member types which means there can\n+only be one null member inside a union definition.\n+\n+\n+An example showing union with aliases:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A record with user's contact information.\n+ */\n+record Contacts {\n+  /** Primary phone number for the user */\n+  primaryPhoneNumber: union[\n+    /** A mobile phone number */\n+    mobile: PhoneNumber,\n+\n+    /**\n+     * A work phone number\n+     */\n+    work: PhoneNumber,\n+\n+    /** A home phone number */\n+    home: PhoneNumber\n+  ]\n+}\n+```\n+Since all three union members `mobile`, `work` and `home` are of the same type\n+`PhoneNumber`, aliases are required for this union.\n+\n+**Aliased union members can have doc strings and custom properties. This is not supported for non-aliased union members.**\n+\n+When using unions with aliases, the alias should be used as the key within the default value:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A record with user's contact information.\n+ */\n+record Contacts {\n+  /** Primary phone number for the user */\n+  primaryPhoneNumber: union[\n+    /** A mobile phone number */\n+    mobile: PhoneNumber,\n+\n+    /**\n+     * A work phone number\n+     */\n+    work: PhoneNumber,\n+\n+    /** A home phone number */\n+    home: PhoneNumber\n+  ] = {\"mobile\": { \"number\": \"314-159-2653\" }}\n+}\n+```\n+\n+## Typerefs\n+\n+Pegasus supports a new schema type known as a typeref. A typeref is like a\n+typedef in C. It does not declare a new type but declares an alias to an\n+existing type.\n+\n+### Typerefs can provide additional clarity when using primitive types.\n+Typerefs are useful for differentiating different uses of the same type. For\n+example, we can use to a typeref to differentiate a string field that holds an\n+URL from an arbitrary string value or a long field that holds an epoch time in\n+milliseconds from a generic long value.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/** Number of milliseconds since midnight, January 1, 1970 UTC. */\n+typeref Time = long\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A common record to represent audit stamps.\n+ */\n+record AuditStamp {\n+  /** Time when this record was created */\n+  createdAt: Time\n+\n+  /** Time when this record was last updated */\n+  updatedAt: Time\n+}\n+```\n+A typeref allows additional meta-data to be associated with primitive and\n+unnamed types. This meta-data can be used to provide documentation or support\n+custom properties.\n+\n+### Typerefs can be used to name anonymous types.\n+A typeref provides a way to refer to common unnamed types such as arrays, maps,\n+and unions. Without typerefs, users may have to wrap these unnamed types with a\n+record in order to address them. Alternatively, users may cut-and-paste common\n+type declarations, resulting in unnecessary duplication and potentially causing\n+inconsistencies if future changes are not propagated correctly to all copies.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+typeref PhoneNumber = union[\n+  /** A mobile phone number */\n+  mobile: PhoneNumber,\n+\n+  /**\n+   * A work phone number\n+   */\n+  work: PhoneNumber,\n+\n+  /** A home phone number */\n+  home: PhoneNumber\n+]\n+\n+```\n+\n+Typerefs can then be referred to by name from any other type:\n+```pdl\n+namespace com.example.models\n+\n+record Contacts {\n+  primaryPhone: PhoneNumber\n+  secondaryPhone: PhoneNumber\n+}\n+```\n+\n+### Typerefs can be used to specify custom types and coercers\n+\n+For example, Joda time has a convenient `DateTime` Java class. If we wish to use\n+this class in Java to represent date-times, all we need to do is define a\n+Pegasus custom type that binds to it:\n+\n+```pdl\n+namespace com.example.models\n+\n+@java.class = \"org.joda.time.DateTime\"\n+@java.coercerClass = \"com.example.time.DateTimeCoercer\"\n+typeref DateTime = string\n+```\n+The coercer is responsible for converting the Pegasus \u201creferenced\u201d type, in this\n+case \"string\" to the Joda `DateTime` class.\n+\n+See [Java Binding]\n+(https://linkedin.github.io/rest.li/java_binding#custom-java-class-binding-for-primitive-types)\n+for more details on defining and using custom types.\n+\n+## Fixed Type\n+\n+The Fixed type is used to define schemas with a fixed size in terms of number of\n+bytes.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+fixed MD5 16\n+```\n+The example above defines a type called `MD5`, which has a size of `16 bytes`.\n+\n+## Import", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43affac2537955fedb2bbd8aae014ad6d8651b9"}, "originalPosition": 869}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU3NTMwOnYy", "diffSide": "RIGHT", "path": "pdl_schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowOToxNFrOFvppiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNTowOToxNFrOFvppiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTc3MQ==", "bodyText": "Maybe be worthwhile to mention that import statements take precedence in name resolution.", "url": "https://github.com/linkedin/rest.li/pull/196#discussion_r385509771", "createdAt": "2020-02-28T05:09:14Z", "author": {"login": "evanw555"}, "path": "pdl_schema.md", "diffHunk": "@@ -0,0 +1,1106 @@\n+---\n+layout: guide\n+title: PDL Schema\n+permalink: /pdl_schema\n+redirect_from: /pdl_syntax\n+excerpt: Rest.li PDL Schema.\n+---\n+\n+# PDL Schema\n+\n+## Contents\n+-   [PDL Schema Definition](#pdl-schema-definition)\n+-   [Creating a Schema](#creating-a-schema)\n+-   [Record Type](#record-type)\n+-   [Primitive Types](#primitive-types)\n+-   [Enum Type](#enum-type)\n+-   [Array Type](#array-type)\n+-   [Map Type](#map-type)\n+-   [Union Type](#union-type)\n+-   [Typerefs](#typerefs)\n+-   [Fixed Type](#fixed-type)\n+-   [Import](#import)\n+-   [Properties](#properties)\n+-   [Package](#package)\n+-   [Escaping](#escaping)\n+\n+## PDL Schema Definition\n+\n+Pegasus is a schema definition and serialization system developed as part of\n+the Rest.li framework. It provides [multi-language\n+support](https://linkedin.github.io/rest.li/multi_language_compatibility_matrix)\n+for services built using Rest.li and handles seemless serialization and\n+deserialization of data between server and clients.\n+\n+PDL is a schema definition language for Pegasus, developed\n+as a user friendly and concise format replacement for the older JSON based\n+[PDSC schema format](https://linkedin.github.io/rest.li/pdsc_syntax).\n+\n+## Creating a Schema\n+\n+Pegasus supports different types of schemas: [Records](#record-type),\n+[Primitive types](#primitive-types), [Enums](#enum-type), [Arrays](#array-type),\n+[Maps](#map-type), [Unions](#union-type), [Fixed](#fixed-type) and\n+[Typerefs](#typerefs). Records, Enums and Typerefs have names (Named schemas)\n+and thus can be defined as top-level schemas. Named schemas can specify an\n+optional namespace to avoid naming conflict between schemas with same name.\n+The name prefixed with the namespace using the dot(.) separator becomes the\n+fully qualified name(FQN) of the schema. Named schemas can be\n+referenced from other schemas using the fully qualified name.\n+\n+Each top-level schema should be stored in its own file with a `.pdl` extension.\n+Name of the file should match the schema name and the directory structure should\n+match the namespace (similar to how Java classes are organized).\n+\n+The Pegasus code generator implements a resolver that is similar to Java class\n+loaders. If there is a reference to a named schema, the code generator will try\n+to look for a file in the code generator\u2019s resolver path. The resolver path is\n+similar to a Java classpath. The fully qualified name of the named schema will\n+be translated to a relative file name. The relative file name is computed by\n+replacing dots (\u201c.\u201d) in the fully qualified name by the directory path separator\n+(typically \u201c/\u201d) and appending a `.pdl` extension. This relative file name looked\n+up using each location in the resolver path until it finds a file that contains\n+the named schema.\n+\n+\n+## Record Type\n+Records are the most common type of Pegasus schemas and usually the starting\n+point when defining data models using Pegasus. A record represents a Named\n+entity with fields representing attributes of that entity. The fields can be\n+primitive types, enums, unions, maps, arrays, other records or any valid Pegasus\n+type.\n+\n+For example:\n+```pdl\n+namespace com.example.time\n+\n+record Date {\n+  day: int\n+  month: int\n+  year: int\n+}\n+```\n+The above example is defining a record called `Date`. This is defined in the\n+namesapce `com.example.time`, giving it the fully qualified name\n+`com.example.time.Date`. So this schema should be defined in the following file\n+```\n+<project-dir>/pegasus/com/example/time/Date.pdl\n+```\n+\n+The `Date` record can then be referenced in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: Date\n+}\n+```\n+The above example is defining a record called `User`:\n+* This record is using the namespace `com.example.models`. So the fully\n+ qualified name is `com.example.models.User`.\n+* This record is defining two fields, `firstName` and `birthday`.\n+ * `firstName` is a primitive field of type `string`.\n+ * `birthday` references the type `com.example.time.Date` from the first example\n+* PDL supports Java like `import` feature that allows you to define references\n+ to external types and then use them in the schema using their simple name.\n+\n+### Record Field attributes\n+Pegasus supports additional features for defining the behavior of fields in a\n+record.\n+#### Record fields can be defined as optional.\n+In Pegasus, a field is required unless the field is explicitly declared as\n+optional using the `optional` keyword. An optional field may be present or\n+absent in the in-memory data structure or serialized data.\n+\n+In the generated client bindings, Pegasus provides has[Field] methods(eg,\n+`hasBirthDay()`) to determine if an optional field is present.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+}\n+```\n+The above example defines the `birthday` field as optional.\n+\n+#### Record fields may have default values.\n+Pegasus supports specifying default values for fields. Though the definition\n+language allows default values for both required and optional fields, it is\n+recommended to use default values only for required fields.\n+\n+The default value for a field is expressed as a JSON value confirming to the\n+type of the field.\n+\n+In Pegasus generated bindings, the get[Field] accessors will return the value of\n+the field it is present or the default value from the schema if the field is\n+absent. The bindings also provide a specialized get accessor that allows the\n+caller to specify whether the default value or null should be returned when an\n+absent field is accessed.\n+\n+See [GetMode](https://linkedin.github.io/rest.li/java_binding#getmode) for more\n+details on accessing optional fields and default values.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import org.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+}\n+```\n+The above example defines a boolean field `isActive`, which has a default value\n+`true`.\n+\n+### Inlined schemas\n+In Pegasus, records and other named schemas need not be top-level schemas. They\n+can be inlined within other record schemas.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+`Address` record in the above example is inlined. It inherits the namespace of\n+the parent record `User`, making its fully qualified name `com.example.models.Address`.\n+\n+* Namespace of inline types can be specified/overriden by defining a Namespace\n+surrounding the inlined type.\n+* The default value of fields using inlined types can be expressed using its\n+serialized JSON representation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: {\n+    namespace com.example.models.address\n+\n+    record Address {\n+      state: string\n+      zipCode: string\n+    }\n+  } = {\n+    \"state\": \"CA\",\n+    \"zipCode\": \"12345\"\n+  }\n+}\n+```\n+***Note:*** If a record or a named schema is referenced by other schemas, it should\n+be a top-level schema. Referencing in-line schemas outside the schema in which\n+they are defined is not allowed.\n+\n+### Doc Strings\n+\n+Pegasus types and fields may be documented using \u201cdoc strings\u201d following the\n+Java style comments.\n+* Comments using `/** */` syntax are treated as schema documentation. They will\n+be included in the in-memory representation and the generated binding classes.\n+* Comments using `/* */` or `//` syntax are allowed but not treated as schema\n+documentation.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+/**\n+ * A record representing an user in the system.\n+ */\n+record User {\n+  /** First name of the user */\n+  firstName: string\n+\n+  /** User's birth day */\n+  birthday: optional Date\n+\n+  // TODO: Can this be an enum?\n+  /** Status of the user. */\n+  isActive: boolean = true\n+}\n+```\n+\n+### Deprecation\n+Pegasus supports marking types or fields as deprecated by adding `@deprecated`\n+annotation. The deprecation details from the schema will be carried over to the\n+bindings generated in  different languages.\n+In Java language, the classes, getter and setter methods generated for\n+deprecated types will be marked as deprecated.\n+\n+It is recommended to specify a string describing the reason for deprecation and\n+the alternative as the value for the `@deprecated` annotation.\n+\n+Deprecate a field:\n+```pdl\n+namespace com.example.models\n+\n+import com.example.time.Date\n+\n+record User {\n+  firstName: string\n+\n+  @deprecated = \"Use birthday instead.\"\n+  birthYear: int\n+\n+  birthday: Date  \n+}\n+```\n+Deprecate a record:\n+```pdl\n+namespace com.example.models\n+\n+@deprecated = \"Use Person type instead.\"\n+record User {\n+  firstName: string\n+}\n+```\n+\n+See [Enum documentation and deprecation](#enum-documentation-and-deprecation)\n+for details on deprecating enum symbols.\n+\n+### Including fields\n+Pegasus records support including fields from one or more other records. When\n+a record is included, all its fields will be included in the current record. It\n+does not include any other attribute of the other record.\n+\n+Includes are transitive, if record A includes record B and record B includes\n+record C, record A contains all the fields declared in record A, record B and\n+record C.\n+\n+The value of the \u201cinclude\u201d attribute should be a list of records or typerefs of\n+records. It is an error to specify non-record types in this list.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp {\n+  firstName: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A common record to represent audit stamps.\n+ */\n+record AuditStamp {\n+  /** Time in milliseconds since epoch when this record was created */\n+  createdAt: long\n+\n+  /** Time in milliseconds since epoch when this record was last updated */\n+  updatedAt: long\n+}\n+```\n+\n+Includes feature allows including fields from multiple records.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/** A common record for specifying version tags of a record */\n+record VersionTag {\n+  versionTag: string\n+}\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * User includes fields of AuditStamp, User will have fields firstName from\n+ * itself and fields createdAt and updatedAt from AuditStamp.\n+ */\n+record User includes AuditStamp, VersionTag {\n+  firstName: string\n+}\n+```\n+\n+***Note:*** Record inclusion does not imply inheritance, it is merely a\n+convenience to reduce duplication when writing schemas.\n+\n+\n+## Primitive Types\n+The above examples already introduced `int`, `long`, `string` and `boolean`\n+primitive types that are supported by Pegasus.\n+The full list of supported Pegasus primitive types are: `int`, `long`, `float`,\n+`double`, `boolean`, `string` and `bytes`.\n+\n+The actual types used for the primitives depends on the language specific\n+binding implementation. For details on Java bindings for Pegasus primitives, see\n+[Primitive Types] (https://linkedin.github.io/rest.li/java_binding#primitive-types)\n+\n+Primitive types cannot be named (except through [typerefs](#typerefs)) and thus\n+cannot be defined as top-level schemas.\n+\n+Some examples showing how different primitive fields can be defined and the\n+syntax for specifying default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitives {\n+  intField: int\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+\n+Primitive types with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitiveDefaults {\n+  intWithDefault: int = 1\n+  longWithDefault: long = 3000000000\n+  floatWithDefault: float = 3.3\n+  doubleWithDefault: double = 4.4E38\n+  booleanWithDefault: boolean = true\n+  stringWithDefault: string = \"DEFAULT\"\n+  bytesWithDefault: bytes = \"\\u0007\"\n+}\n+```\n+\n+## Enum Type\n+\n+Enums, as the name suggests contains an enumeration of symbols. Enums are named\n+schemas and can be defined as top-level schema or inlined.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+enum UserStatus {\n+  ACTIVE\n+  SUSPENDED\n+  INACTIVE\n+}\n+```\n+\n+Enums can be referenced by name in other schemas:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus\n+}\n+```\n+\n+Enums can also be defined inline:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus\n+  suspendedReason: enum StatusReason {\n+    FLAGGED_BY_SPAM_CHECK\n+    REPORTED_BY_ADMIN\n+  }\n+}\n+```\n+\n+### Enum documentation and deprecation\n+Doc comments and deprecation can be added directly to individual enum symbols.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * Defines the states of a user in the system.\n+ */\n+enum UserStatus {\n+  /**\n+   * Represents an active user.\n+   */\n+  ACTIVE\n+\n+  /**\n+   * Represents user suspended for some reason.\n+   */\n+  SUSPENDED\n+\n+  /**\n+   * Represents an user who had deleted/inactivated their account.\n+   */\n+  @deprecated = \"Use INACTIVE for users pending deletion. Deleted users should not be in system\"\n+  DELETED\n+\n+  /**\n+   * Represents users requested for deletion and in the process of being deleted.\n+   */\n+   INACTIVE\n+}\n+```\n+\n+### Enum defaults\n+\n+To specify the default value for an enum field, use the string representation of\n+the enum symbol to set as default.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus = \"ACTIVE\"\n+  suspendedReason: enum StatusReason {\n+    FLAGGED_BY_SPAM_CHECK\n+    REPORTED_BY_ADMIN\n+  } = \"FLAGGED_BY_SPAM_CHECK\"\n+}\n+```\n+\n+## Array Type\n+\n+Pegasus Arrays are defined as a homogeneous collection of \"items\" type. Arrays\n+are ordered, as in the items in an array have specific ordering and the ordering\n+will be honored when the data is serialized, sent over the wire and\n+de-serialized.\n+\n+Some examples below for defining arrays and default values for them.\n+Primitive arrays:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesArray {\n+  ints: array[int]\n+  longs: array[long]\n+  floats: array[float]\n+  doubles: array[double]\n+  booleans: array[boolean]\n+  strings: array[string]\n+  bytes: array[bytes]\n+}\n+```\n+\n+Primitive arrays with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesArrayDefaults {\n+  ints: array[int] = [1, 2, 3]\n+  longs: array[long] = [3000000000, 4000000000]\n+  floats: array[float] = [3.3, 2.5]\n+  doubles: array[double] = [4.4E38, 3.1E24]\n+  booleans: array[boolean] = [true, false]\n+  strings: array[string] = [\"hello\"]\n+  bytes: array[bytes] = [\"\\u0007\"]\n+}\n+```\n+\n+Record or Enum arrays:\n+```pdl\n+namespace com.example.models\n+\n+record SuspendedUsersReport {\n+  users: array[User]\n+  reasons: array[SuspendReason]\n+}\n+```\n+\n+Record or Enum arrays with default values:\n+```pdl\n+namespace com.example.models\n+\n+record SuspendedUsersReport {\n+  users: array[User] = [{ \"firstName\": \"Joker\" }, { \"firstName\": \"Darth\"}]\n+  reasons: array[SuspendReason] = [\"FLAGGED_BY_SPAM_CHECK\"]\n+}\n+```\n+\n+## Map Type\n+\n+Maps are defined with a key type and a value type. The value type can be any\n+valid PDL type, but currently `string` is the only supported key type. Entries\n+in a Map are not ordered and the order can change when the data is\n+serialized/deserialized.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesMap {\n+  ints: map[string, int]\n+  longs: map[string, long]\n+  floats: map[string, float]\n+  doubles: map[string, double]\n+  booleans: map[string, boolean]\n+  strings: map[string, string]\n+  bytes: map[string, bytes]\n+}\n+```\n+\n+Primitive maps with default values:\n+```pdl\n+namespace com.example.models\n+\n+record WithPrimitivesMapDefaults {\n+  ints: map[string, int] = { \"int1\": 1, \"int2\": 2, \"int3\": 3 }\n+  longs: map[string, long] = { \"long1\": 3000000000, \"long2\": 4000000000 }\n+  floats: map[string, float] = { \"float1\": 3.3, \"float2\": 2.1 }\n+  doubles: map[string, double] = {\"double1\": 4.4E38, \"double2\": 3.1E24}\n+  booleans: map[string, boolean] = { \"boolean1\": true, \"boolean2\": true, \"boolean3\": false }\n+  strings: map[string, string] = { \"string1\": \"hello\", \"string2\": \"world\" }\n+  bytes: map[string, bytes] = { \"bytes\": \"\\u0007\" }\n+}\n+```\n+\n+Maps with complex values:\n+```pdl\n+namespace com.example.models\n+\n+record UserReport {\n+  /** Users grouped by their status. Key is the string representation of status enum */\n+  usersByStatus: map[string, array[User]]\n+\n+  /**\n+   * Count of users grouped by firstName and then by status.\n+   * First level key is the firstName of users.\n+   * Second level key is the string representation of status.\n+   */\n+  countByFirstNameAndStatus: map[string, map[string, int]]\n+}\n+```\n+\n+## Union Type\n+Union is a powerful way to model data that can be of different types at\n+different scenarios. Record fields that have this behavior can be defined as a\n+Union type with the expected value types as its members.\n+\n+A union type may be defined with any number of member types. Member type can be\n+primitive, record, enum, map or array. Unions are not allowed as members inside\n+an union.\n+\n+The fully qualified member type names also serve as the \u201cmember keys\u201d (also\n+called as \u201cunion tags\u201d), and identify which union member type data holds. These\n+are used to represent which member is present when the data is serialized.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+record Account {\n+  /**\n+   * Owner of this account. Accounts can be owned either by a single User or an\n+   * user group.\n+   */\n+  owner: union[User, UserGroup]\n+}\n+```\n+\n+The above example defines an `owner` field that can either be an User or an\n+UserGroup.\n+\n+Union with default value:\n+\n+```pdl\n+namespace com.example.models\n+\n+record Account {\n+  /**\n+   * Owner of this account. Accounts can be owned either by a single User or an\n+   * user group.\n+   * By default, All your accounts are belong to CATS.\n+   */\n+  owner: union[User, UserGroup] = { \"com.example.models.User\": { \"firstName\": \"CATS\" }}\n+}\n+```\n+\n+Types can be declared inline within a union definition:\n+```pdl\n+namespace com.example.models\n+\n+record User {\n+  firstName: string\n+  status: UserStatus = \"ACTIVE\"\n+  statusReason: union [\n+    enum ActiveReason {\n+      NEVER_SUSPENDED\n+      SUSPENSION_CLEARED\n+    }\n+    enum SuspendReason {\n+      FLAGGED_BY_SPAM_CHECK\n+      REPORTED_BY_ADMIN\n+    }\n+    enum InactiveReason {\n+      USER_REQUESTED_DELETION\n+      REQUESTED_BY_ADMIN\n+    }\n+  ] = { \"com.example.models.ActiveReason\": \"NEVER_SUSPENDED\" }\n+}\n+```\n+\n+### Union with aliases\n+***Note:*** _Union with aliases is a recent feature in the Pegasus schema\n+*language and it might not be fully supported in non-java languages. Please\n+*check the [support level](/rest.li/multi_language_compatibility_matrix) on all\n+*languages you intend to use before using aliases_\n+\n+Union members can optionally be given an alias. Aliases can be used to create\n+unions with members of the same type or to give better naming for union members.\n+\n+Union with aliases is required for cases where the union contains multiple\n+members that are:\n+* of same primitive type\n+* of same named complex type\n+* arrays of same or different item types\n+* maps of same or different value types\n+* typerefs dereferenced to same type\n+\n+Such unions must specify an unique alias for each member in the union\n+definition. When an alias is specified, it acts as the member\u2019s discriminator\n+unlike the member type name on the standard unions defined above.\n+\n+Aliased unions are defined as:\n+```pdl\n+union [alias: type, /* ... */]\n+```\n+There are few constraints that must be taken in consideration while specifying\n+aliases for union members,\n+\n+1. Aliases must be unique for each member in a union definition.\n+2. Aliases must be specified for either all or none of the members in a union\n+definition.\n+3. Aliases cannot be specified for `null` member types which means there can\n+only be one null member inside a union definition.\n+\n+\n+An example showing union with aliases:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A record with user's contact information.\n+ */\n+record Contacts {\n+  /** Primary phone number for the user */\n+  primaryPhoneNumber: union[\n+    /** A mobile phone number */\n+    mobile: PhoneNumber,\n+\n+    /**\n+     * A work phone number\n+     */\n+    work: PhoneNumber,\n+\n+    /** A home phone number */\n+    home: PhoneNumber\n+  ]\n+}\n+```\n+Since all three union members `mobile`, `work` and `home` are of the same type\n+`PhoneNumber`, aliases are required for this union.\n+\n+**Aliased union members can have doc strings and custom properties. This is not supported for non-aliased union members.**\n+\n+When using unions with aliases, the alias should be used as the key within the default value:\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A record with user's contact information.\n+ */\n+record Contacts {\n+  /** Primary phone number for the user */\n+  primaryPhoneNumber: union[\n+    /** A mobile phone number */\n+    mobile: PhoneNumber,\n+\n+    /**\n+     * A work phone number\n+     */\n+    work: PhoneNumber,\n+\n+    /** A home phone number */\n+    home: PhoneNumber\n+  ] = {\"mobile\": { \"number\": \"314-159-2653\" }}\n+}\n+```\n+\n+## Typerefs\n+\n+Pegasus supports a new schema type known as a typeref. A typeref is like a\n+typedef in C. It does not declare a new type but declares an alias to an\n+existing type.\n+\n+### Typerefs can provide additional clarity when using primitive types.\n+Typerefs are useful for differentiating different uses of the same type. For\n+example, we can use to a typeref to differentiate a string field that holds an\n+URL from an arbitrary string value or a long field that holds an epoch time in\n+milliseconds from a generic long value.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+/** Number of milliseconds since midnight, January 1, 1970 UTC. */\n+typeref Time = long\n+```\n+\n+```pdl\n+namespace com.example.models\n+\n+/**\n+ * A common record to represent audit stamps.\n+ */\n+record AuditStamp {\n+  /** Time when this record was created */\n+  createdAt: Time\n+\n+  /** Time when this record was last updated */\n+  updatedAt: Time\n+}\n+```\n+A typeref allows additional meta-data to be associated with primitive and\n+unnamed types. This meta-data can be used to provide documentation or support\n+custom properties.\n+\n+### Typerefs can be used to name anonymous types.\n+A typeref provides a way to refer to common unnamed types such as arrays, maps,\n+and unions. Without typerefs, users may have to wrap these unnamed types with a\n+record in order to address them. Alternatively, users may cut-and-paste common\n+type declarations, resulting in unnecessary duplication and potentially causing\n+inconsistencies if future changes are not propagated correctly to all copies.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+typeref PhoneNumber = union[\n+  /** A mobile phone number */\n+  mobile: PhoneNumber,\n+\n+  /**\n+   * A work phone number\n+   */\n+  work: PhoneNumber,\n+\n+  /** A home phone number */\n+  home: PhoneNumber\n+]\n+\n+```\n+\n+Typerefs can then be referred to by name from any other type:\n+```pdl\n+namespace com.example.models\n+\n+record Contacts {\n+  primaryPhone: PhoneNumber\n+  secondaryPhone: PhoneNumber\n+}\n+```\n+\n+### Typerefs can be used to specify custom types and coercers\n+\n+For example, Joda time has a convenient `DateTime` Java class. If we wish to use\n+this class in Java to represent date-times, all we need to do is define a\n+Pegasus custom type that binds to it:\n+\n+```pdl\n+namespace com.example.models\n+\n+@java.class = \"org.joda.time.DateTime\"\n+@java.coercerClass = \"com.example.time.DateTimeCoercer\"\n+typeref DateTime = string\n+```\n+The coercer is responsible for converting the Pegasus \u201creferenced\u201d type, in this\n+case \"string\" to the Joda `DateTime` class.\n+\n+See [Java Binding]\n+(https://linkedin.github.io/rest.li/java_binding#custom-java-class-binding-for-primitive-types)\n+for more details on defining and using custom types.\n+\n+## Fixed Type\n+\n+The Fixed type is used to define schemas with a fixed size in terms of number of\n+bytes.\n+\n+For example:\n+```pdl\n+namespace com.example.models\n+\n+fixed MD5 16\n+```\n+The example above defines a type called `MD5`, which has a size of `16 bytes`.\n+\n+## Import\n+Imports are optional statements which allow you to avoid writing fully-qualified\n+names. They function similarly to imports in Java.\n+\n+For example, the following record can be expressed _without_ imports like this:\n+\n+```pdl\n+namespace com.example.models\n+\n+record AuditStamp {\n+  createdAt: com.example.models.time.Time\n+  updatedAt: com.example.models.time.Time\n+}\n+```\n+\n+Alternatively, the record can be expressed using imports, minimizing the need\n+for repetitive code:\n+\n+```pdl\n+namespace com.example.models\n+\n+import com.example.models.time.Time\n+\n+record AuditStamp {\n+  createdAt: Time\n+  updatedAt: Time\n+}\n+```\n+\n+**Note:**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43affac2537955fedb2bbd8aae014ad6d8651b9"}, "originalPosition": 898}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 592, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}