{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MTI4ODcx", "number": 314, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDozNDowNVrOEBjlWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDowOVrOEDzO0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY3MDMzOnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDozNDowNVrOGdeVpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzoyOTozNFrOGgouuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1ODk0OA==", "bodyText": "nit: \"Guide for using PathSpec in Rest.li\"\nAlso, just a general guideline/FYI, but the excerpt property is primarily used for displaying snippets on the search page. Keep this in mind when writing new pages.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433558948", "createdAt": "2020-06-02T00:34:05Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NDkzNg==", "bodyText": "reworded, thanks!", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436874936", "createdAt": "2020-06-08T17:29:34Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1ODk0OA=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY3NDI0OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDozNjoxNlrOGdeX9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozMTo1OFrOGgo0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1OTU0Mg==", "bodyText": "(used in the data-transform)\n\nWhat does this mean? Users may not understand what this is referring to.\n\ntwo forms of concrete existences\n\nI would suggest rephrasing as \"two concrete forms\"", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433559542", "createdAt": "2020-06-02T00:36:16Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NjQ0Ng==", "bodyText": "changed. Thanks", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436876446", "createdAt": "2020-06-08T17:31:58Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1OTU0Mg=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY4MTA3OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo0MDozNVrOGdeb-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozNjoxOFrOGgo_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MDU2OA==", "bodyText": "It may be helpful to explain the relationship between these \"two forms\". The string form isn't just another form, it's the serialized representation of the Java class form. You somewhat explain this in the last sentence, but it could be made more clear.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433560568", "createdAt": "2020-06-02T00:40:35Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3OTEzNA==", "bodyText": "I understand your concern and also mentioned this is not language specific.\nI just feel that given the fact that \"java\" is now the only available language in the wiki docs now, it became harder to explain.\nBut I also think it is not very ambiguous. Rest.li wiki readers who are seeking answers shouldn't get confused.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436879134", "createdAt": "2020-06-08T17:36:18Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MDU2OA=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY4ODM4OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo0NToyMFrOGdegcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozMDoyMFrOGgoweQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MTcxNQ==", "bodyText": "In order to make this page as easy as possible to process, I would start by showing an example of a complex data map along with the string PathSpec to access a certain element, as well as the equivalent Java form.\nfor example:\n{ \"a:\" { \"b\": { \"c\": 123 }}}\nboth /a/b/c and new PathSpec(\"a\", \"b\", \"c\") refer to the innermost element.\nWhat would be really nice is to follow Karthik's style in the PDL docs, and come up with one example data or theme of examples, and use that for all the examples on this page.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433561715", "createdAt": "2020-06-02T00:45:20Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NTM4NQ==", "bodyText": "Added an example", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436875385", "createdAt": "2020-06-08T17:30:20Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MTcxNQ=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY5MDM3OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo0NjozMFrOGdehrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo0MDo0MlrOGgpIjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MjAyOQ==", "bodyText": "I would suggest renaming section to \"Applications\", and having the subsections be \"Specifying Projections\", \"Validation\", etc.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433562029", "createdAt": "2020-06-02T00:46:30Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTU1MA==", "bodyText": "changed. Thanks", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436881550", "createdAt": "2020-06-08T17:40:42Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MjAyOQ=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDY5OTAyOnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo1MjoyMVrOGdenAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzo1Nzo1MlrOGgpvkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MzM5Mw==", "bodyText": "The layout here doesn't really seem to make sense. The \"PathSpec Semantics\" section seems to detail the syntax, whereas the \"PathSpec Syntax\" section just gives a link to some other page.\n\n\nI would suggest consolidating this part into one primary section called \"Syntax\", which details the syntax and semantics for PathSpec and the different features (e.g. array, map, union, attributes) with subsections.\n\n\nThis seems to me to be the most important part, I would suggest bumping up the syntax section to after the intro section and before the \"Applications\" section.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433563393", "createdAt": "2020-06-02T00:52:21Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5MTUzOQ==", "bodyText": "now there are only two sections now, PathSpec Syntax in its string form and PathSpec Syntax in its java binded class form", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436891539", "createdAt": "2020-06-08T17:57:52Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2MzM5Mw=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDcwMzA4OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo1NDozMVrOGdepSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODowMTo1N1rOGgp5DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2Mzk3OQ==", "bodyText": "This is misleading. It seems to imply that only some \"types\" of PathSpec can have attributes. Based on my understanding, any PathSpec can have arbitrary attributes, similar to the way a standard URL can.\nIt would also be worthy to note that certain \"reserved\" attributes have defined behavior based on the PathSpec specific (e.g. start, count). There should be a section for attributes which lists these reserved attributes.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433563979", "createdAt": "2020-06-02T00:54:31Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in RestLi framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec format is represented by separators(`'/'`) and segments in between. \n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment for some types, such as array, could have some attributes, which following the `&` sign, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5Mzk2NA==", "bodyText": "you are right and I am aware of that. But I don't think it meaningful to introduce non-reserved attribute since they are not interpreted anyway. It will add to confusion.\nBut I have re-worded this part.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436893964", "createdAt": "2020-06-08T18:01:57Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in RestLi framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec format is represented by separators(`'/'`) and segments in between. \n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment for some types, such as array, could have some attributes, which following the `&` sign, ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2Mzk3OQ=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDcwNzE3OnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo1NjoxMVrOGderfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo1NjoxMVrOGderfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NDU0MQ==", "bodyText": "typo", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433564541", "createdAt": "2020-06-02T00:56:11Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in RestLi framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec format is represented by separators(`'/'`) and segments in between. \n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment for some types, such as array, could have some attributes, which following the `&` sign, \n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+## PathSpec Syntax in its string form\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](https://linkedin.github.io/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+## Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of record type\n+ */\n+record RecordWithMapFields {\n+\n+  recordMap: map[string, RecordBar]\n+\n+  recordInlineMap: map[string, record RecordInMap {\n+    f: int\n+  }]\n+}\n+```\n+The PathSpec to refer to the record field, and the inline map field, are\n+```\n+/recordMap/*/location\n+/recordInlineMap/*/f\n+```\n+\n+##### Array type\n+Array type is somewhat similar to Map type in the sense that the length might not be definite. For example it could be defined as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing an array field, which holds values of record type\n+ */\n+record RecordWithArrayFields {\n+\n+  recordArray: array[RecordBar]\n+\n+  recordInlineArray: array[record RecordInArray {\n+    f: int\n+  }]\n+}\n+```\n+Then similarly if you are interested in some fields only, you can use wildCard to select all elements so you can refer to a field\n+```\n+/recordArray/*/location\n+/recordInlineArray/*/f\n+```\n+\n+One big difference between Array and Map is that in Array, we support reference to the range. It is achieved by specifying attributes aforementioned. 1\n+\n+Say you want to select some elements in within a range in the array, you can do so by using the \"start\" and \"count\" attribute, \n+```\n+/intArray?start=10&count=5\n+/recordInlineArray?count=2\n+```\n+\n+\n+It worth noting that single element indexing is currently not defined yet. For example indexing the first element of an array is currently not defined. Alternatively this can be achieved by using the range PathSpec.\n+```\n+/recordArray/0 # This sytanx is not defined yet\n+/recordArray?start=0&count=1 # This syntax has been defined\n+```\n+\n+\n+\n+### Union and UnionArray, Alias and Alias in Union\n+\n+##### Union\n+The use case for the PathSpec for union would be a path to one of the types within the union.\n+\n+Here is an example of a record containa a union field, and that union is with a null type\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union with null type\n+ */\n+record UnionExample {\n+\n+  unionWithNull: union[\n+    int,\n+    string,\n+    bytes,\n+    RecordBar,\n+    array[string],\n+    map[string, long],\n+    null\n+  ]\n+}\n+```\n+\n+The PathSpecs for types within the uinos are\n+```\n+/unionWithNull/null\n+/unionWithNull/int\n+/unionWithNull/string\n+```\n+\n+##### UnionArray\n+Union can be used as Array's item type. A common use case is a reference to all the same  type within an union.\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union array\n+ */\n+record UnionArrayExample {\n+\n+  unionArray: array[union[\n+    null,\n+    int,\n+    string,\n+    map[string, string],\n+    array[int],\n+    RecordBar,\n+    FixedMD5\n+  ]]\n+}\n+```\n+\n+```\n+/unionArray/*/null\n+/unionArray/*/int\n+/unionArray/*/string\n+/unionArray/*/RecordBar\n+\n+```\n+In this example, the union also contains array and map, and the reference to them would be \n+```\n+/unionArray/*/map\n+/unionArray/*/array\n+```\n+If the schema defines more than one array or more than one map in the union, they need to have defined alias for each (see Alias usage in next section).\n+\n+##### Alias\n+Alias are used for refer to types (such as record type) that cannot be directly defined in the field due to same name conflict. Here is an example PDSC with name \"AliasTest\" in \"AliasTest.pdsc\"\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * Aliase examples\n+ */\n+@aliases = [\"com.linkedin.pegasus.examples.AliasTest2\"]\n+record AliasTest {\n+  a1: AliasTest\n+  a2: AliasTest\n+}\n+```\n+Here the AliasTest2 is an alias for another record with same name \"AliasTest\" in \"AliasTest2.pdsc\"\n+\n+Then here are the PathSpec can be used\n+```\n+/a1/a1\n+/a1/a2\n+/a1/a1/a2\n+```\n+\n+##### Alias in Union\n+\n+It is worth mentioning that in most cases you will want to use alias in Union. For example in Union you can define two arrays with \n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordWithAliasedUnion {\n+\n+  result: union[\n+    message: string,\n+\n+    successResults: array[string],\n+\n+    failureResults: array[string]\n+  ]\n+\n+  unionArray: array[union[\n+    null,\n+\n+    successResults: array[string],\n+\n+    failureResults: array[string]\n+  ]]\n+}\n+```\n+Then the PathSpec will be \n+```\n+/result/successResults\n+/result/failureResults\n+/unionArray/*/successResults\n+/unionArray/*/failureResults\n+```\n+\n+### TypeRef and Fixed\n+The reference to TypeRef and fixed are following a similar rule: Use its name in the field.\n+\n+##### TypeRef\n+The \"TypeRef\" itself can be treated as just another type, so should use field name to refer to its path. \n+\n+For example\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record TyperefTest {\n+\n+  intRefField: optional typeref IntRef = int\n+  intRefField2: IntRef\n+\n+  bar1: typeref RecordBarRef = RecordBar\n+  bar2: RecordBarRef\n+\n+  barRefMap: map[string, RecordBarRef]\n+}\n+```\n+\n+The paths to the example integer fields here (used TypeRef) are \n+```\n+/intRefField\n+/intRefField2\n+```\n+And for Record field reference within TypeRefed field\n+```\n+/bar1/location\n+/bar2/location\n+```\n+In the Map type example\n+```\n+/barRefMap/*/location\n+```\n+\n+\n+#### FixedI#", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDcyMDIwOnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMTowNDo0MVrOGdezVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzoyNzo1MlrOGgoqog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NjU0OA==", "bodyText": "General comments for this whole PR:\n\n\nI'd suggest rethinking how you frame what a PathSpec is. You say that a PathSpec is a concept with \"two forms\". This isn't exactly true. A PathSpec is a specification with an intended meaning, and is language agnostic. There could be PathSpec support in Python, Go, etc. You should frame PathSpecs as just a specification, and it happens to have implemented bindings in Java (not sure about other languages). I'd recommend highlighting the concept and the specification, and treating the Java binding as just an implementation.\n\n\nAll your links are full links to the live website. I'd advise against this. You should either be using absolute path links (e.g. /rest.li/something) or better yet relative links using the built-in Jekyll relative_url plugin (e.g. {{ 'something' | relative_url }}. This second approach is best-practice because it takes into account the \"base URL\" of the website (e.g. \"/\", \"/rest.li/\"). See here for an example.\n\n\nI see inconsistent formatting of Rest.li's name (e.g. Rest.Li, Restli, RestLi). I'd suggest referencing Rest.li using the standard format: \"Rest.li\". Can be solved using simple search-and-replace.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433566548", "createdAt": "2020-06-02T01:04:41Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3Mzg5MA==", "bodyText": "(1) reworded, thanks!\n(2) Changed, thanks!\n(3) updated, thanks.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436873890", "createdAt": "2020-06-08T17:27:52Z", "author": {"login": "junchuanwang"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NjU0OA=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDcyNDQ5OnYy", "diffSide": "RIGHT", "path": "src/_data/user_guide_navigation.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMTowNzoyNlrOGde12w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1ODozNFrOGhCEBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzE5NQ==", "bodyText": "I don't think this is appropriate for the \"How to\" subheading. This is less of a guide and more of a specification for the PathSpec concept. Tbh I think this would be more appropriate in most of the other sections (eg. Data Schemas, Data, Main Concepts, etc.)", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433567195", "createdAt": "2020-06-02T01:07:26Z", "author": {"login": "evanw555"}, "path": "src/_data/user_guide_navigation.yml", "diffHunk": "@@ -67,6 +67,8 @@ toc:\n         url: /rest.li/Send-Rest_li-Request-Query-In-Request-Body\n       - page: Use Projections\n         url: /rest.li/How-to-use-projections-in-Java\n+      - page: Use PathSpec in Rest.Li", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3MDg1MA==", "bodyText": "I thought about putting this file there. But I had two reasons\n(1) most of the contents in this files are just examples, looks more fitting to \"how to\" section.\n(2) This concept is not very big and has been mentioned in projection or validation. I don't think there needs to be a separate page for that. In fact if we have had too many files in those two secionts Data Schema and Main Concept, it adds burden to the users to understand.\nI mainly want to keep this is a reference guide.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r436870850", "createdAt": "2020-06-08T17:23:24Z", "author": {"login": "junchuanwang"}, "path": "src/_data/user_guide_navigation.yml", "diffHunk": "@@ -67,6 +67,8 @@ toc:\n         url: /rest.li/Send-Rest_li-Request-Query-In-Request-Body\n       - page: Use Projections\n         url: /rest.li/How-to-use-projections-in-Java\n+      - page: Use PathSpec in Rest.Li", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzE5NQ=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4OTk5MA==", "bodyText": "I agree with Evan on this.\nNormally \"How to\" pages should answer how to solve a specific problem. This can go under the \"Main Concepts\" section?", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437289990", "createdAt": "2020-06-09T09:58:34Z", "author": {"login": "karthikbalasub"}, "path": "src/_data/user_guide_navigation.yml", "diffHunk": "@@ -67,6 +67,8 @@ toc:\n         url: /rest.li/Send-Rest_li-Request-Query-In-Request-Body\n       - page: Use Projections\n         url: /rest.li/How-to-use-projections-in-Java\n+      - page: Use PathSpec in Rest.Li", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzE5NQ=="}, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDcyNTUzOnYy", "diffSide": "RIGHT", "path": "src/pathspec_user_guide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMTowODowMVrOGde2cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMTowODowMVrOGde2cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzM0NA==", "bodyText": "nit: \"More Examples\"", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r433567344", "createdAt": "2020-06-02T01:08:01Z", "author": {"login": "evanw555"}, "path": "src/pathspec_user_guide.md", "diffHunk": "@@ -0,0 +1,444 @@\n+---\n+layout: guide\n+title: PathSpec User Guide\n+permalink: /pathspec_user_guide\n+excerpt: Guide for use PathSpec within Rest.Li\n+---\n+\n+# PathSpec User Guide\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.Li framework. It generates uniform references in hierarchical data maps (used in the data-transform) component. It is an abstract path concept which has two forms of concrete existences.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](https://linkedin.github.io/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Restli Framework. Its Java class form is now mainly used for [Projection in Rest.Li framework](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java). The PathSpec java class also has a method to return the correct path string by calling `toString()`.\n+\n+## Current usage\n+### PathSpec in Projection\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar(); \n+```\n+\n+More concrete examples can be found [here in the wiki](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.Li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### PathSpec in Validation\n+PathSpec's string form is used for [Request Validation](https://linkedin.github.io/rest.li/Validation-in-Rest_li) in Rest.Li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSec Semantics\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in RestLi framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec format is represented by separators(`'/'`) and segments in between. \n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment for some types, such as array, could have some attributes, which following the `&` sign, \n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+## PathSpec Syntax in its string form\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](https://linkedin.github.io/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+## Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of record type\n+ */\n+record RecordWithMapFields {\n+\n+  recordMap: map[string, RecordBar]\n+\n+  recordInlineMap: map[string, record RecordInMap {\n+    f: int\n+  }]\n+}\n+```\n+The PathSpec to refer to the record field, and the inline map field, are\n+```\n+/recordMap/*/location\n+/recordInlineMap/*/f\n+```\n+\n+##### Array type\n+Array type is somewhat similar to Map type in the sense that the length might not be definite. For example it could be defined as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing an array field, which holds values of record type\n+ */\n+record RecordWithArrayFields {\n+\n+  recordArray: array[RecordBar]\n+\n+  recordInlineArray: array[record RecordInArray {\n+    f: int\n+  }]\n+}\n+```\n+Then similarly if you are interested in some fields only, you can use wildCard to select all elements so you can refer to a field\n+```\n+/recordArray/*/location\n+/recordInlineArray/*/f\n+```\n+\n+One big difference between Array and Map is that in Array, we support reference to the range. It is achieved by specifying attributes aforementioned. 1\n+\n+Say you want to select some elements in within a range in the array, you can do so by using the \"start\" and \"count\" attribute, \n+```\n+/intArray?start=10&count=5\n+/recordInlineArray?count=2\n+```\n+\n+\n+It worth noting that single element indexing is currently not defined yet. For example indexing the first element of an array is currently not defined. Alternatively this can be achieved by using the range PathSpec.\n+```\n+/recordArray/0 # This sytanx is not defined yet\n+/recordArray?start=0&count=1 # This syntax has been defined\n+```\n+\n+\n+\n+### Union and UnionArray, Alias and Alias in Union\n+\n+##### Union\n+The use case for the PathSpec for union would be a path to one of the types within the union.\n+\n+Here is an example of a record containa a union field, and that union is with a null type\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union with null type\n+ */\n+record UnionExample {\n+\n+  unionWithNull: union[\n+    int,\n+    string,\n+    bytes,\n+    RecordBar,\n+    array[string],\n+    map[string, long],\n+    null\n+  ]\n+}\n+```\n+\n+The PathSpecs for types within the uinos are\n+```\n+/unionWithNull/null\n+/unionWithNull/int\n+/unionWithNull/string\n+```\n+\n+##### UnionArray\n+Union can be used as Array's item type. A common use case is a reference to all the same  type within an union.\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union array\n+ */\n+record UnionArrayExample {\n+\n+  unionArray: array[union[\n+    null,\n+    int,\n+    string,\n+    map[string, string],\n+    array[int],\n+    RecordBar,\n+    FixedMD5\n+  ]]\n+}\n+```\n+\n+```\n+/unionArray/*/null\n+/unionArray/*/int\n+/unionArray/*/string\n+/unionArray/*/RecordBar\n+\n+```\n+In this example, the union also contains array and map, and the reference to them would be \n+```\n+/unionArray/*/map\n+/unionArray/*/array\n+```\n+If the schema defines more than one array or more than one map in the union, they need to have defined alias for each (see Alias usage in next section).\n+\n+##### Alias\n+Alias are used for refer to types (such as record type) that cannot be directly defined in the field due to same name conflict. Here is an example PDSC with name \"AliasTest\" in \"AliasTest.pdsc\"\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * Aliase examples\n+ */\n+@aliases = [\"com.linkedin.pegasus.examples.AliasTest2\"]\n+record AliasTest {\n+  a1: AliasTest\n+  a2: AliasTest\n+}\n+```\n+Here the AliasTest2 is an alias for another record with same name \"AliasTest\" in \"AliasTest2.pdsc\"\n+\n+Then here are the PathSpec can be used\n+```\n+/a1/a1\n+/a1/a2\n+/a1/a1/a2\n+```\n+\n+##### Alias in Union\n+\n+It is worth mentioning that in most cases you will want to use alias in Union. For example in Union you can define two arrays with \n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordWithAliasedUnion {\n+\n+  result: union[\n+    message: string,\n+\n+    successResults: array[string],\n+\n+    failureResults: array[string]\n+  ]\n+\n+  unionArray: array[union[\n+    null,\n+\n+    successResults: array[string],\n+\n+    failureResults: array[string]\n+  ]]\n+}\n+```\n+Then the PathSpec will be \n+```\n+/result/successResults\n+/result/failureResults\n+/unionArray/*/successResults\n+/unionArray/*/failureResults\n+```\n+\n+### TypeRef and Fixed\n+The reference to TypeRef and fixed are following a similar rule: Use its name in the field.\n+\n+##### TypeRef\n+The \"TypeRef\" itself can be treated as just another type, so should use field name to refer to its path. \n+\n+For example\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record TyperefTest {\n+\n+  intRefField: optional typeref IntRef = int\n+  intRefField2: IntRef\n+\n+  bar1: typeref RecordBarRef = RecordBar\n+  bar2: RecordBarRef\n+\n+  barRefMap: map[string, RecordBarRef]\n+}\n+```\n+\n+The paths to the example integer fields here (used TypeRef) are \n+```\n+/intRefField\n+/intRefField2\n+```\n+And for Record field reference within TypeRefed field\n+```\n+/bar1/location\n+/bar2/location\n+```\n+In the Map type example\n+```\n+/barRefMap/*/location\n+```\n+\n+\n+#### FixedI#\n+Fixed type can be defined in a separate file and then refered in another schema by name, for example in schema files:\n+```pdl\n+namespace com.linkedin.pegasus.example\n+\n+fixed FixedMD5 16\n+```\n+Then `FixedMD5` can be used as a type. \n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of union of fix type and inline fix type\n+ */\n+record RecordExampleForFixType {\n+\n+  unionMap: map[string, union[fixed InlineFixedField 1, FixedMD5]]\n+}\n+```\n+As above example shows, when fixed type are defined inline, they will still have field name, so the PathSpec reference to it uses this name, therefore below are PathSpec to the types in the UnionMap defined in this record\n+```\n+/unionMap/*/InlineFixedField\n+/unionMap/*/FixedMD5\n+```\n+\n+## PathSpec Syntax in its java binded class form\n+All auto-generated `RecordTemplate` class has a static nested class `fields` which extends `PathSpec`. To find out, after you build the Rest.Li project, you could check such `RecordTemplate` classes in `GeneratedDataTemplate` folder and to find following codes.\n+```java\n+  public static class Fields extends PathSpec\n+  {\n+    ....\n+  }\n+```\n+[Check example code here](https://github.com/linkedin/rest.li/blob/master/generator-test/src/test/java/com/linkedin/pegasus/generator/test/pdl/fixtures/CustomRecord.java#L62). \n+Therefore it is very easy to get the PathSpec java binded class. Let's say you have a `Foo` schema which has `bar` fields. You can get the PathSpec by following\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+This has also been documented in [How to Use Projections in Java](https://linkedin.github.io/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field)\n+\n+\n+## More Resources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5da12a1d851ef6bd1d7089f6d933533744469cb3"}, "originalPosition": 443}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDEzOTk5OnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozNjowOFrOGhBP8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzo1NTowM1rOGkmwkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NjY1Ng==", "bodyText": "This should be \"How to use..\"", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437276656", "createdAt": "2020-06-09T09:36:08Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzNjk0NQ==", "bodyText": "Renamed and moved to main concepts", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r441036945", "createdAt": "2020-06-16T17:55:03Z", "author": {"login": "junchuanwang"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NjY1Ng=="}, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDE3OTcxOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0Njo1MFrOGhBpIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0Njo1MFrOGhBpIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4MzEwNQ==", "bodyText": "These attributes added to the string form using '?' and '&' separators.", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437283105", "createdAt": "2020-06-09T09:46:50Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDE4MzUwOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0Nzo1N1rOGhBrrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0Nzo1N1rOGhBrrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4Mzc1Nw==", "bodyText": "For collection types..", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437283757", "createdAt": "2020-06-09T09:47:57Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDE4NTEyOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0ODoyNVrOGhBsxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0ODoyNVrOGhBsxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NDAzOQ==", "bodyText": "remove this line?", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437284039", "createdAt": "2020-06-09T09:48:25Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+Each PathSpec has a corresponding string form.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDE5NDMxOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MDo1M1rOGhBycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MDo1M1rOGhBycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NTQ5MA==", "bodyText": "demonstration", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437285490", "createdAt": "2020-06-09T09:50:53Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined various kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus and following sections list the example pathspecs.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+### Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDE5OTUxOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MjoyMlrOGhB10w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MjoyMlrOGhB10w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NjM1NQ==", "bodyText": "It is achieved by using the 'start' and 'count' attributes.\n(Hard to remember which attributes you are referring to, or if someone reads this section directly)", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437286355", "createdAt": "2020-06-09T09:52:22Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined various kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus and following sections list the example pathspecs.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+### Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of record type\n+ */\n+record RecordWithMapFields {\n+\n+  recordMap: map[string, RecordBar]\n+\n+  recordInlineMap: map[string, record RecordInMap {\n+    f: int\n+  }]\n+}\n+```\n+The PathSpec to refer to the record field, and the inline map field, are\n+```\n+/recordMap/*/location\n+/recordInlineMap/*/f\n+```\n+\n+##### Array type\n+Array type is somewhat similar to Map type in the sense that the length might not be definite. For example it could be defined as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing an array field, which holds values of record type\n+ */\n+record RecordWithArrayFields {\n+\n+  recordArray: array[RecordBar]\n+\n+  recordInlineArray: array[record RecordInArray {\n+    f: int\n+  }]\n+}\n+```\n+Then similarly if you are interested in some fields only, you can use wildCard to select all elements so you can refer to a field\n+```\n+/recordArray/*/location\n+/recordInlineArray/*/f\n+```\n+\n+One big difference between Array and Map is that in Array, we support reference to the range. It is achieved by specifying attributes aforementioned. 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDIwNTE4OnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1Mzo1OVrOGhB5eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1Mzo1OVrOGhB5eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NzI4OA==", "bodyText": "s/pdsc/pdl", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437287288", "createdAt": "2020-06-09T09:53:59Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined various kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus and following sections list the example pathspecs.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+### Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of record type\n+ */\n+record RecordWithMapFields {\n+\n+  recordMap: map[string, RecordBar]\n+\n+  recordInlineMap: map[string, record RecordInMap {\n+    f: int\n+  }]\n+}\n+```\n+The PathSpec to refer to the record field, and the inline map field, are\n+```\n+/recordMap/*/location\n+/recordInlineMap/*/f\n+```\n+\n+##### Array type\n+Array type is somewhat similar to Map type in the sense that the length might not be definite. For example it could be defined as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing an array field, which holds values of record type\n+ */\n+record RecordWithArrayFields {\n+\n+  recordArray: array[RecordBar]\n+\n+  recordInlineArray: array[record RecordInArray {\n+    f: int\n+  }]\n+}\n+```\n+Then similarly if you are interested in some fields only, you can use wildCard to select all elements so you can refer to a field\n+```\n+/recordArray/*/location\n+/recordInlineArray/*/f\n+```\n+\n+One big difference between Array and Map is that in Array, we support reference to the range. It is achieved by specifying attributes aforementioned. 1\n+\n+Say you want to select some elements in within a range in the array, you can do so by using the \"start\" and \"count\" attribute, \n+```\n+/intArray?start=10&count=5\n+/recordInlineArray?count=2\n+```\n+\n+\n+It worth noting that single element indexing is currently not defined yet. For example indexing the first element of an array is currently not defined. Alternatively this can be achieved by using the range PathSpec.\n+```\n+/recordArray/0 # This sytanx is not defined yet\n+/recordArray?start=0&count=1 # This syntax has been defined\n+```\n+\n+\n+\n+### Union and UnionArray, Alias and Alias in Unions\n+\n+##### Union\n+The use case for the PathSpec for union would be a path to one of the types within the union.\n+\n+Here is an example of a record containa a union field, and that union is with a null type\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union with null type\n+ */\n+record UnionExample {\n+\n+  unionWithNull: union[\n+    int,\n+    string,\n+    bytes,\n+    RecordBar,\n+    array[string],\n+    map[string, long],\n+    null\n+  ]\n+}\n+```\n+\n+The PathSpecs for types within the uinos are\n+```\n+/unionWithNull/null\n+/unionWithNull/int\n+/unionWithNull/string\n+```\n+\n+##### UnionArray\n+Union can be used as Array's item type. A common use case is a reference to all the same  type within an union.\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union array\n+ */\n+record UnionArrayExample {\n+\n+  unionArray: array[union[\n+    null,\n+    int,\n+    string,\n+    map[string, string],\n+    array[int],\n+    RecordBar,\n+    FixedMD5\n+  ]]\n+}\n+```\n+\n+```\n+/unionArray/*/null\n+/unionArray/*/int\n+/unionArray/*/string\n+/unionArray/*/RecordBar\n+\n+```\n+In this example, the union also contains array and map, and the reference to them would be \n+```\n+/unionArray/*/map\n+/unionArray/*/array\n+```\n+If the schema defines more than one array or more than one map in the union, they need to have defined alias for each (see Alias usage in next section).\n+\n+##### Alias\n+Alias are used for refer to types (such as record type) that cannot be directly defined in the field due to same name conflict. Here is an example PDSC with name \"AliasTest\" in \"AliasTest.pdsc\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDIwNTYzOnYy", "diffSide": "RIGHT", "path": "src/use_pathspec.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDowOVrOGhB5xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1NDowOVrOGhB5xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NzM2NA==", "bodyText": "pdsc -> pdl", "url": "https://github.com/linkedin/rest.li/pull/314#discussion_r437287364", "createdAt": "2020-06-09T09:54:09Z", "author": {"login": "karthikbalasub"}, "path": "src/use_pathspec.md", "diffHunk": "@@ -0,0 +1,479 @@\n+---\n+layout: guide\n+title: Use PathSpec in Rest.Li\n+permalink: /use_pathspec\n+excerpt: Guide for using PathSpec within Rest.li\n+---\n+\n+# Use PathSpec in Rest.Li\n+- [Use PathSpec in Rest.Li](#use-pathspec-in-restli)\n+  - [What is PathSpec](#what-is-pathspec)\n+  - [Applications](#applications)\n+    - [Specifying Projections](#specifying-projections)\n+    - [Request Validation](#request-validation)\n+  - [PathSpec Syntax in its string form](#pathspec-syntax-in-its-string-form)\n+    - [Primitive type fields](#primitive-type-fields)\n+    - [Record type fields](#record-type-fields)\n+    - [Map and Array type fields](#map-and-array-type-fields)\n+        - [Map type](#map-type)\n+        - [Array type](#array-type)\n+    - [Union and UnionArray, Alias and Alias in Unions](#union-and-unionarray-alias-and-alias-in-unions)\n+        - [Union](#union)\n+        - [UnionArray](#unionarray)\n+        - [Alias](#alias)\n+        - [Alias in Unions](#alias-in-unions)\n+    - [TypeRef and Fixed](#typeref-and-fixed)\n+        - [TypeRef](#typeref)\n+      - [Fixed](#fixed)\n+  - [PathSpec Syntax in its java binded class form](#pathspec-syntax-in-its-java-binded-class-form)\n+  - [More resources and examples](#more-resources-and-examples)\n+\n+## What is PathSpec\n+PathSpec represents a path to a component within a complex data object within Rest.li framework. It generates uniform references in hierarchical [datamap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) components. It is an abstract path concept and has its specification. It currently has two concrete forms in Rest.li, but it is not language-specific.\n+\n+1. The PathSpec path can be represented as a string, current example usages of its string form can be found in [Validation annotation](/rest.li/Validation-in-Rest_li#specifying-restli-validation-annotations), where the PathSpec string is used in annotation and the [Annotation Reader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java#L185) would interpret it.\n+\n+2. The PathSpec path also have a binded java class: [PathSpec.java](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/PathSpec.java). This java class can be passed as arguments in Rest.li Framework. Its Java class form is now mainly used for [Projection in Rest.li framework](/rest.li/How-to-use-projections-in-Java). The PathSpec java class has convenient method to return the correct pathspec string by calling `toString()`, which returns the string form.\n+\n+For example:\n+given a data schema\n+```pdl\n+record User {\n+  firstName: string\n+  birthday: optional Date\n+  isActive: boolean = true\n+  address: record Address {\n+    state: string\n+    zipcode: string\n+  }\n+}\n+```\n+both `/address/zipcode` and `new PathSpec(\"addressa\", \"zipcodeb\")` are pathspecs referring to the inner `zipcode` field.\n+## Applications \n+### Specifying Projections\n+PathSpec's java class binding can be used for projection. Users can get PathSpec object that represents the fields in data object. For example, it could be obtained from generated RecordTemplate subclasses using the .fields() method. \n+For example:\n+```java\n+PathSpec pathSpec = Foo.fields().bar();\n+```\n+\n+More concrete examples can be found [here in the wiki](/rest.li/How-to-use-projections-in-Java#getting-the-pathspec-of-a-field).\n+\n+This capability is provided by Rest.li auto-generated code, as data object representation for data in Pegasus schema should extend [RecordTemplate.java](/rest.li/blob/master/data/src/main/java/com/linkedin/data/template/RecordTemplate.java), and will define a inner class called \"fields\", which extended PathSpec.java. By passing PathSpec object to the reqeust builder, the PathSpec is then used by [MaskCreator](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java) to create a [MaskTree](https://github.com/linkedin/rest.li/blob/master/data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskTree.java). Thus, PathSpec can be used to control the projection behavior.\n+\n+### Request Validation\n+PathSpec's string form is used for [Request Validation](/rest.li/Validation-in-Rest_li) in Rest.li Resource. A string path can be added in annotation such as \"CreateOnly\" and \"ReadOnly\". For example:\n+```java\n+@CreateOnly({\"/id\", \"/EXIF\"})\n+public class PhotoResource extends CollectionResourceTemplate<Long, Photo>\n+{\n+    // ...\n+}\n+```\n+\n+This string is then parsed by [RestLiAnnotationReader](https://github.com/linkedin/rest.li/blob/master/restli-server/src/main/java/com/linkedin/restli/internal/server/model/RestLiAnnotationReader.java), and [DataSchemaUtil](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/schema/DataSchemaUtil.java) will do corresponding validation against this path within the DataMap.\n+\n+You can also invoke [RestliDataValidator](https://github.com/linkedin/rest.li/blob/master/restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java) and pass PathSpec string to it. [TestRestLiValidation.java](https://github.com/linkedin/rest.li/blob/master/restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java)'s testCustomValidatorMap() is such an example\n+```java\n+    ...\n+\n+    Map<String, List<String>> annotations = new HashMap<>();\n+    annotations.put(\"createOnly\", Arrays.asList(\"stringB\", \n+        \"intB\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo2\", \"MapWithTyperefs/*/id\"));\n+    annotations.put(\"readOnly\", Arrays.asList(\"stringA\", \n+        \"intA\", \"UnionFieldWithInlineRecord/com.linkedin.restli.examples.greetings.api.myRecord/foo1\", \"ArrayWithInlineRecord/*/bar1\", \"validationDemoNext/stringB\", \"validationDemoNext/UnionFieldWithInlineRecord\"));\n+    ...\n+\n+    validator = new RestLiDataValidator(annotations, ValidationDemo.class, ResourceMethod.CREATE, validatorClassMap);\n+\n+```\n+\n+## PathSpec Syntax in its string form\n+\n+PathSpec has been defined as a path to a component within a complex data object path. This provides a way to traverse the Pegasus data object. The abstract data object, in most case, is a form of [DataMap](https://github.com/linkedin/rest.li/blob/master/data/src/main/java/com/linkedin/data/DataMap.java) internally in Rest.li framework, but PathSpec should be meaningful for the same data object in other forms, for example, a json representing the same data object.\n+\n+The PathSpec string format is represented by separators(`'/'`) and segments in between.\n+```\n+/demoRecord/innerRecordField/nestedInnerRecordField\n+```\n+\n+The path segment could use attribute syntax to carry some meaningful attributes. They attributes could be added following the `&` sign. Users can add any attributes but for some types, there are reserved attributes. For example, for array type, one can specify `start` and `count` attributes and these two attributes are used in specifying projections.\n+```\n+/arrayOfIntFieldE?start=0&count=10\n+```\n+\n+For some collection types, such as maps and arrays, the path segment could also be replaced by the wildcard. A wildcard means that this segment path string can be replaced by any applicable segment string, for example.\n+```\n+/mapOfRecordField/*/innerRecordField\n+```\n+Above examples points to the `innerRecordField` field of the `map` value in a `map` schema. `map` is a collection schema type, here `*` wildcarded its keys.\n+\n+Each PathSpec has a corresponding string form.\n+\n+Pegasus schema has defined various kinds of types, the full specification about the supported types can be found from the document [Rest.li Data Schema And Templates](/rest.li/DATA-Data-Schema-and-Templates). There are mainly following supported types in Pegasus and following sections list the example pathspecs.\n+\n+### Primitive type fields\n+Primitive types includes type such as bytes, string, boolean, double, float, long, int. In the reocrd form, they came with a name to the field in record, so the reference to the primitive types, in most cases are just a PathSpec string which specify the field name of this type. \n+\n+For example for a Pegasus pdsc schema file as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing primitive types\n+ */\n+record RecordTest {\n+  intField: int\n+  intOptionalField: optional int\n+  intDefaultField: int = 17\n+  intDefaultOptionalField: optional int = 42\n+  longField: long\n+  floatField: float\n+  doubleField: double\n+  booleanField: boolean\n+  stringField: string\n+  bytesField: bytes\n+}\n+```\n+The example PathSpec for above fields in this record example would be\n+```\n+/initField\n+/intOptionalField\n+/intDefaultField\n+/intDefaultOPtionalField\n+/longField\n+/floatField\n+/doubleField\n+/booleanField\n+/stringField\n+/bytesField\n+```\n+\n+### Record type fields\n+If a field in a record is of another record type, in this case  you have \"nested field\", then again the reference for the nested path component is the record's field name, \n+\n+For example the above PDSC schema example now hava a record field,\n+\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * example Pegasus schema of a record containing record field\n+ */\n+record RecordTest {\n+  recordField: RecordBar\n+}\n+```\n+And that record expands to\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+record RecordBar {\n+  location: string\n+}\n+```\n+\n+Then the PathSpec reference to the nested field \"location\" is\n+```\n+/recordField/location\n+```\n+### Map and Array type fields\n+Map and Array are two collection type used in Pagasus. \n+\n+##### Map type\n+The map has a key followed by the value referenced. Recall PathSpec's semantic is a reference to a component within a complex data object. The map entries were referenced by their keys. \n+\n+For example, here is a example PathSpec that can be used to traverse the map.\n+\n+```\n+/mapField/<AKeyInMap>\n+```\n+Note that the above PathSpec is referring to the component key-ed by the key in the map. If the value is of a primitive type, the above PathSpec can be implicitly used to refer to the primitive type value.\n+\n+If you want to specifically refer to all the key fields, the syntax is to use the keyword \"$key\"\n+```\n+/mapField/$key\n+```\n+\n+if the value held in the map is a record type and you want to refer to that record, the PathSpec could be\n+\n+```\n+/mapField/<AKeyInMap>/<someRecordField>\n+```\n+\n+Another common use case is that you want to use wildcard (represented by symbol \"*\" ) to \"select all keys\", if the interested path is to a field for all entries in this map, then it would be\n+\n+```\n+/mapField/*/<recordField>\n+```\n+\n+It is worth noting that in Pegasus, the map keys are always of string types.\n+\n+Here is an concrete example of a record, containing a map field, and that map field's map has value of record type. The example also defines a \"recordInlineMap\" field for similar demenstration purpose\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing a map field, which holds values of record type\n+ */\n+record RecordWithMapFields {\n+\n+  recordMap: map[string, RecordBar]\n+\n+  recordInlineMap: map[string, record RecordInMap {\n+    f: int\n+  }]\n+}\n+```\n+The PathSpec to refer to the record field, and the inline map field, are\n+```\n+/recordMap/*/location\n+/recordInlineMap/*/f\n+```\n+\n+##### Array type\n+Array type is somewhat similar to Map type in the sense that the length might not be definite. For example it could be defined as such\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record containing an array field, which holds values of record type\n+ */\n+record RecordWithArrayFields {\n+\n+  recordArray: array[RecordBar]\n+\n+  recordInlineArray: array[record RecordInArray {\n+    f: int\n+  }]\n+}\n+```\n+Then similarly if you are interested in some fields only, you can use wildCard to select all elements so you can refer to a field\n+```\n+/recordArray/*/location\n+/recordInlineArray/*/f\n+```\n+\n+One big difference between Array and Map is that in Array, we support reference to the range. It is achieved by specifying attributes aforementioned. 1\n+\n+Say you want to select some elements in within a range in the array, you can do so by using the \"start\" and \"count\" attribute, \n+```\n+/intArray?start=10&count=5\n+/recordInlineArray?count=2\n+```\n+\n+\n+It worth noting that single element indexing is currently not defined yet. For example indexing the first element of an array is currently not defined. Alternatively this can be achieved by using the range PathSpec.\n+```\n+/recordArray/0 # This sytanx is not defined yet\n+/recordArray?start=0&count=1 # This syntax has been defined\n+```\n+\n+\n+\n+### Union and UnionArray, Alias and Alias in Unions\n+\n+##### Union\n+The use case for the PathSpec for union would be a path to one of the types within the union.\n+\n+Here is an example of a record containa a union field, and that union is with a null type\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union with null type\n+ */\n+record UnionExample {\n+\n+  unionWithNull: union[\n+    int,\n+    string,\n+    bytes,\n+    RecordBar,\n+    array[string],\n+    map[string, long],\n+    null\n+  ]\n+}\n+```\n+\n+The PathSpecs for types within the uinos are\n+```\n+/unionWithNull/null\n+/unionWithNull/int\n+/unionWithNull/string\n+```\n+\n+##### UnionArray\n+Union can be used as Array's item type. A common use case is a reference to all the same  type within an union.\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * a record that has a field contains a union array\n+ */\n+record UnionArrayExample {\n+\n+  unionArray: array[union[\n+    null,\n+    int,\n+    string,\n+    map[string, string],\n+    array[int],\n+    RecordBar,\n+    FixedMD5\n+  ]]\n+}\n+```\n+\n+```\n+/unionArray/*/null\n+/unionArray/*/int\n+/unionArray/*/string\n+/unionArray/*/RecordBar\n+\n+```\n+In this example, the union also contains array and map, and the reference to them would be \n+```\n+/unionArray/*/map\n+/unionArray/*/array\n+```\n+If the schema defines more than one array or more than one map in the union, they need to have defined alias for each (see Alias usage in next section).\n+\n+##### Alias\n+Alias are used for refer to types (such as record type) that cannot be directly defined in the field due to same name conflict. Here is an example PDSC with name \"AliasTest\" in \"AliasTest.pdsc\"\n+```pdl\n+namespace com.linkedin.pegasus.examples\n+\n+/**\n+ * Aliase examples\n+ */\n+@aliases = [\"com.linkedin.pegasus.examples.AliasTest2\"]\n+record AliasTest {\n+  a1: AliasTest\n+  a2: AliasTest\n+}\n+```\n+Here the AliasTest2 is an alias for another record with same name \"AliasTest\" in \"AliasTest2.pdsc\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1bae3173e793db96f2f1aafdaeda9b1b2cefb"}, "originalPosition": 357}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 485, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}