{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4Nzg5NTEz", "number": 407, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0NToxN1rOEgHTFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMToyNDoxM1rOEh6csw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA5NDYzOnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0NToxN1rOHMzPsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMDoyMDozMVrOHM2JIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4NDU2Mg==", "bodyText": "Why do you need this?\nWould it be cleaner to use Function<DataSchema, Validator> that accepts the validating schema and returns the validator to use?\nOther option is to make it a protected method, which can be overridden.\nprotected Validator getValidatorForOutput(DataSchema validatingSchema);\n\nThis way, the logic to initialize the validator is still within this class.\nAlso, this validator has a separate logic for validating input entities (see validateInputEntity and validatePatch) using the DataValidator inner class. It would be good to handle that also. Something like:\nprotected Validator getValidatorForInput(DataSchema validatingSchema);\n\nIn both cases, if the overriding implementation needs caching, it can do\n {\n    return cache.computeIfAbsent(super.getValidator..(schema));\n  }", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483184562", "createdAt": "2020-09-03T18:45:17Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -436,6 +437,19 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate, MaskTree pro\n    * @throws IllegalArgumentException if any argument is null or if the provided data template has no data\n    */\n   protected ValidationResult validateOutputAgainstSchema(RecordTemplate dataTemplate, DataSchema validatingSchema)\n+  {\n+    if (validatingSchema == null)\n+    {\n+      throw new IllegalArgumentException(\"Validating schema is null\");\n+    }\n+\n+    return validateOutputAgainstSchema(dataTemplate,\n+        () -> ValidateDataAgainstSchema.validate(dataTemplate.data(), validatingSchema, new ValidationOptions(),\n+            new DataSchemaAnnotationValidator(validatingSchema)));\n+  }\n+\n+  protected ValidationResult validateOutputAgainstSchema(RecordTemplate dataTemplate,\n+      Supplier<ValidationResult> validationResultSupplier)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93f0cd225724d865df0c69f8b2db6f05c19ac4b8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMjAzNQ==", "bodyText": "In regards to protected Validator getValidatorForOutput(DataSchema validatingSchema);, we would be overriding this in RestLiDataSchemaDataValidator right?\nIn this case, the overridden method would look something like\nprotected Validator getValidatorForOutput(DataSchema validatingSchema) { \n     return _schemaValidator;\n}\n\nIt felt a little strange to me to do something like this, since we are ignoring the input validatingSchema parameter. Perhaps we can check if its == to the class' _validatingSchema and if it is return _schemaValidator, otherwise to create a new one. Thoughts? Essentially something like:\n@Override\n  protected Validator getValidatorForOutput(DataSchema validatingSchema) {\n    if (_validatingSchema.equals(validatingSchema))\n    {\n      return _schemaValidator;\n    }\n    else\n    {\n      return super.getValidatorForOutput(validatingSchema);\n    }\n  }\n\nSimilarly with the first suggestion, it felt strange to ignore schema input. From my understanding of your comment we would essentially have a method in the base class like\n  protected Function<DataSchema, Validator> getValidatorFunction() {\n    return DataSchemaAnnotationValidator::new;\n  }\n\nand override it in RestLiDataSchemaDataValidator with\n  @Override\n  protected Function<DataSchema, Validator> getValidatorFunction() {\n    return schema -> _schemaValidator;\n  }\n\nAgreed it would be great to do a similar thing for getValidatorForInput. Only thing here is the default implementation is new DataValidator(validatingSchema) and DataValidator is a private class in RestLiDataValidator. Is it okay to make it protected so that we have access to it in RestLiDataSchemaDataValidator?", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483232035", "createdAt": "2020-09-03T20:20:31Z", "author": {"login": "vshwnth2"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -436,6 +437,19 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate, MaskTree pro\n    * @throws IllegalArgumentException if any argument is null or if the provided data template has no data\n    */\n   protected ValidationResult validateOutputAgainstSchema(RecordTemplate dataTemplate, DataSchema validatingSchema)\n+  {\n+    if (validatingSchema == null)\n+    {\n+      throw new IllegalArgumentException(\"Validating schema is null\");\n+    }\n+\n+    return validateOutputAgainstSchema(dataTemplate,\n+        () -> ValidateDataAgainstSchema.validate(dataTemplate.data(), validatingSchema, new ValidationOptions(),\n+            new DataSchemaAnnotationValidator(validatingSchema)));\n+  }\n+\n+  protected ValidationResult validateOutputAgainstSchema(RecordTemplate dataTemplate,\n+      Supplier<ValidationResult> validationResultSupplier)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4NDU2Mg=="}, "originalCommit": {"oid": "93f0cd225724d865df0c69f8b2db6f05c19ac4b8"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzIzNDU5OnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo0NTozNlrOHNHKIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo0NTozNlrOHNHKIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMDgxOA==", "bodyText": "nit: this can be DataValidator", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483510818", "createdAt": "2020-09-04T09:45:36Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -32,6 +34,8 @@\n  */\n public class RestLiDataSchemaDataValidator extends RestLiDataValidator {\n   private final DataSchema _validatingSchema;\n+  private final DataValidator _inputDataValidator;\n+  private final DataSchemaAnnotationValidator _outputSchemaValidator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzI0OTg0OnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MDowOVrOHNHTaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNTo1NToyOFrOHONsOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzE5Mg==", "bodyText": "This is not going to be useful. The validatingSchema is for output, based on projection.\nand for inputs it would be the resource entity schema or a subset based on patch for partial_update.\nInstead of initializing in the constructor, you should just use getValidatorFor* methods, but cache them after first invocation?\nAlso this validator class is used only for output validation (input uses RestLiDataValidator directly). so you can remove all the input validator logic and remove the override for getValidatorForInput", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483513192", "createdAt": "2020-09-04T09:50:09Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -53,6 +57,8 @@ public RestLiDataSchemaDataValidator(Annotation[] annotations,\n     }\n \n     _validatingSchema = validatingSchema;\n+    _inputDataValidator = new DataValidator(_validatingSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTM2Nw==", "bodyText": "I actually don't see the need for changes in this file. The changes in other two classes should be enough to override the validator construction logic.", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483515367", "createdAt": "2020-09-04T09:54:20Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -53,6 +57,8 @@ public RestLiDataSchemaDataValidator(Annotation[] annotations,\n     }\n \n     _validatingSchema = validatingSchema;\n+    _inputDataValidator = new DataValidator(_validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzE5Mg=="}, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc2Njc0MA==", "bodyText": "Is the suggestion to sub-class RestLiDataSchemaDataValidator and RestLiDataValidator ourselves in our own implementation and use them in our sub-class of RestLiValidator by overriding createRequestRestLiDataValidator and createResponseRestLiDataValidator?\nFor the output use case, is there a reason we need to do it explicitly via a cache? For each _validatingSchema instantiation, it should be the same DataSchemaAnnotationValidator from my understanding, so it feels that this doesn't have to be done via a cache on an outer layer", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r483766740", "createdAt": "2020-09-04T17:43:01Z", "author": {"login": "vshwnth2"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -53,6 +57,8 @@ public RestLiDataSchemaDataValidator(Annotation[] annotations,\n     }\n \n     _validatingSchema = validatingSchema;\n+    _inputDataValidator = new DataValidator(_validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzE5Mg=="}, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY2NDM3Ng==", "bodyText": "If you plan to re-use this validator, then we can leave the caching. However, this validator is used only for output validation (maybe the javadoc should be updated to mention this). So you should remove the override for getValidatorForInput.", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484664376", "createdAt": "2020-09-08T05:49:39Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -53,6 +57,8 @@ public RestLiDataSchemaDataValidator(Annotation[] annotations,\n     }\n \n     _validatingSchema = validatingSchema;\n+    _inputDataValidator = new DataValidator(_validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzE5Mg=="}, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY2NjQyNw==", "bodyText": "Removed the override and updated the javadoc", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484666427", "createdAt": "2020-09-08T05:55:28Z", "author": {"login": "vshwnth2"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -53,6 +57,8 @@ public RestLiDataSchemaDataValidator(Annotation[] annotations,\n     }\n \n     _validatingSchema = validatingSchema;\n+    _inputDataValidator = new DataValidator(_validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzE5Mg=="}, "originalCommit": {"oid": "01ccf2f9e11c41cd0fcdfbb424b758ebcd919336"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ2MDQ3OnYy", "diffSide": "RIGHT", "path": "restli-server/src/main/java/com/linkedin/restli/server/validation/RestLiValidationFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0MTozMlrOHOOx5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo1NzoxMFrOHOPNaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI2Mw==", "bodyText": "I think you meant to say \"{@link RestLiDataValidator}\", same as line 476, 484, 488", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484684263", "createdAt": "2020-09-08T06:41:32Z", "author": {"login": "junchuanwang"}, "path": "restli-server/src/main/java/com/linkedin/restli/server/validation/RestLiValidationFilter.java", "diffHunk": "@@ -487,4 +467,46 @@ private boolean shouldValidateOnResponse(FilterRequestContext requestContext)\n     future.completeExceptionally(t);\n     return future;\n   }\n+\n+  /**\n+   * Creates a {@link RestLiValidationFilter} to use for validation onRequest.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5MTMwNQ==", "bodyText": "good catch, thanks", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484691305", "createdAt": "2020-09-08T06:57:10Z", "author": {"login": "vshwnth2"}, "path": "restli-server/src/main/java/com/linkedin/restli/server/validation/RestLiValidationFilter.java", "diffHunk": "@@ -487,4 +467,46 @@ private boolean shouldValidateOnResponse(FilterRequestContext requestContext)\n     future.completeExceptionally(t);\n     return future;\n   }\n+\n+  /**\n+   * Creates a {@link RestLiValidationFilter} to use for validation onRequest.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI2Mw=="}, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ2NjAyOnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0MzoyNlrOHOO1Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMDo0M1rOHO5Y5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTA3MQ==", "bodyText": "Sorry can you remind me why this changes from instantiating \"DataValidator\" to \"DataSchemaAnnotationValidator\" now?", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484685071", "createdAt": "2020-09-08T06:43:26Z", "author": {"login": "junchuanwang"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -608,13 +608,21 @@ private ValidationResult validateInputEntity(RecordTemplate entity)\n     //  the client cannot supply them in a create request, so they should be treated as optional.\n     //  similarly for update requests used as upsert (update to create), they are treated as optional.\n     validationOptions.setTreatOptional(_readOnlyOptionalPredicate);\n-    return ValidateDataAgainstSchema.validate(entity, validationOptions, new DataValidator(entity.schema()));\n+    return ValidateDataAgainstSchema.validate(entity, validationOptions, getValidatorForInput(entity.schema()));\n   }\n \n   private ValidationResult validateOutputEntity(RecordTemplate entity, DataSchema validatingSchema)\n   {\n-    DataSchemaAnnotationValidator validator = new DataSchemaAnnotationValidator(validatingSchema);\n-    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(), validator);\n+    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(),\n+        getValidatorForOutput(validatingSchema));\n+  }\n+\n+  protected Validator getValidatorForOutput(DataSchema validatingSchema) {\n+    return new DataSchemaAnnotationValidator(validatingSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY5MTU0Nw==", "bodyText": "both before and after instantiate DataSchemaAnnotationValidator, this just abstracts it out into its own method", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484691547", "createdAt": "2020-09-08T06:57:36Z", "author": {"login": "vshwnth2"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -608,13 +608,21 @@ private ValidationResult validateInputEntity(RecordTemplate entity)\n     //  the client cannot supply them in a create request, so they should be treated as optional.\n     //  similarly for update requests used as upsert (update to create), they are treated as optional.\n     validationOptions.setTreatOptional(_readOnlyOptionalPredicate);\n-    return ValidateDataAgainstSchema.validate(entity, validationOptions, new DataValidator(entity.schema()));\n+    return ValidateDataAgainstSchema.validate(entity, validationOptions, getValidatorForInput(entity.schema()));\n   }\n \n   private ValidationResult validateOutputEntity(RecordTemplate entity, DataSchema validatingSchema)\n   {\n-    DataSchemaAnnotationValidator validator = new DataSchemaAnnotationValidator(validatingSchema);\n-    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(), validator);\n+    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(),\n+        getValidatorForOutput(validatingSchema));\n+  }\n+\n+  protected Validator getValidatorForOutput(DataSchema validatingSchema) {\n+    return new DataSchemaAnnotationValidator(validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTA3MQ=="}, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjM3NA==", "bodyText": "you are right. I previously misunderstood", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r485382374", "createdAt": "2020-09-09T07:00:43Z", "author": {"login": "junchuanwang"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -608,13 +608,21 @@ private ValidationResult validateInputEntity(RecordTemplate entity)\n     //  the client cannot supply them in a create request, so they should be treated as optional.\n     //  similarly for update requests used as upsert (update to create), they are treated as optional.\n     validationOptions.setTreatOptional(_readOnlyOptionalPredicate);\n-    return ValidateDataAgainstSchema.validate(entity, validationOptions, new DataValidator(entity.schema()));\n+    return ValidateDataAgainstSchema.validate(entity, validationOptions, getValidatorForInput(entity.schema()));\n   }\n \n   private ValidationResult validateOutputEntity(RecordTemplate entity, DataSchema validatingSchema)\n   {\n-    DataSchemaAnnotationValidator validator = new DataSchemaAnnotationValidator(validatingSchema);\n-    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(), validator);\n+    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(),\n+        getValidatorForOutput(validatingSchema));\n+  }\n+\n+  protected Validator getValidatorForOutput(DataSchema validatingSchema) {\n+    return new DataSchemaAnnotationValidator(validatingSchema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTA3MQ=="}, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTQ3MjExOnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo0NTozOFrOHOO42g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNjo1MDowN1rOHOPA5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NjA0Mg==", "bodyText": "nit: I personally think \"getValidatorForOutput\" an incomplete name, it makes more sense to me to say for example \"getValidatorForOutputEntityValidation\"", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484686042", "createdAt": "2020-09-08T06:45:38Z", "author": {"login": "junchuanwang"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -66,6 +71,24 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate)\n     return super.validateOutputAgainstSchema(dataTemplate, _validatingSchema);\n   }\n \n+  /**\n+   * Validator to use to validate the output.\n+   * The validator is instantiated in the constructor, so directly returns that if input is equal to _validatingSchema.\n+   * @param validatingSchema schema to validate against\n+   * @return validator\n+   */\n+  @Override\n+  protected Validator getValidatorForOutput(DataSchema validatingSchema) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4ODEwMg==", "bodyText": "sounds good, will update", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r484688102", "createdAt": "2020-09-08T06:50:07Z", "author": {"login": "vshwnth2"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -66,6 +71,24 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate)\n     return super.validateOutputAgainstSchema(dataTemplate, _validatingSchema);\n   }\n \n+  /**\n+   * Validator to use to validate the output.\n+   * The validator is instantiated in the constructor, so directly returns that if input is equal to _validatingSchema.\n+   * @param validatingSchema schema to validate against\n+   * @return validator\n+   */\n+  @Override\n+  protected Validator getValidatorForOutput(DataSchema validatingSchema) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NjA0Mg=="}, "originalCommit": {"oid": "4da09991b7876c6aa611adf79bb74e3d1ed72337"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTA2ODM5OnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzoxNzoyN1rOHOxGAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzoxNjoyNlrOHO51vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0NjQ2NA==", "bodyText": "if the strict pointer equality check is on purpose, please add an inline doc on why it's the case", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r485246464", "createdAt": "2020-09-08T23:17:27Z", "author": {"login": "idarmans"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -66,6 +71,24 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate)\n     return super.validateOutputAgainstSchema(dataTemplate, _validatingSchema);\n   }\n \n+  /**\n+   * Validator to use to validate the output.\n+   * The validator is instantiated in the constructor, so directly returns that if input is equal to _validatingSchema.\n+   * @param validatingSchema schema to validate against\n+   * @return validator\n+   */\n+  @Override\n+  protected Validator getValidatorForOutputEntityValidation(DataSchema validatingSchema) {\n+    if (_validatingSchema == validatingSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916535fce5c50d68b5e5b330a78c8025020404bd"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4OTc1OQ==", "bodyText": "+1 on Ivan's suggestion", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r485389759", "createdAt": "2020-09-09T07:16:26Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataSchemaDataValidator.java", "diffHunk": "@@ -66,6 +71,24 @@ public ValidationResult validateOutput(RecordTemplate dataTemplate)\n     return super.validateOutputAgainstSchema(dataTemplate, _validatingSchema);\n   }\n \n+  /**\n+   * Validator to use to validate the output.\n+   * The validator is instantiated in the constructor, so directly returns that if input is equal to _validatingSchema.\n+   * @param validatingSchema schema to validate against\n+   * @return validator\n+   */\n+  @Override\n+  protected Validator getValidatorForOutputEntityValidation(DataSchema validatingSchema) {\n+    if (_validatingSchema == validatingSchema)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0NjQ2NA=="}, "originalCommit": {"oid": "916535fce5c50d68b5e5b330a78c8025020404bd"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODc5MzAzOnYy", "diffSide": "RIGHT", "path": "gradle.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODoyNzowMVrOHPUg_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODoyNzowMVrOHPUg_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyNjgxMg==", "bodyText": "Please rebase master, it is 29.6.4 in the master. And update CHANGELOG accordingly.", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r485826812", "createdAt": "2020-09-09T18:27:01Z", "author": {"login": "nickibi"}, "path": "gradle.properties", "diffHunk": "@@ -1,4 +1,4 @@\n-version=29.6.2\n+version=29.6.3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9373e03004f1cc2eae48aa5b2b95657209cd42a6"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTk2MDgzOnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMToyNDoxM1rOHPfk9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMToyNDoxM1rOHPfk9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwODA1Mg==", "bodyText": "nit: move braces to newline.", "url": "https://github.com/linkedin/rest.li/pull/407#discussion_r486008052", "createdAt": "2020-09-10T01:24:13Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -608,13 +608,21 @@ private ValidationResult validateInputEntity(RecordTemplate entity)\n     //  the client cannot supply them in a create request, so they should be treated as optional.\n     //  similarly for update requests used as upsert (update to create), they are treated as optional.\n     validationOptions.setTreatOptional(_readOnlyOptionalPredicate);\n-    return ValidateDataAgainstSchema.validate(entity, validationOptions, new DataValidator(entity.schema()));\n+    return ValidateDataAgainstSchema.validate(entity, validationOptions, getValidatorForInputEntityValidation(entity.schema()));\n   }\n \n   private ValidationResult validateOutputEntity(RecordTemplate entity, DataSchema validatingSchema)\n   {\n-    DataSchemaAnnotationValidator validator = new DataSchemaAnnotationValidator(validatingSchema);\n-    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(), validator);\n+    return ValidateDataAgainstSchema.validate(entity.data(), validatingSchema, new ValidationOptions(),\n+        getValidatorForOutputEntityValidation(validatingSchema));\n+  }\n+\n+  protected Validator getValidatorForOutputEntityValidation(DataSchema validatingSchema) {\n+    return new DataSchemaAnnotationValidator(validatingSchema);\n+  }\n+\n+  protected Validator getValidatorForInputEntityValidation(DataSchema validatingSchema) {\n+    return new DataValidator(validatingSchema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed86c9a196cf00547b97759b552432515375a8e"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 338, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}