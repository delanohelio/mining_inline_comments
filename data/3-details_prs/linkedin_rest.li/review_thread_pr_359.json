{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5NjE0NDcz", "number": 359, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozNDoxOFrOET2jqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozODoyMlrOET2oSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MjUyMjY1OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/IdenticalTrafficMultiplierDarkClusterStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozNDoxOFrOG50odg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozNDoxOFrOG50odg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4NDM0Mg==", "bodyText": "javadoc. this should mention that it is similar to RelativeTraffic, etc.", "url": "https://github.com/linkedin/rest.li/pull/359#discussion_r463284342", "createdAt": "2020-07-30T21:34:18Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/IdenticalTrafficMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import java.util.Random;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef412f3c11400c3529d744a289eaf450a2da519"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MjUzNDQ5OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/IdenticalTrafficMultiplierDarkClusterStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozODoyMlrOG50vpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTozODoyMlrOG50vpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4NjE4Mg==", "bodyText": "why is one \"< 0.2\" and the other \"< 0.3\" if they have the same multiplier?", "url": "https://github.com/linkedin/rest.li/pull/359#discussion_r463286182", "createdAt": "2020-07-30T21:38:22Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/IdenticalTrafficMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import java.util.Random;\n+\n+\n+public class IdenticalTrafficMultiplierDarkClusterStrategy implements DarkClusterStrategy {\n+  private final String _originalClusterName;\n+  private final String _darkClusterName;\n+  private final Float _multiplier;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Random _random;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  private static final String RANDOM_NUMBER_KEY = \"identicalTrafficMultiplier.randomNumber\";\n+\n+  public IdenticalTrafficMultiplierDarkClusterStrategy(String sourceClusterName,\n+      String darkClusterName,\n+      Float multiplier,\n+      BaseDarkClusterDispatcher baseDarkClusterDispatcher,\n+      Notifier notifier,\n+      ClusterInfoProvider clusterInfoProvider, Random random)\n+  {\n+    _originalClusterName = sourceClusterName;\n+    _darkClusterName = darkClusterName;\n+    _multiplier = multiplier;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _random = random;\n+    _clusterInfoProvider = clusterInfoProvider;\n+  }\n+\n+  @Override\n+  public boolean handleRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext)\n+  {\n+    int numRequestDuplicates = getNumDuplicateRequests(requestContext);\n+    return _baseDarkClusterDispatcher.sendRequest(originalRequest, darkRequest, requestContext, numRequestDuplicates);\n+  }\n+\n+  /**\n+   * We won't create this strategy if this config isn't valid for this strategy. For instance, we don't want to create\n+   * the IdenticalTrafficMultiplierDarkClusterStrategy if there's no multiplier or if the multiplier is zero, because we'd\n+   * be doing pointless work on every getOrCreate. Instead if will go to the next strategy (or NoOpDarkClusterStrategy).\n+   *\n+   * This is a static method defined here because we don't want to instantiate a strategy to check this. It cannot be a\n+   * method that is on the interface because static methods on an interface cannot be overridden by implementations.\n+   * @param darkClusterConfig\n+   * @return true if config is valid for this strategy\n+   */\n+  public static boolean isValidConfig(DarkClusterConfig darkClusterConfig)\n+  {\n+    return darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0;\n+  }\n+\n+  /**\n+   * The high level goal of this strategy is to send identical traffic to all the dark clusters configured with this\n+   * strategy. It accomplishes this by persisting the random number generated for a request in {@link RequestContext}\n+   * and reusing the same so that if a request is chosen to be sent to one dark cluster, it will be sent for all other\n+   * dark clusters as well.\n+   *\n+   * The logic to determine if a request should be sent to dark cluster or not for the first time is determined similar\n+   * to {@link RelativeTrafficMultiplierDarkClusterStrategy}\n+   *\n+   * Example 1:\n+   * There are 3 dark clusters: A, B and C all of which are configured with same multiplier of 0.1.\n+   * There is 1 source instance and 1 dark instance in each cluster.\n+   * Assume that the strategy is called for A, B and C in the same order.\n+   * For A, there will be no random number persisted in requestContext since we're seeing this request for the first time\n+   * So we compute random number, say 0.05 and persist the same in requestContext\n+   * Avg#DarkRequests = 1 * 0.1 / 1 = 0.1\n+   * since 0.05 < 0.1, request will be sent to A\n+   * When it comes to B, the random number is already present and since it is < 0.2, request will be sent to B", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef412f3c11400c3529d744a289eaf450a2da519"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 540, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}