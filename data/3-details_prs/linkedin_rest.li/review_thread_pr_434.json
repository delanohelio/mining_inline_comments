{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MDU2ODk4", "number": 434, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxOToxNlrOEp6CsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoyMTo1M1rOEp6FmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc4MDMyOnYy", "diffSide": "RIGHT", "path": "generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxOToxNlrOHb3USg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODo1ODowN1rOHb4bPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTkxNA==", "bodyText": "Please add java doc on both these methods and also for getSchemaAndLocations. Given we have mutliple methods, it would be helpful to document their behavior.", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498979914", "createdAt": "2020-10-02T18:19:16Z", "author": {"login": "karthikbalasub"}, "path": "generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java", "diffHunk": "@@ -211,24 +209,33 @@ private void init(AbstractMultiFormatDataSchemaResolver resolver,\n       return _schemaAndLocations;\n     }\n \n+    public Map<DataSchema, DataSchemaLocation> getBaseDataSchemaAndLocations()\n+    {\n+      return _schemaAndLocations.entrySet().stream().filter(entry -> !isExtensionSchemaLocation(entry))\n+          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n     public Map<DataSchema, DataSchemaLocation> getExtensionDataSchemaAndLocations()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODA3OQ==", "bodyText": "Added", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498998079", "createdAt": "2020-10-02T18:58:07Z", "author": {"login": "BrianPin"}, "path": "generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java", "diffHunk": "@@ -211,24 +209,33 @@ private void init(AbstractMultiFormatDataSchemaResolver resolver,\n       return _schemaAndLocations;\n     }\n \n+    public Map<DataSchema, DataSchemaLocation> getBaseDataSchemaAndLocations()\n+    {\n+      return _schemaAndLocations.entrySet().stream().filter(entry -> !isExtensionSchemaLocation(entry))\n+          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n     public Map<DataSchema, DataSchemaLocation> getExtensionDataSchemaAndLocations()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTkxNA=="}, "originalCommit": {"oid": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc4Nzc3OnYy", "diffSide": "RIGHT", "path": "generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoyMTo1NFrOHb3Y2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODo1ODozNlrOHb4cGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTA4Mw==", "bodyText": "Not needed as the test will fail for any uncaught exception.", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498981083", "createdAt": "2020-10-02T18:21:54Z", "author": {"login": "karthikbalasub"}, "path": "generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java", "diffHunk": "@@ -212,6 +212,59 @@ public void testSchemaFilesInExtensionPathInFolder(String[] files, String[] expe\n   }\n \n \n+  @DataProvider(name = \"ERFilesForBaseSchema\")\n+  private Object[][] dataSchemaFiles()\n+  {\n+    return new Object[][]\n+        {\n+            {\n+                new String[]{\n+                    \"extensions/BarExtensions.pdl\",\n+                    \"extensions/FooExtensions.pdl\",\n+                    \"extensions/FuzzExtensions.pdl\",\n+                    \"pegasus/Foo.pdl\",\n+                    \"pegasus/Bar.pdl\",\n+                    \"pegasus/Fuzz.pdsc\"\n+                },\n+                new String[]{\n+                    \"Foo\",\n+                    \"Bar\",\n+                    \"Fuzz\",\n+                    \"InlineRecord\"\n+                }\n+            }\n+        };\n+  }\n+\n+  @Test(dataProvider = \"ERFilesForBaseSchema\")\n+  public void testParseResultToGetBaseSchemas(String[] files, String[] expectedExtensions) throws Exception\n+  {\n+    String pegasusWithFS = pegasusDir + FS;\n+    String resolverPath = pegasusWithFS + \"extensionSchemas/extensions:\"\n+        + pegasusWithFS + \"extensionSchemas/others:\"\n+        + pegasusWithFS + \"extensionSchemas/pegasus\";\n+    try\n+    {\n+      DataSchemaParser parser = new DataSchemaParser(resolverPath);\n+      String[] schemaFiles = Arrays.stream(files).map(casename -> pegasusDir + FS + \"extensionSchemas\" + FS + casename).toArray(String[]::new);\n+      DataSchemaParser.ParseResult parseResult = parser.parseSources(schemaFiles);\n+      Map<DataSchema, DataSchemaLocation> bases = parseResult.getBaseDataSchemaAndLocations();\n+      assertEquals(bases.size(), expectedExtensions.length);\n+      Set<String> actualNames = bases\n+          .keySet()\n+          .stream()\n+          .map(dataSchema -> (NamedDataSchema) dataSchema)\n+          .map(NamedDataSchema::getName)\n+          .collect(Collectors.toSet());\n+      assertEquals(actualNames, Arrays.stream(expectedExtensions).collect(Collectors.toSet()));\n+    }\n+    catch (Exception e)\n+    {\n+      Assert.fail(\"Test failed\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODI5OQ==", "bodyText": "Removed", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498998299", "createdAt": "2020-10-02T18:58:36Z", "author": {"login": "BrianPin"}, "path": "generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java", "diffHunk": "@@ -212,6 +212,59 @@ public void testSchemaFilesInExtensionPathInFolder(String[] files, String[] expe\n   }\n \n \n+  @DataProvider(name = \"ERFilesForBaseSchema\")\n+  private Object[][] dataSchemaFiles()\n+  {\n+    return new Object[][]\n+        {\n+            {\n+                new String[]{\n+                    \"extensions/BarExtensions.pdl\",\n+                    \"extensions/FooExtensions.pdl\",\n+                    \"extensions/FuzzExtensions.pdl\",\n+                    \"pegasus/Foo.pdl\",\n+                    \"pegasus/Bar.pdl\",\n+                    \"pegasus/Fuzz.pdsc\"\n+                },\n+                new String[]{\n+                    \"Foo\",\n+                    \"Bar\",\n+                    \"Fuzz\",\n+                    \"InlineRecord\"\n+                }\n+            }\n+        };\n+  }\n+\n+  @Test(dataProvider = \"ERFilesForBaseSchema\")\n+  public void testParseResultToGetBaseSchemas(String[] files, String[] expectedExtensions) throws Exception\n+  {\n+    String pegasusWithFS = pegasusDir + FS;\n+    String resolverPath = pegasusWithFS + \"extensionSchemas/extensions:\"\n+        + pegasusWithFS + \"extensionSchemas/others:\"\n+        + pegasusWithFS + \"extensionSchemas/pegasus\";\n+    try\n+    {\n+      DataSchemaParser parser = new DataSchemaParser(resolverPath);\n+      String[] schemaFiles = Arrays.stream(files).map(casename -> pegasusDir + FS + \"extensionSchemas\" + FS + casename).toArray(String[]::new);\n+      DataSchemaParser.ParseResult parseResult = parser.parseSources(schemaFiles);\n+      Map<DataSchema, DataSchemaLocation> bases = parseResult.getBaseDataSchemaAndLocations();\n+      assertEquals(bases.size(), expectedExtensions.length);\n+      Set<String> actualNames = bases\n+          .keySet()\n+          .stream()\n+          .map(dataSchema -> (NamedDataSchema) dataSchema)\n+          .map(NamedDataSchema::getName)\n+          .collect(Collectors.toSet());\n+      assertEquals(actualNames, Arrays.stream(expectedExtensions).collect(Collectors.toSet()));\n+    }\n+    catch (Exception e)\n+    {\n+      Assert.fail(\"Test failed\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTA4Mw=="}, "originalCommit": {"oid": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 375, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}