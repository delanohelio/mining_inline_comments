{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2NDYzNTk5", "number": 264, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjoxNDo0NFrOD0hgww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMDowN1rOD3U68g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDAxNjAzOnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjoxNDo0NFrOGJgNMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoyNzo1MVrOGK6ulg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw==", "bodyText": "Curious why this is prioritized order instead of single element? When would a strategy be unavailable other than this initial inconsistent stage when we have schema defined for constant qps but no code impl?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412618033", "createdAt": "2020-04-22T02:14:44Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTYxMg==", "bodyText": "I put this in one of the files, but this was a lesson learned when we initially had just one strategy for DegraderLoadBalancerStrategyName. It made rollout and new strategy changes very painful. We ended up changing to DegraderLoadBalancerStrategyList. With a list, you can decoupling adding a new strategy into the d2-config and having the strategy users upgrade. That would be useful when it's done on the client side, for instance.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412669612", "createdAt": "2020-04-22T04:56:47Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MDI1Nw==", "bodyText": "I see, can we include this explanation to the doc?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413370257", "createdAt": "2020-04-22T22:16:58Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMTE0Mg==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414101142", "createdAt": "2020-04-23T20:27:51Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies.\n+   */\n+  multiplierStrategyList: array[multiplierStrategyType] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODAzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDAyMjI4OnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjoxNzoyMFrOGJgQpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0NDo1MFrOGK7Wow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg==", "bodyText": "Multiplier is implementation specific. Can we use DarkClusterStrategy?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412618916", "createdAt": "2020-04-22T02:17:20Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MDIwMQ==", "bodyText": "ok, I think I can rename it to DarkClusterStrategyType.  I don't think Multiplier is implementation specific, though, because it's not referring to a specific variable, just how the user wants to \"multiply\" the requests to get the desired rate. Lemme know if you still want me to rename.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412670201", "createdAt": "2020-04-22T04:58:47Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MDcyOQ==", "bodyText": "Why do you prefer DarkClusterStrategyType over DarkClusterStrategy? I don't think the Type is necessary here.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413370729", "createdAt": "2020-04-22T22:17:52Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMzY2Ng==", "bodyText": "as discussed, DarkClusterStrategy can't be used because we already have a java class named that. We decided on DarkClusterStrategyName instead.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414103666", "createdAt": "2020-04-23T20:32:00Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMTM5NQ==", "bodyText": "Discussed offline, will use DarkClusterStrategyName .", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414111395", "createdAt": "2020-04-23T20:44:50Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODkxNg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDA0NjY1OnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjoyNzoxNFrOGJgd1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNTowMTo0MVrOGJjcwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyMjI5Mg==", "bodyText": "How about\nThis strategy aims to maintain a proportional amount of incoming QPS at the host level between the source and dark clusters.\nConfigured with \"multiplier\". For example a multiplier of 1 would mean the average incoming QPS for a source host equals that of a dark host. A multiplier of 2 means on average a dark host will receive 2x more traffic than a source host.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412622292", "createdAt": "2020-04-22T02:27:14Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MTE2OA==", "bodyText": "will change. thanks.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412671168", "createdAt": "2020-04-22T05:01:41Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyMjI5Mg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDA2MzA4OnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjozNDoyM1rOGJgmvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDozMzowMFrOGK66tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw==", "bodyText": "I think we can leave out this strategy for when it's actually implemented in a future RB.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412624573", "createdAt": "2020-04-22T02:34:23Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MTQyNg==", "bodyText": "I'd rather not go through another schema review just to add this. I expect it will be added soon.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412671426", "createdAt": "2020-04-22T05:02:26Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzExNg==", "bodyText": "Sure, and for the doc what about\nThis strategy will try to maintain a certain queries per second to the entire dark cluster.\nConfigured with \"dispatcherOutboundTargetRate\".", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413373116", "createdAt": "2020-04-22T22:22:34Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDI0Ng==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414104246", "createdAt": "2020-04-23T20:33:00Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/multiplierStrategyType.pdl", "diffHunk": "@@ -0,0 +1,19 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.\n+ */\n+enum multiplierStrategyType {\n+\n+  /**\n+   * This strategy will try to keep the level of traffic on a dark cluster instance relative to the dispatching instance,\n+   * as indicated by the multiplier.\n+   */\n+  RELATIVE_TRAFFIC\n+\n+  /**\n+   * This strategy will try to maintain a certain queries per second, as specified by dispatcherOutboundTargetRate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNDU3Mw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDA3MjgxOnYy", "diffSide": "LEFT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjozODoyNlrOGJgsDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0NDowNlrOGK7U3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw==", "bodyText": "What's the status on implementing dispatcherOutboundTargetRate? Can we remove these configs if no plans to implement anytime soon? I'd rather introduce a cleaner approach to Constant QPS than what we have in dark canary now.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412625933", "createdAt": "2020-04-22T02:38:26Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3ODA2NA==", "bodyText": "removing would be backwards incompatible, and I think we can implement it sooner rather than later. What's the cleaner approach? I don't think those two are bound to the current constant qps implementation.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412678064", "createdAt": "2020-04-22T05:22:00Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzI4Nw==", "bodyText": "I think backwards incompatibility is fine because only we're consuming it. Cleaner approach is using an implementation that guarantees target QPS so we only need 1 config and not \"dispatcherOutboundMaxRate\".", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413337287", "createdAt": "2020-04-22T21:13:51Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMTAxNA==", "bodyText": "we discussed offline. We will leave it as is, and consider deprecating it later if not needed. To remove it would require a major version bump of pegasus, which is undesirable if it can be avoided.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414101014", "createdAt": "2020-04-23T20:27:38Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMDk0MQ==", "bodyText": "Discussed offline, will leave as is and deprecate later in needed.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414110941", "createdAt": "2020-04-23T20:44:06Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,14 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTkzMw=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDEyODIzOnYy", "diffSide": "LEFT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMzowMjo0OVrOGJhKcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjoyMzowMVrOGKOTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ==", "bodyText": "Can we keep this old behavior of using Jackson to serialize everything and selectively replace each transport properties with output of TransportClientPropertiesConverter?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412633715", "createdAt": "2020-04-22T03:02:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NDAzNw==", "bodyText": "that seems pretty hacky. Doing what I did (use the Map<String, Object>) is more consistent with what the code was doing for other stuff, anyway. The only reason I was trying to use the pegasus object for both in-mem and for zookeeper storage was because I didn't see the need to have two formats; with the inclusion of transportClientProperties I do need the separate format. Regarding your proposal, that would require retraversing the DarkClusterConfigMap and accessing the dataMap directly to hardcode some mappings, and wouldn't take into account further changes in the TransportClientPropertiesConverter. So I don't think that's a better option. Doing the Map<String, Object> way may be more code, but it's pretty understandable and in line with the rest of the Converter classes.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412674037", "createdAt": "2020-04-22T05:10:29Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzMwMQ==", "bodyText": "ok", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413373301", "createdAt": "2020-04-22T22:23:01Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDE5MDAwOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMzozMDoyNFrOGJhrzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNToxNjoyNVrOGJjwFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg==", "bodyText": "this will never be reached because of previous \"darkClusterConfig.getMultiplier() > 0\"", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642252", "createdAt": "2020-04-22T03:30:24Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MzY2NQ==", "bodyText": "I think it would be a lot cleaner if we had the implementations themselves handle these edge cases rather than manually returning NoOpDarkClusterStrategy. In this case always return new RelativeTrafficMultiplierDarkClusterStrategy but since the multiplier is <= 0 then no requests will be sent out.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412643665", "createdAt": "2020-04-22T03:34:42Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NjExOQ==", "bodyText": "yeah, sorry about that. I'll fix that code. The reasons I did not want to have the implementations handle it was because then every handleRequest invocation has to do an if check, rather than only when a strategy has to be created. The tradeoff of putting it in createStrategy seems to be worth not doing that if statement in the hot path.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412676119", "createdAt": "2020-04-22T05:16:25Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDE5MjgyOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMzozMTozMlrOGJhtUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNToxODozMlrOGJjyow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjY0Mg==", "bodyText": "This else statement return breaks the use of strategy list since it will never iterate past the first element. but also made a previous comment on not using a list.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642642", "createdAt": "2020-04-22T03:31:32Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3Njc3MQ==", "bodyText": "doing this will still use the strategylist, because if constant qps isn't available, it will go into the else if and not the else:\nif (RELATIVE_TRAFFIC) {\n}\nelse if (CONSTANT_QPS) {\n}\nelse {\n}", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412676771", "createdAt": "2020-04-22T05:18:32Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjY0Mg=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDIxODgwOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMzo0MzoyMVrOGJh7uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNToxOTowOFrOGJjzlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjMzMQ==", "bodyText": "Prefer using switch/case for clarity.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412646331", "createdAt": "2020-04-22T03:43:21Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else\n+        {\n+          // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n+          return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.\n+    return new NoOpDarkClusterStrategy();\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NzAxMw==", "bodyText": "sure.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412677013", "createdAt": "2020-04-22T05:19:08Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else\n+        {\n+          // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n+          return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.\n+    return new NoOpDarkClusterStrategy();\n   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjMzMQ=="}, "originalCommit": {"oid": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzkzMzA5OnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0ODozNVrOGK7fCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjoxODowN1rOGK-ZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMzU0NQ==", "bodyText": "rename to DarkClusterStrategyPrioritizedList?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414113545", "createdAt": "2020-04-23T20:48:35Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,16 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies. This is a list to support adding new strategies and having the strategy users\n+   * pick it up as they upgrade code versions, versus waiting for all strategy users to upgrade first. This is the same reason\n+   * DegraderLoadBalancerStrategyName was replaced by DegraderLoadBalancerStrategyList.\n+   */\n+  multiplierStrategyList: array[DarkClusterStrategyName] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2MTIxNA==", "bodyText": "sure.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414161214", "createdAt": "2020-04-23T22:18:07Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterConfig.pdl", "diffHunk": "@@ -19,4 +19,16 @@ record DarkClusterConfig {\n    * Max rate dispatcher can send to dark canary. Measured in qps. Will act as upper bound to protect canaries in case of traffic spikes\n    */\n   dispatcherOutboundMaxRate: int = 2147483647\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * Prioritized order of dark cluster multiplier strategies. This is a list to support adding new strategies and having the strategy users\n+   * pick it up as they upgrade code versions, versus waiting for all strategy users to upgrade first. This is the same reason\n+   * DegraderLoadBalancerStrategyName was replaced by DegraderLoadBalancerStrategyList.\n+   */\n+  multiplierStrategyList: array[DarkClusterStrategyName] = [\"RELATIVE_TRAFFIC\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMzU0NQ=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzkzOTI3OnYy", "diffSide": "RIGHT", "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterStrategyName.pdl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo1MDoxM1rOGK7iuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjoyNjowOVrOGK-m8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExNDQ5MQ==", "bodyText": "Please also explain when a strategy may not be available here as well.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414114491", "createdAt": "2020-04-23T20:50:13Z", "author": {"login": "zhang-chris"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterStrategyName.pdl", "diffHunk": "@@ -0,0 +1,20 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2NDcyMw==", "bodyText": "ok.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414164723", "createdAt": "2020-04-23T22:26:09Z", "author": {"login": "davidhoa"}, "path": "d2-schemas/src/main/pegasus/com/linkedin/d2/DarkClusterStrategyName.pdl", "diffHunk": "@@ -0,0 +1,20 @@\n+namespace com.linkedin.d2\n+\n+/**\n+ * There are 2 types of strategy: RELATIVE_TRAFFIC, CONSTANT_QPS. These can be specified in prioritized order and\n+ * will be picked in that order depending on availability.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExNDQ5MQ=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Mzk3NTU1OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo1OToyM1rOGK74MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjozMDo0NlrOGK-u_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA==", "bodyText": "make the naming uniform - I think these are fine:\nDEFAULT_MULTIPLIER\nDEFAULT_DISPATCHER....", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414119984", "createdAt": "2020-04-23T20:59:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjU5Ng==", "bodyText": "Can we use the static variables defined in ClusterProperties? Or move those variables to a more appropriate class?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414152596", "createdAt": "2020-04-23T21:59:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2Njc4MA==", "bodyText": "ah, forgot I had those. I'll use the ones defined in ClusterProperties.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414166780", "createdAt": "2020-04-23T22:30:46Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Mzk4MDM1OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTowMDo0OVrOGK77Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjozNTozNFrOGK-3rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMDc1MA==", "bodyText": "instead of a comment here can we add a description to the javadoc of converter method in TransportClientPropertiesConverter?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414120750", "createdAt": "2020-04-23T21:00:49Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2OTAwNg==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414169006", "createdAt": "2020-04-23T22:35:34Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMDc1MA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDEwNjQwOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTozMzoyMFrOGK9DBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjo0MTozMVrOGK_BlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTE0Mw==", "bodyText": "not necessary here, let's remove", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139143", "createdAt": "2020-04-23T21:33:20Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MTU0MQ==", "bodyText": "since we put it in the pdl, yes, we can remove this.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414171541", "createdAt": "2020-04-23T22:41:31Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTE0Mw=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDExMDk5OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTozNDo0NVrOGK9FtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjo0NDo1N1rOGK_HNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTgyOQ==", "bodyText": "can remove here too. I don't think converter needs to do anything special to be resilient since it's just a string anyway.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139829", "createdAt": "2020-04-23T21:34:45Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST))\n+      {\n+        DataList dataList = new DataList();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> strategyList = (List<String>)props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST);\n+        dataList.addAll(strategyList);\n+\n+        // note that unknown strategyTypes can be added here. This can happen for new strategies as they are rolling\n+        // out, or for bad strategy types. The converter and client code should be resilient to these.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3Mjk4Mw==", "bodyText": "I had this comment because another way would have been to convert each entry in the strategy list to a DarkClusterStrategyName enum, and then create the array. But instead, I chose to go the dataList way that takes the List untouched, so that the unknown strategy is preserved, and the client can return $Unknown instead. But I agree that the comment is not needed anymore, since this is implied by the comments in the pdl.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414172983", "createdAt": "2020-04-23T22:44:57Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST))\n+      {\n+        DataList dataList = new DataList();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> strategyList = (List<String>)props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST);\n+        dataList.addAll(strategyList);\n+\n+        // note that unknown strategyTypes can be added here. This can happen for new strategies as they are rolling\n+        // out, or for bad strategy types. The converter and client code should be resilient to these.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTgyOQ=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDExNzQ5OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTozNjoyNlrOGK9JWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTozNjoyNlrOGK9JWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MDc2MQ==", "bodyText": "Is this necessary? Can we remove? no one is using this config yet anyway", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414140761", "createdAt": "2020-04-23T21:36:26Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDEyMjIxOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTozNzo1MVrOGK9MHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjo1NDo1N1rOGK_Xuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQ2OA==", "bodyText": "Can you include a class-level javadoc explaining how everything here is what is stored in zk, etc to prevent running into this issue again?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414141468", "createdAt": "2020-04-23T21:37:51Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -38,7 +41,7 @@\n   private final Set<URI> _bannedUris;\n   @Deprecated\n   private final List<String>          _prioritizedSchemes;\n-  private final DarkClusterConfigMap _darkClusters;\n+  private final Map<String, Object> _darkClusters;\n   private final boolean              _delegated;\n \n   public ClusterProperties(String clusterName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3NzIxMQ==", "bodyText": "will do.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414177211", "createdAt": "2020-04-23T22:54:57Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -38,7 +41,7 @@\n   private final Set<URI> _bannedUris;\n   @Deprecated\n   private final List<String>          _prioritizedSchemes;\n-  private final DarkClusterConfigMap _darkClusters;\n+  private final Map<String, Object> _darkClusters;\n   private final boolean              _delegated;\n \n   public ClusterProperties(String clusterName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQ2OA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDE1ODA3OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTo0ODowOFrOGK9gyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzoxNjo1OFrOGK_5ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0Njc2Mg==", "bodyText": "I thought I left a comment about this but I don't see it, weird. Anyway can we keep this constructor and do a conversion from  DarkClusterConfigMap to Map<String, Object> instead?", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414146762", "createdAt": "2020-04-23T21:48:08Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -95,9 +102,17 @@ public ClusterProperties(String clusterName,\n       DarkClusterConfigMap darkClusters)\n   {\n     this(clusterName, prioritizedSchemes, properties, bannedUris, partitionProperties, sslSessionValidationStrings,\n-        darkClusters, false);\n+        (Map<String, Object>)null, false);\n   }\n \n+  /**\n+   * @deprecated Use the constructor that uses a Map instead of DarkClusterConfigMap. Using this object is not flexible enough to hold\n+   * transportClientProperties, because {@link com.linkedin.d2.balancer.config.TransportClientPropertiesConverter} uses different\n+   * keys in it's serialization than how Jackson would serialize D2TransportClientProperties. That is problematic since ClusterProperties\n+   * already should have had all necessary conversions done, but in this case the pegasus objects don't have a mechanism to allow the conversions.\n+   * The solution is to use a Map<String, Object> to pass in the darkClusters.\n+   */\n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NTg2Ng==", "bodyText": "I don't think this is a good idea. It'd be confusing since the getter that jackson would use to serialize would have a Map<String, Object> but the constructor would have something different.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414185866", "createdAt": "2020-04-23T23:16:58Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -95,9 +102,17 @@ public ClusterProperties(String clusterName,\n       DarkClusterConfigMap darkClusters)\n   {\n     this(clusterName, prioritizedSchemes, properties, bannedUris, partitionProperties, sslSessionValidationStrings,\n-        darkClusters, false);\n+        (Map<String, Object>)null, false);\n   }\n \n+  /**\n+   * @deprecated Use the constructor that uses a Map instead of DarkClusterConfigMap. Using this object is not flexible enough to hold\n+   * transportClientProperties, because {@link com.linkedin.d2.balancer.config.TransportClientPropertiesConverter} uses different\n+   * keys in it's serialization than how Jackson would serialize D2TransportClientProperties. That is problematic since ClusterProperties\n+   * already should have had all necessary conversions done, but in this case the pegasus objects don't have a mechanism to allow the conversions.\n+   * The solution is to use a Map<String, Object> to pass in the darkClusters.\n+   */\n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0Njc2Mg=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDE3MDczOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/PropertyKeys.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTo1MTo1MFrOGK9oLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzowNjozMFrOGK_p5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0ODY1Mw==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414148653", "createdAt": "2020-04-23T21:51:50Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/PropertyKeys.java", "diffHunk": "@@ -179,6 +179,8 @@\n   public static final String DARK_CLUSTER_MULTIPLIER = \"multiplier\";\n   public static final String DARK_CLUSTER_OUTBOUND_TARGET_RATE = \"dispatcherOutboundTargetRate\";\n   public static final String DARK_CLUSTER_OUTBOUND_MAX_RATE = \"dispatcherOutboundMaxRate\";\n+  public static final String DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST = \"multiplierStrategyList\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MTg2MQ==", "bodyText": "updated to DARK_CLUSTER_STRATEGY_LIST = \"darkClusterStrategyList\"", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414181861", "createdAt": "2020-04-23T23:06:30Z", "author": {"login": "davidhoa"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/PropertyKeys.java", "diffHunk": "@@ -179,6 +179,8 @@\n   public static final String DARK_CLUSTER_MULTIPLIER = \"multiplier\";\n   public static final String DARK_CLUSTER_OUTBOUND_TARGET_RATE = \"dispatcherOutboundTargetRate\";\n   public static final String DARK_CLUSTER_OUTBOUND_MAX_RATE = \"dispatcherOutboundMaxRate\";\n+  public static final String DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST = \"multiplierStrategyList\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0ODY1Mw=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDE4MzAwOnYy", "diffSide": "RIGHT", "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTo1NToyM1rOGK9vLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzowNzoyNlrOGK_rQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDQ0Nw==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150447", "createdAt": "2020-04-23T21:55:23Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MjIxMA==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414182210", "createdAt": "2020-04-23T23:07:26Z", "author": {"login": "davidhoa"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDQ0Nw=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDE4NDEzOnYy", "diffSide": "RIGHT", "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTo1NTo0NlrOGK9v6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzowOTo0MVrOGK_ujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDYzNQ==", "bodyText": "use public static variable", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150635", "createdAt": "2020-04-23T21:55:46Z", "author": {"login": "zhang-chris"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.RELATIVE_TRAFFIC);\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.CONSTANT_QPS);\n+    DarkClusterConfig config = new DarkClusterConfig()\n+      .setMultiplierStrategyList(multiplierStrategyTypeArray);\n+\n+    configMap.put(DARK_CLUSTER_KEY, config);\n+\n+    // these are defaults that will be set if the fields are missing.\n+    config.setMultiplier(0.0f);\n+    config.setDispatcherOutboundTargetRate(0);\n+    config.setDispatcherOutboundMaxRate(Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MzA1NA==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414183054", "createdAt": "2020-04-23T23:09:41Z", "author": {"login": "davidhoa"}, "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.RELATIVE_TRAFFIC);\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.CONSTANT_QPS);\n+    DarkClusterConfig config = new DarkClusterConfig()\n+      .setMultiplierStrategyList(multiplierStrategyTypeArray);\n+\n+    configMap.put(DARK_CLUSTER_KEY, config);\n+\n+    // these are defaults that will be set if the fields are missing.\n+    config.setMultiplier(0.0f);\n+    config.setDispatcherOutboundTargetRate(0);\n+    config.setDispatcherOutboundMaxRate(Integer.MAX_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDYzNQ=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDIxMjIyOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNDoxN1rOGK-AAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODozNjo1NlrOGLkX9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA==", "bodyText": "I'm still a fan of exposing an API in DarkClusterStrategy#isValidConfig that the factory can just call into for each strategy type :)\nThat way everything is self-contained in each impl and the factory doesn't need to know these details.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154754", "createdAt": "2020-04-23T22:04:17Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NTM4NA==", "bodyText": "sure, I can do this. that gives us the best of both; the factory doesn't need to know these details, and we can optimize for the common codepath at the expense of just one additional call when we create the strategy (instead of at each getOrCreateStrategy)", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414185384", "createdAt": "2020-04-23T23:15:48Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4MzQ3Ng==", "bodyText": "ended up declaring a static method in the RelativeTrafficMultiplierDarkClusterStrategy, because you can't have a static method in the interface that you can override in the impl.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414783476", "createdAt": "2020-04-24T18:36:56Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDIxMjcwOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNDoyNFrOGK-ARA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzoxMDo0N1rOGK_wFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDgyMA==", "bodyText": "update name", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154820", "createdAt": "2020-04-23T22:04:24Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MzQ0NA==", "bodyText": "changed to darkClusterStrategyName", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414183444", "createdAt": "2020-04-23T23:10:47Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDgyMA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDIxNTgwOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNToyMFrOGK-CBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzoxMjo1NVrOGK_zkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTI3MQ==", "bodyText": "not necessary since we return no op strategy at end anyway.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155271", "createdAt": "2020-04-23T22:05:20Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NDMzNw==", "bodyText": "ok.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414184337", "createdAt": "2020-04-23T23:12:55Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTI3MQ=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDIxNjE4OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMjowNToyN1rOGK-CQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMzoxMjo0MFrOGK_zMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTMyOA==", "bodyText": "can remove comment", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155328", "createdAt": "2020-04-23T22:05:27Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NDI0Mw==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414184243", "createdAt": "2020-04-23T23:12:40Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTMyOA=="}, "originalCommit": {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzQxMDQyOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMDowN1rOGNhehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODozMDowN1rOGNhehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMzE1Nw==", "bodyText": "-> strategyNameArray", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r416833157", "createdAt": "2020-04-28T18:30:07Z", "author": {"login": "zhang-chris"}, "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +50,78 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDarkClusterStrategyPrioritizedList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getDarkClusterStrategyPrioritizedList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c658f260aa0e998def24eb171a69d906bb05382"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 420, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}