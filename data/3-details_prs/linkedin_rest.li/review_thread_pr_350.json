{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwOTcyMzcx", "number": 350, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjoyMDoyN1rOEQZEHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoxOTozNVrOEQZ7BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjIzMzI0OnYy", "diffSide": "RIGHT", "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/MaskComposition.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjoyMDoyN1rOG0hRYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwODo0MTo0MFrOG0uFiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ==", "bodyText": "although i like this coding style, but it seems it is not consistent with rest of the code.", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457724259", "createdAt": "2020-07-20T22:20:27Z", "author": {"login": "BrianPin"}, "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/MaskComposition.java", "diffHunk": "@@ -90,6 +90,11 @@ public void interpret(InterpreterContext instrCtx)\n                          instrCtx);\n           }\n         }\n+        // This can happen if the mask is for an array field and the merged start/count resulted in default values.\n+        // Setting the wildcard mask to represent all items are included.\n+        if (data.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDM1NA==", "bodyText": "I mean the left bracket should be in a new line", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457724354", "createdAt": "2020-07-20T22:20:42Z", "author": {"login": "BrianPin"}, "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/MaskComposition.java", "diffHunk": "@@ -90,6 +90,11 @@ public void interpret(InterpreterContext instrCtx)\n                          instrCtx);\n           }\n         }\n+        // This can happen if the mask is for an array field and the merged start/count resulted in default values.\n+        // Setting the wildcard mask to represent all items are included.\n+        if (data.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ=="}, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkzNDIxOQ==", "bodyText": "Fixed.", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457934219", "createdAt": "2020-07-21T08:41:40Z", "author": {"login": "karthikbalasub"}, "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/MaskComposition.java", "diffHunk": "@@ -90,6 +90,11 @@ public void interpret(InterpreterContext instrCtx)\n                          instrCtx);\n           }\n         }\n+        // This can happen if the mask is for an array field and the merged start/count resulted in default values.\n+        // Setting the wildcard mask to represent all items are included.\n+        if (data.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ=="}, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjMyNjc0OnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMjo1Nzo0NFrOG0iG-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwODo1MzoxOVrOG0uhCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ==", "bodyText": "This is more like a question, nextToken is set when we see a comma ',',  and this while loop is condition to enter when the nextToken is set to -1. Do we design to process only the token before comma ','?\nIf the token list looks like \"token1, token2\"  then it seems this token2 is not going to be processed or I missed the fact that the use case will not happen.", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457737979", "createdAt": "2020-07-20T22:57:44Z", "author": {"login": "BrianPin"}, "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while descending\");\n+              + toparse.substring(index) + \"' while descending\");\n         }\n-        toparse.delete(0, 2);\n+        index += 2;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case PARSE_FIELDS:\n-\n-        Integer maskValue = null;\n-        if (toparse.charAt(0) == '-')\n+        Integer maskValue;\n+        if (toparse.charAt(index) == '-')\n         {\n           maskValue = MaskOperation.NEGATIVE_MASK_OP.getRepresentation();\n-          toparse.delete(0, 1);\n+          index++;\n         }\n         else\n         {\n           maskValue = MaskOperation.POSITIVE_MASK_OP.getRepresentation();\n         }\n \n         int nextToken = -1;\n-        StringBuilder field = new StringBuilder();\n-        for (int ii = 0; ii < toparse.length(); ++ii)\n+        field.setLength(0);\n+        int fieldIndex = index;\n+        for (; fieldIndex < toparse.length(); ++fieldIndex)\n         {\n-          char c = toparse.charAt(ii);\n+          char c = toparse.charAt(fieldIndex);\n           switch (c)\n           {\n           case ',':\n             state = ParseState.TRAVERSE;\n-            nextToken = ii;\n+            nextToken = fieldIndex;\n             break;\n           case ':':\n-            if (field.length() > 0 && (FilterConstants.START.equals(field.toString()) || FilterConstants.COUNT.equals(field.toString())))\n+            if ((fieldIndex + 1) >= toparse.length())\n+            {\n+              throw new IllegalMaskException(\"Malformed mask syntax: unexpected end of buffer after ':'\");\n+            }\n+            if ((field.length() == FilterConstants.START.length() && field.indexOf(FilterConstants.START) == 0)\n+                || (field.length() == FilterConstants.COUNT.length() && field.indexOf(FilterConstants.COUNT) == 0))\n             {\n-              if (!Character.isDigit(toparse.charAt(ii + 1)))\n+              if (!Character.isDigit(toparse.charAt(fieldIndex + 1)))\n               {\n                 throw new IllegalMaskException(\"Malformed mask syntax: unexpected range value\");\n               }\n \n-              ii++;\n+              fieldIndex++;\n \n               // Aggressively consume the numerical value for the range parameter as this is a special case.\n-              StringBuilder rangeValue = new StringBuilder();\n-              while (ii < toparse.length())\n+              int rangeValue = 0;\n+              while (fieldIndex < toparse.length() && nextToken == -1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MTA3Mg==", "bodyText": "This code block handles the start and count params in the projection.\nFor example: $*:(c),$start:2,$count:4\nWe are parsing for digits after we see the field name as \"$start\" or \"$count\" (see lines 189-190).\nSo we move to the next token if we see \",\" or \")\" (valid), parse the number if we see digit (valid) and anything else is invalid.", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457941072", "createdAt": "2020-07-21T08:53:03Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while descending\");\n+              + toparse.substring(index) + \"' while descending\");\n         }\n-        toparse.delete(0, 2);\n+        index += 2;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case PARSE_FIELDS:\n-\n-        Integer maskValue = null;\n-        if (toparse.charAt(0) == '-')\n+        Integer maskValue;\n+        if (toparse.charAt(index) == '-')\n         {\n           maskValue = MaskOperation.NEGATIVE_MASK_OP.getRepresentation();\n-          toparse.delete(0, 1);\n+          index++;\n         }\n         else\n         {\n           maskValue = MaskOperation.POSITIVE_MASK_OP.getRepresentation();\n         }\n \n         int nextToken = -1;\n-        StringBuilder field = new StringBuilder();\n-        for (int ii = 0; ii < toparse.length(); ++ii)\n+        field.setLength(0);\n+        int fieldIndex = index;\n+        for (; fieldIndex < toparse.length(); ++fieldIndex)\n         {\n-          char c = toparse.charAt(ii);\n+          char c = toparse.charAt(fieldIndex);\n           switch (c)\n           {\n           case ',':\n             state = ParseState.TRAVERSE;\n-            nextToken = ii;\n+            nextToken = fieldIndex;\n             break;\n           case ':':\n-            if (field.length() > 0 && (FilterConstants.START.equals(field.toString()) || FilterConstants.COUNT.equals(field.toString())))\n+            if ((fieldIndex + 1) >= toparse.length())\n+            {\n+              throw new IllegalMaskException(\"Malformed mask syntax: unexpected end of buffer after ':'\");\n+            }\n+            if ((field.length() == FilterConstants.START.length() && field.indexOf(FilterConstants.START) == 0)\n+                || (field.length() == FilterConstants.COUNT.length() && field.indexOf(FilterConstants.COUNT) == 0))\n             {\n-              if (!Character.isDigit(toparse.charAt(ii + 1)))\n+              if (!Character.isDigit(toparse.charAt(fieldIndex + 1)))\n               {\n                 throw new IllegalMaskException(\"Malformed mask syntax: unexpected range value\");\n               }\n \n-              ii++;\n+              fieldIndex++;\n \n               // Aggressively consume the numerical value for the range parameter as this is a special case.\n-              StringBuilder rangeValue = new StringBuilder();\n-              while (ii < toparse.length())\n+              int rangeValue = 0;\n+              while (fieldIndex < toparse.length() && nextToken == -1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ=="}, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MTI1Nw==", "bodyText": "This code block handles the start and count params in the projection.\nFor example: $*:(c),$start:2,$count:4\nWe are parsing for digits after we see the field name as \"$start\" or \"$count\" (see lines 189-190).\nSo we move to the next token if we see \",\" or \")\" (break the loop), parse the number if we see digit (valid) and anything else is invalid.", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457941257", "createdAt": "2020-07-21T08:53:19Z", "author": {"login": "karthikbalasub"}, "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while descending\");\n+              + toparse.substring(index) + \"' while descending\");\n         }\n-        toparse.delete(0, 2);\n+        index += 2;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case PARSE_FIELDS:\n-\n-        Integer maskValue = null;\n-        if (toparse.charAt(0) == '-')\n+        Integer maskValue;\n+        if (toparse.charAt(index) == '-')\n         {\n           maskValue = MaskOperation.NEGATIVE_MASK_OP.getRepresentation();\n-          toparse.delete(0, 1);\n+          index++;\n         }\n         else\n         {\n           maskValue = MaskOperation.POSITIVE_MASK_OP.getRepresentation();\n         }\n \n         int nextToken = -1;\n-        StringBuilder field = new StringBuilder();\n-        for (int ii = 0; ii < toparse.length(); ++ii)\n+        field.setLength(0);\n+        int fieldIndex = index;\n+        for (; fieldIndex < toparse.length(); ++fieldIndex)\n         {\n-          char c = toparse.charAt(ii);\n+          char c = toparse.charAt(fieldIndex);\n           switch (c)\n           {\n           case ',':\n             state = ParseState.TRAVERSE;\n-            nextToken = ii;\n+            nextToken = fieldIndex;\n             break;\n           case ':':\n-            if (field.length() > 0 && (FilterConstants.START.equals(field.toString()) || FilterConstants.COUNT.equals(field.toString())))\n+            if ((fieldIndex + 1) >= toparse.length())\n+            {\n+              throw new IllegalMaskException(\"Malformed mask syntax: unexpected end of buffer after ':'\");\n+            }\n+            if ((field.length() == FilterConstants.START.length() && field.indexOf(FilterConstants.START) == 0)\n+                || (field.length() == FilterConstants.COUNT.length() && field.indexOf(FilterConstants.COUNT) == 0))\n             {\n-              if (!Character.isDigit(toparse.charAt(ii + 1)))\n+              if (!Character.isDigit(toparse.charAt(fieldIndex + 1)))\n               {\n                 throw new IllegalMaskException(\"Malformed mask syntax: unexpected range value\");\n               }\n \n-              ii++;\n+              fieldIndex++;\n \n               // Aggressively consume the numerical value for the range parameter as this is a special case.\n-              StringBuilder rangeValue = new StringBuilder();\n-              while (ii < toparse.length())\n+              int rangeValue = 0;\n+              while (fieldIndex < toparse.length() && nextToken == -1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ=="}, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjM3MzgxOnYy", "diffSide": "RIGHT", "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoxOTozNVrOG0iirw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoxOTozNVrOG0iirw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0NTA3MQ==", "bodyText": "check for index out of bounds", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457745071", "createdAt": "2020-07-20T23:19:35Z", "author": {"login": "logancarmody"}, "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 524, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}