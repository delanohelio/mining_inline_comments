{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTMzOTUw", "number": 321, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoyNTo0MlrOEDkmMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzowMDo0OVrOEEFZUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTgwNzg0OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoyNTo0MlrOGgqsRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTozNjoyOVrOGgtj2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzA3OQ==", "bodyText": "imo comment unnecessary.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436907079", "createdAt": "2020-06-08T18:25:42Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NDA3NA==", "bodyText": "I removed the last sentence, kept the first.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436954074", "createdAt": "2020-06-08T19:36:29Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzA3OQ=="}, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTgxMjMxOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoyNjo1N1rOGgqvBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTozODowMVrOGgtnNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzc4Mg==", "bodyText": "very minor but I think using _sourceClusterName is clearer.\nand maybe \"updatedDarkConfigMap\" or \"latest...\"?", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436907782", "createdAt": "2020-06-08T18:26:57Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NDkzMg==", "bodyText": "made the two changes.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436954932", "createdAt": "2020-06-08T19:38:01Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzc4Mg=="}, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTgzNTMxOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODozMzo0NlrOGgq9mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjozMTo0OFrOGgypCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTUxMw==", "bodyText": "we also need to handle deletes; this only handles create + update. please add a test for this.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436911513", "createdAt": "2020-06-08T18:33:46Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNzMyMg==", "bodyText": "made the changes we talked about. Also, I realized that the StrategyFactoryImpl's getOrCreate() shouldn't modify the strategyMap, because if there's constant traffic, it would make it impossible to remove a dark cluster strategy if the getOrCreate() added to the strategyMap.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437037322", "createdAt": "2020-06-08T22:31:48Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTUxMw=="}, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjA3NjcxOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToyOTowNFrOGgtUfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTozMzoyOFrOGgtdtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDE0Mg==", "bodyText": "can be more concise: \"For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\"", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436950142", "createdAt": "2020-06-08T19:29:04Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MjUwMw==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436952503", "createdAt": "2020-06-08T19:33:28Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDE0Mg=="}, "originalCommit": {"oid": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjYzNzkwOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjo0MDowOFrOGgy0eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjo0MDowOFrOGgy0eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDI0OQ==", "bodyText": "this is not a new change, nothing has changed in this function. I don't know why github shows a diff here, the file looks fine.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437040249", "createdAt": "2020-06-08T22:40:08Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -259,6 +311,18 @@ public void onClusterAdded(String clusterName)\n       // deleting whatever the first cluster listener added. It would have been more straightforward to have\n       // a handle directly to the other clusterListener, but there's no good reason for the StrategyFactory to\n       // expose that or allow it to be passed in, as the clusterListener needs to manipulate internal state.\n+      try", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f07b543a7962853c99ee825a17806def1a2b9ca"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE2MzE3OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo1MjoyOVrOGhfFRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo0NzowMVrOGhhI1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTQ0Ng==", "bodyText": "-> get", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437765446", "createdAt": "2020-06-09T22:52:29Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5OTEyNA==", "bodyText": "fixed.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437799124", "createdAt": "2020-06-10T00:47:01Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTQ0Ng=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE2NDkzOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo1MzoxOFrOGhfGVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDozMToyM1rOGiFQEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA==", "bodyText": "Can remove darkClusterConfig if it's not used anymore.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437765718", "createdAt": "2020-06-09T22:53:18Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n    * @return {@link DarkClusterStrategy}\n    */\n-  DarkClusterStrategy getOrCreate(String darkClusterName, DarkClusterConfig darkClusterConfig);\n+  DarkClusterStrategy get(String darkClusterName, DarkClusterConfig darkClusterConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMDcyNA==", "bodyText": "It's not used in our default implementation of DarkClusterStrategy, but I could see someone wanting a different default implementation rather than NO_OP. Because the DarkClusterStrategyFactoryImpl relies on the zookeeper update, it actually can return the NO_OP for quite a few invocations before zookeeper events trigger a strategy creation. So I'd suggest leaving this in the interface.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437800724", "createdAt": "2020-06-10T00:53:14Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n    * @return {@link DarkClusterStrategy}\n    */\n-  DarkClusterStrategy getOrCreate(String darkClusterName, DarkClusterConfig darkClusterConfig);\n+  DarkClusterStrategy get(String darkClusterName, DarkClusterConfig darkClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5MDgwMQ==", "bodyText": "removed, if needed in the future we can readd.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r438390801", "createdAt": "2020-06-10T20:31:23Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n    * @return {@link DarkClusterStrategy}\n    */\n-  DarkClusterStrategy getOrCreate(String darkClusterName, DarkClusterConfig darkClusterConfig);\n+  DarkClusterStrategy get(String darkClusterName, DarkClusterConfig darkClusterConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE2OTIxOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo1NToxOFrOGhfI_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo1NDoxMlrOGhhQAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NjM5Nw==", "bodyText": "Can remove comments from line 149-152", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437766397", "createdAt": "2020-06-09T22:55:18Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMDk2Mg==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437800962", "createdAt": "2020-06-10T00:54:12Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NjM5Nw=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE3NDM4OnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo1Nzo0NFrOGhfMIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo1NzozMVrOGhhTlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NzIwMA==", "bodyText": "can just convert to 1-liner.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437767200", "createdAt": "2020-06-09T22:57:44Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n+          {\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMTg3Nw==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437801877", "createdAt": "2020-06-10T00:57:31Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n+          {\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NzIwMA=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE4MTYyOnYy", "diffSide": "RIGHT", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzowMDo1MFrOGhfQpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo1NToxMVrOGhhRDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2ODM1Nw==", "bodyText": "comments at 161 and 163 can be removed.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437768357", "createdAt": "2020-06-09T23:00:50Z", "author": {"login": "zhang-chris"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMTIzMQ==", "bodyText": "done.", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437801231", "createdAt": "2020-06-10T00:55:11Z", "author": {"login": "davidhoa"}, "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2ODM1Nw=="}, "originalCommit": {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 489, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}