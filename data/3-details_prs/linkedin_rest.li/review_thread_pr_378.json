{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2OTM0OTQ0", "number": 378, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDowNDoxNFrOEXxuWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzo0MDozNFrOEYKaPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzY3Mzg0OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDowNDoxNFrOG_wiLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo0NjoxOVrOHAT0tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw==", "bodyText": "Is there a way to get the average of all requests in stead of the average of all hosts? If host A gets 100 requests and host B gets 10 requests, we probably want (100 * latencyA + 10 * latencyB) / 110 instead of (latencyA + latencyB) / 2. That will be consistent to how to calculate the cluster average", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469508653", "createdAt": "2020-08-12T20:04:14Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxMDE1NQ==", "bodyText": "BTW you can get avgClusterLatency from PartitionStats in PartitionData, we can probably see if we can reuse PartitionStats, because it's also used for metrics emitting purpose", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469510155", "createdAt": "2020-08-12T20:07:13Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NzU4OA==", "bodyText": "BTW you can get avgClusterLatency from PartitionStats in PartitionData, we can probably see if we can reuse PartitionStats, because it's also used for metrics emitting purpose\n\nI've thought of using PartitionStats. But it only keeps the cluster level latency/call count/error rate. If I want to find out the call stats for each individual host, I still have to go through the TrackerClient map. So I'm thinking using the call stats from the map directly would produce a more accurate result.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469587588", "createdAt": "2020-08-12T22:43:31Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcxODM5Ng==", "bodyText": "OK I will leave this implementation decision to you, as long as we are using the correct way to calculate avg cluster latency :)", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469718396", "createdAt": "2020-08-13T06:11:57Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjgzNg==", "bodyText": "Fixed in the new commit", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470086836", "createdAt": "2020-08-13T16:46:19Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwODY1Mw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzc1NzM3OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDozMTowMlrOG_xWRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo0NzowN1rOHAT2fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMTk4OA==", "bodyText": "On a second thought, I started thinking about for the max deviation, we probably care more about the ones that is greater than the average, if a host has 0 latency, it may impact this max absolute deviation. Should we not use absolute?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469521988", "createdAt": "2020-08-12T20:31:02Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    double variance = weightedLatencies.stream()\n+        .map(latency -> Math.pow(latency - avgLatency, 2))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return Math.sqrt(variance);\n+  }\n+\n+  @Override\n+  public double getLatencyAverageAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getLatencyMedianAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double medianLatency = getMedian(weightedLatencies);\n+\n+    List<Double> medianAbsolutes = weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - medianLatency))\n+        .collect(Collectors.toList());\n+\n+    return getMedian(medianAbsolutes);\n+  }\n+\n+  @Override\n+  public double getLatencyMaxAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5NDExOA==", "bodyText": "Agreed.\nMaybe we could have\n\nStandard Deviation and MeanAbsoluteDeviation to capture the entire variance\nMeanSignedDeviation and MaxSignedDeviation to capture the positive outliers\nWe could also have a metric for (maxLatency - avgLatency) / avgLatency, that directly calculates the max relative health factor.\n\nPlease feel free to share your thoughts on this.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469594118", "createdAt": "2020-08-12T23:02:32Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    double variance = weightedLatencies.stream()\n+        .map(latency -> Math.pow(latency - avgLatency, 2))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return Math.sqrt(variance);\n+  }\n+\n+  @Override\n+  public double getLatencyAverageAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getLatencyMedianAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double medianLatency = getMedian(weightedLatencies);\n+\n+    List<Double> medianAbsolutes = weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - medianLatency))\n+        .collect(Collectors.toList());\n+\n+    return getMedian(medianAbsolutes);\n+  }\n+\n+  @Override\n+  public double getLatencyMaxAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMTk4OA=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NzI5Mg==", "bodyText": "Addressed in the new commit. Please see the comment below.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470087292", "createdAt": "2020-08-13T16:47:07Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    double variance = weightedLatencies.stream()\n+        .map(latency -> Math.pow(latency - avgLatency, 2))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return Math.sqrt(variance);\n+  }\n+\n+  @Override\n+  public double getLatencyAverageAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+\n+    return weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getLatencyMedianAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double medianLatency = getMedian(weightedLatencies);\n+\n+    List<Double> medianAbsolutes = weightedLatencies.stream()\n+        .map(latency -> Math.abs(latency - medianLatency))\n+        .collect(Collectors.toList());\n+\n+    return getMedian(medianAbsolutes);\n+  }\n+\n+  @Override\n+  public double getLatencyMaxAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMTk4OA=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzc2MTcyOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDozMTo1NVrOG_xZIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo0NzozNFrOHAT3gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw==", "bodyText": "Is it possible that a host does not get any traffic so the latency is 0, will it be counted here?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469522723", "createdAt": "2020-08-12T20:31:55Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyNDA0OA==", "bodyText": "Can we add some unit test on this to cover some different cases?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469524048", "createdAt": "2020-08-12T20:33:01Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODI0Mw==", "bodyText": "Is it possible that a host does not get any traffic so the latency is 0, will it be counted here?\n\nSince I had the orElse(0) clause, it shouldn't be a problem if a host doesn't get any traffic.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469588243", "createdAt": "2020-08-12T22:45:21Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODc3OQ==", "bodyText": "Can we add some unit test on this to cover some different cases?\n\nSure, I've written some local unit tests. Would you like me to also submit those as official code changes?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469588779", "createdAt": "2020-08-12T22:46:52Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcxOTgzNA==", "bodyText": "I mean for the host that does not have any traffic, we probably don't want to count it in the deviation. For example if we have 5 hosts in total, for some reason 4 of them have avg host latency 30, 32, 32, 34 and the other one does not have any traffic, hence the host latency is 0. When we calculate the deviation, I'm thinking about if we should only use 30, 32, 32, 34 as data points.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469719834", "createdAt": "2020-08-13T06:15:57Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcxOTk0MA==", "bodyText": "Yes it would be great to always have some unit test coverage", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r469719940", "createdAt": "2020-08-13T06:16:17Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NzU1Mg==", "bodyText": "Unit tests added in the new commit.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470087552", "createdAt": "2020-08-13T16:47:34Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    List<Double> weightedLatencies = stateMap.keySet().stream()\n+        .map(trackerClient -> getWeightedLatency(trackerClient.getLatestCallStats()))\n+        .collect(Collectors.toList());\n+\n+    double avgLatency = weightedLatencies.stream()\n+        .mapToDouble(Double::doubleValue)\n+        .average()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyMjcyMw=="}, "originalCommit": {"oid": "db440eee1299a78d25fb818b96a4b52034dfd52e"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzY0ODIyOnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzoyODoyM1rOHAV1MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODowMjoyOFrOHAXdLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDExOTcyOA==", "bodyText": "Wondering how do you plan to implement this in container? Do you plan to go with multiple percentile relative factors?", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470119728", "createdAt": "2020-08-13T17:28:23Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    return calculateStandardDeviation(stateMap.keySet());\n+  }\n+\n+  @Override\n+  public double getLatencyMeanAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    return stateMap.keySet().stream()\n+        .map(trackerClient -> Math.abs(StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getAboveAverageLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    Set<TrackerClient> aboveAvgClients = stateMap.keySet().stream()\n+        .filter(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) > avgLatency)\n+        .collect(Collectors.toSet());\n+\n+    return calculateStandardDeviation(aboveAvgClients);\n+  }\n+\n+  @Override\n+  public double getMaxLatencyRelativeFactor()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+    long maxLatency = stateMap.keySet().stream()\n+        .map(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()))\n+        .mapToLong(Long::longValue)\n+        .max()\n+        .orElse(0L);\n+\n+    return avgLatency == 0 ? 0 : maxLatency / avgLatency;\n+  }\n+\n+  @Override\n+  public double getNthPercentileLatencyRelativeFactor(double pct)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE0NjM1MQ==", "bodyText": "I'm not sure about which percentile to use. I can start by trying out p99, p95. So having a more general interface here might be easier for later experimentations.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470146351", "createdAt": "2020-08-13T18:02:28Z", "author": {"login": "rickzx"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    return calculateStandardDeviation(stateMap.keySet());\n+  }\n+\n+  @Override\n+  public double getLatencyMeanAbsoluteDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    return stateMap.keySet().stream()\n+        .map(trackerClient -> Math.abs(StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) - avgLatency))\n+        .mapToDouble(Double::doubleValue)\n+        .average()\n+        .orElse(0);\n+  }\n+\n+  @Override\n+  public double getAboveAverageLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+\n+    Set<TrackerClient> aboveAvgClients = stateMap.keySet().stream()\n+        .filter(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()) > avgLatency)\n+        .collect(Collectors.toSet());\n+\n+    return calculateStandardDeviation(aboveAvgClients);\n+  }\n+\n+  @Override\n+  public double getMaxLatencyRelativeFactor()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    double avgLatency = getAvgClusterLatency(stateMap.keySet());\n+    long maxLatency = stateMap.keySet().stream()\n+        .map(trackerClient -> StateUpdater.getAvgHostLatency(trackerClient.getCallTracker().getCallStats()))\n+        .mapToLong(Long::longValue)\n+        .max()\n+        .orElse(0L);\n+\n+    return avgLatency == 0 ? 0 : maxLatency / avgLatency;\n+  }\n+\n+  @Override\n+  public double getNthPercentileLatencyRelativeFactor(double pct)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDExOTcyOA=="}, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzY2OTc1OnYy", "diffSide": "RIGHT", "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzozMjowNlrOHAWCfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzozMjowNlrOHAWCfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzEzMw==", "bodyText": "As we discussed offline, I think it's fair to remove mean, since the calculation is a bit more complicated, also it did not provide too much additional value", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470123133", "createdAt": "2020-08-13T17:32:06Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/main/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmx.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import com.linkedin.d2.balancer.util.partitions.DefaultPartitionAccessor;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class RelativeLoadBalancerStrategyJmx implements RelativeLoadBalancerStrategyJmxMBean\n+{\n+  private final RelativeLoadBalancerStrategy _strategy;\n+\n+  public RelativeLoadBalancerStrategyJmx(RelativeLoadBalancerStrategy strategy)\n+  {\n+    _strategy = strategy;\n+  }\n+\n+  @Override\n+  public double getLatencyStandardDeviation()\n+  {\n+    Map<TrackerClient, TrackerClientState> stateMap =\n+        _strategy.getPartitionState(DefaultPartitionAccessor.DEFAULT_PARTITION_ID).getTrackerClientStateMap();\n+\n+    return calculateStandardDeviation(stateMap.keySet());\n+  }\n+\n+  @Override\n+  public double getLatencyMeanAbsoluteDeviation()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzcxODM3OnYy", "diffSide": "RIGHT", "path": "d2/src/test/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmxTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzo0MDozNFrOHAWgrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODowMDowNFrOHAXXfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzMDg2MA==", "bodyText": "Let's also have a unit test where the call count and latency for some of the hosts are 0.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470130860", "createdAt": "2020-08-13T17:40:34Z", "author": {"login": "rachelhanhan"}, "path": "d2/src/test/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmxTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.relative.PartitionState;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientMockHelper;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.Test;\n+\n+import static org.easymock.EasyMock.anyInt;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class RelativeLoadBalancerStrategyJmxTest {\n+  private RelativeLoadBalancerStrategyJmx mockRelativeLoadBalancerStrategyJmx(List<TrackerClient> trackerClients)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientsMap = new HashMap<>();\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      trackerClientsMap.put(trackerClient, new TrackerClientState(1, 1));\n+    }\n+\n+    RelativeLoadBalancerStrategy strategy = Mockito.mock(RelativeLoadBalancerStrategy.class);\n+    PartitionState state = Mockito.mock(PartitionState.class);\n+    Mockito.when(state.getTrackerClientStateMap()).thenReturn(trackerClientsMap);\n+    Mockito.when(strategy.getPartitionState(anyInt())).thenReturn(state);\n+\n+    return new RelativeLoadBalancerStrategyJmx(strategy);\n+  }\n+\n+  @Test\n+  public void testLatencyDeviation()\n+  {\n+    List<TrackerClient> trackerClientsEqual = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 200L), Arrays.asList(100L, 100L), Arrays.asList(0, 0));\n+\n+    RelativeLoadBalancerStrategyJmx jmx = mockRelativeLoadBalancerStrategyJmx(trackerClientsEqual);\n+    assertEquals(jmx.getLatencyStandardDeviation(), 0.0);\n+    assertEquals(jmx.getLatencyMeanAbsoluteDeviation(), 0.0);\n+    assertEquals(jmx.getAboveAverageLatencyStandardDeviation(), 0.0);\n+\n+    List<TrackerClient> trackerClientsDiverse1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10),\n+        Arrays.asList(100L, 150L, 200L), Arrays.asList(50L, 75L, 100L), Arrays.asList(0, 0, 0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE0NDg5Mg==", "bodyText": "Added in the latest commit.", "url": "https://github.com/linkedin/rest.li/pull/378#discussion_r470144892", "createdAt": "2020-08-13T18:00:04Z", "author": {"login": "rickzx"}, "path": "d2/src/test/java/com/linkedin/d2/jmx/RelativeLoadBalancerStrategyJmxTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.jmx;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.relative.PartitionState;\n+import com.linkedin.d2.balancer.strategies.relative.RelativeLoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientMockHelper;\n+import com.linkedin.d2.balancer.strategies.relative.TrackerClientState;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.Test;\n+\n+import static org.easymock.EasyMock.anyInt;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class RelativeLoadBalancerStrategyJmxTest {\n+  private RelativeLoadBalancerStrategyJmx mockRelativeLoadBalancerStrategyJmx(List<TrackerClient> trackerClients)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientsMap = new HashMap<>();\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      trackerClientsMap.put(trackerClient, new TrackerClientState(1, 1));\n+    }\n+\n+    RelativeLoadBalancerStrategy strategy = Mockito.mock(RelativeLoadBalancerStrategy.class);\n+    PartitionState state = Mockito.mock(PartitionState.class);\n+    Mockito.when(state.getTrackerClientStateMap()).thenReturn(trackerClientsMap);\n+    Mockito.when(strategy.getPartitionState(anyInt())).thenReturn(state);\n+\n+    return new RelativeLoadBalancerStrategyJmx(strategy);\n+  }\n+\n+  @Test\n+  public void testLatencyDeviation()\n+  {\n+    List<TrackerClient> trackerClientsEqual = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 200L), Arrays.asList(100L, 100L), Arrays.asList(0, 0));\n+\n+    RelativeLoadBalancerStrategyJmx jmx = mockRelativeLoadBalancerStrategyJmx(trackerClientsEqual);\n+    assertEquals(jmx.getLatencyStandardDeviation(), 0.0);\n+    assertEquals(jmx.getLatencyMeanAbsoluteDeviation(), 0.0);\n+    assertEquals(jmx.getAboveAverageLatencyStandardDeviation(), 0.0);\n+\n+    List<TrackerClient> trackerClientsDiverse1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10),\n+        Arrays.asList(100L, 150L, 200L), Arrays.asList(50L, 75L, 100L), Arrays.asList(0, 0, 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEzMDg2MA=="}, "originalCommit": {"oid": "63e53a37e3e525e022c1f464a360e213bbf6d468"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 298, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}