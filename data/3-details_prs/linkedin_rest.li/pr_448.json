{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDE5MzE0", "number": 448, "title": "Improve translate schema task performance.", "bodyText": "Parse all input sources using the same parser/resolver to avoid loading referenced schemas multiple times.", "createdAt": "2020-10-15T11:08:55Z", "url": "https://github.com/linkedin/rest.li/pull/448", "merged": true, "mergeCommit": {"oid": "5656769a0bce79f5c07e2a7d6932ec744b6fd4a5"}, "closed": true, "closedAt": "2020-10-23T03:50:24Z", "author": {"login": "karthikbalasub"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSv8amAFqTUwOTI3MTAzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVMWUYgBqjM5MTE3MzU4MzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjcxMDM1", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-509271035", "createdAt": "2020-10-15T11:17:57Z", "commit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMToxNzo1OFrOHiC6AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMToxNzo1OFrOHiC6AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTI0OA==", "bodyText": "can we print schema location (or path) with the error?", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505461248", "createdAt": "2020-10-15T11:17:58Z", "author": {"login": "aman1309"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5Mjc4NjI2", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-509278626", "createdAt": "2020-10-15T11:28:52Z", "commit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMToyODo1M1rOHiDQdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMToyODo1M1rOHiDQdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Njk5Ng==", "bodyText": "Is this error covered after this change?", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505466996", "createdAt": "2020-10-15T11:28:53Z", "author": {"login": "junchuanwang"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -345,46 +346,6 @@ private void writeTranslatedSchemasToDirectory(\n     }\n   }\n \n-  private static NamedDataSchema checkForErrorsAndGetTopLevelSchema(\n-      File file, String schemaFullname, PegasusSchemaParser parser, StringBuilder errorMessages)\n-  {\n-    StringBuilder errorMessageBuilder = parser.errorMessageBuilder();\n-    if (errorMessageBuilder.length() > 0)\n-    {\n-      errorMessages.append(\"Failed to parse schema: \")\n-          .append(file.getAbsolutePath())\n-          .append(\"\\nfullname: \")\n-          .append(schemaFullname)\n-          .append(\"\\nerrors: \")\n-          .append(errorMessageBuilder.toString())\n-          .append(\"\\n\");\n-      return null;\n-    }\n-    List<DataSchema> topLevelSchemas = parser.topLevelDataSchemas();\n-    if (topLevelSchemas.size() != 1)\n-    {\n-      errorMessages.append(\"Expected one top level schema for: \")\n-          .append(file.getAbsolutePath())\n-          .append(\" but got \")\n-          .append(topLevelSchemas.size())\n-          .append(\" schemas.\")\n-          .append(\"\\n\");\n-      return  null;\n-    }\n-    DataSchema sourceSchema = topLevelSchemas.get(0);\n-    if (!(sourceSchema instanceof NamedDataSchema) ||\n-        !((NamedDataSchema) sourceSchema).getFullName().equals(schemaFullname))\n-    {\n-      errorMessages.append(\"Parsed top-level schema does not match the schema file name. File: \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTIwMjY1", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-509520265", "createdAt": "2020-10-15T15:43:40Z", "commit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNTo0Mzo0MFrOHiOSPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjoxMjo0NFrOHiPiyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NzY3Nw==", "bodyText": "nit: space after for", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505647677", "createdAt": "2020-10-15T15:43:40Z", "author": {"login": "nickibi"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng==", "bodyText": "Parsing schemas in this way, we may not get expected result.\nDataSchemaParser.ParseResult (parsedSources) also contains embedded name schemas which are unnecessary to be top level schemas.", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505668296", "createdAt": "2020-10-15T16:12:44Z", "author": {"login": "nickibi"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5Njc3MDg3", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-509677087", "createdAt": "2020-10-15T18:54:15Z", "commit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUyMzY0", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-509852364", "createdAt": "2020-10-15T22:28:46Z", "commit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjoyODo0NlrOHidrsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjoyODo0NlrOHidrsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5OTk1NQ==", "bodyText": "Is it worth to just skip the error and keep looping?", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505899955", "createdAt": "2020-10-15T22:28:46Z", "author": {"login": "BrianPin"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema.\");\n+        System.exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6"}, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/41cbc914e380964b7a537015624da4c2e5e9b6d6", "committedDate": "2020-10-15T11:07:15Z", "message": "Improve translate schema task performance by parsing all source files\ntogether. This avoids loading the schemas multiple times."}, "afterCommit": {"oid": "30d9a5afed3971be1dec2b8f42cc28a0787e19fe", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/30d9a5afed3971be1dec2b8f42cc28a0787e19fe", "committedDate": "2020-10-23T00:10:29Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjA4NTIy", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-515208522", "createdAt": "2020-10-23T00:38:02Z", "commit": {"oid": "30d9a5afed3971be1dec2b8f42cc28a0787e19fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDozODowMlrOHm4hyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDozODowMlrOHm4hyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNDA5MQ==", "bodyText": "nit: remove extra line", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510534091", "createdAt": "2020-10-23T00:38:02Z", "author": {"login": "nickibi"}, "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,36 +206,67 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for (Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      // DataSchemaParse::parseSources returns all schemas from the source dir and the schemas referenced by it.\n+      // For translation we need to skip the following schemas:\n+      //   - From source files not matching the source format specified.\n+      //   - Schemas not loaded from the source dir provided as input.\n+      //   - Nested schemas.\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat) ||\n+          !location.toString().startsWith(_sourceDir.getAbsolutePath()) ||\n+          !isTopLevelSchema(schema, location))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema. Location: {}\", location.getSourceFile().getAbsolutePath());\n+        System.exit(1);\n       }\n     }\n-    if (errorMessages.length() > 0)\n+    return topLevelTranslatedSchemas;\n+  }\n+\n+  /**\n+   * Returns true if the schema name matches the file name of the location, indicating the schema is a top-level\n+   * schema.\n+   */\n+  private boolean isTopLevelSchema(DataSchema schema, DataSchemaLocation location)\n+  {\n+    if (!(schema instanceof NamedDataSchema))\n     {\n-      LOGGER.error(errorMessages.toString());\n-      System.exit(1);\n+      // Top-level schemas should be named.\n+      return false;\n     }\n-    return topLevelTranslatedSchemas;\n+    NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+    String namespace = namedDataSchema.getNamespace();\n+    String path = location.toString();\n+    if (!FileUtil.removeFileExtension(path.substring(path.lastIndexOf(File.separator) + 1)).equalsIgnoreCase(namedDataSchema.getName()))\n+    {\n+      // Schema name didn't match.\n+      return false;\n+    }\n+\n+    final String parent = path.substring(0, path.lastIndexOf(File.separator));\n+    // Finally check if namespace matches.\n+    return parent.endsWith(namespace.replace('.', File.separatorChar));\n   }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30d9a5afed3971be1dec2b8f42cc28a0787e19fe"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjA5OTgx", "url": "https://github.com/linkedin/rest.li/pull/448#pullrequestreview-515209981", "createdAt": "2020-10-23T00:43:41Z", "commit": {"oid": "ee12e2109cd8058f360c00f34e7fbceac6eb372d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee12e2109cd8058f360c00f34e7fbceac6eb372d", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/ee12e2109cd8058f360c00f34e7fbceac6eb372d", "committedDate": "2020-10-23T00:42:19Z", "message": "Merge branch 'master' into perf/schema_translate"}, "afterCommit": {"oid": "5cb65762092773d8e8694ba1feb613a98a2fd3ab", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/5cb65762092773d8e8694ba1feb613a98a2fd3ab", "committedDate": "2020-10-23T00:43:33Z", "message": "Release 29.7.13"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db1afbd4bd64aaa95db9619b45f3e8dc083c712", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/7db1afbd4bd64aaa95db9619b45f3e8dc083c712", "committedDate": "2020-10-23T01:32:11Z", "message": "Improve translate schema task performance by parsing all source files\ntogether. This avoids loading the schemas multiple times."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f16cb05993e4dffe8a89db07d3fb38bf18f3c52", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/4f16cb05993e4dffe8a89db07d3fb38bf18f3c52", "committedDate": "2020-10-23T01:32:11Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b5035c98115c7b9cf5182b42d45bdd321c64b17", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/0b5035c98115c7b9cf5182b42d45bdd321c64b17", "committedDate": "2020-10-23T01:32:11Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "159119379b06313a49a96ff5ac60e4310babcb12", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/159119379b06313a49a96ff5ac60e4310babcb12", "committedDate": "2020-10-23T01:32:43Z", "message": "Release 29.7.14"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "170e3ba0bbb36b3a78fe07e013964afd200df5dc", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/170e3ba0bbb36b3a78fe07e013964afd200df5dc", "committedDate": "2020-10-23T01:31:29Z", "message": "Merge branch 'master' into perf/schema_translate"}, "afterCommit": {"oid": "159119379b06313a49a96ff5ac60e4310babcb12", "author": {"user": null}, "url": "https://github.com/linkedin/rest.li/commit/159119379b06313a49a96ff5ac60e4310babcb12", "committedDate": "2020-10-23T01:32:43Z", "message": "Release 29.7.14"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4718, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}