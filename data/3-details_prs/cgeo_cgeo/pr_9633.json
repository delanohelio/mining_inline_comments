{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDcxMDAy", "number": 9633, "title": "Parse formula for waypoint in personal cache note (related to #9211)", "bodyText": "preparation and first implementation for parsing the PN for waypoints with formula as coordinates (related to #9211)\nI used the GeopointParser as example for the FormulaParser and extracted some basics out of the CoordinateCalculateDialog to use it in the parser.\nIn first step only plain-formulas are parsed, I already tried some of the other formats, but with the buttons-representation there will probably some more refactoring necessary.\nI am preparing a different PR for indicating, that a waypoint has a formula defined.\nSupported syntax:\nLike the \"normal\" waypoint-syntax, use (F-PLAIN) to indicate the plain-formula (like (NO-COORD) for empty coords), then the formula string with both coordinates and (optional) already known variables / equations separated with \"|\".\nAn existing formula will be exported in the same way, if a waypoint is stored in PN.\nExample:\n@Final (F) (F-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5|\nOnly upper-case letters are allowed in the formula, for the variables list I don't have a regular expression at the moment. Probably I can add some later.\nI also try to formulate some description for the manual.", "createdAt": "2020-12-30T20:05:10Z", "url": "https://github.com/cgeo/cgeo/pull/9633", "merged": true, "mergeCommit": {"oid": "23f74c4aa2b26b7d6265719bd6329f07e824b438"}, "closed": true, "closedAt": "2021-04-17T10:31:29Z", "author": {"login": "murggel"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdrWCDcABqjQxNTgzNjQxODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeN5-jXgFqTYzODIwMjgzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82334b5c6d6938a5166017501874e2777353981b", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/82334b5c6d6938a5166017501874e2777353981b", "committedDate": "2020-12-30T20:28:44Z", "message": "fix codacy-issues"}, "afterCommit": {"oid": "2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "committedDate": "2020-12-30T21:14:12Z", "message": "remove duplicate files and fix codacy-issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "committedDate": "2020-12-30T21:14:12Z", "message": "remove duplicate files and fix codacy-issues"}, "afterCommit": {"oid": "070f222ae7cc1832c63c629c5aee38e384cf8bd2", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/070f222ae7cc1832c63c629c5aee38e384cf8bd2", "committedDate": "2020-12-30T21:23:33Z", "message": "remove duplicate files and fix codacy-issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "070f222ae7cc1832c63c629c5aee38e384cf8bd2", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/070f222ae7cc1832c63c629c5aee38e384cf8bd2", "committedDate": "2020-12-30T21:23:33Z", "message": "remove duplicate files and fix codacy-issues"}, "afterCommit": {"oid": "b9acd6af856174f0ca316af097822d3db2835a4f", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/b9acd6af856174f0ca316af097822d3db2835a4f", "committedDate": "2021-01-04T11:03:39Z", "message": "refactor WaypointParser and FormulaParser to non-static class\nsplit up WaypointTest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ede18fae291fac51ae5f5ca8660eb78aedd709d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/9ede18fae291fac51ae5f5ca8660eb78aedd709d", "committedDate": "2021-01-07T17:02:32Z", "message": "add test for formula-stability"}, "afterCommit": {"oid": "9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "committedDate": "2021-01-07T22:37:50Z", "message": "adapt comments and order of keywords"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "committedDate": "2021-01-07T22:37:50Z", "message": "adapt comments and order of keywords"}, "afterCommit": {"oid": "1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "committedDate": "2021-01-07T22:48:24Z", "message": "adapt comments and order of keywords, fix codacy issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "committedDate": "2021-01-07T22:48:24Z", "message": "adapt comments and order of keywords, fix codacy issues"}, "afterCommit": {"oid": "d989ccc96d8969a70d220f4db22b9875a3291609", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/d989ccc96d8969a70d220f4db22b9875a3291609", "committedDate": "2021-01-08T09:09:04Z", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d989ccc96d8969a70d220f4db22b9875a3291609", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/d989ccc96d8969a70d220f4db22b9875a3291609", "committedDate": "2021-01-08T09:09:04Z", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils"}, "afterCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/a402ec75a5ddba61ae9d5ad9664c02a578275580", "committedDate": "2021-01-08T09:15:55Z", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjkzNDQy", "url": "https://github.com/cgeo/cgeo/pull/9633#pullrequestreview-564693442", "createdAt": "2021-01-09T08:17:25Z", "commit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoxNzoyNVrOIQoVSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1NDozOVrOIQohuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw==", "bodyText": "c:geo does not use Serializable put Parcelable. But also the later only if needed. I assume here it is probably not needed at all? (since you use json)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554308937", "createdAt": "2021-01-09T08:17:25Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTIzNg==", "bodyText": "I think \"getLabel\" and \"setAutoChar\" could be instance methods of class \"ButtonData\" instead of moving them into the enum. Or am I missing something?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309236", "createdAt": "2021-01-09T08:21:21Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {\n+\n+    /** The three states the button can be put into */\n+    public enum ValueType {\n+        INPUT_VAL {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.inputVal;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char nextChar) {\n+                buttonData.autoChar = nextChar;\n+                return nextChar;\n+            }\n+\n+        },\n+        AUTO_CHAR {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.autoChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar++;\n+                return nextChar;\n+            }\n+        },\n+        BLANK {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return ButtonData.BLANK;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                buttonData.autoChar = autoChar;\n+                return autoChar;\n+            }\n+        },\n+        CUSTOM {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.customChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar;\n+                if ('A' <= buttonData.customChar && buttonData.customChar <= 'Z') {\n+                    nextChar = buttonData.customChar;\n+                    nextChar++;\n+                }\n+\n+                return nextChar;\n+            }\n+        };\n+\n+        public abstract char getLabel(ButtonData buttonData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTM2MQ==", "bodyText": "+1 for making a separate package out of this! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309361", "createdAt": "2021-01-09T08:23:12Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CalculationUtils.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package cgeo.geocaching.utils;\n+package cgeo.geocaching.calculator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ==", "bodyText": "Could org.apache.commons.lang3.CharUtils be used instead?\nIf not: can this be moved as method to an existing Utils class? Maybe TextUtils?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309615", "createdAt": "2021-01-09T08:25:30Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDE4Nw==", "bodyText": "Kudos for extraction of the parsing methods into an own class! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310187", "createdAt": "2021-01-09T08:32:01Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/models/WaypointParser.java", "diffHunk": "@@ -0,0 +1,454 @@\n+package cgeo.geocaching.models;\n+\n+import cgeo.geocaching.calculator.CoordinatesCalculateUtils;\n+import cgeo.geocaching.calculator.FormulaParser;\n+import cgeo.geocaching.calculator.VariableData;\n+import cgeo.geocaching.enumerations.WaypointType;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.location.GeopointFormatter;\n+import cgeo.geocaching.location.GeopointParser;\n+import cgeo.geocaching.location.GeopointWrapper;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.TextUtils;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class WaypointParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDMyMA==", "bodyText": "Use the constant here instead of hardcoded --", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310320", "createdAt": "2021-01-09T08:33:28Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package cgeo.geocaching.models;\n+\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class WaypointUserNoteCombiner {\n+\n+    private static final String SEPARATOR = \"\\n--\\n\";\n+    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + SEPARATOR + \"\\\\s*\");\n+\n+    private Waypoint waypoint;\n+\n+    /**\n+     *\n+     */\n+    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n+        this.waypoint = waypoint;\n+    }\n+\n+\n+    /**\n+     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n+     *\n+     * @return string with combined note\n+     */\n+    public final String getCombinedNoteAndUserNote() {\n+        final String userNote = this.waypoint.getUserNote();\n+        if (this.waypoint.isUserDefined()) {\n+            return userNote;\n+        } else {\n+            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n+            if (StringUtils.isNotEmpty(userNote)) {\n+                newNote.append(SEPARATOR);\n+                newNote.append(userNote);\n+            }\n+            return newNote.toString();\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     * For userDefined waypoints only userNote is set.\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    public void updateNoteAndUserNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String fixedCombinedNote = combinedNote;\n+            // \\n was removed via validate\n+            if (combinedNote.startsWith(\"--\\n\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDczMA==", "bodyText": "I am not sure I understand what this method is doing. Is there a Unit test for it?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310730", "createdAt": "2021-01-09T08:37:10Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/utils/TextUtils.java", "diffHunk": "@@ -420,6 +428,29 @@ public static String replaceAll(final String text, final String startToken, fina\n         return result;\n     }\n \n+    @NonNull\n+    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDk3Mw==", "bodyText": "An example formula in the class javadoc would be great", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310973", "createdAt": "2021-01-09T08:40:18Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTEyMA==", "bodyText": "Is MinDecFormulaParser the only subclass of AbstractLatLonFormulaParser? If yes, why do we need the subclass?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311120", "createdAt": "2021-01-09T08:42:40Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ==", "bodyText": "There should be coordinate parsers for many coordinates formats in some other class available (alas, they don't parse for variable values inside of course). Can't they be reused somehow (parametereized to accept also letters instead of numbers)?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311279", "createdAt": "2021-01-09T08:44:16Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw==", "bodyText": "Is AbstractLatLonFormulaParser the only subclass of AbstractFormularParser? If yes, why do we need the subclass?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311337", "createdAt": "2021-01-09T08:44:59Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA==", "bodyText": "I think this abstract class could be replaced by an interface?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311394", "createdAt": "2021-01-09T08:45:37Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTYyMg==", "bodyText": "This methods performance would profit from \"list\" being a map (char -> VariableData).  Would that be an adequate data structure for a collection of VariableData's?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311622", "createdAt": "2021-01-09T08:48:12Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg==", "bodyText": "Isn't this the same as calling \"getVariable\" with \"remove=true\"?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311692", "createdAt": "2021-01-09T08:48:52Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTc1OQ==", "bodyText": "This method modifies the content of parameter \"variables\", which should not be done. At least there should be a comment on the method telling which params will be modified.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311759", "createdAt": "2021-01-09T08:49:59Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTgyNA==", "bodyText": "I dont understand difference between \"variables\" and \"varBank\". Maybe a short comment would help?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311824", "createdAt": "2021-01-09T08:51:01Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTg4Mw==", "bodyText": "If I understand the code correctly, then the value of \"variableNames\" could be extracted from list \"variables\". Is this correct? Then this parameter should be removed.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311883", "createdAt": "2021-01-09T08:51:53Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjEyMA==", "bodyText": "Kudos for writing unit tests! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554312120", "createdAt": "2021-01-09T08:54:39Z", "author": {"login": "eddiemuc"}, "path": "tests/src/cgeo/geocaching/calculator/FormulaParserTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.junit.Test;\n+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+\n+public class FormulaParserTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5de89e0e0009b56265df3bb1001e716cca7344a", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/a5de89e0e0009b56265df3bb1001e716cca7344a", "committedDate": "2021-01-09T22:17:39Z", "message": "incorporate review comments"}, "afterCommit": {"oid": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/4751dd40eeffee2cf381a313443308e52b2e7ff1", "committedDate": "2021-01-09T23:47:57Z", "message": "incorporate review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/4751dd40eeffee2cf381a313443308e52b2e7ff1", "committedDate": "2021-01-09T23:47:57Z", "message": "incorporate review comments"}, "afterCommit": {"oid": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "committedDate": "2021-01-17T22:34:19Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "committedDate": "2021-01-17T22:34:19Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}, "afterCommit": {"oid": "c6d040552255b39e72ce189c47a941fead596eb4", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/c6d040552255b39e72ce189c47a941fead596eb4", "committedDate": "2021-01-17T22:58:40Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6d040552255b39e72ce189c47a941fead596eb4", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/c6d040552255b39e72ce189c47a941fead596eb4", "committedDate": "2021-01-17T22:58:40Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}, "afterCommit": {"oid": "82c4d8e14cc013dac69f627891533b18bb2e6f86", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/82c4d8e14cc013dac69f627891533b18bb2e6f86", "committedDate": "2021-01-17T23:10:56Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82c4d8e14cc013dac69f627891533b18bb2e6f86", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/82c4d8e14cc013dac69f627891533b18bb2e6f86", "committedDate": "2021-01-17T23:10:56Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}, "afterCommit": {"oid": "0bcbe1ee454e764b731c2fbb0f8aa1c96248302d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/0bcbe1ee454e764b731c2fbb0f8aa1c96248302d", "committedDate": "2021-01-17T23:47:07Z", "message": "merge with master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a52b1aed26a63100c7b88da68e0d8212957c6dc", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/4a52b1aed26a63100c7b88da68e0d8212957c6dc", "committedDate": "2021-01-26T00:22:24Z", "message": "evaluate formula after parsing"}, "afterCommit": {"oid": "52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "committedDate": "2021-01-26T11:16:51Z", "message": "evaluate formula after parsing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "committedDate": "2021-01-26T11:16:51Z", "message": "evaluate formula after parsing"}, "afterCommit": {"oid": "365d08526d66552c6d13481824c59c71ef1d7ece", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/365d08526d66552c6d13481824c59c71ef1d7ece", "committedDate": "2021-01-26T12:12:56Z", "message": "evaluate formula after parsing (moving evaluate-methods from CoordinatesCalculateDialog to CalcStateEvaluator)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2db04eaf3bfdd72c56b23360fa25fc693a84d54", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/d2db04eaf3bfdd72c56b23360fa25fc693a84d54", "committedDate": "2021-02-02T22:17:54Z", "message": "set calcState from parsed text if calcState from existing waypoint is empty"}, "afterCommit": {"oid": "f70bd2ae6f7f28b857bc005ee787f438ffa42921", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/f70bd2ae6f7f28b857bc005ee787f438ffa42921", "committedDate": "2021-02-15T01:01:13Z", "message": "merge from master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f70bd2ae6f7f28b857bc005ee787f438ffa42921", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/f70bd2ae6f7f28b857bc005ee787f438ffa42921", "committedDate": "2021-02-15T01:01:13Z", "message": "merge from master"}, "afterCommit": {"oid": "5847e78465043096aa941fdf6fb1ab3199ae8e19", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/5847e78465043096aa941fdf6fb1ab3199ae8e19", "committedDate": "2021-03-31T15:26:10Z", "message": "waypoint with formula is userModified"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "743cc64fbd0ba41d94843aebb3929d5a25871608", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/743cc64fbd0ba41d94843aebb3929d5a25871608", "committedDate": "2021-04-15T20:44:17Z", "message": "move / split classes to calculator package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "857908a08c9b5652a36600c7c081d46dbdf33803", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/857908a08c9b5652a36600c7c081d46dbdf33803", "committedDate": "2021-04-15T20:47:09Z", "message": "move methods to parse waypoint to WaypointParser\nsuppress NPath-complexity warning with remark for \"parseWaypointType\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167826d3ae8b30dcdeea3206217079af9b92d9a0", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/167826d3ae8b30dcdeea3206217079af9b92d9a0", "committedDate": "2021-04-15T20:47:11Z", "message": "move methods to combine user note to WaypointUserNoteCombiner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/552ffe707ac5f49f517d31b062ad620c6ad499c2", "committedDate": "2021-04-15T20:47:13Z", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/694006d08fd3c96e34033e9d1a1cf3e7e588f231", "committedDate": "2021-04-15T20:47:14Z", "message": "incorporate review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af91323ed99f67b76dc4479a659b5a48bae865a9", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/af91323ed99f67b76dc4479a659b5a48bae865a9", "committedDate": "2021-04-15T20:47:14Z", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b52db28b4adec1c159f70541c5a8f6e356e2db41", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/b52db28b4adec1c159f70541c5a8f6e356e2db41", "committedDate": "2021-04-15T20:47:14Z", "message": "merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d39ad6788a90131633bb01a21efce68305693c10", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/d39ad6788a90131633bb01a21efce68305693c10", "committedDate": "2021-04-15T20:47:15Z", "message": "evaluate formula after parsing (moving evaluate-methods from CoordinatesCalculateDialog to CalcStateEvaluator)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa5c260276b7f4b0b263ccdd08dbbe547b6c6003", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/aa5c260276b7f4b0b263ccdd08dbbe547b6c6003", "committedDate": "2021-04-15T20:47:18Z", "message": "set calcState from parsed text if calcState from existing waypoint is empty"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7ee0274f0755464b07dc04b1ac5cb0022ed8a88", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/a7ee0274f0755464b07dc04b1ac5cb0022ed8a88", "committedDate": "2021-04-15T20:47:20Z", "message": "make formula-string configurable in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5d5c850fbafb306a351212d5d9a739214ca9e0", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/3b5d5c850fbafb306a351212d5d9a739214ca9e0", "committedDate": "2021-04-15T20:47:20Z", "message": "merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df9f801ead62a0a66becce0b81ccda079d309e3d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/df9f801ead62a0a66becce0b81ccda079d309e3d", "committedDate": "2021-04-15T20:47:21Z", "message": "return variable-name in string, if value can not be evaluated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa9ac17ff25e856cd8e710440197dc5af58cf08d", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/aa9ac17ff25e856cd8e710440197dc5af58cf08d", "committedDate": "2021-04-15T20:47:21Z", "message": "waypoint with formula is userModified"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79ff3adfccbd43c56f156dd3b096fe32b9759144", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/79ff3adfccbd43c56f156dd3b096fe32b9759144", "committedDate": "2021-04-15T20:47:22Z", "message": "convert lower case letter in formula into upper case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "committedDate": "2021-04-15T20:47:22Z", "message": "split function getParseableFormula into formulaString (different for the various formula-types) and variablesString"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4245ad0ab96a8d70c825d224d1e52b4160dd0f4a", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/4245ad0ab96a8d70c825d224d1e52b4160dd0f4a", "committedDate": "2021-04-15T20:39:17Z", "message": "split function getParseableFormula into formulaString (different for the various formula-types) and variablesString"}, "afterCommit": {"oid": "30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "committedDate": "2021-04-15T20:47:22Z", "message": "split function getParseableFormula into formulaString (different for the various formula-types) and variablesString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9a330f6b98562a60837896bf1ff89634923dcaa", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/a9a330f6b98562a60837896bf1ff89634923dcaa", "committedDate": "2021-04-15T22:32:44Z", "message": "resolve conflicts due to rebase to master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b22218ab0d52aa3ec99191bdd338dd1fb7e5ef8", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/8b22218ab0d52aa3ec99191bdd338dd1fb7e5ef8", "committedDate": "2021-04-15T21:53:55Z", "message": "rebase to master"}, "afterCommit": {"oid": "a9a330f6b98562a60837896bf1ff89634923dcaa", "author": {"user": {"login": "murggel", "name": null}}, "url": "https://github.com/cgeo/cgeo/commit/a9a330f6b98562a60837896bf1ff89634923dcaa", "committedDate": "2021-04-15T22:32:44Z", "message": "resolve conflicts due to rebase to master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MjAyODM2", "url": "https://github.com/cgeo/cgeo/pull/9633#pullrequestreview-638202836", "createdAt": "2021-04-17T06:22:19Z", "commit": {"oid": "a9a330f6b98562a60837896bf1ff89634923dcaa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1540, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}