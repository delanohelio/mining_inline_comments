{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ3MDcxMDAy", "number": 9633, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoxNzoyNVrOFMv_9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1NDozOVrOFMwK4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTEzNjUzOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoxNzoyNVrOIQoVSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQwOTozNDozMFrOIQ2aKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw==", "bodyText": "c:geo does not use Serializable put Parcelable. But also the later only if needed. I assume here it is probably not needed at all? (since you use json)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554308937", "createdAt": "2021-01-09T08:17:25Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTY1OQ==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479659", "createdAt": "2021-01-09T22:18:53Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ4NDAwOA==", "bodyText": "Hm, I am not sure, if it's needed for storing in DB? But I guess, there only the JSON-String is stored.\nOn testing on the emulator, I got some leaks-messages, which I have not seen before. I will switch to local master-branch, to check, whether they appear there as well or I have to take a closer look at this. Probably I will need your help then ...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554484008", "createdAt": "2021-01-09T23:07:54Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUyODMxNw==", "bodyText": "I can assure you that serialization is not needed for db store.\nWas this also in the classes before? (In case you moved them) I have the strong feeling it is not needed, but it also doesn't hurt.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554528317", "createdAt": "2021-01-10T08:00:12Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUzOTU2Mw==", "bodyText": "It was already in the class before move.\nI moved it then for VariableData as well.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554539563", "createdAt": "2021-01-10T09:34:30Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTEzOTA2OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoyMToyMVrOIQoWdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxMjoyNDoxN1rOIQu19A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTIzNg==", "bodyText": "I think \"getLabel\" and \"setAutoChar\" could be instance methods of class \"ButtonData\" instead of moving them into the enum. Or am I missing something?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309236", "createdAt": "2021-01-09T08:21:21Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {\n+\n+    /** The three states the button can be put into */\n+    public enum ValueType {\n+        INPUT_VAL {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.inputVal;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char nextChar) {\n+                buttonData.autoChar = nextChar;\n+                return nextChar;\n+            }\n+\n+        },\n+        AUTO_CHAR {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.autoChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar++;\n+                return nextChar;\n+            }\n+        },\n+        BLANK {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return ButtonData.BLANK;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                buttonData.autoChar = autoChar;\n+                return autoChar;\n+            }\n+        },\n+        CUSTOM {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.customChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar;\n+                if ('A' <= buttonData.customChar && buttonData.customChar <= 'Z') {\n+                    nextChar = buttonData.customChar;\n+                    nextChar++;\n+                }\n+\n+                return nextChar;\n+            }\n+        };\n+\n+        public abstract char getLabel(ButtonData buttonData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQxNTYwNA==", "bodyText": "I just moved the class out of the CalculatorDialog as whole.\nBut since there are different types of Buttons, (CustomInput, Blank, AutoChar and CustomChar) which leads to different behaviour, this is handled via the abstract methods getLabel and setAutoChar of the enum", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554415604", "createdAt": "2021-01-09T12:24:17Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {\n+\n+    /** The three states the button can be put into */\n+    public enum ValueType {\n+        INPUT_VAL {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.inputVal;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char nextChar) {\n+                buttonData.autoChar = nextChar;\n+                return nextChar;\n+            }\n+\n+        },\n+        AUTO_CHAR {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.autoChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar++;\n+                return nextChar;\n+            }\n+        },\n+        BLANK {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return ButtonData.BLANK;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                buttonData.autoChar = autoChar;\n+                return autoChar;\n+            }\n+        },\n+        CUSTOM {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.customChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar;\n+                if ('A' <= buttonData.customChar && buttonData.customChar <= 'Z') {\n+                    nextChar = buttonData.customChar;\n+                    nextChar++;\n+                }\n+\n+                return nextChar;\n+            }\n+        };\n+\n+        public abstract char getLabel(ButtonData buttonData);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTIzNg=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE0MDA5OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CalculationUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoyMzoxMlrOIQoW8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoyMzoxMlrOIQoW8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTM2MQ==", "bodyText": "+1 for making a separate package out of this! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309361", "createdAt": "2021-01-09T08:23:12Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CalculationUtils.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package cgeo.geocaching.utils;\n+package cgeo.geocaching.calculator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE0MjM4OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODoyNTozMFrOIQoX7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMjoxODoyM1rOIQyv9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ==", "bodyText": "Could org.apache.commons.lang3.CharUtils be used instead?\nIf not: can this be moved as method to an existing Utils class? Maybe TextUtils?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309615", "createdAt": "2021-01-09T08:25:30Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQxNzIzOQ==", "bodyText": "I just moved the class out of the CalculatorDialog as whole.\nBut I will have a look into the package if it fits the needs", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554417239", "createdAt": "2021-01-09T12:27:14Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTYwNA==", "bodyText": "Moved it as method to TextUtils", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479604", "createdAt": "2021-01-09T22:18:23Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE0NzUwOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/models/WaypointParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozMjowMVrOIQoaKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMFQxMTo1OTo1M1rOIQ3eWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDE4Nw==", "bodyText": "Kudos for extraction of the parsing methods into an own class! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310187", "createdAt": "2021-01-09T08:32:01Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/models/WaypointParser.java", "diffHunk": "@@ -0,0 +1,454 @@\n+package cgeo.geocaching.models;\n+\n+import cgeo.geocaching.calculator.CoordinatesCalculateUtils;\n+import cgeo.geocaching.calculator.FormulaParser;\n+import cgeo.geocaching.calculator.VariableData;\n+import cgeo.geocaching.enumerations.WaypointType;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.location.GeopointFormatter;\n+import cgeo.geocaching.location.GeopointParser;\n+import cgeo.geocaching.location.GeopointWrapper;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.TextUtils;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class WaypointParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1NzAxNg==", "bodyText": "As reminder for me:\ncheck, if there are more changes in parsing methods in master which has to be adapted to WaypointParser", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554557016", "createdAt": "2021-01-10T11:59:53Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/models/WaypointParser.java", "diffHunk": "@@ -0,0 +1,454 @@\n+package cgeo.geocaching.models;\n+\n+import cgeo.geocaching.calculator.CoordinatesCalculateUtils;\n+import cgeo.geocaching.calculator.FormulaParser;\n+import cgeo.geocaching.calculator.VariableData;\n+import cgeo.geocaching.enumerations.WaypointType;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.location.GeopointFormatter;\n+import cgeo.geocaching.location.GeopointParser;\n+import cgeo.geocaching.location.GeopointWrapper;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.TextUtils;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class WaypointParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDE4Nw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE0ODY0OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozMzoyOFrOIQoasA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMjoxNzo1OFrOIQyv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDMyMA==", "bodyText": "Use the constant here instead of hardcoded --", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310320", "createdAt": "2021-01-09T08:33:28Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package cgeo.geocaching.models;\n+\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class WaypointUserNoteCombiner {\n+\n+    private static final String SEPARATOR = \"\\n--\\n\";\n+    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + SEPARATOR + \"\\\\s*\");\n+\n+    private Waypoint waypoint;\n+\n+    /**\n+     *\n+     */\n+    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n+        this.waypoint = waypoint;\n+    }\n+\n+\n+    /**\n+     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n+     *\n+     * @return string with combined note\n+     */\n+    public final String getCombinedNoteAndUserNote() {\n+        final String userNote = this.waypoint.getUserNote();\n+        if (this.waypoint.isUserDefined()) {\n+            return userNote;\n+        } else {\n+            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n+            if (StringUtils.isNotEmpty(userNote)) {\n+                newNote.append(SEPARATOR);\n+                newNote.append(userNote);\n+            }\n+            return newNote.toString();\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     * For userDefined waypoints only userNote is set.\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    public void updateNoteAndUserNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String fixedCombinedNote = combinedNote;\n+            // \\n was removed via validate\n+            if (combinedNote.startsWith(\"--\\n\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTU3MA==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479570", "createdAt": "2021-01-09T22:17:58Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package cgeo.geocaching.models;\n+\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class WaypointUserNoteCombiner {\n+\n+    private static final String SEPARATOR = \"\\n--\\n\";\n+    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + SEPARATOR + \"\\\\s*\");\n+\n+    private Waypoint waypoint;\n+\n+    /**\n+     *\n+     */\n+    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n+        this.waypoint = waypoint;\n+    }\n+\n+\n+    /**\n+     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n+     *\n+     * @return string with combined note\n+     */\n+    public final String getCombinedNoteAndUserNote() {\n+        final String userNote = this.waypoint.getUserNote();\n+        if (this.waypoint.isUserDefined()) {\n+            return userNote;\n+        } else {\n+            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n+            if (StringUtils.isNotEmpty(userNote)) {\n+                newNote.append(SEPARATOR);\n+                newNote.append(userNote);\n+            }\n+            return newNote.toString();\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     * For userDefined waypoints only userNote is set.\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    public void updateNoteAndUserNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String fixedCombinedNote = combinedNote;\n+            // \\n was removed via validate\n+            if (combinedNote.startsWith(\"--\\n\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDMyMA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1MjI0OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/utils/TextUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozNzoxMFrOIQocSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMjoxNjo1N1rOIQyvlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDczMA==", "bodyText": "I am not sure I understand what this method is doing. Is there a Unit test for it?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310730", "createdAt": "2021-01-09T08:37:10Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/utils/TextUtils.java", "diffHunk": "@@ -420,6 +428,29 @@ public static String replaceAll(final String text, final String startToken, fina\n         return result;\n     }\n \n+    @NonNull\n+    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTUwOA==", "bodyText": "I remove it with String.split ;-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479508", "createdAt": "2021-01-09T22:16:57Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/utils/TextUtils.java", "diffHunk": "@@ -420,6 +428,29 @@ public static String replaceAll(final String text, final String startToken, fina\n         return result;\n     }\n \n+    @NonNull\n+    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDczMA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1NDQ2OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0MDoxOFrOIQodPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMjoxODozM1rOIQyv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDk3Mw==", "bodyText": "An example formula in the class javadoc would be great", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310973", "createdAt": "2021-01-09T08:40:18Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTYwOQ==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479609", "createdAt": "2021-01-09T22:18:33Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDk3Mw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1NTczOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0Mjo0MFrOIQod0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMDoyNToyM1rOIQyGRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTEyMA==", "bodyText": "Is MinDecFormulaParser the only subclass of AbstractLatLonFormulaParser? If yes, why do we need the subclass?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311120", "createdAt": "2021-01-09T08:42:40Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2ODkzNQ==", "bodyText": "No, there can / should be the others as well, but with your next comment, probably that will be done with reusing the other parser...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554468935", "createdAt": "2021-01-09T20:25:23Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTEyMA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1NzExOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0NDoxNlrOIQoebw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMjo0NjoyOFrOIVV7xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ==", "bodyText": "There should be coordinate parsers for many coordinates formats in some other class available (alas, they don't parse for variable values inside of course). Can't they be reused somehow (parametereized to accept also letters instead of numbers)?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311279", "createdAt": "2021-01-09T08:44:16Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2ODg0OA==", "bodyText": "Nice idea, didn't thougt about that. I will have a look into that...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554468848", "createdAt": "2021-01-09T20:24:37Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU0MDE2Mw==", "bodyText": "I looked into it and remembered that I thought about it, but the other parser returns a Point /Double, whereas I need a string. So I just used it to copy and modify.\nBut I will think, if probably it can be reused somehow else, or just extend the classes with methods returning a string, which then can be converted to double ...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554540163", "createdAt": "2021-01-10T09:39:09Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MDU1OQ==", "bodyText": "If its too complicated don't do it. I assume the formulas only work for MicDec-formatted coordinates anyway, do they?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554550559", "createdAt": "2021-01-10T11:05:54Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MTU1OA==", "bodyText": "You are probably right, for the other formats only letters will be accepted instead of digits, but no formula.\nFormulas there only can appear in the variables.\nBut even then it makes probably more sense to reuse some logic...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554551558", "createdAt": "2021-01-10T11:14:08Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI1MDM3NQ==", "bodyText": "Did not manage yet to extract the logic.\nI will keep the AbstractParser for the other coordinate-formats, if there will be also parsers for it later", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559250375", "createdAt": "2021-01-17T22:46:28Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1NzY0OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0NDo1OVrOIQoeqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQyMDo1OToyMVrOIc0cmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw==", "bodyText": "Is AbstractLatLonFormulaParser the only subclass of AbstractFormularParser? If yes, why do we need the subclass?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311337", "createdAt": "2021-01-09T08:44:59Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MjU0MQ==", "bodyText": "Probably yes,  but with your previous comment, probably that will be done with reusing the other parser...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554472541", "createdAt": "2021-01-09T21:02:31Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA5MDMyOA==", "bodyText": "Did not manage yet to bring to a common base-class or logic...\nIf I have some more time, I will probably give it another try...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r567090328", "createdAt": "2021-01-29T20:59:21Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE1ODE2OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0NTozN1rOIQoe4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMzoxMjoxMVrOIVWIUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA==", "bodyText": "I think this abstract class could be replaced by an interface?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311394", "createdAt": "2021-01-09T08:45:37Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MjU1OA==", "bodyText": "Probably yes, but with your previous comment, probably that will be done with reusing the other parser...", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554472558", "createdAt": "2021-01-09T21:02:48Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI1MzU4NA==", "bodyText": "changed to interface", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559253584", "createdAt": "2021-01-17T23:12:11Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2MDIzOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0ODoxMlrOIQofxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0ODoxMlrOIQofxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTYyMg==", "bodyText": "This methods performance would profit from \"list\" being a map (char -> VariableData).  Would that be an adequate data structure for a collection of VariableData's?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311622", "createdAt": "2021-01-09T08:48:12Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2MDg3OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0ODo1MlrOIQogDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMjo0MDozNFrOIVV41A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg==", "bodyText": "Isn't this the same as calling \"getVariable\" with \"remove=true\"?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311692", "createdAt": "2021-01-09T08:48:52Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MzcxMw==", "bodyText": "Seems so.\nI see 3 possibilities:\n\ncall getVariable(...false) in the method findAndRemoveData\nreplace the whole method findAndRemoveData with getVariable(...false)\nleave both methods and remove the parameter remove from getVariable and adapt all calls of getVariable(....true)  with findAndRemoveData\ncombination out of all having 3 functions:\n\n\nfindVariableData without boolean\nfindVariableDataAndRemove\nfindVariableData with boolean: the first two calls the third one\n\nI am not sure, which one I prefer, but variant 1 is the less preferred\nBTW isn't there any package in java which can handle that?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554473713", "createdAt": "2021-01-09T21:14:53Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MzkwMQ==", "bodyText": "With your next comment, probably variant 3 or 4 will be best", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554473901", "createdAt": "2021-01-09T21:16:22Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MDc5NA==", "bodyText": "I like 3 best :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554550794", "createdAt": "2021-01-10T11:07:31Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0OTYyMA==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559249620", "createdAt": "2021-01-17T22:40:34Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2MTQzOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo0OTo1OVrOIQogTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMjo0MDo1NFrOIVV5Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTc1OQ==", "bodyText": "This method modifies the content of parameter \"variables\", which should not be done. At least there should be a comment on the method telling which params will be modified.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311759", "createdAt": "2021-01-09T08:49:59Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0OTY3OA==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559249678", "createdAt": "2021-01-17T22:40:54Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTc1OQ=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2MTk5OnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1MTowMVrOIQogkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMjoxOTo0MlrOIQywSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTgyNA==", "bodyText": "I dont understand difference between \"variables\" and \"varBank\". Maybe a short comment would help?", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311824", "createdAt": "2021-01-09T08:51:01Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTY5MA==", "bodyText": "Done", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479690", "createdAt": "2021-01-09T22:19:42Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTgyNA=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2MjUxOnYy", "diffSide": "RIGHT", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1MTo1M1rOIQogyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQyMToyNzoxMFrOIQyd6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTg4Mw==", "bodyText": "If I understand the code correctly, then the value of \"variableNames\" could be extracted from list \"variables\". Is this correct? Then this parameter should be removed.", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311883", "createdAt": "2021-01-09T08:51:53Z", "author": {"login": "eddiemuc"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3NDk4Ng==", "bodyText": "I will rename the function and add description", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554474986", "createdAt": "2021-01-09T21:27:10Z", "author": {"login": "murggel"}, "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTg4Mw=="}, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4OTE2NDUwOnYy", "diffSide": "RIGHT", "path": "tests/src/cgeo/geocaching/calculator/FormulaParserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1NDozOVrOIQohuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODo1NDozOVrOIQohuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjEyMA==", "bodyText": "Kudos for writing unit tests! :-)", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554312120", "createdAt": "2021-01-09T08:54:39Z", "author": {"login": "eddiemuc"}, "path": "tests/src/cgeo/geocaching/calculator/FormulaParserTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.junit.Test;\n+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+\n+public class FormulaParserTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1730, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}