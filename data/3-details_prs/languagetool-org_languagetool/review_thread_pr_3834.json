{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4Njg5MDk1", "number": 3834, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDoxMzoxMFrOE3ZVOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo0NTo0N1rOE3aAGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTIyMTcwOnYy", "diffSide": "RIGHT", "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDoxMzoxMFrOHwt6lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo0NzowM1rOHwu_uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTk3Mg==", "bodyText": "This operator is not very common, could you add a comment?", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520845972", "createdAt": "2020-11-10T20:13:10Z", "author": {"login": "danielnaber"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1772,56 +1806,37 @@ public static void removeTemporaryFiles() {\n                     \", text length: \" + annotatedText.getPlainText().length());\n             //        \", text length: \" + annotatedText.getPlainText().length() + \", common word count: \" + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));\n           }\n-          charCount += sentence.length();\n-          lineCount += countLineBreaks(sentence);\n-\n-          // calculate matching column:\n-          int lineBreakPos = sentence.lastIndexOf('\\n');\n-          if (lineBreakPos == -1) {\n-            columnCount += sentence.length();\n-          } else {\n-            if (lineBreakPos == 0) {\n-              columnCount = sentence.length();\n-              if (!language.getSentenceTokenizer().singleLineBreaksMarksPara()) {\n-                columnCount--;\n-              }\n-            } else {\n-              columnCount = sentence.length() - lineBreakPos;\n-            }\n-          }\n         } catch (ErrorRateTooHighException e) {\n           throw e;\n         } catch (Exception e) {\n           throw new RuntimeException(\"Could not check sentence (language: \" + language + \"): <sentcontent>\"\n-                  + StringUtils.abbreviate(analyzedSentence.toTextString(), 500) + \"</sentcontent>\", e);\n+                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 500) + \"</sentcontent>\", e);\n         }\n       }\n       return ruleMatches;\n     }\n \n-    private LineColumnRange getLineColumnRange(RuleMatch match) {\n-      LineColumnPosition fromPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition toPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition pos = new LineColumnPosition(0, 0);\n-      int charCount = 0;\n-      for (AnalyzedSentence analyzedSentence : analyzedSentences) {\n-        for (AnalyzedTokenReadings readings : analyzedSentence.getTokens()) {\n-          String token = readings.getToken();\n-          if (\"\\n\".equals(token)) {\n-            pos.line++;\n-            pos.column = 0;\n-          }\n-          pos.column += token.length();\n-          charCount += token.length();\n-          if (charCount == match.getFromPos()) {\n-            fromPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-          if (charCount == match.getToPos()) {\n-            toPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-        }\n+    private LineColumnPosition findLineColumn(int offset) {\n+      if (sentences.isEmpty()) return new LineColumnPosition(0, 0);\n+\n+      SentenceData sentence = findSentenceContaining(offset);\n+      String prefix = sentence.text.substring(0, offset - sentence.startOffset);\n+      return new LineColumnPosition(\n+        sentence.startLine + countLineBreaks(prefix),\n+        processColumnChange(sentence.startColumn, prefix));\n+    }\n+\n+    private SentenceData findSentenceContaining(int offset) {\n+      int low = 0;\n+      int high = sentences.size() - 1;\n+      while (low <= high) {\n+        int mid = (low + high) >>> 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2MzY3Mw==", "bodyText": "It's inspired by JDK code, but indeed, this could be simplified. Will do!", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520863673", "createdAt": "2020-11-10T20:47:03Z", "author": {"login": "donnerpeter"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1772,56 +1806,37 @@ public static void removeTemporaryFiles() {\n                     \", text length: \" + annotatedText.getPlainText().length());\n             //        \", text length: \" + annotatedText.getPlainText().length() + \", common word count: \" + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));\n           }\n-          charCount += sentence.length();\n-          lineCount += countLineBreaks(sentence);\n-\n-          // calculate matching column:\n-          int lineBreakPos = sentence.lastIndexOf('\\n');\n-          if (lineBreakPos == -1) {\n-            columnCount += sentence.length();\n-          } else {\n-            if (lineBreakPos == 0) {\n-              columnCount = sentence.length();\n-              if (!language.getSentenceTokenizer().singleLineBreaksMarksPara()) {\n-                columnCount--;\n-              }\n-            } else {\n-              columnCount = sentence.length() - lineBreakPos;\n-            }\n-          }\n         } catch (ErrorRateTooHighException e) {\n           throw e;\n         } catch (Exception e) {\n           throw new RuntimeException(\"Could not check sentence (language: \" + language + \"): <sentcontent>\"\n-                  + StringUtils.abbreviate(analyzedSentence.toTextString(), 500) + \"</sentcontent>\", e);\n+                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 500) + \"</sentcontent>\", e);\n         }\n       }\n       return ruleMatches;\n     }\n \n-    private LineColumnRange getLineColumnRange(RuleMatch match) {\n-      LineColumnPosition fromPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition toPos = new LineColumnPosition(-1, -1);\n-      LineColumnPosition pos = new LineColumnPosition(0, 0);\n-      int charCount = 0;\n-      for (AnalyzedSentence analyzedSentence : analyzedSentences) {\n-        for (AnalyzedTokenReadings readings : analyzedSentence.getTokens()) {\n-          String token = readings.getToken();\n-          if (\"\\n\".equals(token)) {\n-            pos.line++;\n-            pos.column = 0;\n-          }\n-          pos.column += token.length();\n-          charCount += token.length();\n-          if (charCount == match.getFromPos()) {\n-            fromPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-          if (charCount == match.getToPos()) {\n-            toPos = new LineColumnPosition(pos.line, pos.column);\n-          }\n-        }\n+    private LineColumnPosition findLineColumn(int offset) {\n+      if (sentences.isEmpty()) return new LineColumnPosition(0, 0);\n+\n+      SentenceData sentence = findSentenceContaining(offset);\n+      String prefix = sentence.text.substring(0, offset - sentence.startOffset);\n+      return new LineColumnPosition(\n+        sentence.startLine + countLineBreaks(prefix),\n+        processColumnChange(sentence.startColumn, prefix));\n+    }\n+\n+    private SentenceData findSentenceContaining(int offset) {\n+      int low = 0;\n+      int high = sentences.size() - 1;\n+      while (low <= high) {\n+        int mid = (low + high) >>> 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTMzMTQ1OnYy", "diffSide": "RIGHT", "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo0NTo0N1rOHwu8_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNjoyNjo1MlrOHw_xHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg==", "bodyText": "Here's an inconsistency. Some clients expect column to be 0-based (as in javadoc) and some \u2014 1-based. From the history I've seen that the similar condition in the previous version of code was a hack to make some tests happy (since they're using deprecated API anyway), so I've decided to create an equivalent.", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520862972", "createdAt": "2020-11-10T20:45:47Z", "author": {"login": "donnerpeter"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDgzNQ==", "bodyText": "Line/column information is deprecated in LT, we don't show it anymore in the JSON response (our main use case), we just keep it running for the command-line LT.", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520870835", "createdAt": "2020-11-10T21:00:36Z", "author": {"login": "danielnaber"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Mjc0OA==", "bodyText": "Any plans to remove it?", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520872748", "createdAt": "2020-11-10T21:04:20Z", "author": {"login": "donnerpeter"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk5NQ==", "bodyText": "I'd prefer to have it removed, but I see the line number is useful when running LT on the command-line, so it would need to be calculated somewhere else (maybe not in JLanguageTool). But I have no plans to work on this.", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520875995", "createdAt": "2020-11-10T21:11:04Z", "author": {"login": "danielnaber"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg4ODIyMQ==", "bodyText": "Do you mean only org.languagetool.commandline.Main or anything else? If the former, I think this calculation could be moved there relatively easily, and JLanguageTool could become free of this logic, and maybe even faster.", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520888221", "createdAt": "2020-11-10T21:34:47Z", "author": {"login": "donnerpeter"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg5NDU0Mg==", "bodyText": "I haven't checked closely, but yes, org.languagetool.commandline.Main sounds like the logical place for this code.", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r520894542", "createdAt": "2020-11-10T21:47:07Z", "author": {"login": "danielnaber"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEzODQ2MQ==", "bodyText": "I can also see some column usages in XML serialization, Wikipedia and UI HTML. I don't know of their importance nowadays. But maybe I'll take a look at this some day :)", "url": "https://github.com/languagetool-org/languagetool/pull/3834#discussion_r521138461", "createdAt": "2020-11-11T06:26:52Z", "author": {"login": "donnerpeter"}, "path": "languagetool-core/src/main/java/org/languagetool/JLanguageTool.java", "diffHunk": "@@ -1703,14 +1743,10 @@ public static void removeTemporaryFiles() {\n             }\n             RuleMatch newMatch = new RuleMatch(match);\n             newMatch.setOffsetPosition(newFromPos, newToPos);\n-            newMatch.setLine(range.from.line);\n-            newMatch.setEndLine(range.to.line);\n-            if (match.getLine() == 0) {\n-              newMatch.setColumn(range.from.column + 1);\n-            } else {\n-              newMatch.setColumn(range.from.column);\n-            }\n-            newMatch.setEndColumn(range.to.column);\n+            newMatch.setLine(from.line);\n+            newMatch.setEndLine(to.line);\n+            newMatch.setColumn(from.column - (from.line == 0 ? 1 : 0));\n+            newMatch.setEndColumn(to.column - (to.line == 0 ? 1 : 0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2Mjk3Mg=="}, "originalCommit": {"oid": "54bafb357a62f3876d86657f67521e5c19251d91"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3712, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}