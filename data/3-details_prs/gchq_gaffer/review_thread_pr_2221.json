{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwOTg0MDQz", "number": 2221, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTowNTozNVrODW4cjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo1OToyMFrODXgwRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MzIwMDc3OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTowNTozNVrOFb46rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTowNTozNVrOFb46rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc4ODM5Ng==", "bodyText": "Isn't clear from the comment that it's also possible to whitelist", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r364788396", "createdAt": "2020-01-09T15:05:35Z", "author": {"login": "ss130257"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MzM1OTU4OnYy", "diffSide": "RIGHT", "path": "core/graph/src/test/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTo0NzowOFrOFb6cJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTo0NzowOFrOFb6cJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDgxMzM1MQ==", "bodyText": "I don't think you tested a function being allowed when it IS in the whitelist", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r364813351", "createdAt": "2020-01-09T15:47:08Z", "author": {"login": "ss130257"}, "path": "core/graph/src/test/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriserTest.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MzM4OTU0OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTo1NToyMFrOFb6vAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNTo1NToyMFrOFb6vAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDgxODE3Ng==", "bodyText": "Should you add authorisedFunctionPatterns here as well?", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r364818176", "createdAt": "2020-01-09T15:55:20Z", "author": {"login": "ss130257"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MzUzNjQ1OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxNjozNjo1NVrOFb8KLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNDoyMTowMFrOFc4ZGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg0MTUxOA==", "bodyText": "Matching of the \"class\":\" string feels a bit fragile to me. You may want to consider creating a TreeModel from the Json string and traversing the tree of JsonNode objects checking for \"class\" fields.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r364841518", "createdAt": "2020-01-09T16:36:55Z", "author": {"login": "ss130257"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();\n+    private List<Pattern> unauthorisedFunctionPatterns = new ArrayList<>();\n+\n+    public FunctionAuthoriser() {\n+    }\n+\n+    public FunctionAuthoriser(final List<Class<? extends Function>> unauthorisedFunctions, final List<Pattern> unauthorisedFunctionPatterns, final List<Pattern> authorisedFunctionPatterns) {\n+        this.setUnauthorisedFunctions(unauthorisedFunctions);\n+        this.setAuthorisedFunctionPatterns(authorisedFunctionPatterns);\n+        this.setUnauthorisedFunctionPatterns(unauthorisedFunctionPatterns);\n+    }\n+\n+    @Override\n+    public void preExecute(final OperationChain<?> opChain, final Context context) {\n+        String chainString;\n+        try {\n+            chainString = new String(JSONSerialiser.serialise(opChain));\n+        } catch (final SerialisationException e) {\n+            // This should never happen in real life as operation chains should\n+            // always be json serialisable. However this could happen if using a\n+            // mock in testing. To account for this, it will be logged.\n+            LOGGER.warn(\"Failed to serialise operation chain: \" + opChain);\n+            return;\n+        }\n+\n+        if (unauthorisedFunctions != null) {\n+            checkNoBlacklistedFunctionsArePresent(chainString);\n+        }\n+        if (authorisedFunctionPatterns != null || unauthorisedFunctionPatterns != null) {\n+            checkAllFunctionsUsedAppearInPatterns(chainString);\n+        }\n+    }\n+\n+    private List<Predicate> convertPatternsToPredicates(final List<Pattern> patterns) {\n+        return patterns.stream()\n+                .map(Pattern::asPredicate)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void checkAllFunctionsUsedAppearInPatterns(final String chainString) {\n+        boolean noWhitelistPatterns = (authorisedFunctionPatterns == null || authorisedFunctionPatterns.isEmpty());\n+        boolean noBlacklistPatterns = (unauthorisedFunctionPatterns == null || unauthorisedFunctionPatterns.isEmpty());\n+\n+        Predicate<String> isAuthorised = createAuthorisationFunction(noBlacklistPatterns, noWhitelistPatterns);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4ODk3MA==", "bodyText": "Rather than going to String then to JsonNode, you might be able to use the valueToTree method on ObjectMapper. Just had a quick look at it and it should work. You would need to expose this in the Gaffer JSONSerialiser class.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365788970", "createdAt": "2020-01-13T12:56:48Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();\n+    private List<Pattern> unauthorisedFunctionPatterns = new ArrayList<>();\n+\n+    public FunctionAuthoriser() {\n+    }\n+\n+    public FunctionAuthoriser(final List<Class<? extends Function>> unauthorisedFunctions, final List<Pattern> unauthorisedFunctionPatterns, final List<Pattern> authorisedFunctionPatterns) {\n+        this.setUnauthorisedFunctions(unauthorisedFunctions);\n+        this.setAuthorisedFunctionPatterns(authorisedFunctionPatterns);\n+        this.setUnauthorisedFunctionPatterns(unauthorisedFunctionPatterns);\n+    }\n+\n+    @Override\n+    public void preExecute(final OperationChain<?> opChain, final Context context) {\n+        String chainString;\n+        try {\n+            chainString = new String(JSONSerialiser.serialise(opChain));\n+        } catch (final SerialisationException e) {\n+            // This should never happen in real life as operation chains should\n+            // always be json serialisable. However this could happen if using a\n+            // mock in testing. To account for this, it will be logged.\n+            LOGGER.warn(\"Failed to serialise operation chain: \" + opChain);\n+            return;\n+        }\n+\n+        if (unauthorisedFunctions != null) {\n+            checkNoBlacklistedFunctionsArePresent(chainString);\n+        }\n+        if (authorisedFunctionPatterns != null || unauthorisedFunctionPatterns != null) {\n+            checkAllFunctionsUsedAppearInPatterns(chainString);\n+        }\n+    }\n+\n+    private List<Predicate> convertPatternsToPredicates(final List<Pattern> patterns) {\n+        return patterns.stream()\n+                .map(Pattern::asPredicate)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void checkAllFunctionsUsedAppearInPatterns(final String chainString) {\n+        boolean noWhitelistPatterns = (authorisedFunctionPatterns == null || authorisedFunctionPatterns.isEmpty());\n+        boolean noBlacklistPatterns = (unauthorisedFunctionPatterns == null || unauthorisedFunctionPatterns.isEmpty());\n+\n+        Predicate<String> isAuthorised = createAuthorisationFunction(noBlacklistPatterns, noWhitelistPatterns);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg0MTUxOA=="}, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwMzY3OA==", "bodyText": "Would this get around the issue of being reliant on things being serialised as \"class\" fields?", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365803678", "createdAt": "2020-01-13T13:30:43Z", "author": {"login": "d47853"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();\n+    private List<Pattern> unauthorisedFunctionPatterns = new ArrayList<>();\n+\n+    public FunctionAuthoriser() {\n+    }\n+\n+    public FunctionAuthoriser(final List<Class<? extends Function>> unauthorisedFunctions, final List<Pattern> unauthorisedFunctionPatterns, final List<Pattern> authorisedFunctionPatterns) {\n+        this.setUnauthorisedFunctions(unauthorisedFunctions);\n+        this.setAuthorisedFunctionPatterns(authorisedFunctionPatterns);\n+        this.setUnauthorisedFunctionPatterns(unauthorisedFunctionPatterns);\n+    }\n+\n+    @Override\n+    public void preExecute(final OperationChain<?> opChain, final Context context) {\n+        String chainString;\n+        try {\n+            chainString = new String(JSONSerialiser.serialise(opChain));\n+        } catch (final SerialisationException e) {\n+            // This should never happen in real life as operation chains should\n+            // always be json serialisable. However this could happen if using a\n+            // mock in testing. To account for this, it will be logged.\n+            LOGGER.warn(\"Failed to serialise operation chain: \" + opChain);\n+            return;\n+        }\n+\n+        if (unauthorisedFunctions != null) {\n+            checkNoBlacklistedFunctionsArePresent(chainString);\n+        }\n+        if (authorisedFunctionPatterns != null || unauthorisedFunctionPatterns != null) {\n+            checkAllFunctionsUsedAppearInPatterns(chainString);\n+        }\n+    }\n+\n+    private List<Predicate> convertPatternsToPredicates(final List<Pattern> patterns) {\n+        return patterns.stream()\n+                .map(Pattern::asPredicate)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void checkAllFunctionsUsedAppearInPatterns(final String chainString) {\n+        boolean noWhitelistPatterns = (authorisedFunctionPatterns == null || authorisedFunctionPatterns.isEmpty());\n+        boolean noBlacklistPatterns = (unauthorisedFunctionPatterns == null || unauthorisedFunctionPatterns.isEmpty());\n+\n+        Predicate<String> isAuthorised = createAuthorisationFunction(noBlacklistPatterns, noWhitelistPatterns);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg0MTUxOA=="}, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyODM3Nw==", "bodyText": "From what I can tell, this would only provide a small performance benefit if you don't make use of the more efficient blacklisting capability (Since the blacklisting capability requires it to be a string anyway).", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365828377", "createdAt": "2020-01-13T14:21:00Z", "author": {"login": "d47853"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes, or a list of patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();\n+    private List<Pattern> unauthorisedFunctionPatterns = new ArrayList<>();\n+\n+    public FunctionAuthoriser() {\n+    }\n+\n+    public FunctionAuthoriser(final List<Class<? extends Function>> unauthorisedFunctions, final List<Pattern> unauthorisedFunctionPatterns, final List<Pattern> authorisedFunctionPatterns) {\n+        this.setUnauthorisedFunctions(unauthorisedFunctions);\n+        this.setAuthorisedFunctionPatterns(authorisedFunctionPatterns);\n+        this.setUnauthorisedFunctionPatterns(unauthorisedFunctionPatterns);\n+    }\n+\n+    @Override\n+    public void preExecute(final OperationChain<?> opChain, final Context context) {\n+        String chainString;\n+        try {\n+            chainString = new String(JSONSerialiser.serialise(opChain));\n+        } catch (final SerialisationException e) {\n+            // This should never happen in real life as operation chains should\n+            // always be json serialisable. However this could happen if using a\n+            // mock in testing. To account for this, it will be logged.\n+            LOGGER.warn(\"Failed to serialise operation chain: \" + opChain);\n+            return;\n+        }\n+\n+        if (unauthorisedFunctions != null) {\n+            checkNoBlacklistedFunctionsArePresent(chainString);\n+        }\n+        if (authorisedFunctionPatterns != null || unauthorisedFunctionPatterns != null) {\n+            checkAllFunctionsUsedAppearInPatterns(chainString);\n+        }\n+    }\n+\n+    private List<Predicate> convertPatternsToPredicates(final List<Pattern> patterns) {\n+        return patterns.stream()\n+                .map(Pattern::asPredicate)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void checkAllFunctionsUsedAppearInPatterns(final String chainString) {\n+        boolean noWhitelistPatterns = (authorisedFunctionPatterns == null || authorisedFunctionPatterns.isEmpty());\n+        boolean noBlacklistPatterns = (unauthorisedFunctionPatterns == null || unauthorisedFunctionPatterns.isEmpty());\n+\n+        Predicate<String> isAuthorised = createAuthorisationFunction(noBlacklistPatterns, noWhitelistPatterns);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg0MTUxOA=="}, "originalCommit": {"oid": "5153aa8818f28db22c114380de8ce2d28cc0243b"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTc1NzI2OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/Graph.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0MjowOFrOFc1okQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0MjowOFrOFc1okQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4MzE4NQ==", "bodyText": "Perhaps create a default black list and store that in another class, otherwise this list here could get rather big and messy.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365783185", "createdAt": "2020-01-13T12:42:08Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/Graph.java", "diffHunk": "@@ -995,6 +1000,11 @@ private void updateGraphHooks(final GraphConfig config) {\n                     config.getHooks().add(0, new NamedOperationResolver());\n                 }\n             }\n+            if (!hasFunctionAuthoriserHook && !config.isSkipDefaultSecurityHooks()) {\n+                config.getHooks().add(new FunctionAuthoriser.Builder()\n+                        .unauthorisedFunctions(Lists.newArrayList(CreateObject.class))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTc2NDg4OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/GraphConfig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0NToxNFrOFc1s_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMDowNzozNlrOFdSFow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NDMxOA==", "bodyText": "I'm not sure about this.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365784318", "createdAt": "2020-01-13T12:45:14Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/GraphConfig.java", "diffHunk": "@@ -64,6 +65,9 @@\n     private String description;\n     private List<GraphHook> hooks = new ArrayList<>();\n \n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    private boolean skipDefaultSecurityHooks = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5NzE2OQ==", "bodyText": "This makes sure that any existing graph config which doesn't have the field set will have the value set to false. Is there something I overlooked?", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365797169", "createdAt": "2020-01-13T13:16:02Z", "author": {"login": "d47853"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/GraphConfig.java", "diffHunk": "@@ -64,6 +65,9 @@\n     private String description;\n     private List<GraphHook> hooks = new ArrayList<>();\n \n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    private boolean skipDefaultSecurityHooks = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NDMxOA=="}, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI0OTM3OQ==", "bodyText": "I am just not sure whether having a boolean to toggle security hooks on/off is the best way of doing it. Although I can't quickly think of a better way. For example, OperationAuthoriser and OperationChainLimiter are also security related hooks.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r366249379", "createdAt": "2020-01-14T10:07:36Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/GraphConfig.java", "diffHunk": "@@ -64,6 +65,9 @@\n     private String description;\n     private List<GraphHook> hooks = new ArrayList<>();\n \n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+    private boolean skipDefaultSecurityHooks = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NDMxOA=="}, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTc3MTA5OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/Graph.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0NzozN1rOFc1wfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0NzozN1rOFc1wfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NTIxMw==", "bodyText": "If we are adding this FunctionAuthoriser by default for every Gaffer system, we should make sure it is efficient and doesn't error.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365785213", "createdAt": "2020-01-13T12:47:37Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/Graph.java", "diffHunk": "@@ -995,6 +1000,11 @@ private void updateGraphHooks(final GraphConfig config) {\n                     config.getHooks().add(0, new NamedOperationResolver());\n                 }\n             }\n+            if (!hasFunctionAuthoriserHook && !config.isSkipDefaultSecurityHooks()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTc3Njc1OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo0OTozNlrOFc1zsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMzoyMTo0OVrOFc2orA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NjAzNA==", "bodyText": "Just wondering if it might be simpler to just call these white and black lists? As you refer to white and black lists in other parts of the code.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365786034", "createdAt": "2020-01-13T12:49:36Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes or patterns, or a list of authorised\n+ * patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\", \"authorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5OTU5Ng==", "bodyText": "I agree it's probably better to be consistent, although when creating this in JSON, it makes it more understandable in my opinion - especially given that there are two blacklists.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365799596", "createdAt": "2020-01-13T13:21:49Z", "author": {"login": "d47853"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes or patterns, or a list of authorised\n+ * patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\", \"authorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NjAzNA=="}, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTgwNDg1OnYy", "diffSide": "RIGHT", "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo1OToyMFrOFc2Djw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo1OToyMFrOFc2Djw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5MDA5NQ==", "bodyText": "The downside of using this mechanism, is you are assuming that all Functions will be serialised with a 'class' field. They should be, but if they are wrapped in some custom object and the JsonSubType annotation changes it, then it could be serialised differently.", "url": "https://github.com/gchq/Gaffer/pull/2221#discussion_r365790095", "createdAt": "2020-01-13T12:59:20Z", "author": {"login": "p013570"}, "path": "core/graph/src/main/java/uk/gov/gchq/gaffer/graph/hook/FunctionAuthoriser.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2019 Crown Copyright\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package uk.gov.gchq.gaffer.graph.hook;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import uk.gov.gchq.gaffer.commonutil.exception.UnauthorisedException;\n+import uk.gov.gchq.gaffer.exception.SerialisationException;\n+import uk.gov.gchq.gaffer.jsonserialisation.JSONSerialiser;\n+import uk.gov.gchq.gaffer.operation.OperationChain;\n+import uk.gov.gchq.gaffer.store.Context;\n+import uk.gov.gchq.koryphe.impl.predicate.And;\n+import uk.gov.gchq.koryphe.impl.predicate.Not;\n+import uk.gov.gchq.koryphe.impl.predicate.Or;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The FunctionAuthoriser is a {@link GraphHook} which stops a user running\n+ * Functions which have been banned. The Authoriser can be configured with a\n+ * list of unauthorised function classes or patterns, or a list of authorised\n+ * patterns to check against.\n+ * <p>\n+ * It should be noted that using the unauthorisedFunctions list will be more\n+ * efficient than using any of the patterns.\n+ */\n+@JsonPropertyOrder(value = {\"unauthorisedFunctions\", \"unauthorisedFunctionPatterns\", \"authorisedFunctionPatterns\"})\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n+public class FunctionAuthoriser implements GraphHook {\n+\n+    private static final String ERROR_MESSAGE_PREFIX = \"Operation chain contained an unauthorised function: \";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FunctionAuthoriser.class);\n+    private List<Class<? extends Function>> unauthorisedFunctions = new ArrayList<>();\n+    private List<Pattern> authorisedFunctionPatterns = new ArrayList<>();\n+    private List<Pattern> unauthorisedFunctionPatterns = new ArrayList<>();\n+\n+    public FunctionAuthoriser() {\n+    }\n+\n+    public FunctionAuthoriser(final List<Class<? extends Function>> unauthorisedFunctions, final List<Pattern> unauthorisedFunctionPatterns, final List<Pattern> authorisedFunctionPatterns) {\n+        this.setUnauthorisedFunctions(unauthorisedFunctions);\n+        this.setAuthorisedFunctionPatterns(authorisedFunctionPatterns);\n+        this.setUnauthorisedFunctionPatterns(unauthorisedFunctionPatterns);\n+    }\n+\n+    @Override\n+    public void preExecute(final OperationChain<?> opChain, final Context context) {\n+        String chainString;\n+        try {\n+            chainString = new String(JSONSerialiser.serialise(opChain));\n+        } catch (final SerialisationException e) {\n+            // This should never happen in real life as operation chains should\n+            // always be json serialisable. However this could happen if using a\n+            // mock in testing. To account for this, it will be logged.\n+            LOGGER.warn(\"Failed to serialise operation chain: \" + opChain);\n+            return;\n+        }\n+\n+        if (unauthorisedFunctions != null) {\n+            checkNoBlacklistedFunctionsArePresent(chainString);\n+        }\n+        if (authorisedFunctionPatterns != null || unauthorisedFunctionPatterns != null) {\n+            checkAllFunctionsUsedAppearInCorrectPatterns(chainString);\n+        }\n+    }\n+\n+    private List<Predicate> convertPatternsToPredicates(final List<Pattern> patterns) {\n+        return patterns.stream()\n+                .map(Pattern::asPredicate)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void checkAllFunctionsUsedAppearInCorrectPatterns(final String chainString) {\n+        boolean noWhitelistPatterns = (authorisedFunctionPatterns == null || authorisedFunctionPatterns.isEmpty());\n+        boolean noBlacklistPatterns = (unauthorisedFunctionPatterns == null || unauthorisedFunctionPatterns.isEmpty());\n+\n+        Predicate<String> isAuthorised = createAuthorisationFunction(noBlacklistPatterns, noWhitelistPatterns);\n+\n+        final JsonNode node;\n+        try {\n+            node = JSONSerialiser.getJsonNodeFromString(chainString);\n+        } catch (final SerialisationException e) {\n+            // This should never happen as the string is derived from a\n+            // serialised object. Therefore throw an exception here.\n+            throw new RuntimeException(\"Failed to convert serialised operation\" +\n+                    \" chain into a JsonNode\", e);\n+        }\n+\n+        List<String> classNames = node.findValuesAsText(\"class\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f612e13fa031934dcc13b1691affd1724cecd36"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4322, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}