{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzYzODI3", "number": 695, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0NzowM1rOEleuNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1NTowNVrOElextQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzM2MTE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0NzowM1rOHU-2EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1MTozNVrOHU-4tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzIxNw==", "bodyText": "Shouldn't it be !runtimeCache.shouldValidateReturnedValue?", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763217", "createdAt": "2020-09-21T01:47:03Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2Mzg5NQ==", "bodyText": "Oh nevermind, there is no method in this call", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763895", "createdAt": "2020-09-21T01:51:35Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzIxNw=="}, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzM2MjUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0ODoxMlrOHU-2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwNTozMzowMVrOHVBITA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzM4Nw==", "bodyText": "Probably call to runtime.shouldValidateBean is needed", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763387", "createdAt": "2020-09-21T01:48:12Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDY1Mg==", "bodyText": "think this call is always protected by a public call before which already have the exit condition - at least was the intent", "url": "https://github.com/apache/cxf/pull/695#discussion_r491800652", "createdAt": "2020-09-21T05:33:01Z", "author": {"login": "rmannibucau"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzM4Nw=="}, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzM3MDEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1NTowNVrOHU-6vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1NTowNVrOHU-6vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2NDQxMw==", "bodyText": "Should you also check for isBeanConstrained and cache that?", "url": "https://github.com/apache/cxf/pull/695#discussion_r491764413", "createdAt": "2020-09-21T01:55:05Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {\n+            return validator.validate(bean);\n+        }\n+        return emptySet();\n+    }\n+\n+    @Override\n+    public void close() {\n+        close.run();\n     }\n \n-    private ExecutableValidator getExecutableValidator() {\n+    // only created when there is a single validator/factory so it is safe to cache\n+    // note: the validator is passed as param to avoid to create useless ones\n+    private static class RuntimeCache {\n+        private final ConcurrentMap<Class<?>, Boolean> types = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> params = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> returnedValues = new ConcurrentHashMap<>();\n+\n+        public boolean shouldValidateParameters(final Validator validator, final Method method) {\n+            return params.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), m.getParameterTypes())\n+                    .hasConstrainedParameters());\n+        }\n \n-        return factory.getValidator().forExecutables();\n+        public boolean shouldValidateReturnedValue(final Validator validator, final Method method) {\n+            return returnedValues.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), method.getParameterTypes())\n+                    .hasConstrainedReturnValue());\n+        }\n+\n+        public boolean shouldValidateBean(final Validator validator, final Class<?> clazz) {\n+            return types.computeIfAbsent(clazz, it -> validator.getConstraintsForClass(it).hasConstraints());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 189}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3606, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}