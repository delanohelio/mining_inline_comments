{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzYzODI3", "number": 695, "title": "Enable to pass a bval Validator to BeanValidationProvider (it is more\u2026", "bodyText": "\u2026 than enough and faster than creating validators again and again) + enable to cache the fact no validation is needed", "createdAt": "2020-09-18T14:46:13Z", "url": "https://github.com/apache/cxf/pull/695", "merged": true, "mergeCommit": {"oid": "57f88470951d981eccbe1f427cbe0398438f706d"}, "closed": true, "closedAt": "2020-10-21T12:50:45Z", "author": {"login": "rmannibucau"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKGtncAH2gAyNDg5MzYzODI3OmVlNjdiYmQwYWU3ZWIxNzYwMmQ4NzllYmQyZjk5OTM1YTE3NjQ3MDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLIlb8AFqTQ5MjkxNzY1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705", "author": {"user": {"login": "rmannibucau", "name": "Romain Manni-Bucau"}}, "url": "https://github.com/apache/cxf/commit/ee67bbd0ae7eb17602d879ebd2f99935a1764705", "committedDate": "2020-09-18T14:45:44Z", "message": "Enable to pass a bval Validator to BeanValidationProvider (it is more than enough and faster than creating validators again and again) + enable to cache the fact no validation is needed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjQ2Njk4", "url": "https://github.com/apache/cxf/pull/695#pullrequestreview-492246698", "createdAt": "2020-09-21T01:47:03Z", "commit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0NzowM1rOHU-2EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0NzowM1rOHU-2EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzIxNw==", "bodyText": "Shouldn't it be !runtimeCache.shouldValidateReturnedValue?", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763217", "createdAt": "2020-09-21T01:47:03Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjQ2ODU4", "url": "https://github.com/apache/cxf/pull/695#pullrequestreview-492246858", "createdAt": "2020-09-21T01:48:12Z", "commit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0ODoxMlrOHU-2uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo0ODoxMlrOHU-2uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzM4Nw==", "bodyText": "Probably call to runtime.shouldValidateBean is needed", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763387", "createdAt": "2020-09-21T01:48:12Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjQ3ODc5", "url": "https://github.com/apache/cxf/pull/695#pullrequestreview-492247879", "createdAt": "2020-09-21T01:55:05Z", "commit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1NTowNVrOHU-6vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMTo1NTowNVrOHU-6vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2NDQxMw==", "bodyText": "Should you also check for isBeanConstrained and cache that?", "url": "https://github.com/apache/cxf/pull/695#discussion_r491764413", "createdAt": "2020-09-21T01:55:05Z", "author": {"login": "reta"}, "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {\n+            return validator.validate(bean);\n+        }\n+        return emptySet();\n+    }\n+\n+    @Override\n+    public void close() {\n+        close.run();\n     }\n \n-    private ExecutableValidator getExecutableValidator() {\n+    // only created when there is a single validator/factory so it is safe to cache\n+    // note: the validator is passed as param to avoid to create useless ones\n+    private static class RuntimeCache {\n+        private final ConcurrentMap<Class<?>, Boolean> types = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> params = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> returnedValues = new ConcurrentHashMap<>();\n+\n+        public boolean shouldValidateParameters(final Validator validator, final Method method) {\n+            return params.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), m.getParameterTypes())\n+                    .hasConstrainedParameters());\n+        }\n \n-        return factory.getValidator().forExecutables();\n+        public boolean shouldValidateReturnedValue(final Validator validator, final Method method) {\n+            return returnedValues.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), method.getParameterTypes())\n+                    .hasConstrainedReturnValue());\n+        }\n+\n+        public boolean shouldValidateBean(final Validator validator, final Class<?> clazz) {\n+            return types.computeIfAbsent(clazz, it -> validator.getConstraintsForClass(it).hasConstraints());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef93d642bd52a5e8e6e0e4147a0296fd8eb8bb88", "author": {"user": {"login": "rmannibucau", "name": "Romain Manni-Bucau"}}, "url": "https://github.com/apache/cxf/commit/ef93d642bd52a5e8e6e0e4147a0296fd8eb8bb88", "committedDate": "2020-09-21T05:35:56Z", "message": "shouldValidateBean must call isBeanConstrained and not hasConstraints, thanks @reta"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE3NjU5", "url": "https://github.com/apache/cxf/pull/695#pullrequestreview-492917659", "createdAt": "2020-09-21T19:30:32Z", "commit": {"oid": "ef93d642bd52a5e8e6e0e4147a0296fd8eb8bb88"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2125, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}