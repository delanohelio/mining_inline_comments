{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MTU5MDYz", "number": 3877, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MDoxN1rOFFJJuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MToxN1rOFFJMiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTM3MTQ3OnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/service/NetworkRoundTripDecisionMakerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MDoxN1rOIFgAnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MDoxN1rOIFgAnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzODIzNg==", "bodyText": "typo", "url": "https://github.com/telstra/open-kilda/pull/3877#discussion_r542638236", "createdAt": "2020-12-14T18:50:17Z", "author": {"login": "nikitamarchenko"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/service/NetworkRoundTripDecisionMakerService.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.service;\n+\n+import org.openkilda.wfm.share.model.Endpoint;\n+\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+@Slf4j\n+public class NetworkRoundTripDecisionMakerService {\n+    private final Clock clock;\n+\n+    private final IDecisionMakerCarrier carrier;\n+    private final Duration expireDelay;\n+\n+    private final Map<Endpoint, Entry> entries = new HashMap<>();\n+    private final SortedMap<Instant, Set<Endpoint>> timeouts = new TreeMap<>();\n+\n+    public NetworkRoundTripDecisionMakerService(IDecisionMakerCarrier carrier, Duration expireDelay) {\n+        this(Clock.systemUTC(), carrier, expireDelay);\n+    }\n+\n+    public NetworkRoundTripDecisionMakerService(Clock clock, IDecisionMakerCarrier carrier, Duration expireDelay) {\n+        this.clock = clock;\n+\n+        this.carrier = carrier;\n+        this.expireDelay = expireDelay;\n+    }\n+\n+    /**\n+     * Register/update round trip tracking data for specific endpoint.\n+     */\n+    public void discovered(Endpoint endpoint, long packetId) {\n+        Entry entry = entries.get(endpoint);\n+        if (entry != null && packetId < entry.getLastSeenPacketId()) {\n+            log.debug(\"Ignore staled round trip discovery on {} (packet_id: {})\", endpoint, packetId);\n+            return;\n+        }\n+\n+        Instant expireAt = clock.instant().plus(expireDelay);\n+        entries.put(endpoint, new Entry(packetId, expireAt));\n+        timeouts.computeIfAbsent(expireAt, key -> new HashSet<>()).add(endpoint);\n+\n+        if (entry == null) {\n+            log.info(\"Register round trip status entry for {}\", endpoint);\n+        }\n+\n+        // Emits each registered round trip event. Some ISLs monitor can ignore some round trip ACTIVATE events as part\n+        // of race conditions prevention fight.\n+        carrier.linkRoundTripActive(endpoint);\n+    }\n+\n+    /**\n+     * Remove tracking fro specific endpoint.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd09a649a0313c4bf68c47baa6c0b8b5bc9b8cd2"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTM3ODY1OnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/service/NetworkRoundTripDecisionMakerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MToxN1rOIFgFBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MToxN1rOIFgFBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzOTM2NQ==", "bodyText": "typo", "url": "https://github.com/telstra/open-kilda/pull/3877#discussion_r542639365", "createdAt": "2020-12-14T18:51:17Z", "author": {"login": "nikitamarchenko"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/service/NetworkRoundTripDecisionMakerService.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.service;\n+\n+import org.openkilda.wfm.share.model.Endpoint;\n+\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+@Slf4j\n+public class NetworkRoundTripDecisionMakerService {\n+    private final Clock clock;\n+\n+    private final IDecisionMakerCarrier carrier;\n+    private final Duration expireDelay;\n+\n+    private final Map<Endpoint, Entry> entries = new HashMap<>();\n+    private final SortedMap<Instant, Set<Endpoint>> timeouts = new TreeMap<>();\n+\n+    public NetworkRoundTripDecisionMakerService(IDecisionMakerCarrier carrier, Duration expireDelay) {\n+        this(Clock.systemUTC(), carrier, expireDelay);\n+    }\n+\n+    public NetworkRoundTripDecisionMakerService(Clock clock, IDecisionMakerCarrier carrier, Duration expireDelay) {\n+        this.clock = clock;\n+\n+        this.carrier = carrier;\n+        this.expireDelay = expireDelay;\n+    }\n+\n+    /**\n+     * Register/update round trip tracking data for specific endpoint.\n+     */\n+    public void discovered(Endpoint endpoint, long packetId) {\n+        Entry entry = entries.get(endpoint);\n+        if (entry != null && packetId < entry.getLastSeenPacketId()) {\n+            log.debug(\"Ignore staled round trip discovery on {} (packet_id: {})\", endpoint, packetId);\n+            return;\n+        }\n+\n+        Instant expireAt = clock.instant().plus(expireDelay);\n+        entries.put(endpoint, new Entry(packetId, expireAt));\n+        timeouts.computeIfAbsent(expireAt, key -> new HashSet<>()).add(endpoint);\n+\n+        if (entry == null) {\n+            log.info(\"Register round trip status entry for {}\", endpoint);\n+        }\n+\n+        // Emits each registered round trip event. Some ISLs monitor can ignore some round trip ACTIVATE events as part\n+        // of race conditions prevention fight.\n+        carrier.linkRoundTripActive(endpoint);\n+    }\n+\n+    /**\n+     * Remove tracking fro specific endpoint.\n+     */\n+    public void clear(Endpoint endpoint) {\n+        if (entries.remove(endpoint) != null) {\n+            log.info(\"Remove round trip status entry for {}\", endpoint);\n+        }\n+    }\n+\n+    /**\n+     * Process time tick - locate expired entries and amit round trip INACTIVE events for them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd09a649a0313c4bf68c47baa6c0b8b5bc9b8cd2"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2325, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}