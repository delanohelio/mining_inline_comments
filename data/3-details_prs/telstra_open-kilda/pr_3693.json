{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMDM1NzQ4", "number": 3693, "title": "Add an operations queue to the Reroute topology.", "bodyText": "Closes: #3140\ncloses #3703", "createdAt": "2020-08-25T08:34:11Z", "url": "https://github.com/telstra/open-kilda/pull/3693", "merged": true, "mergeCommit": {"oid": "a6d756f3b35f06a9d37299557eff74d65ac037d6"}, "closed": true, "closedAt": "2020-10-19T17:07:27Z", "author": {"login": "dpoltavets"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdELzESABqjM3MDgyMDkxOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdT9JWUgBqjM4OTEzMzY2NzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2943cc8560dc4502b41f6cb6850343c1fc338773", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/2943cc8560dc4502b41f6cb6850343c1fc338773", "committedDate": "2020-08-25T08:30:47Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "committedDate": "2020-08-31T05:16:48Z", "message": "Added an operations queue to the Reroute topology."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NTkxNDI1", "url": "https://github.com/telstra/open-kilda/pull/3693#pullrequestreview-478591425", "createdAt": "2020-08-31T12:59:48Z", "commit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1OTo0OFrOHJ3xlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzoyNTowNFrOHKBuiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExMzA0NQ==", "bodyText": "Remove extra space before dot.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480113045", "createdAt": "2020-08-31T12:59:48Z", "author": {"login": "rozdy"}, "path": "docs/design/hub-and-spoke/reroute/retry/README.md", "diffHunk": "@@ -13,13 +15,18 @@ This solution is aimed to fix mentioned above issues.\n \n ![Flow reroute retry](flow-reroute-retry.png \"Flow reroute retry\")\n \n-FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n+FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine \n+time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n \n | flow-id | in-progress | pending  | throttling |\n | ---     | ---         | ---      | ---        |\n | 1       | request1    | request2 | request3   |\n \n-Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and retry counter to decide will system emit reroute retry request or not.\n+Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and \n+retry counter to decide will system emit reroute retry request or not.\n \n ![Flow reroute queue service](flow-reroute-queue-service.png \"Flow reroute queue service\")\n \n+OperationQueueBolt is needed for sequential execution of operations supplied by Reroute Topology for a flow .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2NjQxNQ==", "bodyText": "queue", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480266415", "createdAt": "2020-08-31T17:06:04Z", "author": {"login": "rozdy"}, "path": "docs/design/hub-and-spoke/reroute/retry/flow-operation-queue.puml", "diffHunk": "@@ -0,0 +1,46 @@\n+@startuml\n+title Flow operation queue\n+\n+box \"Reroute Topology\" #LightGreen\n+    participant RerouteBolt\n+    participant FlowRerouteQueueBolt\n+    participant OperationQueueBolt\n+    participant CoordinatorBolt\n+end box\n+participant \"Flow H&S Topology\" as FlowHS\n+\n+== Request to OperationQueueBolt ==\n+RerouteBolt -> OperationQueueBolt : Path swap command\n+activate OperationQueueBolt\n+RerouteBolt -> FlowRerouteQueueBolt : Reroute command\n+FlowRerouteQueueBolt -> OperationQueueBolt: Reroute command\n+OperationQueueBolt -> OperationQueueBolt : add command to the queue\n+OperationQueueBolt -> FlowHS : command\n+OperationQueueBolt -> CoordinatorBolt : register callback\n+deactivate OperationQueueBolt\n+\n+== Flow HS response ==\n+FlowHS -> OperationQueueBolt : operation result\n+activate OperationQueueBolt\n+OperationQueueBolt -> CoordinatorBolt : cancel callback\n+alt reroute response\n+    OperationQueueBolt -> FlowRerouteQueueBolt : operation result\n+end\n+\n+alt there is an command in the queue\n+    OperationQueueBolt -> FlowHS : command\n+    OperationQueueBolt -> CoordinatorBolt : register callback\n+    deactivate OperationQueueBolt\n+end\n+\n+== Timeout ==\n+CoordinatorBolt -> OperationQueueBolt : operation timeout\n+activate OperationQueueBolt\n+\n+alt there is an command in the queu", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NjEwNQ==", "bodyText": "Do we need success field in PathSwapResult only to log it here? We already logged it in H&S.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480276105", "createdAt": "2020-08-31T17:25:04Z", "author": {"login": "rozdy"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjYwNzY4", "url": "https://github.com/telstra/open-kilda/pull/3693#pullrequestreview-481660768", "createdAt": "2020-09-03T09:27:48Z", "commit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOToyNzo0OFrOHMeKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOToyNzo0OFrOHMeKGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzOTA2Ng==", "bodyText": "maybe we should use warn/error log level here?", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r482839066", "createdAt": "2020-09-03T09:27:48Z", "author": {"login": "niksv"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/pathswap/action/OnFinishedWithErrorAction.java", "diffHunk": "@@ -36,5 +36,9 @@ public OnFinishedWithErrorAction(FlowOperationsDashboardLogger dashboardLogger)\n     public void execute(State from, State to, Event event, FlowPathSwapContext context, FlowPathSwapFsm stateMachine) {\n         dashboardLogger.onFailedFlowUpdate(stateMachine.getFlowId(), stateMachine.getErrorReason());\n         stateMachine.saveActionToHistory(\"Failed to swap paths for the flow\", stateMachine.getErrorReason());\n+\n+        log.info(\"Flow {} path swap failed\", stateMachine.getFlowId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/d2b30c872db1a0847b00e5028eca03bd93b9a7f0", "committedDate": "2020-08-31T05:16:48Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "6df27f1aeafeb56e82cf5511f079925120faa33b", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/6df27f1aeafeb56e82cf5511f079925120faa33b", "committedDate": "2020-09-04T04:16:49Z", "message": "Added an operations queue to the Reroute topology."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6df27f1aeafeb56e82cf5511f079925120faa33b", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/6df27f1aeafeb56e82cf5511f079925120faa33b", "committedDate": "2020-09-04T04:16:49Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "6742f4bf78f080594c93c846d10cd47edfa6f77d", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/6742f4bf78f080594c93c846d10cd47edfa6f77d", "committedDate": "2020-10-06T06:17:11Z", "message": "Added an operations queue to the Reroute topology."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6742f4bf78f080594c93c846d10cd47edfa6f77d", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/6742f4bf78f080594c93c846d10cd47edfa6f77d", "committedDate": "2020-10-06T06:17:11Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "e4fa5472eb92f83bedffd7a29f22f62435c18df8", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/e4fa5472eb92f83bedffd7a29f22f62435c18df8", "committedDate": "2020-10-06T10:03:18Z", "message": "Added an operations queue to the Reroute topology."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzQ1Mzgx", "url": "https://github.com/telstra/open-kilda/pull/3693#pullrequestreview-507745381", "createdAt": "2020-10-13T19:05:13Z", "commit": {"oid": "e4fa5472eb92f83bedffd7a29f22f62435c18df8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4fa5472eb92f83bedffd7a29f22f62435c18df8", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/e4fa5472eb92f83bedffd7a29f22f62435c18df8", "committedDate": "2020-10-06T10:03:18Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "3315800259b82775cc21a509656551945c906cec", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/3315800259b82775cc21a509656551945c906cec", "committedDate": "2020-10-14T06:47:44Z", "message": "Added an operations queue to the Reroute topology."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjUxMjYw", "url": "https://github.com/telstra/open-kilda/pull/3693#pullrequestreview-510651260", "createdAt": "2020-10-16T17:05:52Z", "commit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzowNTo1MlrOHjI2sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzo0MDo1N1rOHjKFuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwNzI4Mw==", "bodyText": "Do we really want to use anchored emit here (getCurrentTuple())?", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506607283", "createdAt": "2020-10-16T17:05:52Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/FlowRerouteQueueBolt.java", "diffHunk": "@@ -106,15 +110,15 @@ protected void init() {\n     public void declareOutputFields(OutputFieldsDeclarer declarer) {\n         super.declareOutputFields(declarer);\n         declarer.declareStream(TimeWindowBolt.STREAM_TIME_WINDOW_EVENT_ID, new Fields(FIELD_ID_CONTEXT));\n-        declarer.declareStream(STREAM_FLOWHS_ID, RerouteTopology.KAFKA_FIELDS);\n+        declarer.declareStream(STREAM_OPERATION_QUEUE_ID, FIELDS_OPERATION_QUEUE);\n         declarer.declareStream(STREAM_NORTHBOUND_ID, RerouteTopology.KAFKA_FIELDS);\n     }\n \n     @Override\n     public void sendRerouteRequest(String correlationId, FlowRerouteRequest request) {\n         log.info(\"Send reroute request {} with correlationId {}\", request, correlationId);\n-        getOutput().emit(STREAM_FLOWHS_ID, getCurrentTuple(),\n-                new Values(correlationId, new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+        emit(STREAM_OPERATION_QUEUE_ID, getCurrentTuple(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwODcyNA==", "bodyText": "... code is better without this garbage.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506608724", "createdAt": "2020-10-16T17:08:49Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxMjIxOA==", "bodyText": "Why you use 2 arguments if you read the first argument value from the second argument value?\nPS Other service calls have the same issue with flowId arguments.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506612218", "createdAt": "2020-10-16T17:14:40Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void init() {\n+        this.service = new OperationQueueService(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void handleInput(Tuple tuple) throws PipelineException {\n+        CommandContext context = pullContext(tuple);\n+        MessageData data = pullValue(tuple, FIELD_ID_PAYLOAD, MessageData.class);\n+        if (data instanceof FlowPathSwapRequest) {\n+            FlowPathSwapRequest flowPathSwapRequest = (FlowPathSwapRequest) data;\n+            service.addFirst(flowPathSwapRequest.getFlowId(), context.getCorrelationId(), flowPathSwapRequest);\n+        } else if (data instanceof FlowRerouteRequest) {\n+            FlowRerouteRequest flowRerouteRequest = (FlowRerouteRequest) data;\n+            service.addLast(flowRerouteRequest.getFlowId(), context.getCorrelationId(), flowRerouteRequest);\n+        } else if (data instanceof RerouteResultInfoData) {\n+            RerouteResultInfoData rerouteResultInfoData = (RerouteResultInfoData) data;\n+            service.operationCompleted(rerouteResultInfoData.getFlowId(), rerouteResultInfoData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODE3Mw==", "bodyText": "newContext ... looks extremely weird. Can we have just context? Or just redefine correlationId, while we don't need context itself.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506618173", "createdAt": "2020-10-16T17:25:20Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/RerouteBolt.java", "diffHunk": "@@ -158,29 +163,25 @@ public void emitManualRerouteCommand(String flowId, FlowThrottlingData flowThrot\n      * Emit swap command for consumer.\n      *\n      * @param correlationId correlation id to pass through\n-     * @param path affected paths\n-     * @param reason initial reason of reroute\n+     * @param flowId flow\n+     * @param reason initial reason of path swap\n      */\n     @Override\n-    public void emitPathSwapCommand(String correlationId, FlowPath path, String reason) {\n-        FlowPathSwapRequest request = new FlowPathSwapRequest(path.getFlow().getFlowId(), path.getPathId());\n-        getOutput().emit(STREAM_SWAP_ID, getCurrentTuple(), new Values(correlationId,\n-                new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+    public void emitPathSwapCommand(String correlationId, String flowId, String reason) {\n+        CommandContext newContext = new CommandContext(correlationId).fork(UUID.randomUUID().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTQzMw==", "bodyText": "Why warn? Ther is normal to have no such records due to race condition on timeout remove request.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506621433", "createdAt": "2020-10-16T17:31:10Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNzUxMw==", "bodyText": "Have we ever clean up this map? This approach creates a memory leak that can be triggered/used via NB API (you need to produce reroute requests for not existing/unique flowId... endlessly).", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506627513", "createdAt": "2020-10-16T17:40:57Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);\n+        queueData.setTaskInProgress(null);\n+        processQueue(queueData);\n+    }\n+\n+    private void processQueue(FlowQueueData queueData) {\n+        if (!queueData.getQueue().isEmpty() && !queueData.isOperationInProgress()) {\n+            OperationData operationData = queueData.getQueue().pop();\n+            carrier.emitRequest(operationData.getCorrelationId(), operationData.getCommandData());\n+            queueData.setTaskInProgress(operationData.getCorrelationId());\n+            log.info(\"Flow command {} has been sent\", operationData.getCommandData());\n+        }\n+    }\n+\n+    private FlowQueueData getFlowQueueData(String flowId) {\n+        return flowCommands.computeIfAbsent(flowId, v -> new FlowQueueData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 106}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3315800259b82775cc21a509656551945c906cec", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/3315800259b82775cc21a509656551945c906cec", "committedDate": "2020-10-14T06:47:44Z", "message": "Added an operations queue to the Reroute topology."}, "afterCommit": {"oid": "66add84650acbdfcdd2a20f1d29391d9547e685c", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/66add84650acbdfcdd2a20f1d29391d9547e685c", "committedDate": "2020-10-16T19:13:50Z", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fedd9de46b17e56e5efc361e78f3336ce367648", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/5fedd9de46b17e56e5efc361e78f3336ce367648", "committedDate": "2020-10-19T05:15:51Z", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66add84650acbdfcdd2a20f1d29391d9547e685c", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/66add84650acbdfcdd2a20f1d29391d9547e685c", "committedDate": "2020-10-16T19:13:50Z", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows."}, "afterCommit": {"oid": "5fedd9de46b17e56e5efc361e78f3336ce367648", "author": {"user": {"login": "dpoltavets", "name": "Dmitriy Poltavets"}}, "url": "https://github.com/telstra/open-kilda/commit/5fedd9de46b17e56e5efc361e78f3336ce367648", "committedDate": "2020-10-19T05:15:51Z", "message": "Added an operations queue to the Reroute topology.\n\nSince the swap paths operation is not blocked by the 'in_progress' flow status, during a network breakdown, these flows may not process correctly. This fix orders swap paths requests and reroute requests for protected flows."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3556, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}