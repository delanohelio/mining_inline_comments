{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1ODY4OTc5", "number": 3137, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0ODowOFrODaIIGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzoyNToyMVrODa4AiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIyNzE0OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0ODowOFrOFg59hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo0Mjo1NFrOFhW39A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODM4OQ==", "bodyText": "I don't think this wait is required", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048389", "createdAt": "2020-01-23T10:48:08Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMjEwMA==", "bodyText": "agree", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370522100", "createdAt": "2020-01-24T08:42:54Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODM4OQ=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIzMDAwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0OTowMVrOFg5_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOToxNzoyMFrOFhXpSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODgyMA==", "bodyText": "explain this, or use a meaningful name for the variable", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048820", "createdAt": "2020-01-23T10:49:01Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzNDcyOQ==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370534729", "createdAt": "2020-01-24T09:17:20Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODgyMA=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIzODY0OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo1MjowNVrOFg6Ekg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOToxMDo0MVrOFhXfOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDE5NA==", "bodyText": "So the flow status is still UP at this point, am I correct?", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050194", "createdAt": "2020-01-23T10:52:05Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzMjE1NA==", "bodyText": "you are right", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370532154", "createdAt": "2020-01-24T09:10:41Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDE5NA=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI0MzE0OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo1MzozOVrOFg6Hdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOToxNjoyOFrOFhXn-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDkzNQ==", "bodyText": "please prefer northbound.getLink(isltToBreak)... over your construction. IslUtils implementation will request all isls, while my call will only request one", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050935", "createdAt": "2020-01-23T10:53:39Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzNDM5Mg==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370534392", "createdAt": "2020-01-24T09:16:28Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDkzNQ=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI1MzUwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo1NzowNlrOFg6Nvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTozNzozMFrOFhYJ2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MjU0Mw==", "bodyText": "any chance for tidy cleanup?", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370052543", "createdAt": "2020-01-23T10:57:06Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0MzA2NA==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370543064", "createdAt": "2020-01-24T09:37:30Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MjU0Mw=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI2MDkwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo1OTo0MVrOFg6SHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTozNzoyOVrOFhYJxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzY2Mw==", "bodyText": "If you decide to do a tidy cleanup, I suggest to remove the flow as a first step, so that just in case it ended up in 'Down' state, we don't trigger it to 'in progress' by bringing above ports to up status", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370053663", "createdAt": "2020-01-23T10:59:41Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"\n+        antiflap.portUp(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+        broughtDownPorts.each { antiflap.portUp(it.switchId, it.portNo) }\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0MzA0Nw==", "bodyText": "thx, done", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370543047", "createdAt": "2020-01-24T09:37:29Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"\n+        antiflap.portUp(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+        broughtDownPorts.each { antiflap.portUp(it.switchId, it.portNo) }\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzY2Mw=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI3MTUzOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTowMzo0OFrOFg6Y0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo0MjowNVrOFhW2xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTM3Ng==", "bodyText": "Please don't get too keen on commenting the code whith given/when/then. These blocks must describe the test case, not the code. You can comment code using regular //comment comments", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370055376", "createdAt": "2020-01-23T11:03:48Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMTc5Ng==", "bodyText": "agree", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370521796", "createdAt": "2020-01-24T08:42:05Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTM3Ng=="}, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTA3MjA5OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzoyNToyMVrOFiCgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0OTozMVrOFiDOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw==", "bodyText": "While we don't have a history verification that the reroute reason was 'switch up event', I'd like to see an explicit assert that all the switch-related isls are up before this action (or at least one?). Otherwise - I'm not sure what was the reason of reroute and it is very easy to receive a false-successful run.", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371236987", "createdAt": "2020-01-27T13:25:21Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MTg5NA==", "bodyText": "I thought L464 should be enough.\nI can add the same verification before activating the switch, but I think there is no sense\nit takes system less than second for getting from L464 to L471", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371241894", "createdAt": "2020-01-27T13:35:19Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw=="}, "originalCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0ODcyNQ==", "bodyText": "OK, didn't realize that islToReroute belongs to switch to break. It's fine then", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371248725", "createdAt": "2020-01-27T13:49:31Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw=="}, "originalCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2082, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}