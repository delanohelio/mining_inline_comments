{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTc0NzA4", "number": 3438, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMjowOTowMFrOD6njyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowMjowNVrOD9aG0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzkyMTM5OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMjowOTowMVrOGSjXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoxMToxOVrOGVQ2HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwNjk2Mg==", "bodyText": "this constant is unused", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r422106962", "createdAt": "2020-05-08T12:09:01Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java", "diffHunk": "@@ -83,12 +83,15 @@\n             75, FlowEncapsulationType.VXLAN);\n \n     protected static final FlowEndpoint endpointEgressZeroVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 11, 0);\n-    protected static final FlowEndpoint endpointEgressOneVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressSingleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressDoubleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 13, 70, 71);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cba45390f4cb23b57fcce2b47e7620236093b27"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0OTI3Ng==", "bodyText": "Removed.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424949276", "createdAt": "2020-05-14T08:11:19Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java", "diffHunk": "@@ -83,12 +83,15 @@\n             75, FlowEncapsulationType.VXLAN);\n \n     protected static final FlowEndpoint endpointEgressZeroVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 11, 0);\n-    protected static final FlowEndpoint endpointEgressOneVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressSingleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressDoubleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 13, 70, 71);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwNjk2Mg=="}, "originalCommit": {"oid": "6cba45390f4cb23b57fcce2b47e7620236093b27"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNzk5NjY5OnYy", "diffSide": "RIGHT", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMjozNzoxN1rOGSkEew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoyMTo1N1rOGVROqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjExODUyMw==", "bodyText": "we have method  findByEndpointAndVlan() so you can use it instead of checking outer vlan manually\nI'm not really sure about this break. Example:\nyou have 2 flows: common flow and one switch one port flow.\nflow1 src:  sw = 1, port = 1, outer vlan = 1, inner vlan = 2\nflow2 src:  sw = 1, port = 1, outer vlan = 5, inner vlan = 5\nflow2 dst:  sw = 1, port = 1, outer vlan = 1, inner vlan = 3\n\nneedle will be equal to sw = 1, port = 1, outer vlan = 1\nduring first iteration you will add flow1 to the result\nduring second iteration you will compare needle with flow2 src but flow2.src.outerVlal != needle.outerClan\nthat is why you will break and you wouldn't compare needle with flow2.dst\nExpected result: flow1 and flow2 in result\nActual Result: flow1 in result\n\nI think you should also check src/dstMultiTableFlag for flows, because only flows which are in multiTable mode use shared rule.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r422118523", "createdAt": "2020-05-08T12:37:17Z", "author": {"login": "niksv"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java", "diffHunk": "@@ -98,6 +104,29 @@ protected FlowPath getFlowPath(PathId pathId) {\n         return new HashSet<>(flowRepository.findFlowsIdsByEndpointWithMultiTableSupport(switchId, port));\n     }\n \n+    protected List<Flow> findOuterVlanMatchSharedRuleUsage(FlowEndpoint needle) {\n+        if (! FlowEndpoint.isVlanIdSet(needle.getOuterVlanId())) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<Flow> results = new ArrayList<>();\n+        for (Flow entry : flowRepository.findByEndpoint(needle.getSwitchId(), needle.getPortNumber())) {\n+            for (FlowSideAdapter flowSide : new FlowSideAdapter[] {\n+                    new FlowSourceAdapter(entry),\n+                    new FlowDestAdapter(entry)}) {\n+                FlowEndpoint endpoint = flowSide.getEndpoint();\n+                if (needle.isSwitchPortEquals(endpoint)) {\n+                    if (needle.getOuterVlanId() == endpoint.getOuterVlanId()) {\n+                        results.add(entry);\n+                    }\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cba45390f4cb23b57fcce2b47e7620236093b27"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NTU2Mw==", "bodyText": "1 - findByEndpointAndVlan return only 1 flow (this is incorrect from what this method should do/return.\n2 - fixed.\n3 - fixed.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424955563", "createdAt": "2020-05-14T08:21:57Z", "author": {"login": "surabujin"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java", "diffHunk": "@@ -98,6 +104,29 @@ protected FlowPath getFlowPath(PathId pathId) {\n         return new HashSet<>(flowRepository.findFlowsIdsByEndpointWithMultiTableSupport(switchId, port));\n     }\n \n+    protected List<Flow> findOuterVlanMatchSharedRuleUsage(FlowEndpoint needle) {\n+        if (! FlowEndpoint.isVlanIdSet(needle.getOuterVlanId())) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<Flow> results = new ArrayList<>();\n+        for (Flow entry : flowRepository.findByEndpoint(needle.getSwitchId(), needle.getPortNumber())) {\n+            for (FlowSideAdapter flowSide : new FlowSideAdapter[] {\n+                    new FlowSourceAdapter(entry),\n+                    new FlowDestAdapter(entry)}) {\n+                FlowEndpoint endpoint = flowSide.getEndpoint();\n+                if (needle.isSwitchPortEquals(endpoint)) {\n+                    if (needle.getOuterVlanId() == endpoint.getOuterVlanId()) {\n+                        results.add(entry);\n+                    }\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjExODUyMw=="}, "originalCommit": {"oid": "6cba45390f4cb23b57fcce2b47e7620236093b27"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzUxNzQ2OnYy", "diffSide": "RIGHT", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzo1NDozNlrOGT6dtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODozMjozMFrOGVRo2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDAwNg==", "bodyText": "filter is a bad naming. It should be something like switchRules, expectedRules, rulesToBeInstalled, etc\nfilter is to general", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423534006", "createdAt": "2020-05-12T07:54:36Z", "author": {"login": "niksv"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MjI2Nw==", "bodyText": "renamed", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424962267", "createdAt": "2020-05-14T08:32:30Z", "author": {"login": "surabujin"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDAwNg=="}, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzUyMjQ2OnYy", "diffSide": "RIGHT", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzo1NTo0OVrOGT6gyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODozMzowMlrOGVRqPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDc5Mg==", "bodyText": "entry is a bad naming too. it must be rawCookie ot something connected with cookie", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423534792", "createdAt": "2020-05-12T07:55:49Z", "author": {"login": "niksv"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {\n+        List<BaseFlow> results = new ArrayList<>();\n+        for (long entry : filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MjYyMw==", "bodyText": "... don't agree. Renamed.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424962623", "createdAt": "2020-05-14T08:33:02Z", "author": {"login": "surabujin"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {\n+        List<BaseFlow> results = new ArrayList<>();\n+        for (long entry : filter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDc5Mg=="}, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzU5MjA2OnYy", "diffSide": "RIGHT", "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSourceAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODoxNDo1MlrOGT7NbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODozOTowNlrOGVR5kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NjIyMA==", "bodyText": "I'm not very sure about naming. Why Egress? here you are checking that flow endpoint is source and path is forward. I thought such paths called ingress", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423546220", "createdAt": "2020-05-12T08:14:52Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSourceAdapter.java", "diffHunk": "@@ -37,4 +40,9 @@ public FlowEndpoint getEndpoint() {\n     public boolean isMultiTableSegment() {\n         return flow.isSrcWithMultiTable();\n     }\n+\n+    @Override\n+    public boolean isPrimaryEgressPath(@NonNull PathId pathId) {\n+        return pathId.equals(flow.getForwardPathId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2NjU0NA==", "bodyText": "This path goes from source to dest i.e. it is forward path. So from the \"source\" flow side view, it is egress path, because it starts at the \"source\" side and goes somewhere else (in our case to the dest side of the flow).\nWhy it must be \"ingress\"?", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424966544", "createdAt": "2020-05-14T08:39:06Z", "author": {"login": "surabujin"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSourceAdapter.java", "diffHunk": "@@ -37,4 +40,9 @@ public FlowEndpoint getEndpoint() {\n     public boolean isMultiTableSegment() {\n         return flow.isSrcWithMultiTable();\n     }\n+\n+    @Override\n+    public boolean isPrimaryEgressPath(@NonNull PathId pathId) {\n+        return pathId.equals(flow.getForwardPathId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NjIyMA=="}, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzYwOTM5OnYy", "diffSide": "RIGHT", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODoxOToxOVrOGT7YUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODo1MjoxNlrOGVSawQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0OTAxMQ==", "bodyText": "You must check that flow is in multiTable mode.\nScenario:\n\nset multiTable = false on switches\ncreate flow with one vlan\nvalidate src/dst switch\n\nExpected Result:\nno missing rules.\nActual Result:\nmissing shared rule", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423549011", "createdAt": "2020-05-12T08:19:19Z", "author": {"login": "niksv"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +182,41 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (switchId.equals(endpoint.getSwitchId())\n+                    && FlowEndpoint.isVlanIdSet(endpoint.getOuterVlanId())\n+                    && ingress.isPrimaryEgressPath(path.getPathId())) {\n+                result.add(FlowSharedSegmentCookie.builder(SharedSegmentType.QINQ_OUTER_VLAN)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3NTA0MQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424975041", "createdAt": "2020-05-14T08:52:16Z", "author": {"login": "surabujin"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +182,41 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (switchId.equals(endpoint.getSwitchId())\n+                    && FlowEndpoint.isVlanIdSet(endpoint.getOuterVlanId())\n+                    && ingress.isPrimaryEgressPath(path.getPathId())) {\n+                result.add(FlowSharedSegmentCookie.builder(SharedSegmentType.QINQ_OUTER_VLAN)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0OTAxMQ=="}, "originalCommit": {"oid": "fddff585c5eca08f2c07cbd9447b5a4b79062756"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODU3MDM4OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjo0Nzo0N1rOGUE4Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODo1Mjo0N1rOGVScEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcwNDYzNA==", "bodyText": "Here must be Ingress table.\nThere is a problem with priorities.\nCurrent priorities:\nDouble tag 0\nSingle tag -10\nDefault Port -1\n\nIt means that Default Port will catch all single tag traffic\nDefault port priority must be changed.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423704634", "createdAt": "2020-05-12T12:47:47Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "diffHunk": "@@ -72,28 +78,83 @@ public IngressFlowModFactory(\n     /**\n      * Make rule to match traffic by port+vlan and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeOuterVlanOnlyForwardMessage(MeterId effectiveMeterId) {\n+    public OFFlowMod makeOuterOnlyVlanForwardMessage(MeterId effectiveMeterId) {\n         FlowEndpoint endpoint = command.getEndpoint();\n         OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n-                .setCookie(U64.of(command.getCookie().getValue()))\n                 .setMatch(OfAdapter.INSTANCE.matchVlanId(of, of.buildMatch(), endpoint.getOuterVlanId())\n-                                  .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n-                                  .build());\n-        return makeForwardMessage(of, builder, effectiveMeterId);\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, endpoint.getVlanStack());\n+    }\n+\n+    /**\n+     * Make rule to forward traffic matched by outer VLAN tag and forward in in ISL (or out port in case one-switch\n+     * flow).\n+     */\n+    public OFFlowMod makeSingleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -10)\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n+    }\n+\n+    /**\n+     * Make rule to match inner VLAN tag and forward in in ISL (or out port in case one-switch flow).\n+     */\n+    public OFFlowMod makeDoubleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlan(endpoint.getInnerVlanId()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n     }\n \n     /**\n      * Make rule to match whole port traffic and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeDefaultPortFlowMatchAndForwardMessage(MeterId effectiveMeterId) {\n-        // FIXME we need some space between match rules (so it should be -10 instead of -1)\n-        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID),\n-                                                                      -1)\n-                .setCookie(U64.of(command.getCookie().getValue()))\n+    public OFFlowMod makeDefaultPortForwardMessage(MeterId effectiveMeterId) {\n+        // FIXME we need some space between match rules (so priorityOffset should be -10 instead of -1)\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.PRE_INGRESS_TABLE_ID), -1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bbb89c75492dc74881c5487adf7aee8dff06aae"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3NTM3OA==", "bodyText": "yes - fixed", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424975378", "createdAt": "2020-05-14T08:52:47Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "diffHunk": "@@ -72,28 +78,83 @@ public IngressFlowModFactory(\n     /**\n      * Make rule to match traffic by port+vlan and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeOuterVlanOnlyForwardMessage(MeterId effectiveMeterId) {\n+    public OFFlowMod makeOuterOnlyVlanForwardMessage(MeterId effectiveMeterId) {\n         FlowEndpoint endpoint = command.getEndpoint();\n         OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n-                .setCookie(U64.of(command.getCookie().getValue()))\n                 .setMatch(OfAdapter.INSTANCE.matchVlanId(of, of.buildMatch(), endpoint.getOuterVlanId())\n-                                  .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n-                                  .build());\n-        return makeForwardMessage(of, builder, effectiveMeterId);\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, endpoint.getVlanStack());\n+    }\n+\n+    /**\n+     * Make rule to forward traffic matched by outer VLAN tag and forward in in ISL (or out port in case one-switch\n+     * flow).\n+     */\n+    public OFFlowMod makeSingleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -10)\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n+    }\n+\n+    /**\n+     * Make rule to match inner VLAN tag and forward in in ISL (or out port in case one-switch flow).\n+     */\n+    public OFFlowMod makeDoubleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlan(endpoint.getInnerVlanId()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n     }\n \n     /**\n      * Make rule to match whole port traffic and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeDefaultPortFlowMatchAndForwardMessage(MeterId effectiveMeterId) {\n-        // FIXME we need some space between match rules (so it should be -10 instead of -1)\n-        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID),\n-                                                                      -1)\n-                .setCookie(U64.of(command.getCookie().getValue()))\n+    public OFFlowMod makeDefaultPortForwardMessage(MeterId effectiveMeterId) {\n+        // FIXME we need some space between match rules (so priorityOffset should be -10 instead of -1)\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.PRE_INGRESS_TABLE_ID), -1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcwNDYzNA=="}, "originalCommit": {"oid": "7bbb89c75492dc74881c5487adf7aee8dff06aae"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTE3NjI3OnYy", "diffSide": "RIGHT", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTozMzoyOVrOGWBLSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzoyNzo0N1rOGWqjqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0MTEzMQ==", "bodyText": "We must NOT check that switch is in multiTable. We must check that flow endpoint in multi table\nscenario:\n\nswitch is in multiTable\ncreate flow outer vlan 1, inner vlan 0.\nupdate switch props (multiTable=false)\n\nExpected result:\nshared rule still on switch because flow still in multiTableMode\nActualResult:\nshared rules was removed. flow doesn't work", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r425741131", "createdAt": "2020-05-15T11:33:29Z", "author": {"login": "niksv"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +186,45 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        boolean isMultiTableMode = isSwitchInMultiTableMode(switchId);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (isMultiTableMode\n+                    && ingress.isMultiTableSegment()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d48d8b440b9fc9573b6f3253f4c6248b1f5db35"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxOTExMw==", "bodyText": "Why this scenario is invalid? After multi-table mode change affected flows must be updated too. Unless this moment they are invalid and must report discrepancies on validation.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426419113", "createdAt": "2020-05-18T07:27:47Z", "author": {"login": "surabujin"}, "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +186,45 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        boolean isMultiTableMode = isSwitchInMultiTableMode(switchId);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (isMultiTableMode\n+                    && ingress.isMultiTableSegment()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0MTEzMQ=="}, "originalCommit": {"oid": "8d48d8b440b9fc9573b6f3253f4c6248b1f5db35"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTgxNDUxOnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressFlow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1MDo1MVrOGWrTOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTozOTowMFrOGWvVtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTI5MA==", "bodyText": "pleas Update toString() too", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426431290", "createdAt": "2020-05-18T07:50:51Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressFlow.java", "diffHunk": "@@ -336,6 +329,7 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be123379d6ba7fb3667a2e5be6f1f23726770448"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5NzQ2MQ==", "bodyText": "nice catch ... too used to lombok", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426497461", "createdAt": "2020-05-18T09:39:00Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressFlow.java", "diffHunk": "@@ -336,6 +329,7 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTI5MA=="}, "originalCommit": {"oid": "be123379d6ba7fb3667a2e5be6f1f23726770448"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTgyNzU3OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallOneSwitchFlow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNzo1NDoyNlrOGWrbCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTozOToxM1rOGWvWMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzI4OQ==", "bodyText": "please update toString() too", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426433289", "createdAt": "2020-05-18T07:54:26Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallOneSwitchFlow.java", "diffHunk": "@@ -330,7 +315,9 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be123379d6ba7fb3667a2e5be6f1f23726770448"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5NzU4Nw==", "bodyText": "added", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426497587", "createdAt": "2020-05-18T09:39:13Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallOneSwitchFlow.java", "diffHunk": "@@ -330,7 +315,9 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzI4OQ=="}, "originalCommit": {"oid": "be123379d6ba7fb3667a2e5be6f1f23726770448"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTkwMDQwOnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxNDoyOFrOGWsIhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0MzoyN1rOGWvgag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NDkzNQ==", "bodyText": "(nit) As you added @getter to each field you can just add @getter to the class", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426444935", "createdAt": "2020-05-18T08:14:28Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -16,26 +16,38 @@\n package org.openkilda.floodlight.model;\n \n import org.openkilda.floodlight.error.CorruptedNetworkDataException;\n+import org.openkilda.messaging.model.NetworkEndpoint;\n import org.openkilda.messaging.model.Ping;\n import org.openkilda.messaging.model.PingMeters;\n+import org.openkilda.model.FlowEndpoint;\n \n import com.auth0.jwt.JWTCreator;\n import com.auth0.jwt.interfaces.DecodedJWT;\n+import lombok.Getter;\n+import lombok.Setter;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.projectfloodlight.openflow.types.DatapathId;\n \n import java.util.UUID;\n \n public class PingData implements ISignPayload {\n-    private static String JWT_KEY_PREFIX = \"openkilda.ping.\";\n-\n+    @Getter @Setter\n     private long sendTime = 0;\n+    @Getter @Setter\n     private long senderLatency = 0;\n \n-    private final Short sourceVlan;\n+    @Getter\n+    private final int ingressPortNumber;\n+    @Getter\n+    private final int ingressVlanId;\n+    @Getter\n+    private final int ingressInnerVlanId;\n+    @Getter\n     private final DatapathId source;\n+    @Getter\n     private final DatapathId dest;\n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMDIwMg==", "bodyText": "In this case, I must remove all generic getters, it increases change size, I am not allowed to do it now.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426500202", "createdAt": "2020-05-18T09:43:27Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -16,26 +16,38 @@\n package org.openkilda.floodlight.model;\n \n import org.openkilda.floodlight.error.CorruptedNetworkDataException;\n+import org.openkilda.messaging.model.NetworkEndpoint;\n import org.openkilda.messaging.model.Ping;\n import org.openkilda.messaging.model.PingMeters;\n+import org.openkilda.model.FlowEndpoint;\n \n import com.auth0.jwt.JWTCreator;\n import com.auth0.jwt.interfaces.DecodedJWT;\n+import lombok.Getter;\n+import lombok.Setter;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.projectfloodlight.openflow.types.DatapathId;\n \n import java.util.UUID;\n \n public class PingData implements ISignPayload {\n-    private static String JWT_KEY_PREFIX = \"openkilda.ping.\";\n-\n+    @Getter @Setter\n     private long sendTime = 0;\n+    @Getter @Setter\n     private long senderLatency = 0;\n \n-    private final Short sourceVlan;\n+    @Getter\n+    private final int ingressPortNumber;\n+    @Getter\n+    private final int ingressVlanId;\n+    @Getter\n+    private final int ingressInnerVlanId;\n+    @Getter\n     private final DatapathId source;\n+    @Getter\n     private final DatapathId dest;\n+    @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NDkzNQ=="}, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTkwNjYxOnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoxNjoxNFrOGWsMgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0Njo1OVrOGWvovg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTk1Mg==", "bodyText": "key is unused", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426445952", "createdAt": "2020-05-18T08:16:14Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -168,7 +157,47 @@ public int hashCode() {\n                 .toHashCode();\n     }\n \n+    private static int decodeVlanId(DecodedJWT token, String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMjMzNA==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426502334", "createdAt": "2020-05-18T09:46:59Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -168,7 +157,47 @@ public int hashCode() {\n                 .toHashCode();\n     }\n \n+    private static int decodeVlanId(DecodedJWT token, String key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTk1Mg=="}, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjEzNTgyOnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOToxNDoxNVrOGWuZ7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo1MTo0OFrOGWv07w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE1Nw==", "bodyText": "Can we use new RulesContext() instead of null to do new face with NPE?", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426482157", "createdAt": "2020-05-18T09:14:15Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwNTQ1NQ==", "bodyText": "RulesContext() is used only in *Remove commands and only after null check i.e it is a nullable field by its design.\nAs for me - invalid \"default\" values for a nullable field can make much more damage than null.\nFixed.", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426505455", "createdAt": "2020-05-18T09:51:48Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE1Nw=="}, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjEzNjA0OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOToxNDoxOFrOGWuaEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo1MjowNVrOGWv1qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE5Mw==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426482193", "createdAt": "2020-05-18T09:14:18Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);\n+\n+        return new FlowSegmentSyncWrapperCommand(command, replyTopic);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallOneSwitchFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        FlowEndpoint egressEndpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getOutputPort(), request.getOutputVlanId(),\n+                request.getOutputInnerVlanId());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        OneSwitchFlowInstallCommand command = new OneSwitchFlowInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig, egressEndpoint,\n+                null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwNTY0Mg==", "bodyText": "same :)", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426505642", "createdAt": "2020-05-18T09:52:05Z", "author": {"login": "surabujin"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);\n+\n+        return new FlowSegmentSyncWrapperCommand(command, replyTopic);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallOneSwitchFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        FlowEndpoint egressEndpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getOutputPort(), request.getOutputVlanId(),\n+                request.getOutputInnerVlanId());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        OneSwitchFlowInstallCommand command = new OneSwitchFlowInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig, egressEndpoint,\n+                null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE5Mw=="}, "originalCommit": {"oid": "097bae993bf85cca48ece853577137f82cb07a84"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzE3NDU5OnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowMjowNVrOGW4lYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDowMjowNVrOGW4lYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0ODkyOA==", "bodyText": "should we also map connected devices fields in method\npublic abstract FlowEndpoint mapFlowEndpoint(FlowEndpointV2 input); ?", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426648928", "createdAt": "2020-05-18T14:02:05Z", "author": {"login": "niksv"}, "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java", "diffHunk": "@@ -149,9 +150,43 @@ public FlowResponseV2 toFlowResponseV2(FlowDto flowDto) {\n     @Mapping(target = \"type\", ignore = true)\n     public abstract FlowRequest toFlowRequest(FlowRequestV2 request);\n \n+    @Mapping(target = \"flowId\", source = \"id\")\n+    @Mapping(target = \"bandwidth\", source = \"maximumBandwidth\")\n+    @Mapping(target = \"transitEncapsulationId\", ignore = true)\n+    @Mapping(target = \"type\", ignore = true)\n+    @Mapping(target = \"detectConnectedDevices\", ignore = true)\n+    public abstract FlowRequest toFlowRequest(FlowCreatePayload request);\n+\n     @Mapping(target = \"outerVlanId\", source = \"vlanId\")\n     public abstract FlowEndpoint mapFlowEndpoint(FlowEndpointV2 input);\n \n+    @Mapping(target = \"switchId\", source = \"datapath\")\n+    @Mapping(target = \"outerVlanId\", source = \"vlanId\")\n+    @Mapping(target = \"trackLldpConnectedDevices\", source = \"detectConnectedDevices.lldp\")\n+    @Mapping(target = \"trackArpConnectedDevices\", source = \"detectConnectedDevices.arp\")\n+    public abstract FlowEndpoint mapFlowEndpoint(FlowEndpointPayload input);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32f01ec039da28c7915b6e097fc49cf1e06f242"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1962, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}