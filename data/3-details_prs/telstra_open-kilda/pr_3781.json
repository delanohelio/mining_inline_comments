{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMjA3NDY4", "number": 3781, "title": "Add test that reveals #3780", "bodyText": "", "createdAt": "2020-10-13T11:13:43Z", "url": "https://github.com/telstra/open-kilda/pull/3781", "merged": true, "mergeCommit": {"oid": "23047cc06890e8cb505685702c2c9cabc39f8fd8"}, "closed": true, "closedAt": "2020-11-09T09:07:38Z", "author": {"login": "rtretyak"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSvSzggFqTUwOTIyOTg0MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZeyLTAFqTUyNDA2MjU5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjI5ODQx", "url": "https://github.com/telstra/open-kilda/pull/3781#pullrequestreview-509229841", "createdAt": "2020-10-15T10:19:47Z", "commit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxOTo0OFrOHiA9Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyOTowNFrOHiBSng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyOTM0Ng==", "bodyText": "this test is ignored, do we really need to keep these lines as commented out?", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505429346", "createdAt": "2020-10-15T10:19:48Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMTc4Nw==", "bodyText": "how about combining these two wait into single?", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505431787", "createdAt": "2020-10-15T10:24:05Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjA1MQ==", "bodyText": "the same comment as in L252", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505432051", "createdAt": "2020-10-15T10:24:32Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNDc4Mg==", "bodyText": "please, disable bfd session", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505434782", "createdAt": "2020-10-15T10:29:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [newIsl, newIsl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        and: \"Bfd on Discovered ISL reports 'up' status\"\n+        [newOldIsl, newOldIsl.reversed].each {\n+            verifyAll(northbound.getLink(it)) {\n+                enableBfd\n+                bfdSessionStatus == \"up\"\n+            }\n+        }\n+\n+        cleanup: \"Removed Moved ISL\" //this cleanup is not comprehensive\n+        newIsl && northbound.deleteLink(islUtils.toLinkParameters(newIsl))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "committedDate": "2020-10-30T11:55:33Z", "message": "Add test that reveals #3780"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/672ca6386ff211e66397ff68a2b2db0f889100c6", "committedDate": "2020-10-13T11:11:12Z", "message": "Add test that reveals #3780"}, "afterCommit": {"oid": "8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "committedDate": "2020-10-30T11:55:33Z", "message": "Add test that reveals #3780"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MDYyNTkz", "url": "https://github.com/telstra/open-kilda/pull/3781#pullrequestreview-524062593", "createdAt": "2020-11-05T09:17:18Z", "commit": {"oid": "8eb34a6781d0ac0facf7eab3e22b9873e9b1f222"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3743, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}