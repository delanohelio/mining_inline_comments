{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwMzk2Njky", "number": 3165, "title": "Rework unit-tests for flow H&S services", "bodyText": "Use correct implementation of persistence layer to make test's results\nrepresentative.", "createdAt": "2020-02-03T16:06:03Z", "url": "https://github.com/telstra/open-kilda/pull/3165", "merged": true, "mergeCommit": {"oid": "5507dd4d94e34950723fe8d539b79393a57ca16d"}, "closed": true, "closedAt": "2020-03-12T15:55:55Z", "author": {"login": "surabujin"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBB7cBAFqTM1MjkwNTY1MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMPDaygBqjMxMTM4NzU2MzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTA1NjUw", "url": "https://github.com/telstra/open-kilda/pull/3165#pullrequestreview-352905650", "createdAt": "2020-02-04T11:30:19Z", "commit": {"oid": "74eb78ed4f827ef17d85f809892253bb555b9a15"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMTozMDoxOVrOFlQ14Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMjo0NTozOFrOFlSyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxNzU2OQ==", "bodyText": "Maybe we should create issue for this case?", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374617569", "createdAt": "2020-02-04T11:30:19Z", "author": {"login": "rozdy"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowDeleteServiceTest.java", "diffHunk": "@@ -231,57 +149,48 @@ public void shouldCompleteDeleteOnTimeoutRuleRemoval() {\n \n         // 4 times sending 4 rules = 16 requests.\n         verify(carrier, times(16)).sendSpeakerRequest(any());\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(FORWARD_FLOW_PATH))));\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(REVERSE_FLOW_PATH))));\n-        verify(flowResourcesManager, times(1)).deallocatePathResources(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"forward\",\n-                        Matchers.<PathResources>hasProperty(\"pathId\", is(FORWARD_FLOW_PATH)))));\n-        verify(flowRepository, times(1)).delete(eq(flow));\n+        verifyFlowIsMissing(flow);\n     }\n \n     @Test\n     public void shouldFailDeleteOnTimeoutDuringRuleRemoval() {\n-        Flow flow = build2SwitchFlow();\n-        buildFlowResources();\n-\n-        FlowDeleteService deleteService = new FlowDeleteService(carrier, persistenceManager,\n-                flowResourcesManager, TRANSACTION_RETRIES_LIMIT, SPEAKER_COMMAND_RETRIES_LIMIT);\n+        String flowId = makeFlow().getFlowId();\n \n-        deleteService.handleRequest(\"test_key\", commandContext, FLOW_ID);\n+        FlowDeleteService service = makeService();\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        service.handleRequest(dummyRequestKey, commandContext, flowId);\n+        verifyFlowStatus(flowId, FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        deleteService.handleTimeout(\"test_key\");\n+        service.handleTimeout(dummyRequestKey);\n \n         verify(carrier, times(4)).sendSpeakerRequest(any());\n-        verify(flowResourcesManager, never()).deallocatePathResources(any());\n-        verify(flowPathRepository, never()).delete(any());\n-        verify(flowRepository, never()).delete(any());\n+        // FIXME(surabujin): flow stays in IN_PROGRESS status, any further request can't be handled.\n+        //  em... there is no actual handling for timeout event, so FSM will stack in memory forever", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74eb78ed4f827ef17d85f809892253bb555b9a15"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MjY5Mw==", "bodyText": "I think it's better to write correct test and ignore it with link to issue.", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374642693", "createdAt": "2020-02-04T12:31:12Z", "author": {"login": "rozdy"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowDeleteServiceTest.java", "diffHunk": "@@ -365,32 +264,23 @@ public void shouldCompleteDeleteOnErrorDuringRemovingFlow() {\n         }\n \n         verify(carrier, times(4)).sendSpeakerRequest(any());\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(FORWARD_FLOW_PATH))));\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(REVERSE_FLOW_PATH))));\n-        verify(flowResourcesManager, times(1)).deallocatePathResources(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"forward\",\n-                        Matchers.<PathResources>hasProperty(\"pathId\", is(FORWARD_FLOW_PATH)))));\n-        verify(flowRepository, times(1)).delete(eq(flow));\n+        // FIXME(surabujin): one more way to make not removable via kilda-API flow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74eb78ed4f827ef17d85f809892253bb555b9a15"}, "originalPosition": 442}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0OTUzMw==", "bodyText": "Dont -> Down", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374649533", "createdAt": "2020-02-04T12:45:38Z", "author": {"login": "rozdy"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteServiceTest.java", "diffHunk": "@@ -26,954 +25,619 @@\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.reset;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n-import static org.openkilda.model.SwitchProperties.DEFAULT_FLOW_ENCAPSULATION_TYPES;\n \n import org.openkilda.floodlight.api.request.FlowSegmentRequest;\n-import org.openkilda.floodlight.api.response.SpeakerFlowSegmentResponse;\n import org.openkilda.floodlight.flow.response.FlowErrorResponse;\n import org.openkilda.floodlight.flow.response.FlowErrorResponse.ErrorCode;\n-import org.openkilda.model.Cookie;\n+import org.openkilda.messaging.error.ErrorType;\n+import org.openkilda.messaging.info.flow.FlowRerouteResponse;\n import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowEncapsulationType;\n import org.openkilda.model.FlowPath;\n import org.openkilda.model.FlowPathStatus;\n import org.openkilda.model.FlowStatus;\n import org.openkilda.model.IslEndpoint;\n-import org.openkilda.model.MeterId;\n import org.openkilda.model.PathId;\n import org.openkilda.model.PathSegment;\n-import org.openkilda.model.Switch;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.model.SwitchProperties;\n-import org.openkilda.model.TransitVlan;\n-import org.openkilda.pce.Path;\n-import org.openkilda.pce.Path.Segment;\n+import org.openkilda.model.history.FlowEvent;\n import org.openkilda.pce.PathPair;\n import org.openkilda.pce.exception.RecoverableException;\n import org.openkilda.pce.exception.UnroutableFlowException;\n-import org.openkilda.persistence.repositories.RepositoryFactory;\n-import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n-import org.openkilda.persistence.repositories.SwitchRepository;\n-import org.openkilda.persistence.repositories.history.FlowEventRepository;\n-import org.openkilda.wfm.CommandContext;\n-import org.openkilda.wfm.share.flow.resources.EncapsulationResources;\n-import org.openkilda.wfm.share.flow.resources.FlowResources;\n-import org.openkilda.wfm.share.flow.resources.FlowResources.PathResources;\n+import org.openkilda.persistence.repositories.FlowPathRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.IslRepository;\n import org.openkilda.wfm.share.flow.resources.ResourceAllocationException;\n-import org.openkilda.wfm.share.flow.resources.transitvlan.TransitVlanEncapsulation;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n+import org.hamcrest.Matchers;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatchers;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n-import java.util.ArrayList;\n+import java.time.Instant;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n @RunWith(MockitoJUnitRunner.class)\n public class FlowRerouteServiceTest extends AbstractFlowTest {\n     private static final int TRANSACTION_RETRIES_LIMIT = 3;\n     private static final int PATH_ALLOCATION_RETRIES_LIMIT = 10;\n     private static final int PATH_ALLOCATION_RETRY_DELAY = 0;\n     private static final int SPEAKER_COMMAND_RETRIES_LIMIT = 0;\n-    private static final String FLOW_ID = \"TEST_FLOW\";\n-    private static final SwitchId SWITCH_1 = new SwitchId(1);\n-    private static final SwitchId SWITCH_2 = new SwitchId(2);\n-    private static final SwitchId SWITCH_3 = new SwitchId(3);\n-    private static final PathId OLD_FORWARD_FLOW_PATH = new PathId(FLOW_ID + \"_forward_old\");\n-    private static final PathId OLD_REVERSE_FLOW_PATH = new PathId(FLOW_ID + \"_reverse_old\");\n-    private static final PathId NEW_FORWARD_FLOW_PATH = new PathId(FLOW_ID + \"_forward_new\");\n-    private static final PathId NEW_REVERSE_FLOW_PATH = new PathId(FLOW_ID + \"_reverse_new\");\n \n     @Mock\n     private FlowRerouteHubCarrier carrier;\n-    @Mock\n-    private CommandContext commandContext;\n-    @Mock\n-    private FlowEventRepository flowEventRepository;\n-\n-    private FlowRerouteService rerouteService;\n \n-    private String currentRequestKey;\n-\n-    private Map<SwitchId, Switch> swMap = new HashMap<>();\n+    private String currentRequestKey = dummyRequestKey;\n \n     @Before\n     public void setUp() {\n-        RepositoryFactory repositoryFactory = mock(RepositoryFactory.class);\n-        when(repositoryFactory.createFlowRepository()).thenReturn(flowRepository);\n-        when(flowPathRepository.getUsedBandwidthBetweenEndpoints(any(), anyInt(), any(), anyInt())).thenReturn(0L);\n-        when(repositoryFactory.createFlowPathRepository()).thenReturn(flowPathRepository);\n-        when(repositoryFactory.createFeatureTogglesRepository()).thenReturn(featureTogglesRepository);\n-\n-        when(repositoryFactory.createIslRepository()).thenReturn(islRepository);\n-\n-        SwitchRepository switchRepository = mock(SwitchRepository.class);\n-        when(switchRepository.reload(any())).thenAnswer(invocation -> invocation.getArgument(0));\n-        when(repositoryFactory.createSwitchRepository()).thenReturn(switchRepository);\n-\n-        SwitchPropertiesRepository switchPropertiesRepository = mock(SwitchPropertiesRepository.class);\n-        when(switchPropertiesRepository.findBySwitchId(any(SwitchId.class))).thenAnswer((invocation) ->\n-                Optional.of(SwitchProperties.builder()\n-                        .multiTable(false)\n-                        .supportedTransitEncapsulation(DEFAULT_FLOW_ENCAPSULATION_TYPES)\n-                        .build()));\n-        when(repositoryFactory.createSwitchPropertiesRepository()).thenReturn(switchPropertiesRepository);\n-\n-        when(flowEventRepository.existsByTaskId(any())).thenReturn(false);\n-        when(repositoryFactory.createFlowEventRepository()).thenReturn(flowEventRepository);\n-\n-        when(persistenceManager.getRepositoryFactory()).thenReturn(repositoryFactory);\n-\n         doAnswer(getSpeakerCommandsAnswer()).when(carrier).sendSpeakerRequest(any());\n \n-        doAnswer(invocation -> {\n-            FlowRerouteFact retry = invocation.getArgument(0);\n-            currentRequestKey = retry.getKey();\n-            rerouteService.handlePostponedRequest(retry);\n-            return null;\n-        }).when(carrier).injectRetry(any());\n-\n-        rerouteService = new FlowRerouteService(carrier, persistenceManager,\n-                pathComputer, flowResourcesManager, TRANSACTION_RETRIES_LIMIT,\n-                PATH_ALLOCATION_RETRIES_LIMIT, PATH_ALLOCATION_RETRY_DELAY, SPEAKER_COMMAND_RETRIES_LIMIT);\n-\n-        currentRequestKey = \"test-key\";\n-\n-        for (SwitchId id : new SwitchId[] {SWITCH_1, SWITCH_2, SWITCH_3}) {\n-            Switch entry = makeSwitch(id);\n-            swMap.put(id, entry);\n-            when(switchRepository.findById(eq(id))).thenReturn(Optional.of(entry));\n-        }\n+        // must be done before first service create attempt, because repository objects are cached inside FSM actions\n+        setupFlowRepositorySpy();\n+        setupFlowPathRepositorySpy();\n+        setupIslRepositorySpy();\n     }\n \n     @Test\n-    public void shouldFailRerouteFlowIfNoPathAvailable()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenThrow(new UnroutableFlowException(\"No path found\"));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.DOWN, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(1)).getPath(any(), any());\n-        verify(flowResourcesManager, never()).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    public void shouldFailRerouteFlowIfNoPathAvailable() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), new UnroutableFlowException(injectedErrorMessage));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.DOWN, ErrorType.NOT_FOUND);\n+        verify(pathComputer, times(1))\n+                .getPath(makeFlowArgumentMatch(origin.getFlowId()), any());\n     }\n \n     @Test\n-    public void shouldFailRerouteFlowIfRecoverableException()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenThrow(new RecoverableException(\"PCE error\"));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(flowResourcesManager, never()).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    public void shouldFailRerouteFlowIfRecoverableException() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), new RecoverableException(injectedErrorMessage));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n+        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+                .getPath(makeFlowArgumentMatch(origin.getFlowId()), any());\n     }\n \n     @Test\n     public void shouldFailRerouteFlowIfMultipleOverprovisionBandwidth()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        when(islRepository.updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong()))\n-                .thenThrow(ResourceAllocationException.class);\n+        IslRepository repository = setupIslRepositorySpy();\n+        doThrow(ResourceAllocationException.class)\n+                .when(repository).updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(islRepository, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+        verify(repository, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n                 .updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong());\n-        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n     }\n \n     @Test\n     public void shouldFailRerouteFlowIfNoResourcesAvailable()\n             throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        when(flowResourcesManager.allocateFlowResources(any()))\n-                .thenThrow(new ResourceAllocationException(\"No resources\"));\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        doThrow(new ResourceAllocationException(injectedErrorMessage))\n+                .when(flowResourcesManager).allocateFlowResources(makeFlowArgumentMatch(origin.getFlowId()));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n+\n+        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+                .allocateFlowResources(makeFlowArgumentMatch(origin.getFlowId()));\n     }\n \n     @Test\n     public void shouldFailRerouteFlowOnResourcesAllocationConstraint()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-        doThrow(new RuntimeException(\"Must fail\")).when(flowPathRepository).lockInvolvedSwitches(any(), any());\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .createOrUpdate(any(FlowPath.class));\n \n-        verify(flowResourcesManager, times(0)).deallocatePathResources(any());\n-        verify(flowResourcesManager, times(0)).deallocatePathResources(any(), anyLong(), any());\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n     }\n \n-    @Test\n-    public void shouldSkipRerouteIfNoNewPathFound()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair());\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    private void testExpectedFailure(\n+            FlowRerouteFact request, Flow origin, FlowStatus expectedFlowStatus, ErrorType expectedError) {\n+        makeService().handleRequest(request);\n+\n+        verifyNoSpeakerInteraction(carrier);\n+        verifyNorthboundErrorResponse(carrier, expectedError);\n+\n+        Flow result = verifyFlowStatus(origin.getFlowId(), expectedFlowStatus);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnUnsuccessfulInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldSkipRerouteIfNoNewPathFound() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make2SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        makeService().handleRequest(new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyNoSpeakerInteraction(carrier);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isInstallRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", FlowErrorResponse.errorBuilder()\n-                        .messageContext(request.getMessageContext())\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n+    }\n+\n+    @Test\n+    public void shouldFailRerouteOnUnsuccessfulInstallation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isInstallRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, FlowErrorResponse.errorBuilder()\n+                        .messageContext(speakerRequest.getMessageContext())\n                         .errorCode(ErrorCode.UNKNOWN)\n-                        .description(\"Switch is unavailable\")\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n+                        .description(injectedErrorMessage)\n+                        .commandId(speakerRequest.getCommandId())\n+                        .metadata(speakerRequest.getMetadata())\n+                        .switchId(speakerRequest.getSwitchId())\n                         .build());\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnTimeoutDuringInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnTimeoutDuringInstallation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        rerouteService.handleTimeout(\"test_key\");\n+        service.handleTimeout(currentRequestKey);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnUnsuccessfulValidation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnUnsuccessfulValidation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", FlowErrorResponse.errorBuilder()\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, FlowErrorResponse.errorBuilder()\n                         .errorCode(ErrorCode.UNKNOWN)\n-                        .description(\"Unknown rule\")\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n+                        .description(injectedErrorMessage)\n+                        .messageContext(speakerRequest.getMessageContext())\n+                        .commandId(speakerRequest.getCommandId())\n+                        .metadata(speakerRequest.getMetadata())\n+                        .switchId(speakerRequest.getSwitchId())\n                         .build());\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnTimeoutDuringValidation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnTimeoutDuringValidation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleTimeout(\"test_key\");\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleTimeout(currentRequestKey);\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnSwapPathsError()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n-\n-        doAnswer(invocation -> {\n-            // imitate transaction rollback\n-            Flow persistedFlow = invocation.getArgument(0);\n-            FlowPath oldForward = persistedFlow.getPaths().stream()\n-                    .filter(path -> path.getPathId().equals(OLD_FORWARD_FLOW_PATH))\n-                    .findAny().get();\n-            persistedFlow.setForwardPath(oldForward);\n-            FlowPath oldReverse = persistedFlow.getPaths().stream()\n-                    .filter(path -> path.getPathId().equals(OLD_REVERSE_FLOW_PATH))\n-                    .findAny().get();\n-            persistedFlow.setReversePath(oldReverse);\n-\n-            throw new RuntimeException(\"A persistence error\");\n-        }).when(flowRepository).createOrUpdate(argThat(\n-                hasProperty(\"forwardPathId\", equalTo(NEW_FORWARD_FLOW_PATH))));\n-\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+    public void shouldFailRerouteOnSwapPathsError() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowRepository repository = setupFlowRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository).createOrUpdate(\n+                argThat(hasProperty(\"forwardPathId\", Matchers.not(equalTo(origin.getForwardPathId())))));\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldFailRerouteOnErrorDuringCompletingFlowPathInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n-\n-        doAnswer(invocation -> {\n-            // imitate transaction rollback\n-            flow.getPath(invocation.getArgument(0)).ifPresent(\n-                    persistedFlowPath -> persistedFlowPath.setStatus(FlowPathStatus.IN_PROGRESS));\n-\n-            throw new RuntimeException(\"A persistence error\");\n-        }).when(flowPathRepository).updateStatus(eq(NEW_FORWARD_FLOW_PATH), eq(FlowPathStatus.ACTIVE));\n-\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        Set<PathId> originalPaths = origin.getPaths().stream()\n+                .map(FlowPath::getPathId)\n+                .collect(Collectors.toSet());\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .updateStatus(\n+                        ArgumentMatchers.argThat(argument -> !originalPaths.contains(argument)),\n+                        eq(FlowPathStatus.ACTIVE));\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldCompleteRerouteOnErrorDuringCompletingFlowPathRemoval()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .delete(argThat(hasProperty(\"pathId\", equalTo(origin.getForwardPathId()))));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        doThrow(new RuntimeException(\"A persistence error\"))\n-                .when(flowPathRepository).delete(argThat(\n-                hasProperty(\"pathId\", equalTo(OLD_FORWARD_FLOW_PATH))));\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldCompleteRerouteOnErrorDuringResourceDeallocation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        doThrow(new RuntimeException(\"A persistence error\"))\n+        doThrow(new RuntimeException(injectedErrorMessage))\n                 .when(flowResourcesManager).deallocatePathResources(argThat(\n                 hasProperty(\"forward\",\n-                        hasProperty(\"pathId\", equalTo(OLD_FORWARD_FLOW_PATH)))));\n+                        hasProperty(\"pathId\", equalTo(origin.getForwardPathId())))));\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldSuccessfullyRerouteFlow()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.DOWN);\n+    public void shouldSuccessfullyRerouteFlow() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        origin.setStatus(FlowStatus.DOWN);\n+        flushFlowChanges(origin);\n \n-        when(pathComputer.getPath(any(), any()))\n-                .thenReturn(build2SwitchPathPair(2, 3))\n-                .thenReturn(build3SwitchPathPair());\n-        buildFlowResources();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldSuccessfullyHandleOverlappingRequests()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.DOWN);\n-\n-        when(pathComputer.getPath(any(), any()))\n-                .thenReturn(build2SwitchPathPair(2, 3))\n-                .thenReturn(build3SwitchPathPair());\n+    public void shouldSuccessfullyHandleOverlappingRequests() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        origin.setStatus(FlowStatus.DOWN);\n+        flushFlowChanges(origin);\n \n-        FlowResources resourcesOrigin = makeFlowResources(\n-                flow.getFlowId(), flow.getForwardPathId(), flow.getReversePathId());\n+        when(pathComputer.getPath(makeFlowArgumentMatch(origin.getFlowId()), any()))\n+                .thenReturn(make2SwitchAltPathPair())\n+                .thenReturn(make3SwitchesPathPair());\n \n-        PathId pathForwardFirst = new PathId(flow.getFlowId() + \"_forward_first\");\n-        PathId pathReverseFirst = new PathId(flow.getFlowId() + \"_reverse_first\");\n-        FlowResources resourcesFirst = makeFlowResources(\n-                flow.getFlowId(), pathForwardFirst, pathReverseFirst, resourcesOrigin);\n+        FlowRerouteService service = makeService();\n+        setupPostponedRequestInjector(service);\n \n-        PathId pathForwardSecond = new PathId(flow.getFlowId() + \"_forward_second\");\n-        PathId pathReverseSecond = new PathId(flow.getFlowId() + \"_reverse_second\");\n-        FlowResources resourcesSecond = makeFlowResources(\n-                flow.getFlowId(), pathForwardSecond, pathReverseSecond, resourcesFirst);\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        when(flowResourcesManager.allocateFlowResources(any()))\n-                .thenReturn(resourcesFirst)\n-                .thenReturn(resourcesSecond);\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, false, null));\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key2\", commandContext, flow.getFlowId(), null, false, false, null));\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n+        String overlappingKey = dummyRequestKey + \"2\";\n+        service.handleRequest(new FlowRerouteFact(\n+                overlappingKey, commandContext, origin.getFlowId(), null, false, false, null));\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n \n         FlowSegmentRequest request;\n         while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+            produceAsyncResponse(service, request);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(pathForwardSecond, flow.getForwardPathId());\n-        assertEquals(pathReverseSecond, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n+\n+        FlowPath forwardPath = result.getForwardPath();\n+        Assert.assertNotNull(forwardPath);\n+        Assert.assertTrue(1 < forwardPath.getSegments().size());  // second path have 2 segments\n     }\n \n     @Test\n     public void shouldFixFlowStatusOnRequestConflict() {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.UP);\n-\n-        reset(flowEventRepository);\n-        when(flowEventRepository.existsByTaskId(any()))\n-                .thenReturn(true)\n-                .thenReturn(true);\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, false, null));\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+        Flow origin = makeFlow();\n+\n+        FlowEvent dummyHistoryEntry = FlowEvent.builder()\n+                .flowId(origin.getFlowId())\n+                .timestamp(Instant.now())\n+                .action(\"injected-collision\")\n+                .actor(getClass().getSimpleName())\n+                .taskId(commandContext.getCorrelationId())\n+                .details(\"dummy\")\n+                .build();\n+        persistenceManager.getRepositoryFactory().createFlowEventRepository()\n+                .createOrUpdate(dummyHistoryEntry);\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.UP); // because effectivelyDown == false\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, true, null));\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, true, null));\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n-        assertEquals(FlowStatus.DOWN, flow.getStatus());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.DOWN); // because effectivelyDown == true\n     }\n \n     @Test\n-    public void shouldMakeFlowDontOnTimeoutIfEffectivelyDown()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldMakeFlowDontOnTimeoutIfEffectivelyDown() throws RecoverableException, UnroutableFlowException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74eb78ed4f827ef17d85f809892253bb555b9a15"}, "originalPosition": 965}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74eb78ed4f827ef17d85f809892253bb555b9a15", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/74eb78ed4f827ef17d85f809892253bb555b9a15", "committedDate": "2020-02-03T16:03:33Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}, "afterCommit": {"oid": "e6332958525317ceef5f663ae92ea4f40d468d3a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/e6332958525317ceef5f663ae92ea4f40d468d3a", "committedDate": "2020-02-06T09:58:06Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6332958525317ceef5f663ae92ea4f40d468d3a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/e6332958525317ceef5f663ae92ea4f40d468d3a", "committedDate": "2020-02-06T09:58:06Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}, "afterCommit": {"oid": "4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "committedDate": "2020-02-24T15:39:27Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDI4MTk0", "url": "https://github.com/telstra/open-kilda/pull/3165#pullrequestreview-370428194", "createdAt": "2020-03-06T15:54:19Z", "commit": {"oid": "4fe2f7de70df06e53a5da1e72ca98636ed24c8e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "committedDate": "2020-03-10T09:25:03Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "committedDate": "2020-02-24T15:39:27Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}, "afterCommit": {"oid": "2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "committedDate": "2020-03-10T09:25:03Z", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3703, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}