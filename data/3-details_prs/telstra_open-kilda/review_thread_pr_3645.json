{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzNTc1Mzc5", "number": 3645, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo1ODoyMVrOEUk64g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1MTowMlrOEXMgcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDExODc0OnYy", "diffSide": "RIGHT", "path": "confd/templates/base-storm-topology/topology.properties.tmpl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo1ODoyMVrOG62viQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjoyMDo1N1rOG_eqUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2NzQ5Nw==", "bodyText": "should it be commented out?", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r464367497", "createdAt": "2020-08-03T11:58:21Z", "author": {"login": "andriidovhan"}, "path": "confd/templates/base-storm-topology/topology.properties.tmpl", "diffHunk": "@@ -90,6 +90,7 @@ floodlight.alive.timeout = {{ getv \"/kilda_floodlight_alive_timeout\" }}\n floodlight.alive.interval = {{ getv \"/kilda_floodlight_alive_interval\" }}\n message.blacklist.timeout = {{ getv \"/kilda_message_blacklist_timeout\" }}\n floodlight.regions = {{ getv \"/kilda_floodlight_regions\" }}\n+# floodlight.switch.mapping.remove.delay.seconds = 900", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e93e3c14414d85dc8d7dd8da8687fc5da810be62"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIxNTgyNQ==", "bodyText": "this was some rebase/conflict glitch. Fixed itself after rebase", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r469215825", "createdAt": "2020-08-12T12:20:57Z", "author": {"login": "rtretyak"}, "path": "confd/templates/base-storm-topology/topology.properties.tmpl", "diffHunk": "@@ -90,6 +90,7 @@ floodlight.alive.timeout = {{ getv \"/kilda_floodlight_alive_timeout\" }}\n floodlight.alive.interval = {{ getv \"/kilda_floodlight_alive_interval\" }}\n message.blacklist.timeout = {{ getv \"/kilda_message_blacklist_timeout\" }}\n floodlight.regions = {{ getv \"/kilda_floodlight_regions\" }}\n+# floodlight.switch.mapping.remove.delay.seconds = 900", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2NzQ5Nw=="}, "originalCommit": {"oid": "e93e3c14414d85dc8d7dd8da8687fc5da810be62"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzE0Nzc5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/atdd-staging/src/main/java/org/openkilda/atdd/staging/config/TopologyConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo0Mzo0M1rOG-yR2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo0Mzo0M1rOG-yR2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ4ODY2Nw==", "bodyText": "looks like it is removed from confd/vars/main.yml", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468488667", "createdAt": "2020-08-11T10:43:43Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/atdd-staging/src/main/java/org/openkilda/atdd/staging/config/TopologyConfig.java", "diffHunk": "@@ -35,7 +35,7 @@\n     @Value(\"file:${topology.definition.file:topology.yaml}\")\n     private Resource topologyDefinitionFile;\n \n-    @Value(\"#{'${floodlight.controllers.management.openflow}'.split(',').get(0)}\")\n+    @Value(\"#{'${floodlight.openflow}'.split(',').get(0)}\")\n     private String managementController;\n \n     @Value(\"#{'${floodlight.controllers.stat.openflow}'.split(',').get(0)}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzE2NTI2OnYy", "diffSide": "RIGHT", "path": "src-java/testing/atdd-staging/src/main/java/org/openkilda/atdd/staging/config/TopologyConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo0OToxNVrOG-ycjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDo0OToxNVrOG-ycjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ5MTQwNQ==", "bodyText": "you can also remove List<String> controllerHosts", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468491405", "createdAt": "2020-08-11T10:49:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/atdd-staging/src/main/java/org/openkilda/atdd/staging/config/TopologyConfig.java", "diffHunk": "@@ -55,7 +55,6 @@ public TopologyDefinition topologyDefinition() throws IOException {\n         List<String> controllerHosts = Arrays.asList(managementController, statController);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzM3OTUwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/service/lockkeeper/LockKeeperVirtualImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTo1NjowM1rOG-0dHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTo1NjowM1rOG-0dHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyNDMxOQ==", "bodyText": "probably would be better to call this variable as  swAddress ?", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468524319", "createdAt": "2020-08-11T11:56:03Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/service/lockkeeper/LockKeeperVirtualImpl.java", "diffHunk": "@@ -184,41 +194,52 @@ public void unblockFloodlightAccess(String region, FloodlightResourceAddress add\n     @Override\n     public void shapeSwitchesTraffic(List<Switch> switches, TrafficControlData tcData) {\n         log.debug(\"Add traffic control rules for switches {}\",\n-                switches.stream().map(Switch::getDpId).collect(Collectors.toList()));\n+                switches.stream().map(Switch::getDpId).collect(toList()));\n         List<FloodlightResourceAddress> swResources = switches.stream()\n-                .map(sw -> LockKeeperService.toFlResource(sw, mgmtManager)).collect(Collectors.toList());\n+                .flatMap(sw -> sw.getRegions().stream().map(region -> {\n+                    Floodlight fl = flHelper.getFlByRegion(region);\n+                    String swInfo = fl.getFloodlightService().getSwitches().stream().filter(s ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ1NzkyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxODowOFrOG-1LrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxODowOFrOG-1LrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNjIzNg==", "bodyText": "@Tidy?", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468536236", "createdAt": "2020-08-11T12:18:08Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "diffHunk": "@@ -25,12 +27,26 @@ class FloodlightKafkaConnectionSpec extends HealthCheckSpecification {\n     @Value('${antiflap.cooldown}')\n     int antiflapCooldown\n \n-    def \"System survives temporary connection outage between Floodlight and Kafka\"() {\n-        setup: \"Pick a region to break, find which isls are between regions\"\n-        assumeTrue(\"This test requires at least 2 floodlight regions\", mgmtFlManager.regions.size() > 1)\n-        def regionToBreak = mgmtFlManager.regions.first()\n+    def \"System properly handles ISL statuses during connection problems between Floodlights and Kafka\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ3MTkxOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyMjowNVrOG-1UBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyMjowNVrOG-1UBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzODM3NQ==", "bodyText": "please remove println or use log.debug(\"\")", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468538375", "createdAt": "2020-08-11T12:22:05Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "diffHunk": "@@ -41,9 +57,10 @@ class FloodlightKafkaConnectionSpec extends HealthCheckSpecification {\n         def nonRtlTransitIsls = islsBetweenRegions.findAll { isl ->\n             [isl.srcSwitch, isl.dstSwitch].any { !it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n         }\n-        def asyncWait = task {\n+        println nonRtlTransitIsls", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ5NzAxOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyOToyNFrOG-1jHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjoxNDoxN1rOG_ecpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU0MjIzOQ==", "bodyText": "Why do you need forEach there?", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468542239", "createdAt": "2020-08-11T12:29:24Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "diffHunk": "@@ -41,9 +57,10 @@ class FloodlightKafkaConnectionSpec extends HealthCheckSpecification {\n         def nonRtlTransitIsls = islsBetweenRegions.findAll { isl ->\n             [isl.srcSwitch, isl.dstSwitch].any { !it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n         }\n-        def asyncWait = task {\n+        println nonRtlTransitIsls\n+        def nonRtlShouldFail = task {\n             wait(WAIT_OFFSET + discoveryTimeout) {\n-                nonRtlTransitIsls.each { assert northbound.getLink(it).state == IslChangeType.FAILED }\n+                nonRtlTransitIsls.forEach { assert northbound.getLink(it).state == IslChangeType.FAILED }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIxMjMyNA==", "bodyText": "nonRtlTransitIsls can be an empty list, in this case each will return an empty list, which will be considered as 'groovy false'. forEach is always void", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r469212324", "createdAt": "2020-08-12T12:14:17Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/FloodlightKafkaConnectionSpec.groovy", "diffHunk": "@@ -41,9 +57,10 @@ class FloodlightKafkaConnectionSpec extends HealthCheckSpecification {\n         def nonRtlTransitIsls = islsBetweenRegions.findAll { isl ->\n             [isl.srcSwitch, isl.dstSwitch].any { !it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n         }\n-        def asyncWait = task {\n+        println nonRtlTransitIsls\n+        def nonRtlShouldFail = task {\n             wait(WAIT_OFFSET + discoveryTimeout) {\n-                nonRtlTransitIsls.each { assert northbound.getLink(it).state == IslChangeType.FAILED }\n+                nonRtlTransitIsls.forEach { assert northbound.getLink(it).state == IslChangeType.FAILED }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU0MjIzOQ=="}, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU0NDAyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/stats/MflStatSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0MjoxNlrOG-1_ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0MjoxNlrOG-1_ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU0OTUxNA==", "bodyText": "1 -> first?\nthen it will be in the same style as\nfirst RW switch available\nsecond RW switch available\nsecond RO switch available", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468549514", "createdAt": "2020-08-11T12:42:16Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/stats/MflStatSpec.groovy", "diffHunk": "@@ -238,4 +241,105 @@ class MflStatSpec extends HealthCheckSpecification {\n             flowHelperV2.deleteFlow(flow.flowId)\n         }\n     }\n+\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    def \"System is able to collect stats if at least 1 stats or management controller is available\"() {\n+        given: \"A flow, src switch is connected to 2 RW and 2 RO floodlights\"\n+        assumeTrue(\"Require at least 2 switches with connected traffgen\", topology.activeTraffGens.size() > 1)\n+        def srcSwitch = topology.activeTraffGens*.switchConnected.find { flHelper.filterRegionsByMode(it.regions, RW).size() == 2 &&\n+            flHelper.filterRegionsByMode(it.regions, RO).size() == 2 }\n+        assumeTrue(\"This test requires a tg switch in 2 RW regions and 2 RO regions\", srcSwitch != null)\n+        def dstSwitch = topology.activeTraffGens*.switchConnected.find { it.dpId != srcSwitch.dpId }\n+        def flow = flowHelperV2.randomFlow(srcSwitch, dstSwitch)\n+        flow.maximumBandwidth = 100\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Src switch is only left with 1 management controller (no stats controllers)\"\n+        def regionToStay = srcSwitch.regions.find { flHelper.getFlByRegion(it).mode == RW }\n+        def blockData = lockKeeper.knockoutSwitch(srcSwitch, srcSwitch.regions - regionToStay)\n+\n+        and: \"Generate traffic on the given flow\"\n+        Date startTime = new Date()\n+        def traffExam = traffExamProvider.get()\n+        def exam = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildExam(flowHelperV2.toV1(flow), (int) flow.maximumBandwidth, 5)\n+        exam.setResources(traffExam.startExam(exam, true))\n+        assert traffExam.waitExam(exam).hasTraffic()\n+\n+        then: \"Stat on the src switch should be collected (first RW switch available)\"\n+        def metric = metricPrefix + \"flow.raw.bytes\"\n+        def tags = [switchid: srcSwitch.dpId.toOtsdFormat(), flowid: flow.flowId]\n+        def waitInterval = 10\n+        def initStats\n+        //first 60 seconds - trying to retrieve stats from management controller, next 60 seconds from stat controller\n+        Wrappers.wait(statsRouterInterval * 2 + WAIT_OFFSET, waitInterval) {\n+            initStats = otsdb.query(startTime, metric, tags).dps\n+            assert initStats.size() >= 1\n+        }\n+\n+        when: \"Src switch is only left with the other management controller (no stats controllers)\"\n+        lockKeeper.reviveSwitch(srcSwitch, blockData)\n+        regionToStay = srcSwitch.regions.find { flHelper.getFlByRegion(it).mode == RW && it != regionToStay }\n+        blockData = lockKeeper.knockoutSwitch(srcSwitch, srcSwitch.regions - regionToStay)\n+\n+        and: \"Generate traffic on the given flow\"\n+        exam.setResources(traffExam.startExam(exam, true))\n+        assert traffExam.waitExam(exam).hasTraffic()\n+\n+        then: \"Stat on the src switch should be collected (second RW switch available)\"\n+        def newStats\n+        //first 60 seconds - trying to retrieve stats from management controller, next 60 seconds from stat controller\n+        Wrappers.wait(statsRouterInterval * 2 + WAIT_OFFSET, waitInterval) {\n+            newStats = otsdb.query(startTime, metric, tags).dps\n+            assert newStats.size() > initStats.size()\n+            assert newStats.entrySet()[-2].value < newStats.entrySet()[-1].value\n+        }\n+\n+        when: \"Set only 1 statistic controller on the src switch and disconnect from management\"\n+        initStats = newStats\n+        lockKeeper.reviveSwitch(srcSwitch, blockData)\n+        regionToStay = srcSwitch.regions.find { flHelper.getFlByRegion(it).mode == RO }\n+        blockData = lockKeeper.knockoutSwitch(srcSwitch, srcSwitch.regions - regionToStay)\n+\n+        and: \"Generate traffic on the given flow\"\n+        exam.setResources(traffExam.startExam(exam, true))\n+        assert traffExam.waitExam(exam).hasTraffic()\n+\n+        then: \"Stat on the src switch should be collected (1 RO switch available)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU0OTA5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/stats/MflStatSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0Mzo0NlrOG-2CqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo0Mzo0NlrOG-2CqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1MDMxMg==", "bodyText": "@Tidy?", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468550312", "createdAt": "2020-08-11T12:43:46Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/stats/MflStatSpec.groovy", "diffHunk": "@@ -238,4 +241,105 @@ class MflStatSpec extends HealthCheckSpecification {\n             flowHelperV2.deleteFlow(flow.flowId)\n         }\n     }\n+\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    def \"System is able to collect stats if at least 1 stats or management controller is available\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU3NjE5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/config/DefaultServiceConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1MTowMlrOG-2TTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1MTowMlrOG-2TTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1NDU3Mw==", "bodyText": "floodlght.modes is missed", "url": "https://github.com/telstra/open-kilda/pull/3645#discussion_r468554573", "createdAt": "2020-08-11T12:51:02Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/config/DefaultServiceConfig.java", "diffHunk": "@@ -85,30 +87,34 @@ public RestTemplate traffExamRestTemplate() {\n     public Map<String, RestTemplate> lockKeeperRestTemplates(\n             @Value(\"${lockkeeper.port}\") Integer lockKeeperPort,\n             @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n-            @Value(\"#{'${floodlight.controllers.management.endpoints}'.split(',')}\") List<String> mgmtFloodlights) {\n+            @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> flEndpoints) {\n         Map<String, RestTemplate> result = new HashMap<>();\n-        for (int i = 0; i < mgmtFloodlights.size(); i++) {\n-            String lockKeeperEndpoint = mgmtFloodlights.get(i)\n+        for (int i = 0; i < flEndpoints.size(); i++) {\n+            String lockKeeperEndpoint = flEndpoints.get(i)\n                     .replaceFirst(\"(.*):\\\\d+\", \"$1:\" + lockKeeperPort);\n             result.put(regions.get(i), buildLoggingRestTemplate(lockKeeperEndpoint));\n         }\n         return result;\n     }\n \n-    @Bean(name = \"managementFloodlights\")\n-    public List<FloodlightService> managementFloodlights(\n-            @Value(\"#{'${floodlight.controllers.management.endpoints}'.split(',')}\") List<String> mgmtFloodlights) {\n-        List<FloodlightService> services = new ArrayList<>();\n-        mgmtFloodlights.forEach(f -> services.add(new FloodlightServiceImpl(f)));\n-        return services;\n-    }\n-\n-    @Bean(name = \"statsFloodlights\")\n-    public List<FloodlightService> statsFloodlights(\n-            @Value(\"#{'${floodlight.controllers.stat.endpoints}'.split(',')}\") List<String> mgmtFloodlights) {\n-        List<FloodlightService> services = new ArrayList<>();\n-        mgmtFloodlights.forEach(f -> services.add(new FloodlightServiceImpl(f)));\n-        return services;\n+    @Bean\n+    public List<Floodlight> floodlights(@Value(\"#{'${floodlight.openflows}'.split(',')}\") List<String> openflows,\n+                                        @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> endpoints,\n+                                        @Value(\"#{'${floodlight.containers}'.split(',')}\") List<String> containers,\n+                                        @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n+                                        @Value(\"#{'${floodlight.modes}'.split(',')}\") List<String> modes) {\n+        if (openflows.size() != endpoints.size() || openflows.size() != containers.size()\n+                || openflows.size() != regions.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "985622c91545826dbf31e19ed1c347f2683a42db"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1781, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}