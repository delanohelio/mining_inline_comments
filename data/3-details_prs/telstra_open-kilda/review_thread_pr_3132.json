{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MzY1Mjcw", "number": 3132, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0MjowNlrODaIAlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMToxMzo1OVrODaIj7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIwNzkwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0MjowNlrOFg5yIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTozMzoxNlrOFg7Gcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0NTQ3Mg==", "bodyText": "I guess we can omit it.reversed", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370045472", "createdAt": "2020-01-23T10:42:06Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2NzA1OA==", "bodyText": "When looking for islToBreak i want to consider isls in both directions, since I don't want its 'srcSwitch' part to be equal to switchToBreak. For example, if it happens that there is only 1 islToBreak that works for me and its srcSwitch equals to switchToBreak, then I will pick reversed version of this isl", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370067058", "createdAt": "2020-01-23T11:33:16Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0NTQ3Mg=="}, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzIyNTA1OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0NzoyOVrOFg58Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNDo0MTo0NFrOFhAkIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODA3NA==", "bodyText": "how about checking that flowPath is the same as mainPath?", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370048074", "createdAt": "2020-01-23T10:47:29Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1NjU3OA==", "bodyText": "added, but I don't really see how it can be different from mainPath. we are not testing our 'makePathMorePreferable' here", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370156578", "createdAt": "2020-01-23T14:41:44Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODA3NA=="}, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI5MzY1OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMToxMjozOFrOFg6mWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNDo0MjozNVrOFhAmTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1ODg0Mw==", "bodyText": "misconfigured ?", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370058843", "createdAt": "2020-01-23T11:12:38Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1NzEzNQ==", "bodyText": "added", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370157135", "createdAt": "2020-01-23T14:42:35Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1ODg0Mw=="}, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzI5ODM3OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMToxMzo1OVrOFg6o6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNDo0NDoyN1rOFhAqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1OTQ5Nw==", "bodyText": "northbound.deleteLinkProps(northbound.getAllLinkProps())", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370059497", "createdAt": "2020-01-23T11:13:59Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])\n+        }\n+\n+        cleanup:\n+        if(switchIsOut) {\n+            database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.INACTIVE)\n+            lockKeeper.reviveSwitch(switchToBreak)\n+            Wrappers.wait(WAIT_OFFSET) {\n+                assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.ACTIVATED\n+            }\n+        }\n+        if(portDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+                assert northbound.getLink(islToBreak).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        flow && flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1ODI4Mw==", "bodyText": "added", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370158283", "createdAt": "2020-01-23T14:44:27Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])\n+        }\n+\n+        cleanup:\n+        if(switchIsOut) {\n+            database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.INACTIVE)\n+            lockKeeper.reviveSwitch(switchToBreak)\n+            Wrappers.wait(WAIT_OFFSET) {\n+                assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.ACTIVATED\n+            }\n+        }\n+        if(portDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+                assert northbound.getLink(islToBreak).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        flow && flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1OTQ5Nw=="}, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2070, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}