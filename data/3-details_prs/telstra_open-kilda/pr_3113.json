{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNjc2MzUx", "number": 3113, "title": "Add test for #3087", "bodyText": "Partially covers #3087", "createdAt": "2020-01-14T14:51:58Z", "url": "https://github.com/telstra/open-kilda/pull/3113", "merged": true, "mergeCommit": {"oid": "e65c424ab69b109259413294cd2cf8846d1dd174"}, "closed": true, "closedAt": "2020-02-04T10:49:59Z", "author": {"login": "rtretyak"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6TeJuABqjI5NDc3MzUwOTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcA_SCOABqjMwMDU1OTYxNTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2becc1c658f074bb7fba113e5cf3f95f75a067b6", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/2becc1c658f074bb7fba113e5cf3f95f75a067b6", "committedDate": "2020-01-14T14:50:52Z", "message": "Add test for #3087"}, "afterCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/835a9d512942ea75eff14ef1a2788924e2edd2f2", "committedDate": "2020-01-14T16:23:26Z", "message": "Add test for #3087"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDcyNTE4", "url": "https://github.com/telstra/open-kilda/pull/3113#pullrequestreview-343072518", "createdAt": "2020-01-15T09:10:43Z", "commit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxMDo0M1rOFdxZWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxMDo0M1rOFdxZWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MjMzMQ==", "bodyText": "northbound.portUp(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\nnorthbound.portUp(commonIsl.srcSwitch.dpId, commonIsl.srcPort)", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366762331", "createdAt": "2020-01-15T09:10:43Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDc4MjQy", "url": "https://github.com/telstra/open-kilda/pull/3113#pullrequestreview-343078242", "createdAt": "2020-01-15T09:20:09Z", "commit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyMDowOVrOFdxqgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyMDowOVrOFdxqgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NjcyMw==", "bodyText": "flow && flowHelperV2.deleteFlow(flow.flowId)", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366766723", "createdAt": "2020-01-15T09:20:09Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/835a9d512942ea75eff14ef1a2788924e2edd2f2", "committedDate": "2020-01-14T16:23:26Z", "message": "Add test for #3087"}, "afterCommit": {"oid": "95753697ad5723676106e7d66a21af267e497c5e", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/95753697ad5723676106e7d66a21af267e497c5e", "committedDate": "2020-01-15T13:33:03Z", "message": "Add test for #3087"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95753697ad5723676106e7d66a21af267e497c5e", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/95753697ad5723676106e7d66a21af267e497c5e", "committedDate": "2020-01-15T13:33:03Z", "message": "Add test for #3087"}, "afterCommit": {"oid": "9684193465abc8e39c152d5b3fa5008733c320cf", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/9684193465abc8e39c152d5b3fa5008733c320cf", "committedDate": "2020-01-15T14:16:41Z", "message": "Add test for #3087"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTkxMzM2", "url": "https://github.com/telstra/open-kilda/pull/3113#pullrequestreview-347191336", "createdAt": "2020-01-23T10:24:13Z", "commit": {"oid": "9684193465abc8e39c152d5b3fa5008733c320cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9684193465abc8e39c152d5b3fa5008733c320cf", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/9684193465abc8e39c152d5b3fa5008733c320cf", "committedDate": "2020-01-15T14:16:41Z", "message": "Add test for #3087"}, "afterCommit": {"oid": "c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "committedDate": "2020-01-27T15:13:48Z", "message": "Add test for #3087"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97f7ecc695c1ca1bb22708484ec481b39948435", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/d97f7ecc695c1ca1bb22708484ec481b39948435", "committedDate": "2020-02-04T10:49:32Z", "message": "Add test for #3087"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "committedDate": "2020-01-27T15:13:48Z", "message": "Add test for #3087"}, "afterCommit": {"oid": "d97f7ecc695c1ca1bb22708484ec481b39948435", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/d97f7ecc695c1ca1bb22708484ec481b39948435", "committedDate": "2020-02-04T10:49:32Z", "message": "Add test for #3087"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3684, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}