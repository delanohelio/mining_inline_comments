{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNjgxOTQy", "number": 3500, "title": "Server42 Part 2 DPDK", "bodyText": "First here #3436\nContain:\n\nServer 42 cpp dpdk application", "createdAt": "2020-05-25T10:42:15Z", "url": "https://github.com/telstra/open-kilda/pull/3500", "merged": true, "mergeCommit": {"oid": "604430639b6bb53be0be2748fc0b45dbf68432e1"}, "closed": true, "closedAt": "2020-06-05T13:10:03Z", "author": {"login": "nikitamarchenko"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABck1QdRABqjMzNzExMTI4OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoSZmDABqjM0MTEyMjgxNzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67345203c7856a4375b5576639ab099935dee113", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/67345203c7856a4375b5576639ab099935dee113", "committedDate": "2020-05-25T10:33:33Z", "message": "Server42 Part 2 DPDK"}, "afterCommit": {"oid": "c3f3532161e637603f16a37753cfdc22da8e4823", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/c3f3532161e637603f16a37753cfdc22da8e4823", "committedDate": "2020-05-25T19:29:56Z", "message": "Server42 Part 2 DPDK"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3f3532161e637603f16a37753cfdc22da8e4823", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/c3f3532161e637603f16a37753cfdc22da8e4823", "committedDate": "2020-05-25T19:29:56Z", "message": "Server42 Part 2 DPDK"}, "afterCommit": {"oid": "da5be7fd6d60b416a091c89d9a997a31a9dd4a26", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/da5be7fd6d60b416a091c89d9a997a31a9dd4a26", "committedDate": "2020-05-26T09:45:35Z", "message": "Server42 Part 2 DPDK"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da5be7fd6d60b416a091c89d9a997a31a9dd4a26", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/da5be7fd6d60b416a091c89d9a997a31a9dd4a26", "committedDate": "2020-05-26T09:45:35Z", "message": "Server42 Part 2 DPDK"}, "afterCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/7150720510bbea95a8230c8d63a81c7db787c889", "committedDate": "2020-05-28T09:12:43Z", "message": "Server42 Part 2 DPDK"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjU4MDM1", "url": "https://github.com/telstra/open-kilda/pull/3500#pullrequestreview-420658035", "createdAt": "2020-05-29T05:18:25Z", "commit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwODE3Njkz", "url": "https://github.com/telstra/open-kilda/pull/3500#pullrequestreview-420817693", "createdAt": "2020-05-29T10:01:42Z", "commit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwOTEwODgz", "url": "https://github.com/telstra/open-kilda/pull/3500#pullrequestreview-420910883", "createdAt": "2020-05-29T12:36:45Z", "commit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjozNjo0NVrOGca3mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjo1MDozMVrOGcbTLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MzUyOA==", "bodyText": "Intel forever (r) :)", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r432453528", "createdAt": "2020-05-29T12:36:45Z", "author": {"login": "surabujin"}, "path": "src-cpp/server42/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,134 @@\n+cmake_minimum_required(VERSION 3.14.5 FATAL_ERROR)\n+\n+project(server42 LANGUAGES CXX)\n+\n+set(CMAKE_CXX_STANDARD 17)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n+set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+\n+if (NOT CMAKE_BUILD_TYPE)\n+    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\n+endif ()\n+\n+message(STATUS \"Build type set to ${CMAKE_BUILD_TYPE}\")\n+\n+# https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html\n+# https://wiki.gentoo.org/wiki/GCC_optimization\n+if(CMAKE_BUILD_TYPE MATCHES Debug)\n+    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O0 -march=native -Wall -Wextra -Wno-unused-parameter -ggdb -msse -msse2 -msse3 -msse4.1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1NTU4Nw==", "bodyText": "Should it be ${BOOST_COMPONENTS_REQUIRED}?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r432455587", "createdAt": "2020-05-29T12:40:44Z", "author": {"login": "surabujin"}, "path": "src-cpp/server42/CMakeLists.txt", "diffHunk": "@@ -0,0 +1,134 @@\n+cmake_minimum_required(VERSION 3.14.5 FATAL_ERROR)\n+\n+project(server42 LANGUAGES CXX)\n+\n+set(CMAKE_CXX_STANDARD 17)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n+set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+\n+if (NOT CMAKE_BUILD_TYPE)\n+    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\n+endif ()\n+\n+message(STATUS \"Build type set to ${CMAKE_BUILD_TYPE}\")\n+\n+# https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html\n+# https://wiki.gentoo.org/wiki/GCC_optimization\n+if(CMAKE_BUILD_TYPE MATCHES Debug)\n+    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O0 -march=native -Wall -Wextra -Wno-unused-parameter -ggdb -msse -msse2 -msse3 -msse4.1\")\n+else()\n+    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O3 -march=native -Wall -Wextra -Wno-unused-parameter -g -ggdb -msse -msse2 -msse3 -msse4.1\")\n+endif()\n+\n+message(STATUS \"CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS}\")\n+\n+\n+set_property(DIRECTORY PROPERTY EP_BASE ${CMAKE_BINARY_DIR}/subprojects)\n+\n+set(STAGED_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/stage)\n+message(STATUS \"${PROJECT_NAME} staged install: ${STAGED_INSTALL_PREFIX}\")\n+\n+list(APPEND BOOST_COMPONENTS_REQUIRED filesystem system atomic log stacktrace test program_options context)\n+set(Boost_MINIMUM_REQUIRED 1.71.0)\n+\n+\n+add_subdirectory(external/upstream)\n+\n+find_package(Boost\n+        ${Boost_MINIMUM_REQUIRED}\n+        COMPONENTS\n+        atomic log test_exec_monitor stacktrace_basic stacktrace_backtrace program_options context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MDU5MQ==", "bodyText": "markdown join this all in one line... As for me it (and all other shell blocks) should be wrapped into code block", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r432460591", "createdAt": "2020-05-29T12:50:31Z", "author": {"login": "surabujin"}, "path": "src-cpp/server42/README.md", "diffHunk": "@@ -0,0 +1,34 @@\n+# TBD\n+\n+# pipework\n+from https://github.com/jpetazzo/pipework\n+wget https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework && chmod +x pipework\n+\n+# how to run\n+docker run -it --privileged -v /sys/bus/pci/drivers:/sys/bus/pci/drivers -v /sys/kernel/mm/hugepages:/sys/kernel/mm/hugepages -v /sys/devices/system/node:/sys/devices/system/node -v /dev:/dev --name server42-dpdk kilda/server42dpdk:latest\n+\n+# python script for calc cores mask\n+hex(int('1111', 2)) = 0xf\n+\n+# check memory channels for -m option of EAL\n+sudo dmidecode | grep Interleaved -- memory channels\n+\n+# connect to kilda setup\n+sudo ./pipework br_kilda_int  -i eth1 server42-dpdk    10.0.77.2/24", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjIyNTc2", "url": "https://github.com/telstra/open-kilda/pull/3500#pullrequestreview-424222576", "createdAt": "2020-06-04T08:36:16Z", "commit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODozNjoxNlrOGe7jHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTowMjozMlrOGe8g-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NjExMQ==", "bodyText": "why is it error?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435086111", "createdAt": "2020-06-04T08:36:16Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/Control.cpp", "diffHunk": "@@ -0,0 +1,129 @@\n+#include \"Control.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include \"control.pb.h\"\n+\n+#include \"PacketGenerator.h\"\n+\n+namespace org::openkilda {\n+\n+    using CommandPacket = server42::control::messaging::flowrtt::CommandPacket;\n+    using CommandPacketResponse = server42::control::messaging::flowrtt::CommandPacketResponse;\n+    using Command = server42::control::messaging::flowrtt::CommandPacket_Type;\n+    using AddFlow = server42::control::messaging::flowrtt::AddFlow;\n+    using RemoveFlow = server42::control::messaging::flowrtt::RemoveFlow;\n+    using Error = server42::control::messaging::flowrtt::Error;\n+    using Flow = server42::control::messaging::flowrtt::Flow;\n+\n+    buffer_t trivial_response_from(const CommandPacket &command_packet) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(command_packet.communication_id());\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    buffer_t error_response_from(boost::int64_t communication_id, const std::string &what) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(communication_id);\n+        Error error;\n+        error.set_what(what);\n+        response.add_error()->PackFrom(error);\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    void add_flow(AddFlow &addFlow, flow_pool_t &flow_pool, pcpp::DpdkDevice *device) {\n+\n+        BOOST_LOG_TRIVIAL(error) << \"add_flow\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NjkwMg==", "bodyText": "why?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435086902", "createdAt": "2020-06-04T08:37:25Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/Control.cpp", "diffHunk": "@@ -0,0 +1,129 @@\n+#include \"Control.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include \"control.pb.h\"\n+\n+#include \"PacketGenerator.h\"\n+\n+namespace org::openkilda {\n+\n+    using CommandPacket = server42::control::messaging::flowrtt::CommandPacket;\n+    using CommandPacketResponse = server42::control::messaging::flowrtt::CommandPacketResponse;\n+    using Command = server42::control::messaging::flowrtt::CommandPacket_Type;\n+    using AddFlow = server42::control::messaging::flowrtt::AddFlow;\n+    using RemoveFlow = server42::control::messaging::flowrtt::RemoveFlow;\n+    using Error = server42::control::messaging::flowrtt::Error;\n+    using Flow = server42::control::messaging::flowrtt::Flow;\n+\n+    buffer_t trivial_response_from(const CommandPacket &command_packet) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(command_packet.communication_id());\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    buffer_t error_response_from(boost::int64_t communication_id, const std::string &what) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(communication_id);\n+        Error error;\n+        error.set_what(what);\n+        response.add_error()->PackFrom(error);\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    void add_flow(AddFlow &addFlow, flow_pool_t &flow_pool, pcpp::DpdkDevice *device) {\n+\n+        BOOST_LOG_TRIVIAL(error) << \"add_flow\";\n+\n+        if (server42::control::messaging::flowrtt::Flow_EncapsulationType_VXLAN ==\n+            addFlow.flow().transit_encapsulation_type()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQyOQ==", "bodyText": "how encapsulation_type differs from transit_encapsulation type?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435087429", "createdAt": "2020-06-04T08:38:12Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/Control.cpp", "diffHunk": "@@ -0,0 +1,129 @@\n+#include \"Control.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include \"control.pb.h\"\n+\n+#include \"PacketGenerator.h\"\n+\n+namespace org::openkilda {\n+\n+    using CommandPacket = server42::control::messaging::flowrtt::CommandPacket;\n+    using CommandPacketResponse = server42::control::messaging::flowrtt::CommandPacketResponse;\n+    using Command = server42::control::messaging::flowrtt::CommandPacket_Type;\n+    using AddFlow = server42::control::messaging::flowrtt::AddFlow;\n+    using RemoveFlow = server42::control::messaging::flowrtt::RemoveFlow;\n+    using Error = server42::control::messaging::flowrtt::Error;\n+    using Flow = server42::control::messaging::flowrtt::Flow;\n+\n+    buffer_t trivial_response_from(const CommandPacket &command_packet) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(command_packet.communication_id());\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    buffer_t error_response_from(boost::int64_t communication_id, const std::string &what) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(communication_id);\n+        Error error;\n+        error.set_what(what);\n+        response.add_error()->PackFrom(error);\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    void add_flow(AddFlow &addFlow, flow_pool_t &flow_pool, pcpp::DpdkDevice *device) {\n+\n+        BOOST_LOG_TRIVIAL(error) << \"add_flow\";\n+\n+        if (server42::control::messaging::flowrtt::Flow_EncapsulationType_VXLAN ==\n+            addFlow.flow().transit_encapsulation_type()) {\n+            BOOST_LOG_TRIVIAL(error) << \"VXLAN as transit is not supported, skip add_flow'\";\n+            return;\n+        }\n+\n+        if (server42::control::messaging::flowrtt::Flow_EncapsulationType_VXLAN ==\n+            addFlow.flow().encapsulation_type()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5MzcyMw==", "bodyText": "blows mind after java:-p", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435093723", "createdAt": "2020-06-04T08:48:58Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/Control.cpp", "diffHunk": "@@ -0,0 +1,129 @@\n+#include \"Control.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include \"control.pb.h\"\n+\n+#include \"PacketGenerator.h\"\n+\n+namespace org::openkilda {\n+\n+    using CommandPacket = server42::control::messaging::flowrtt::CommandPacket;\n+    using CommandPacketResponse = server42::control::messaging::flowrtt::CommandPacketResponse;\n+    using Command = server42::control::messaging::flowrtt::CommandPacket_Type;\n+    using AddFlow = server42::control::messaging::flowrtt::AddFlow;\n+    using RemoveFlow = server42::control::messaging::flowrtt::RemoveFlow;\n+    using Error = server42::control::messaging::flowrtt::Error;\n+    using Flow = server42::control::messaging::flowrtt::Flow;\n+\n+    buffer_t trivial_response_from(const CommandPacket &command_packet) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(command_packet.communication_id());\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    buffer_t error_response_from(boost::int64_t communication_id, const std::string &what) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(communication_id);\n+        Error error;\n+        error.set_what(what);\n+        response.add_error()->PackFrom(error);\n+        std::vector<boost::uint8_t> result(response.ByteSizeLong());\n+        response.SerializeToArray(result.data(), result.size());\n+        return result;\n+    }\n+\n+    void add_flow(AddFlow &addFlow, flow_pool_t &flow_pool, pcpp::DpdkDevice *device) {\n+\n+        BOOST_LOG_TRIVIAL(error) << \"add_flow\";\n+\n+        if (server42::control::messaging::flowrtt::Flow_EncapsulationType_VXLAN ==\n+            addFlow.flow().transit_encapsulation_type()) {\n+            BOOST_LOG_TRIVIAL(error) << \"VXLAN as transit is not supported, skip add_flow'\";\n+            return;\n+        }\n+\n+        if (server42::control::messaging::flowrtt::Flow_EncapsulationType_VXLAN ==\n+            addFlow.flow().encapsulation_type()) {\n+            BOOST_LOG_TRIVIAL(error) <<\"VXLAN is not supported, skip add_flow'\";\n+            return;\n+        }\n+\n+        FlowCreateArgument arg = {\n+                .flow_pool = flow_pool,\n+                .device = device,\n+                .dst_mac = addFlow.flow().dst_mac(),\n+                .tunnel_id = addFlow.flow().tunnel_id(),\n+                .transit_tunnel_id = addFlow.flow().transit_tunnel_id(),\n+                .udp_src_port = addFlow.flow().udp_src_port(),\n+                .flow_id = addFlow.flow().flow_id(),\n+                .direction = addFlow.flow().direction()\n+        };\n+\n+        generate_and_add_packet_for_flow(arg);\n+    }\n+\n+\n+    void remove_flow(org::openkilda::server42::control::messaging::flowrtt::RemoveFlow &remove_flow,\n+                     org::openkilda::flow_pool_t &flow_pool) {\n+        flow_pool.remove_flow(remove_flow.flow().flow_id());\n+    }\n+\n+\n+    buffer_t get_list_flows(boost::int64_t communication_id, flow_pool_t &pool) {\n+        CommandPacketResponse response;\n+        response.set_communication_id(communication_id);\n+\n+        for (const std::string &flow_id : pool.get_flowid_table()) {\n+            Flow flow;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5ODcwOA==", "bodyText": "why src is masked?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435098708", "createdAt": "2020-06-04T08:57:20Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/PacketGenerator.cpp", "diffHunk": "@@ -0,0 +1,60 @@\n+#include \"PacketGenerator.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include <pcapplusplus/EthLayer.h>\n+#include <pcapplusplus/VlanLayer.h>\n+#include <pcapplusplus/UdpLayer.h>\n+#include <pcapplusplus/IPv4Layer.h>\n+#include <pcapplusplus/PayloadLayer.h>\n+\n+#include \"Payload.h\"\n+\n+namespace org::openkilda {\n+\n+    void generate_and_add_packet_for_flow(const FlowCreateArgument& arg) {\n+\n+        pcpp::Packet newPacket(64);\n+\n+        pcpp::MacAddress dst(arg.dst_mac);\n+        pcpp::MacAddress src(arg.device->getMacAddress());\n+        pcpp::EthLayer newEthernetLayer(src, dst);\n+        newPacket.addLayer(&newEthernetLayer);\n+\n+        uint16_t nextType = arg.tunnel_id ? PCPP_ETHERTYPE_VLAN : PCPP_ETHERTYPE_IP;\n+\n+        pcpp::VlanLayer newVlanLayer(arg.transit_tunnel_id, false, 1, nextType);\n+        if (arg.transit_tunnel_id) {\n+            newPacket.addLayer(&newVlanLayer);\n+        }\n+\n+        pcpp::VlanLayer newVlanLayer2(arg.tunnel_id, false, 1, PCPP_ETHERTYPE_IP);\n+        if (arg.tunnel_id) {\n+            newPacket.addLayer(&newVlanLayer2);\n+        }\n+\n+        pcpp::IPv4Layer newIPLayer(pcpp::IPv4Address(std::string(\"192.168.0.1/24\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMTYyMw==", "bodyText": "how heavy this parse is? Since packets are predefined, does it make sence to work with offesets in buf instead of packet?", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435101623", "createdAt": "2020-06-04T09:02:02Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/Workers.cpp", "diffHunk": "@@ -0,0 +1,324 @@\n+#include \"Workers.h\"\n+\n+#include <cstdint>\n+#include <chrono>\n+#include <map>\n+#include <random>\n+\n+#include <netinet/in.h>\n+\n+#include <boost/atomic.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <boost/log/trivial.hpp>\n+#include <boost/format.hpp>\n+\n+#include <rte_branch_prediction.h>\n+#include <rte_ring.h>\n+#include <rte_mbuf.h>\n+\n+#include <pcapplusplus/UdpLayer.h>\n+#include <pcapplusplus/MBufRawPacket.h>\n+#include <pcapplusplus/DpdkDevice.h>\n+#include <pcapplusplus/EthLayer.h>\n+\n+#include <zmq.hpp>\n+\n+#include \"statistics.pb.h\"\n+\n+#include \"Config.h\"\n+#include \"Payload.h\"\n+\n+\n+namespace org::openkilda {\n+\n+    bool write_thread(boost::atomic<bool> &alive,\n+                      pcpp::DpdkDevice* device,\n+                      org::openkilda::flow_pool_t& m_pool,\n+                      std::mutex& m_pool_guard) {\n+\n+        const uint64_t cycles_in_one_second = rte_get_timer_hz();\n+        const uint64_t cycles_in_500_ms = cycles_in_one_second / 2;\n+\n+        while (alive.load()) {\n+            try {\n+                BOOST_LOG_TRIVIAL(info) << \"tick pool_size: \" << m_pool.table.size();\n+\n+                uint64_t start_tsc = rte_get_timer_cycles();\n+                {\n+                    std::lock_guard<std::mutex> guard(m_pool_guard);\n+                    pcpp::MBufRawPacket **start = m_pool.table.data();\n+                    pcpp::MBufRawPacket **end = start + m_pool.table.size();\n+\n+                    const auto chunk_size = long(Config::chunk_size);\n+                    uint_fast8_t error_count = 0;\n+                    for (pcpp::MBufRawPacket **pos = start; pos < end; pos += chunk_size) {\n+                        uint16_t send = 0;\n+                        uint_fast8_t tries = 0;\n+\n+                        pcpp::MBufRawPacket mbuf_send_buffer[Config::chunk_size];\n+                        pcpp::MBufRawPacket *mbuf_send_buffer_p[Config::chunk_size];\n+\n+                        for (uint_fast8_t i = 0; i < std::min(chunk_size, end - pos); ++i) {\n+                            mbuf_send_buffer[i].initFromRawPacket(*(pos+i), device);\n+                            mbuf_send_buffer_p[i] = &mbuf_send_buffer[i];\n+                            mbuf_send_buffer_p[i]->setFreeMbuf(true);\n+                        }\n+\n+\n+                        while (send != std::min(chunk_size, end - pos)) {\n+                            send = device->sendPackets(mbuf_send_buffer_p, std::min(chunk_size, end - pos), 0, false);\n+                            if (send != std::min(chunk_size, end - pos)) {\n+                                if(++tries > 3) {\n+                                    ++error_count;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        if (error_count > 5) {\n+                            BOOST_LOG_TRIVIAL(error) << \"Errors while send packets, drop send try\";\n+                            break;\n+                        }\n+                    }\n+                }\n+                while (true) {\n+                    uint64_t current_tsc = rte_get_timer_cycles();\n+                    if (unlikely(current_tsc - start_tsc >= cycles_in_500_ms)) {\n+                        break;\n+                    }\n+                }\n+            } catch (std::exception &exception) {\n+                BOOST_LOG_TRIVIAL(error) << \"Error \" << exception.what();\n+            } catch (...) {\n+                BOOST_LOG_TRIVIAL(error) << \"unhandled Error\";\n+            };\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    bool read_thread(\n+            boost::atomic<bool> &alive,\n+            pcpp::DpdkDevice *device,\n+            boost::shared_ptr<rte_ring> ring) {\n+\n+        BOOST_LOG_TRIVIAL(info) << \"read_thread started \";\n+        pcpp::MBufRawPacket mbuf_raw_table[Config::chunk_size];\n+\n+        pcpp::MBufRawPacket *mbuf_raw_ptr_table[Config::chunk_size] = {};\n+\n+        rte_mbuf *mbuf_table[Config::chunk_size] = {};\n+\n+        for (int i = 0; i < Config::chunk_size; ++i) {\n+            mbuf_raw_ptr_table[i] = &mbuf_raw_table[i];\n+            mbuf_raw_ptr_table[i]->setFreeMbuf(false);\n+        }\n+\n+        while (alive.load()) {\n+            const uint32_t table_size = device->receivePackets(mbuf_raw_ptr_table, Config::chunk_size, 0);\n+\n+            if (unlikely(table_size == 0)) {\n+                continue;\n+            }\n+\n+            BOOST_LOG_TRIVIAL(debug) << \"read_thread recived packets \" << table_size;\n+\n+            for (uint32_t i = 0; i < table_size; ++i) {\n+                mbuf_table[i] = mbuf_raw_ptr_table[i]->getMBuf();\n+            }\n+\n+            uint32_t enqueued = rte_ring_sp_enqueue_bulk(ring.get(), reinterpret_cast<void *const *>(mbuf_table), table_size,\n+                                                         nullptr);\n+\n+            if (unlikely(enqueued == 0)) {\n+                //TODO: add_to_statistics\n+                BOOST_LOG_TRIVIAL(error) << \"ring is full discard \" << table_size << \" packets\";\n+                for (uint32_t i = 0; i < table_size; ++i) {\n+                    mbuf_raw_ptr_table[i]->setFreeMbuf(true);\n+                    mbuf_raw_ptr_table[i]->clear();\n+                    mbuf_raw_ptr_table[i]->setFreeMbuf(false);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    bool process_thread(uint32_t core_id,\n+            boost::atomic<bool> &alive,\n+            boost::shared_ptr<rte_ring> rx_ring,\n+            uint16_t zmq_port,\n+            const pcpp::MacAddress &src_mac) {\n+\n+        using Bucket = server42::stats::messaging::flowrtt::FlowLatencyPacketBucket;\n+\n+        zmq::context_t context(1);\n+        context.setctxopt(ZMQ_THREAD_AFFINITY_CPU_ADD, core_id);\n+        zmq::socket_t socket(context, ZMQ_PUSH);\n+\n+        std::string endpoint = str(boost::format(\"tcp://*:%1%\") % zmq_port);\n+        socket.bind(endpoint);\n+\n+        BOOST_LOG_TRIVIAL(info)\n+            << \"process_thread on core_id: \" << core_id << \" \"\n+            << \"bind zmq socket for push on \" << endpoint;\n+\n+        uint64_t packet_id = 0;\n+        pcpp::Packet dummy_packet;\n+\n+        rte_mbuf *mbuf_table[Config::chunk_size] = {};\n+\n+        void **const mbuf_table_prt = reinterpret_cast<void **>(mbuf_table);\n+        while (alive.load()) {\n+            try {\n+                uint32_t table_size =\n+                        rte_ring_mc_dequeue_bulk(rx_ring.get(), mbuf_table_prt, Config::chunk_size, nullptr);\n+\n+                if (unlikely(table_size == 0)) {\n+                    continue;\n+                }\n+\n+                BOOST_LOG_TRIVIAL(debug) << \"process_thread recived packets \" << table_size;\n+\n+                Bucket bucket;\n+\n+                for (uint32_t i = 0; i < table_size; ++i) {\n+\n+                    // A macro that points to the start of the data in the mbuf.\n+                    const uint8_t *mbuf = rte_pktmbuf_mtod(mbuf_table[i], const uint8_t*);\n+                    pcpp::RawPacket raw_packet(mbuf,\n+                                               rte_pktmbuf_pkt_len(mbuf_table[i]),\n+                                               timeval(),\n+                                               false,\n+                                               pcpp::LINKTYPE_ETHERNET);\n+\n+                    pcpp::Packet parsed_packet(&raw_packet);\n+\n+                    auto eth = parsed_packet.getLayerOfType<pcpp::EthLayer>();\n+                    auto udp = parsed_packet.getLayerOfType<pcpp::UdpLayer>();\n+\n+                    if (likely(eth->getDestMac() == src_mac && udp)) {\n+                        if (udp->getLayerPayloadSize() == sizeof(Payload)) {\n+                            packet_id++;\n+                            auto payload = reinterpret_cast<const org::openkilda::Payload *>(udp->getLayerPayload());\n+                            auto packet = bucket.add_packet();\n+\n+                            BOOST_LOG_TRIVIAL(debug) << \"flow_id: \" << payload->flow_id << \" \"\n+                                                     << \"t0 raw: \" << payload->t0 << \" \"\n+                                                     << \"t1 raw: \" << payload->t1 << \" \"\n+                                                     << \"t0: \" << be64toh(payload->t0) << \" \"\n+                                                     << \"t1: \" << be64toh(payload->t1) << \" \"\n+                                                     << \"packet_id: \" << packet_id << \" \"\n+                                                     << \"direction: \" << payload->direction;\n+\n+                            packet->set_flow_id(payload->flow_id);\n+                            packet->set_t0(be64toh(payload->t0));\n+                            packet->set_t1(be64toh(payload->t1));\n+                            packet->set_packet_id(packet_id);\n+                            packet->set_direction(payload->direction);\n+                            BOOST_LOG_TRIVIAL(debug) << packet->DebugString();\n+                        } else {\n+                            BOOST_LOG_TRIVIAL(error)\n+                                << \"drop packet by invalid payload size: \" << udp->getLayerPayloadSize() << \" \"\n+                                << \"expected: \" << sizeof(Payload);\n+                        }\n+                    } else {\n+                        if (eth->getDestMac() != src_mac) {\n+                            BOOST_LOG_TRIVIAL(error)\n+                                << \"drop packet by invalid mac dst: \" << eth->getDestMac().toString() << \" \"\n+                                << \"expected :\" << src_mac.toString();\n+                        } else {\n+                            BOOST_LOG_TRIVIAL(error)\n+                                << \"drop packet by missed udp layer\";\n+                        }\n+                    }\n+\n+                    rte_pktmbuf_free(mbuf_table[i]);\n+                }\n+\n+                if (bucket.packet_size()) {\n+\n+                    zmq::message_t message(bucket.ByteSizeLong());\n+                    BOOST_LOG_TRIVIAL(debug) << \"flow_bucket <\" << bucket.DebugString() << \">\";\n+                    bucket.SerializeToArray(message.data(), message.size());\n+\n+                    /*\n+                     * When a ZMQ_PUSH socket enters the mute state due to having reached the high water mark for all\n+                     * downstream nodes, or if there are no downstream nodes at all, then any zmq_send(3) operations on\n+                     * the socket shall block until the mute state ends or at least one downstream node becomes available\n+                     * for sending; messages are not discarded.\n+                     */\n+                    while (!socket.send(message, ZMQ_DONTWAIT) && alive) {}\n+\n+                } else {\n+                    BOOST_LOG_TRIVIAL(info) << \"flow_bucket packet_size==0 \" << bucket.DebugString() << \"\\n\" << std::flush;\n+                }\n+\n+            } catch (zmq::error_t &exception) {\n+                BOOST_LOG_TRIVIAL(error) << \"ZMQ Error \" << exception.what();\n+            } catch (std::exception &exception) {\n+                BOOST_LOG_TRIVIAL(error) << \"Error \" << exception.what();\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    bool echo_thread(boost::atomic<bool> &alive,\n+                     pcpp::DpdkDevice* device) {\n+\n+        pcpp::MBufRawPacket *rx_mbuf[Config::chunk_size] = {};\n+\n+        const pcpp::MacAddress src(device->getMacAddress());\n+\n+        std::map<std::string, uint64_t> fake_duration;\n+        std::random_device rd{};\n+        std::uniform_int_distribution<int> base_latency(10000, 20000);\n+        std::uniform_int_distribution<int> random_latency(0, 1000);\n+\n+\n+        while (alive.load()) {\n+            uint16_t num_of_packets = device->receivePackets(rx_mbuf, Config::chunk_size, 0);\n+\n+            for (uint16_t i = 0; i < num_of_packets; ++i) {\n+\n+                pcpp::Packet parsed_packet(rx_mbuf[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMTk0Ng==", "bodyText": "what?:)", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435101946", "createdAt": "2020-06-04T09:02:32Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/control.proto", "diffHunk": "@@ -0,0 +1,59 @@\n+syntax = \"proto3\";\n+\n+package org.openkilda.server42.control.messaging.flowrtt;\n+\n+import \"google/protobuf/any.proto\";\n+\n+message Flow {\n+    string flow_id = 1;\n+    enum EncapsulationType {\n+        VLAN = 0;\n+        VXLAN = 1;\n+    }\n+    EncapsulationType encapsulation_type = 2;\n+    int64 tunnel_id = 3;\n+    EncapsulationType transit_encapsulation_type = 4;\n+    int64 transit_tunnel_id = 5;\n+    bool direction = 6;\n+    string dst_mac = 7;\n+    int64 udp_src_port = 8;\n+}\n+\n+message CommandPacket {\n+    enum Type {\n+        ADD_FLOW = 0;\n+        REMOVE_FLOW = 1;\n+        CLEAR_FLOWS = 2;\n+        LIST_FLOWS = 3;\n+        PUSH_SETTINGS = 4;\n+    }\n+    int64 communication_id = 1;\n+    Type type = 2;\n+    repeated google.protobuf.Any command = 3;\n+}\n+\n+message CommandPacketResponse {\n+    int64 communication_id = 1;\n+    repeated google.protobuf.Any response = 2;\n+    repeated google.protobuf.Any error = 3;\n+}\n+\n+message AddFlow {\n+    Flow flow = 1;\n+}\n+\n+message RemoveFlow {\n+    Flow flow = 1;\n+}\n+\n+message ListFlows {\n+    repeated Flow flow = 1;\n+}\n+\n+message PushSettings {\n+    int32 packet_generation_interval_in_ms = 1;\n+}\n+\n+message Error {\n+    string what = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjU2ODQ2", "url": "https://github.com/telstra/open-kilda/pull/3500#pullrequestreview-424256846", "createdAt": "2020-06-04T09:19:06Z", "commit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxOTowN1rOGe9IgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxOTowN1rOGe9IgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjA2NQ==", "bodyText": "move to const", "url": "https://github.com/telstra/open-kilda/pull/3500#discussion_r435112065", "createdAt": "2020-06-04T09:19:07Z", "author": {"login": "timofei-durakov"}, "path": "src-cpp/server42/src/PacketGenerator.cpp", "diffHunk": "@@ -0,0 +1,60 @@\n+#include \"PacketGenerator.h\"\n+\n+#include <boost/log/trivial.hpp>\n+\n+#include <pcapplusplus/EthLayer.h>\n+#include <pcapplusplus/VlanLayer.h>\n+#include <pcapplusplus/UdpLayer.h>\n+#include <pcapplusplus/IPv4Layer.h>\n+#include <pcapplusplus/PayloadLayer.h>\n+\n+#include \"Payload.h\"\n+\n+namespace org::openkilda {\n+\n+    void generate_and_add_packet_for_flow(const FlowCreateArgument& arg) {\n+\n+        pcpp::Packet newPacket(64);\n+\n+        pcpp::MacAddress dst(arg.dst_mac);\n+        pcpp::MacAddress src(arg.device->getMacAddress());\n+        pcpp::EthLayer newEthernetLayer(src, dst);\n+        newPacket.addLayer(&newEthernetLayer);\n+\n+        uint16_t nextType = arg.tunnel_id ? PCPP_ETHERTYPE_VLAN : PCPP_ETHERTYPE_IP;\n+\n+        pcpp::VlanLayer newVlanLayer(arg.transit_tunnel_id, false, 1, nextType);\n+        if (arg.transit_tunnel_id) {\n+            newPacket.addLayer(&newVlanLayer);\n+        }\n+\n+        pcpp::VlanLayer newVlanLayer2(arg.tunnel_id, false, 1, PCPP_ETHERTYPE_IP);\n+        if (arg.tunnel_id) {\n+            newPacket.addLayer(&newVlanLayer2);\n+        }\n+\n+        pcpp::IPv4Layer newIPLayer(pcpp::IPv4Address(std::string(\"192.168.0.1/24\")),\n+                                   pcpp::IPv4Address(std::string(\"192.168.1.1\")));\n+\n+        newIPLayer.getIPv4Header()->timeToLive = 128;\n+        newPacket.addLayer(&newIPLayer);\n+\n+        pcpp::UdpLayer newUdpLayer(arg.udp_src_port, 58168);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af481a9c5e3d6d367c76c3b987e0797288848cd0", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/af481a9c5e3d6d367c76c3b987e0797288848cd0", "committedDate": "2020-06-05T13:09:05Z", "message": "Server42 Part 2 DPDK"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7150720510bbea95a8230c8d63a81c7db787c889", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/7150720510bbea95a8230c8d63a81c7db787c889", "committedDate": "2020-05-28T09:12:43Z", "message": "Server42 Part 2 DPDK"}, "afterCommit": {"oid": "af481a9c5e3d6d367c76c3b987e0797288848cd0", "author": {"user": {"login": "nikitamarchenko", "name": "Nikita Marchenko"}}, "url": "https://github.com/telstra/open-kilda/commit/af481a9c5e3d6d367c76c3b987e0797288848cd0", "committedDate": "2020-06-05T13:09:05Z", "message": "Server42 Part 2 DPDK"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3571, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}