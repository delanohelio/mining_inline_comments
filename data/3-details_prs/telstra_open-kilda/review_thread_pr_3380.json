{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxODY1MzU5", "number": 3380, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODoyMDowNVrOD0oIrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMjoxOTo0M1rOD0ucqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTEwMTI0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODoyMDowNVrOGJps6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo1Mzo1OVrOGJtzSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3MzYwOQ==", "bodyText": "'two switches' or 'switch pair'", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412773609", "createdAt": "2020-04-22T08:20:05Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MDc3OA==", "bodyText": "two switches", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412840778", "createdAt": "2020-04-22T09:53:59Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3MzYwOQ=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTE2NDkxOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODozMzowN1rOGJqScw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMjo1NjozNVrOGJ078Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4MzIxOQ==", "bodyText": "it will be good to have one more check for this when searching a swPair. Otherwise you can pick 2 switches with parallel isls and no 2+ switch paths", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412783219", "createdAt": "2020-04-22T08:33:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzMTAzNg==", "bodyText": "assumeTrue was added\n\nOtherwise you can pick 2 switches with parallel isls\n\nI guess it is not possible due to it.size() != 2", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412931036", "createdAt": "2020-04-22T12:18:49Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4MzIxOQ=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNTY2Nw==", "bodyText": "allPaths between your two switches are not guaranteed to have a path longer than 2. In this case your findAll will become an empty list. It is the case when two switches have 2 parallel isls and one of the switches don't have other isls.", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412935667", "createdAt": "2020-04-22T12:25:54Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4MzIxOQ=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk1NzY4MQ==", "bodyText": "fixed completely", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412957681", "createdAt": "2020-04-22T12:56:35Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4MzIxOQ=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTIxMzY0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo0MzozMFrOGJqvlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTowOTowNVrOGJwtKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5MDY3OA==", "bodyText": "line above is not adding anything to broughtDownPorts. Moreover, all this is very obfuscated, to be honest I cannot really picture what is happening on lines 137-143. Must be simplified. Work with involvedIsls instead:\ndef otherIsls = allPaths.findAll { it != mainPath && it != protectedPath }.collect { pathHelper.getInvolvedIsls(it).first() }.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\notherIsls.each { antiflap.portDown(it.srcSwitch, it.srcPort) }\n\nsimple, readable, more compact, better result (break all paths, not only alternative ports on src switch)", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412790678", "createdAt": "2020-04-22T08:43:30Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4ODM2Mg==", "bodyText": "refactored\ndef broughtDownPorts = []\ndef otherIsls = []\ndef involvedIsls = (pathHelper.getInvolvedIsls(mainPath) + pathHelper.getInvolvedIsls(protectedPath)).unique()\nallPaths.findAll { it != mainPath && it != protectedPath }.each {\n     pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n         otherIsls.add(it)\n     }\n}\nbroughtDownPorts = otherIsls.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\nbroughtDownPorts.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412888362", "createdAt": "2020-04-22T11:09:05Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5MDY3OA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI0MzM1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo0OToyN1rOGJrBJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo1NzoyMFrOGJt8aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTE3NA==", "bodyText": "dst switch", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412795174", "createdAt": "2020-04-22T08:49:27Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MzExNQ==", "bodyText": "my bad(", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412843115", "createdAt": "2020-04-22T09:57:20Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTE3NA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI0NTkzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1MDowMlrOGJrCvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowMzoyMlrOGJuMlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTU4Mg==", "bodyText": "remove", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412795582", "createdAt": "2020-04-22T08:50:02Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0NzI1Mg==", "bodyText": "what a shame, my fault", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412847252", "createdAt": "2020-04-22T10:03:22Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTU4Mg=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI1ODgzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1MjozOVrOGJrKbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowMToyN1rOGJuHvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NzU0OA==", "bodyText": "I just don't feel that 'Disconnect dst switch' is 'given', and 'Mark the transit switch as ACTIVE in db' is 'when'. Whether make them both 'when' or make them both 'given' or just combine them into 1 step. Not sure why you decide to separate them that much", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412797548", "createdAt": "2020-04-22T08:52:39Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0NjAxMw==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412846013", "createdAt": "2020-04-22T10:01:27Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NzU0OA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI2NzAwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1NDoyM1rOGJrPUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowODo0MVrOGJua3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5ODgwMA==", "bodyText": "retriesAmount?", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412798800", "createdAt": "2020-04-22T08:54:23Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"\n+        Wrappers.wait(WAIT_OFFSET * 2) { // delete 'wait' when 3237 is merged\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        and: \"All involved switches pass switch validation(except dst switch)\"\n+        def involvedSwitchIds = pathHelper.getInvolvedSwitches(protectedPath)[0..-2]*.dpId\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            involvedSwitchIds.each { swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        when: \"Connect dst switch back to the controller\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE) //set real status\n+        switchHelper.reviveSwitch(swPair.dst, blockData)\n+        isSwitchActivated = true\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(discoveryInterval + rerouteDelay) {\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!isSwitchActivated && blockData) {\n+            database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE)\n+            switchHelper.reviveSwitch(swToManipulate, blockData)\n+        }\n+        !broughtDownPorts.empty && broughtDownPorts.every { antiflap.portUp(it.switchId, it.portNo) }\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+\n+        where:\n+        data << [\n+                [\n+                        description: \"update\",\n+                        historyAction: UPDATE_ACTION,\n+                        historySize: 15, //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MDkxMQ==", "bodyText": "ok, let it be", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412850911", "createdAt": "2020-04-22T10:08:41Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"\n+        Wrappers.wait(WAIT_OFFSET * 2) { // delete 'wait' when 3237 is merged\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        and: \"All involved switches pass switch validation(except dst switch)\"\n+        def involvedSwitchIds = pathHelper.getInvolvedSwitches(protectedPath)[0..-2]*.dpId\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            involvedSwitchIds.each { swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        when: \"Connect dst switch back to the controller\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE) //set real status\n+        switchHelper.reviveSwitch(swPair.dst, blockData)\n+        isSwitchActivated = true\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(discoveryInterval + rerouteDelay) {\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!isSwitchActivated && blockData) {\n+            database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE)\n+            switchHelper.reviveSwitch(swToManipulate, blockData)\n+        }\n+        !broughtDownPorts.empty && broughtDownPorts.every { antiflap.portUp(it.switchId, it.portNo) }\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+\n+        where:\n+        data << [\n+                [\n+                        description: \"update\",\n+                        historyAction: UPDATE_ACTION,\n+                        historySize: 15, //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5ODgwMA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI3Mjc3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1NToyOFrOGJrSug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowMzozN1rOGJuNJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5OTY3NA==", "bodyText": "flow", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412799674", "createdAt": "2020-04-22T08:55:28Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0NzM5Ng==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412847396", "createdAt": "2020-04-22T10:03:37Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5OTY3NA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI4NDE0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1Nzo0OFrOGJrZYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowNzo1N1rOGJuY-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMTM3OA==", "bodyText": "I feel like this verification must come before you verify flow paths. Because now you are verifying paths on a flow which is basically still 'in progress', so those path verifications are not quite legal", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412801378", "createdAt": "2020-04-22T08:57:48Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MDQyNQ==", "bodyText": "agree", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412850425", "createdAt": "2020-04-22T10:07:57Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMTM3OA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTI5NDkyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowMDoxMFrOGJrf9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDowODoxOFrOGJuZ6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMzA2Mw==", "bodyText": "pretty tight timeout with no room for actual reroute operations. May be unstable", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412803063", "createdAt": "2020-04-22T09:00:10Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"\n+        Wrappers.wait(WAIT_OFFSET * 2) { // delete 'wait' when 3237 is merged\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        and: \"All involved switches pass switch validation(except dst switch)\"\n+        def involvedSwitchIds = pathHelper.getInvolvedSwitches(protectedPath)[0..-2]*.dpId\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            involvedSwitchIds.each { swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        when: \"Connect dst switch back to the controller\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE) //set real status\n+        switchHelper.reviveSwitch(swPair.dst, blockData)\n+        isSwitchActivated = true\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(discoveryInterval + rerouteDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MDY2Nw==", "bodyText": "agree", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412850667", "createdAt": "2020-04-22T10:08:18Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switch pair with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+\n+        and: \"All alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath && it.first() != protectedPath.first()\n+        }*.first().unique()\n+        // it.size() != 2 -> avoid paths with one link, these links are already added to broughtDownPorts in line above\n+        allPaths.findAll {\n+            it != mainPath && it != protectedPath  && it.last() != protectedPath.last() && it.size() != 2\n+        }*.last().unique().each { broughtDownPorts.add(it) }\n+        broughtDownPorts.each { antiflap.portDown(it.switchId, it.portNo) }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"A protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *   srcSwitch - - - - - dstSwitch <- swToManipulate\n+         *          \\              /\n+         *           \\           /\n+         *           transitSwitch\n+         *\n+         **/\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+        def flowPathInfo = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfo) == mainPath\n+        assert pathHelper.convert(flowPathInfo.protectedPath) == protectedPath\n+\n+        and: \"Disconnect dst switch transit switch on protected path\"\n+        def swToManipulate = swPair.dst\n+        def blockData = switchHelper.knockoutSwitch(swToManipulate, mgmtFlManager)\n+        def isSwitchActivated = false\n+\n+        when: \"Mark the transit switch as ACTIVE in db\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init flow #data.description\"\n+        data.action(flow)\n+\n+        then: \"System retried to #data.description\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getFlowHistory(flow.flowId).findAll {\n+                it.action == data.historyAction\n+            }.last().histories*.details.findAll{ it =~ /.+ Retrying/}.size() == data.historySize\n+            println(data.historySize)\n+        }\n+\n+        then: \"Flows are not rerouted\"\n+        def flowPathInfoAfterSwap = northbound.getFlowPath(flow.flowId)\n+        assert pathHelper.convert(flowPathInfoAfterSwap) == mainPath\n+        assert pathHelper.convert(flowPathInfoAfterSwap.protectedPath) == protectedPath\n+\n+        and: \"Flow is DOWN\"\n+        Wrappers.wait(WAIT_OFFSET * 2) { // delete 'wait' when 3237 is merged\n+            assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        and: \"All involved switches pass switch validation(except dst switch)\"\n+        def involvedSwitchIds = pathHelper.getInvolvedSwitches(protectedPath)[0..-2]*.dpId\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            involvedSwitchIds.each { swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        when: \"Connect dst switch back to the controller\"\n+        database.setSwitchStatus(swToManipulate.dpId, SwitchStatus.INACTIVE) //set real status\n+        switchHelper.reviveSwitch(swPair.dst, blockData)\n+        isSwitchActivated = true\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(discoveryInterval + rerouteDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMzA2Mw=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQxOTAzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzoxMFrOGJsqrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo1NDowNFrOGJtzdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjE5MA==", "bodyText": "to be more specific, we retry rule installation during update/swap", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412822190", "createdAt": "2020-04-22T09:27:10Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MDgyMA==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412840820", "createdAt": "2020-04-22T09:54:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +117,140 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry #data.description if previous one is failed\"(){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjE5MA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQyMzIzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyODoxMFrOGJstaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTo1NDo0OFrOGJt1UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjg4OA==", "bodyText": "remove", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412822888", "createdAt": "2020-04-22T09:28:10Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -1,5 +1,8 @@\n package org.openkilda.functionaltests.spec.resilience\n \n+import static org.openkilda.functionaltests.helpers.SwitchHelper.getNorthbound", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MTI5Nw==", "bodyText": "I forgot that it is already defined in BaseSpecification", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412841297", "createdAt": "2020-04-22T09:54:48Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -1,5 +1,8 @@\n package org.openkilda.functionaltests.spec.resilience\n \n+import static org.openkilda.functionaltests.helpers.SwitchHelper.getNorthbound", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjg4OA=="}, "originalCommit": {"oid": "1a05edd7932b991b081f8ab556c418540edc5b9a"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NjEzNTQ1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMjoxOTo0M1rOGJzWCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMjoyNzowNFrOGJzpaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzMTU5Mw==", "bodyText": "how 'isls' transform into 'ports' by just reducing the isls list? It is still 'brokenIsls' or 'broughtDownIsls' whatever but not 'ports'", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412931593", "createdAt": "2020-04-22T12:19:43Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +118,141 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry rule installation during #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switches with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+        assumeTrue(\"Unable to find a  required protectedPath\", protectedPath as boolean)\n+\n+        and: \"All alternative paths unavailable (bring ports down)\"\n+        def broughtDownPorts = []\n+        def otherIsls = []\n+        def involvedIsls = (pathHelper.getInvolvedIsls(mainPath) + pathHelper.getInvolvedIsls(protectedPath)).unique()\n+        allPaths.findAll { it != mainPath && it != protectedPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                otherIsls.add(it)\n+            }\n+        }\n+        broughtDownPorts = otherIsls.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85fd33511ec2f9d11368fb92c2911d43f0550501"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNjU1Mw==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3380#discussion_r412936553", "createdAt": "2020-04-22T12:27:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -112,4 +118,141 @@ and at least 1 path must remain safe\"\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    @Unroll\n+    def \"System tries to retry rule installation during #data.description if previous one is failed\"(){\n+        given: \"Two active neighboring switches with two diverse paths at least\"\n+        def allPaths\n+        def swPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            allPaths = it.paths\n+            allPaths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        }\n+\n+        List<PathNode> mainPath = allPaths.min { it.size() }\n+        //find path with more than two switches\n+        List<PathNode> protectedPath = allPaths.findAll { it != mainPath && it.size() != 2 }.min { it.size() }\n+        assumeTrue(\"Unable to find a  required protectedPath\", protectedPath as boolean)\n+\n+        and: \"All alternative paths unavailable (bring ports down)\"\n+        def broughtDownPorts = []\n+        def otherIsls = []\n+        def involvedIsls = (pathHelper.getInvolvedIsls(mainPath) + pathHelper.getInvolvedIsls(protectedPath)).unique()\n+        allPaths.findAll { it != mainPath && it != protectedPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                otherIsls.add(it)\n+            }\n+        }\n+        broughtDownPorts = otherIsls.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzMTU5Mw=="}, "originalCommit": {"oid": "85fd33511ec2f9d11368fb92c2911d43f0550501"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1928, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}