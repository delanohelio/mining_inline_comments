{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1Njk4OTQx", "number": 3135, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNToxNzo0MVrODZ3mZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMTowMToyOFrODac6oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NDUxOTQyOnYy", "diffSide": "RIGHT", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNToxNzo0MVrOFgf5mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTozNDozN1rOFg7IqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMTQwMA==", "bodyText": "Pair of ordered lists that represents forward path from start to end and reverse one\nCorrect javadoc for previous method also, please.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r369621400", "createdAt": "2020-01-22T15:17:41Z", "author": {"login": "rozdy"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java", "diffHunk": "@@ -39,6 +39,16 @@\n                                                    WeightFunction weightFunction)\n             throws UnroutableFlowException;\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return an ordered list that represents the path from start to end, or an empty list if no path found.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97335b57d136a498112eb81c01d92cd13e5f2943"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2NzYyNA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370067624", "createdAt": "2020-01-23T11:34:37Z", "author": {"login": "dpoltavets"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java", "diffHunk": "@@ -39,6 +39,16 @@\n                                                    WeightFunction weightFunction)\n             throws UnroutableFlowException;\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return an ordered list that represents the path from start to end, or an empty list if no path found.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMTQwMA=="}, "originalCommit": {"oid": "97335b57d136a498112eb81c01d92cd13e5f2943"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NDU4NTMzOnYy", "diffSide": "RIGHT", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNTozNDoyNFrOFggixg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTozNzo1OVrOFg7NtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk0Mg==", "bodyText": "Algorithm with max weight is very similar to previous one. Maybe we can generalize it using different weight shift and path weight comparison functions to avoid code duplication?", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r369631942", "createdAt": "2020-01-22T15:34:24Z", "author": {"login": "rozdy"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,69 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return An ordered list that represents the path from start to end, or an empty list\n+     */\n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long bestWeight = Long.MAX_VALUE;\n+        SearchNode bestPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < bestWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    bestWeight = shiftedCurrentWeight;\n+                    bestPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {\n+                continue;\n+            }\n+\n+            // Otherwise, if we've been here before, see if this path is better\n+            SearchNode prior = visited.get(current.dstSw);\n+            if (prior != null && shiftedCurrentWeight >= Math.abs(maxWeight - prior.parentWeight)) {\n+                continue;\n+            }\n+\n+            // Either this is the first time, or this one has less weight .. either way, this node should\n+            // be the one in the visited list\n+            visited.put(current.dstSw, current);\n+\n+            // At this stage .. haven't found END, haven't gone too deep, and we are not over weight.\n+            // So, add the outbound isls.\n+            current.dstSw.getOutgoingLinks().stream()\n+                    .sorted(Comparator.comparing(edge -> edge.getDestSwitch().getSwitchId()))\n+                    .forEach(edge -> toVisit.add(current.addNode(edge)));\n+        }\n+\n+        return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97335b57d136a498112eb81c01d92cd13e5f2943"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2ODkxNg==", "bodyText": "Algorithm with max weight looks similar, but we are searching path in another way.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370068916", "createdAt": "2020-01-23T11:37:59Z", "author": {"login": "dpoltavets"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,69 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return An ordered list that represents the path from start to end, or an empty list\n+     */\n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long bestWeight = Long.MAX_VALUE;\n+        SearchNode bestPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < bestWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    bestWeight = shiftedCurrentWeight;\n+                    bestPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {\n+                continue;\n+            }\n+\n+            // Otherwise, if we've been here before, see if this path is better\n+            SearchNode prior = visited.get(current.dstSw);\n+            if (prior != null && shiftedCurrentWeight >= Math.abs(maxWeight - prior.parentWeight)) {\n+                continue;\n+            }\n+\n+            // Either this is the first time, or this one has less weight .. either way, this node should\n+            // be the one in the visited list\n+            visited.put(current.dstSw, current);\n+\n+            // At this stage .. haven't found END, haven't gone too deep, and we are not over weight.\n+            // So, add the outbound isls.\n+            current.dstSw.getOutgoingLinks().stream()\n+                    .sorted(Comparator.comparing(edge -> edge.getDestSwitch().getSwitchId()))\n+                    .forEach(edge -> toVisit.add(current.addNode(edge)));\n+        }\n+\n+        return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk0Mg=="}, "originalCommit": {"oid": "97335b57d136a498112eb81c01d92cd13e5f2943"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDI5NTUzOnYy", "diffSide": "RIGHT", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwODo1Nzo0NlrOFhXM3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTo0NToxMlrOFhYWwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNzQ1Mg==", "bodyText": "here must be current.parentWeight >= maxWeight", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370527452", "createdAt": "2020-01-24T08:57:46Z", "author": {"login": "niksv"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */\n+    private SearchNode getDesiredPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long desiredWeight = Long.MAX_VALUE;\n+        SearchNode desiredPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < desiredWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    desiredWeight = shiftedCurrentWeight;\n+                    desiredPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "704b7ffc18ac14165fdea675e7b4499d9618fdb4"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0NjM2OA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370546368", "createdAt": "2020-01-24T09:45:12Z", "author": {"login": "dpoltavets"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */\n+    private SearchNode getDesiredPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long desiredWeight = Long.MAX_VALUE;\n+        SearchNode desiredPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < desiredWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    desiredWeight = shiftedCurrentWeight;\n+                    desiredPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNzQ1Mg=="}, "originalCommit": {"oid": "704b7ffc18ac14165fdea675e7b4499d9618fdb4"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDU4NjEzOnYy", "diffSide": "RIGHT", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMDo0MzoxMlrOFhZ62Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMDo1NDo0OFrOFhaN5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3MTk5Mw==", "bodyText": "Javadoc return section is outdated.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370571993", "createdAt": "2020-01-24T10:43:12Z", "author": {"login": "rozdy"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef35092b26935953e80ab6a3cc7ce9634d08ee04"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3Njg3MQ==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370576871", "createdAt": "2020-01-24T10:54:48Z", "author": {"login": "dpoltavets"}, "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3MTk5Mw=="}, "originalCommit": {"oid": "ef35092b26935953e80ab6a3cc7ce9634d08ee04"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDYzMzI5OnYy", "diffSide": "RIGHT", "path": "services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMTowMToyOFrOFhaXvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMTowMToyOFrOFhaXvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTM4OA==", "bodyText": "I genuinely do not understand the narrative of these tests. How do you compare cheapness to deepness in test names?", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370579388", "createdAt": "2020-01-24T11:01:28Z", "author": {"login": "rtretyak"}, "path": "services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java", "diffHunk": "@@ -135,6 +135,71 @@ public void shouldChooseCheaperWithSameDepth() throws  UnroutableFlowException {\n         assertEquals(SWITCH_ID_3, rpath.get(0).getDestSwitch().getSwitchId());\n     }\n \n+    @Test\n+    public void shouldChooseCheaperOverTooDeepMaxWeightStrategy() throws  UnroutableFlowException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35bc5ddc2377813fc903d5f41cfe3d22e751550f"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2079, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}