{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0OTEwNjAy", "number": 3602, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo0MjoxMFrOEOljKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1NDo0MVrOEOl2bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzMwNzMwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo0MjoxMFrOGx0RAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1MDo1MlrOGx6kQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4OTcyOA==", "bodyText": "A more compact groovy way would be\ndef updateRequest =[location: [(data.field): data.newValue] as SwitchPatchDto", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454889728", "createdAt": "2020-07-15T08:42:10Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Mjk2MA==", "bodyText": "thx, done", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454992960", "createdAt": "2020-07-15T11:50:52Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4OTcyOA=="}, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzM0OTI0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1Mjo1MlrOGx0rAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0MzozNVrOGx8UQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NjM4Nw==", "bodyText": "Just create a method that maps SwitchDto (initConf) to SwitchPatchDto and get rid of all these if-else branches", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454896387", "createdAt": "2020-07-15T08:52:52Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTYzNQ==", "bodyText": "I didn't extract it into separate method(I will do it when we start to use this kind of operation more often).\nFor now I just refactored this block of code", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r455021635", "createdAt": "2020-07-15T12:43:35Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NjM4Nw=="}, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzM1NjYyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo1NDo0MVrOGx0viQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NTowN1rOGx6scQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NzU0NQ==", "bodyText": "northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap { it.pop = initConf.pop ?: \"\" }", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454897545", "createdAt": "2020-07-15T08:54:41Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:\n+        if (initConf.location.\"$data.field\") {\n+            northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = initConf.location.\"$data.field\" }\n+            })\n+        } else {\n+            if (data.field in [\"latitude\", \"longitude\"]) {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = 0 }\n+                })\n+            } else {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = \"\" }\n+                })\n+            }\n+        }\n+\n+        where:\n+        data << [\n+                [\n+                        field   : \"latitude\",\n+                        newValue: 654\n+                ],\n+                [\n+                        field   : \"longitude\",\n+                        newValue: 456\n+                ],\n+                [\n+                        field   : \"street\",\n+                        newValue: \"testStreet\"\n+                ],\n+                [\n+                        field   : \"city\",\n+                        newValue: \"testCity\"\n+                ],\n+                [\n+                        field   : \"country\",\n+                        newValue: \"testCountry\"\n+                ]\n+        ]\n+    }\n+\n+    @Tidy\n+    def \"Able to partially update switch a 'pop' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a 'pop' field\"\n+        def newPopValue = \"test_POP\"\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap { it.pop = newPopValue })\n+\n+        then: \"Update response reflects the changes\"\n+        response.pop == newPopValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).pop == newPopValue\n+\n+        cleanup:\n+        if (initConf.pop) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NTA1Nw==", "bodyText": "thx, done", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454995057", "createdAt": "2020-07-15T11:55:07Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:\n+        if (initConf.location.\"$data.field\") {\n+            northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = initConf.location.\"$data.field\" }\n+            })\n+        } else {\n+            if (data.field in [\"latitude\", \"longitude\"]) {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = 0 }\n+                })\n+            } else {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = \"\" }\n+                })\n+            }\n+        }\n+\n+        where:\n+        data << [\n+                [\n+                        field   : \"latitude\",\n+                        newValue: 654\n+                ],\n+                [\n+                        field   : \"longitude\",\n+                        newValue: 456\n+                ],\n+                [\n+                        field   : \"street\",\n+                        newValue: \"testStreet\"\n+                ],\n+                [\n+                        field   : \"city\",\n+                        newValue: \"testCity\"\n+                ],\n+                [\n+                        field   : \"country\",\n+                        newValue: \"testCountry\"\n+                ]\n+        ]\n+    }\n+\n+    @Tidy\n+    def \"Able to partially update switch a 'pop' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a 'pop' field\"\n+        def newPopValue = \"test_POP\"\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap { it.pop = newPopValue })\n+\n+        then: \"Update response reflects the changes\"\n+        response.pop == newPopValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).pop == newPopValue\n+\n+        cleanup:\n+        if (initConf.pop) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NzU0NQ=="}, "originalCommit": {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1907, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}