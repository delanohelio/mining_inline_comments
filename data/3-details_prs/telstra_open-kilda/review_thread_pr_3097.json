{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNTY4Njk0", "number": 3097, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjozNTozOFrODWwB3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjozNjowN1rODW1m7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTgyMTc1OnYy", "diffSide": "RIGHT", "path": "services/src/checkstyle/checkstyle-header.txt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjozNTozOFrOFbsC5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwNjozNTozOFrOFbsC5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU3NzUxMQ==", "bodyText": "nit: may be 20\\d{2}", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364577511", "createdAt": "2020-01-09T06:35:38Z", "author": {"login": "niksv"}, "path": "services/src/checkstyle/checkstyle-header.txt", "diffHunk": "@@ -1,4 +1,4 @@\n-^/\\* Copyright 201\\d Telstra Open Source\n+^/\\* Copyright \\d{4} Telstra Open Source", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c288b850abf0970743aa1192f93d35fa170fa2a7"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjYyMDc1OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1MDo1M1rOFbzbIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1MDo1M1rOFbzbIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODQwMg==", "bodyText": "nit: wouldn't call it queue since you refactored that", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364698402", "createdAt": "2020-01-09T11:50:53Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjYzMDE0OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1NDoyOFrOFbzgjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1NDoyOFrOFbzgjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5OTc5MQ==", "bodyText": "nit: why not to throw exception here?", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364699791", "createdAt": "2020-01-09T11:54:28Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjYzMzU1OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1NTozNlrOFbziew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1NTozNlrOFbziew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMDI4Mw==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364700283", "createdAt": "2020-01-09T11:55:36Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();\n+        }\n+\n+        // use method raises exception on empty queue access, because queue can't be empty by used design\n+        return queue.get();\n+    }\n+\n+    /**\n+     * Locate, remove and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> remove(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjY0MDEyOnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1ODoxMlrOFbzmZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1ODoxMlrOFbzmZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMTI4Ng==", "bodyText": "let's rename it to handlePostponedRequest?", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364701286", "createdAt": "2020-01-09T11:58:12Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -69,6 +73,16 @@ public FlowRerouteService(FlowRerouteHubCarrier carrier, PersistenceManager pers\n                 speakerCommandRetriesLimit);\n     }\n \n+    /**\n+     * Handle postponed reroute request.\n+     */\n+    public void handleRequest(FlowRerouteFact reroute) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjY0Nzk1OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjowMToyOFrOFbzq9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoyNzozMVrOFb0SKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw==", "bodyText": "this is a very strange return result for a method call, tbh I'd implement size here istead", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364702453", "createdAt": "2020-01-09T12:01:28Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMjQ4OQ==", "bodyText": "+1", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364712489", "createdAt": "2020-01-09T12:27:31Z", "author": {"login": "niksv"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw=="}, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjY3NTI0OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoxMjo1M1rOFbz7ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoxMjo1M1rOFbz7ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwNjY2MA==", "bodyText": "check queue size rather than push return value that is tight to 1 size", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364706660", "createdAt": "2020-01-09T12:12:53Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -87,24 +101,15 @@ public void handleRequest(String key, CommandContext commandContext, String flow\n             return;\n         }\n \n-        String eventKey = commandContext.getCorrelationId();\n-        if (flowEventRepository.existsByTaskId(eventKey)) {\n-            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n-            return;\n+        FlowRerouteFact reroute = new FlowRerouteFact(\n+                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n+        if (retryQueue.push(reroute)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjY4NjM4OnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoxNjozNlrOFb0Bkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoxNjozNlrOFb0Bkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwODI0Mw==", "bodyText": "will this exception be raised each time there are no pending reroutes in a queue?", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364708243", "createdAt": "2020-01-09T12:16:36Z", "author": {"login": "timofei-durakov"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -151,12 +156,54 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    private void initReroute(FlowRerouteFact reroute) {\n+        final CommandContext commandContext = reroute.getCommandContext();\n+\n+        String eventKey = commandContext.getCorrelationId();\n+        if (flowEventRepository.existsByTaskId(eventKey)) {\n+            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n+            return;\n+        }\n+\n+        final String flowId =  reroute.getFlowId();\n+        final String key = reroute.getKey();\n+        FlowRerouteFsm fsm = fsmFactory.newInstance(commandContext, flowId);\n+        fsms.put(key, fsm);\n+\n+        FlowRerouteContext context = FlowRerouteContext.builder()\n+                .flowId(flowId)\n+                .pathsToReroute(reroute.getPathsToReroute())\n+                .forceReroute(reroute.isForceReroute())\n+                .rerouteReason(reroute.getRerouteReason())\n+                .build();\n+        fsmExecutor.fire(fsm, Event.NEXT, context);\n+\n+        removeIfFinished(fsm, key);\n+    }\n+\n     private void removeIfFinished(FlowRerouteFsm fsm, String key) {\n         if (fsm.isTerminated()) {\n-            log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n-            fsms.remove(key);\n+            performHousekeeping(fsm, key);\n \n-            carrier.cancelTimeoutCallback(key);\n+            // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n+            retryQueue.peek(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n+        }\n+    }\n+\n+    private void performHousekeeping(FlowRerouteFsm fsm, String key) {\n+        log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+        fsms.remove(key);\n+\n+        carrier.cancelTimeoutCallback(key);\n+\n+        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+                .orElseThrow(() -> new IllegalStateException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjcwOTAwOnYy", "diffSide": "RIGHT", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjoyNToxNVrOFb0O3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjozOTowNlrOFb0jNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng==", "bodyText": "As far as I can see state with active == null and pending != null is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364711646", "createdAt": "2020-01-09T12:25:15Z", "author": {"login": "rozdy"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {\n+    private FlowRerouteFact active = null;\n+    private FlowRerouteFact pending = null;\n+\n+    /**\n+     * Add request into \"queue\".\n+     */\n+    public void add(FlowRerouteFact reroute) {\n+        if (active == null) {\n+            active = reroute;\n+        } else if (pending == null) {\n+            pending = reroute;\n+        } else {\n+            pending = mergePending(pending, reroute);\n+        }\n+    }\n+\n+    /**\n+     * Return first/active queue entry.\n+     */\n+    public Optional<FlowRerouteFact> get() {\n+        FlowRerouteFact result = active;\n+        if (result == null) {\n+            result = pending;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNjg1Mg==", "bodyText": "or throw exception if active == null and pending != null", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364716852", "createdAt": "2020-01-09T12:39:06Z", "author": {"login": "niksv"}, "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {\n+    private FlowRerouteFact active = null;\n+    private FlowRerouteFact pending = null;\n+\n+    /**\n+     * Add request into \"queue\".\n+     */\n+    public void add(FlowRerouteFact reroute) {\n+        if (active == null) {\n+            active = reroute;\n+        } else if (pending == null) {\n+            pending = reroute;\n+        } else {\n+            pending = mergePending(pending, reroute);\n+        }\n+    }\n+\n+    /**\n+     * Return first/active queue entry.\n+     */\n+    public Optional<FlowRerouteFact> get() {\n+        FlowRerouteFact result = active;\n+        if (result == null) {\n+            result = pending;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng=="}, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MjczNTgwOnYy", "diffSide": "RIGHT", "path": "services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjozNjowN1rOFb0euw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMjozNjowN1rOFb0euw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNTcwNw==", "bodyText": "all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364715707", "createdAt": "2020-01-09T12:36:07Z", "author": {"login": "niksv"}, "path": "services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class RerouteRetryQueueTest {\n+    private final CommandContext context = new CommandContext();\n+    private final String flowId = \"flowA\";\n+    private final FlowRerouteFact rerouteEmpty = new FlowRerouteFact(\n+            \"empty\", context, flowId, null, false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathA = new FlowRerouteFact(\n+            \"pathA\", context, flowId, Collections.singleton(new PathId(\"flowA-pathA\")), false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathB = new FlowRerouteFact(\n+            \"pathB\", context, flowId, Collections.singleton(new PathId(\"flowA-pathB\")), false, \"reason 1\");\n+    private final FlowRerouteFact rerouteForced = new FlowRerouteFact(\n+            \"forced\", context, flowId, null, true, \"reason 1\");\n+\n+    @Test\n+    public void addAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        Assert.assertEquals(0, queue.size());\n+        Assert.assertTrue(queue.isEmpty());\n+\n+        queue.add(rerouteEmpty);\n+        Assert.assertEquals(1, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathA);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathB);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+    }\n+\n+    @Test\n+    public void removeAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        // empty\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+\n+        // one entry\n+        queue.add(rerouteEmpty);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        // two entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        // more than 2 entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(reroutePathB);\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertNotEquals(reroutePathA, reroute.get());  // merged entry\n+        Assert.assertNotEquals(reroutePathB, reroute.get());  // merged entry\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+    }\n+\n+    @Test\n+    public void getOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        Assert.assertFalse(queue.get().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+        queue.add(rerouteEmpty);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.add(reroutePathA);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.remove();\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+    }\n+\n+    @Test\n+    public void mergeOperation() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(rerouteForced);\n+        queue.add(reroutePathB);\n+\n+        Optional<FlowRerouteFact> potential;\n+        queue.remove();\n+        potential = queue.get();\n+        Assert.assertTrue(potential.isPresent());\n+\n+        FlowRerouteFact reroute = potential.get();\n+        Assert.assertEquals(reroutePathB.getKey(), reroute.getKey());\n+        Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n+        Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n+\n+        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n+                .map(FlowRerouteFact::getPathsToReroute)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toSet());\n+        Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n+        Assert.assertTrue(reroute.isForceReroute());\n+        Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067"}, "originalPosition": 165}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2170, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}