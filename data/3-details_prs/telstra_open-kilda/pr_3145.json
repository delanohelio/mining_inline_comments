{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2OTA1Nzc4", "number": 3145, "title": "Add tests for MAX_LATENCY PCE strategy", "bodyText": "", "createdAt": "2020-01-24T16:03:52Z", "url": "https://github.com/telstra/open-kilda/pull/3145", "merged": true, "mergeCommit": {"oid": "2eceb71448b68db431b1d13911841cd29c197b38"}, "closed": true, "closedAt": "2020-01-27T15:22:47Z", "author": {"login": "rtretyak"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9iDRFgFqTM0ODA5NTE0MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-dFohAFqTM0ODY3NDgwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDk1MTQx", "url": "https://github.com/telstra/open-kilda/pull/3145#pullrequestreview-348095141", "createdAt": "2020-01-24T17:04:39Z", "commit": {"oid": "90bea8a42734dce451e9d0f773a49daf218e7c3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzowNDozOVrOFhkRpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzowNDozOVrOFhkRpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MTY3MQ==", "bodyText": "has to be 102", "url": "https://github.com/telstra/open-kilda/pull/3145#discussion_r370741671", "createdAt": "2020-01-24T17:04:39Z", "author": {"login": "rtretyak"}, "path": "services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java", "diffHunk": "@@ -255,25 +256,73 @@ public void shouldReturnTheShortestPath() throws  UnroutableFlowException {\n         assertEquals(SWITCH_ID_E, rpath.get(1).getDestSwitch().getSwitchId());\n     }\n \n+    /**\n+     * System picks path closest to maxWeight. Omit too cheap path, omit equal to maxWeight path\n+     */\n     @Test\n     public void shouldReturnThePathClosestToMaxWeight() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-        // found path should be E -10-> A -40-> C -10-> F\n+        //given 3 paths that cost: 198, 200, 201\n+        AvailableNetwork network = buildThreePathsNetwork();\n+        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n+        //when: request a path with maxWeight 201\n+        Pair<List<Edge>, List<Edge>> pairPath =\n+                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION, 201);\n+        //then: system picks 200 path\n+        List<SwitchId> forwardSwitches = getInvolvedSwitches(pairPath.getLeft());\n+        assertThat(forwardSwitches, equalTo(Arrays.asList(SWITCH_ID_1, SWITCH_ID_3, SWITCH_ID_5)));\n+        assertThat(getInvolvedSwitches(pairPath.getRight()), equalTo(Lists.reverse(forwardSwitches)));\n+    }\n \n+    /**\n+     * Ensure system picks path closest to maxWeight from the bottom. Omit closest path from the top even if it is\n+     * closer than the one from the bottom\n+     */\n+    @Test\n+    public void shouldReturnThePathBottomClosestToMaxWeight() throws  UnroutableFlowException {\n+        //given 3 paths that cost: 198, 200, 201\n+        AvailableNetwork network = buildThreePathsNetwork();\n         BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n+        //when: request a path with maxWeight 200\n         Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_E, SWITCH_ID_F, WEIGHT_FUNCTION, 65L);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_E, fpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, fpath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_F, fpath.get(2).getDestSwitch().getSwitchId());\n+                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION, 200);\n+        //then: system picks 198 path\n+        List<SwitchId> forwardSwitches = getInvolvedSwitches(pairPath.getLeft());\n+        assertThat(forwardSwitches, equalTo(Arrays.asList(SWITCH_ID_1, SWITCH_ID_2, SWITCH_ID_5)));\n+        assertThat(getInvolvedSwitches(pairPath.getRight()), equalTo(Lists.reverse(forwardSwitches)));\n+    }\n \n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_F, rpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, fpath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, rpath.get(2).getDestSwitch().getSwitchId());\n+    /**\n+     * Check that we calculate path based on the forward-way links weight. Weight of the reversed links is ignored\n+     */\n+    @Test\n+    public void maxWeightStratUsesOnlyForwardLinkIslWeight() throws UnroutableFlowException {\n+        //given 2 paths with costs: path1 forward 100, path1 reverse 102, path2 forward 101, path2 reverse 100\n+        AvailableNetwork network = new AvailableNetwork();\n+        addLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 1, 100, 0, null, false);\n+        addLink(network, SWITCH_ID_2, SWITCH_ID_1, 1, 1, 101, 0, null, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90bea8a42734dce451e9d0f773a49daf218e7c3f"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90bea8a42734dce451e9d0f773a49daf218e7c3f", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/90bea8a42734dce451e9d0f773a49daf218e7c3f", "committedDate": "2020-01-24T16:01:10Z", "message": "Add tests for MAX_LATENCY PCE strategy"}, "afterCommit": {"oid": "91df63cc2ef7b301efc47ed40373cd85696ced35", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/91df63cc2ef7b301efc47ed40373cd85696ced35", "committedDate": "2020-01-27T11:22:30Z", "message": "Add tests for MAX_LATENCY PCE strategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87b705641ae16b2f29680f12e85621eac396173f", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/87b705641ae16b2f29680f12e85621eac396173f", "committedDate": "2020-01-27T12:06:46Z", "message": "Add tests for MAX_LATENCY PCE strategy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91df63cc2ef7b301efc47ed40373cd85696ced35", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/91df63cc2ef7b301efc47ed40373cd85696ced35", "committedDate": "2020-01-27T11:22:30Z", "message": "Add tests for MAX_LATENCY PCE strategy"}, "afterCommit": {"oid": "87b705641ae16b2f29680f12e85621eac396173f", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/87b705641ae16b2f29680f12e85621eac396173f", "committedDate": "2020-01-27T12:06:46Z", "message": "Add tests for MAX_LATENCY PCE strategy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njc0ODA2", "url": "https://github.com/telstra/open-kilda/pull/3145#pullrequestreview-348674806", "createdAt": "2020-01-27T13:51:38Z", "commit": {"oid": "87b705641ae16b2f29680f12e85621eac396173f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3695, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}