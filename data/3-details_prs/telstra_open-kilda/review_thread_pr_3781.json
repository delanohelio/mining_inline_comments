{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMjA3NDY4", "number": 3781, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxOTo0OFrOEt7SlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyOTowM1rOEt7gIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTkyNzg5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxOTo0OFrOHiA9Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoxOTo0OFrOHiA9Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyOTM0Ng==", "bodyText": "this test is ignored, do we really need to keep these lines as commented out?", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505429346", "createdAt": "2020-10-15T10:19:48Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTk0MzUyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyNDowNVrOHiBG6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyNDowNVrOHiBG6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMTc4Nw==", "bodyText": "how about combining these two wait into single?", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505431787", "createdAt": "2020-10-15T10:24:05Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTk0NTAyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyNDozMlrOHiBH8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyNDozMlrOHiBH8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjA1MQ==", "bodyText": "the same comment as in L252", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505432051", "createdAt": "2020-10-15T10:24:32Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NTk2MjU3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyOTowNFrOHiBSng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDoyOTowNFrOHiBSng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNDc4Mg==", "bodyText": "please, disable bfd session", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505434782", "createdAt": "2020-10-15T10:29:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [newIsl, newIsl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        and: \"Bfd on Discovered ISL reports 'up' status\"\n+        [newOldIsl, newOldIsl.reversed].each {\n+            verifyAll(northbound.getLink(it)) {\n+                enableBfd\n+                bfdSessionStatus == \"up\"\n+            }\n+        }\n+\n+        cleanup: \"Removed Moved ISL\" //this cleanup is not comprehensive\n+        newIsl && northbound.deleteLink(islUtils.toLinkParameters(newIsl))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ca6386ff211e66397ff68a2b2db0f889100c6"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2225, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}