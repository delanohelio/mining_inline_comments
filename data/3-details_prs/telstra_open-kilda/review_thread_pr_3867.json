{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzOTQxNjEx", "number": 3867, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozNjoyNVrOFH1cIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozODo1MVrOFH1fyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzU5OTA0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozNjoyNVrOIJcaoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTo1MjozNVrOIJc_qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3MzY2NA==", "bodyText": "Maybe enable one by one? To see what happens if only 1-way traffic starts to flow", "url": "https://github.com/telstra/open-kilda/pull/3867#discussion_r546773664", "createdAt": "2020-12-21T15:36:25Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -288,4 +289,156 @@ round trip latency rule is removed on the dst switch\"() {\n             }\n         }\n     }\n+\n+    @Tidy\n+    @Tags([SMOKE_SWITCHES])\n+    def \"A round trip latency ISL goes down when portDiscovery property is disabled on the src/dst ports\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        then: \"Isl is still DISCOVERED\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl,).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        when: \"Disable portDiscovery property on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"Status of the link is changed to FAILED\"\n+        //don't need to wait discoveryTimeout, disablePortDiscovery(on src/dst sides) == portDown\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def allLinks = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(allLinks, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(allLinks, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == FAILED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == FAILED\n+            assert islInfoReverse.actualState == FAILED\n+        }\n+\n+        when: \"Enable portDiscovery on the src/dst ports\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dd6878c6d81dbfe5a40271b73e17c25f99b64cc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4MzE0Nw==", "bodyText": "I don't think so. It will be the same as on L325.\nI mean a link will be discovered in one direction only.", "url": "https://github.com/telstra/open-kilda/pull/3867#discussion_r546783147", "createdAt": "2020-12-21T15:52:35Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -288,4 +289,156 @@ round trip latency rule is removed on the dst switch\"() {\n             }\n         }\n     }\n+\n+    @Tidy\n+    @Tags([SMOKE_SWITCHES])\n+    def \"A round trip latency ISL goes down when portDiscovery property is disabled on the src/dst ports\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        then: \"Isl is still DISCOVERED\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl,).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        when: \"Disable portDiscovery property on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"Status of the link is changed to FAILED\"\n+        //don't need to wait discoveryTimeout, disablePortDiscovery(on src/dst sides) == portDown\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def allLinks = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(allLinks, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(allLinks, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == FAILED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == FAILED\n+            assert islInfoReverse.actualState == FAILED\n+        }\n+\n+        when: \"Enable portDiscovery on the src/dst ports\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3MzY2NA=="}, "originalCommit": {"oid": "5dd6878c6d81dbfe5a40271b73e17c25f99b64cc"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzYwODQyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNTozODo1MVrOIJcf5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjowMToxMVrOIJdS9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3NTAxMw==", "bodyText": "If the assumption fails on L371, this code will still try to run. Need a better solution here and below", "url": "https://github.com/telstra/open-kilda/pull/3867#discussion_r546775013", "createdAt": "2020-12-21T15:38:51Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -288,4 +289,156 @@ round trip latency rule is removed on the dst switch\"() {\n             }\n         }\n     }\n+\n+    @Tidy\n+    @Tags([SMOKE_SWITCHES])\n+    def \"A round trip latency ISL goes down when portDiscovery property is disabled on the src/dst ports\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        then: \"Isl is still DISCOVERED\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl,).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        when: \"Disable portDiscovery property on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"Status of the link is changed to FAILED\"\n+        //don't need to wait discoveryTimeout, disablePortDiscovery(on src/dst sides) == portDown\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def allLinks = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(allLinks, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(allLinks, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == FAILED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == FAILED\n+            assert islInfoReverse.actualState == FAILED\n+        }\n+\n+        when: \"Enable portDiscovery on the src/dst ports\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: true))\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: true))\n+        portDiscoveryIsEnabledOnSrcPort = true\n+        portDiscoveryIsEnabledOnDstPort = true\n+\n+        then: \"ISL is rediscovered\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == DISCOVERED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        cleanup:\n+        !portDiscoveryIsEnabledOnSrcPort && northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId,\n+                roundTripIsl.srcPort, new PortPropertiesDto(discoveryEnabled: true))\n+        !portDiscoveryIsEnabledOnDstPort && northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId,\n+                roundTripIsl.dstPort, new PortPropertiesDto(discoveryEnabled: true))\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(roundTripIsl).get().state == DISCOVERED\n+            assert islUtils.getIslInfo(roundTripIsl.reversed).get().state == DISCOVERED\n+        }\n+    }\n+\n+    @Tidy\n+    def \"Able to delete failed ISL without force if it was discovered with disabled portDiscovery on a switch\"() {\n+        given: \"A deleted round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        antiflap.portDown(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == FAILED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == FAILED\n+        }\n+        def portIsUp = false\n+        northbound.deleteLink(islUtils.toLinkParameters(roundTripIsl))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert !islUtils.getIslInfo(links, roundTripIsl).present\n+        }\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        and: \"Revive the ISL back (bring switch port up)\"\n+        antiflap.portUp(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort)\n+        portIsUp = true\n+\n+        then: \"The ISL is rediscovered\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == DISCOVERED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == DISCOVERED\n+        }\n+\n+        and: \"The src/dst switches are valid\"\n+        //https://github.com/telstra/open-kilda/issues/3906\n+//        [roundTripIsl.srcSwitch, roundTripIsl.dstSwitch].each {\n+//            def validateInfo = northbound.validateSwitch(it.dpId).rules\n+//            assert validateInfo.missing.empty\n+//            assert validateInfo.excess.empty\n+//            assert validateInfo.misconfigured.empty\n+//        }\n+\n+        when: \"Disable portDiscovery on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"The ISL is failed\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == FAILED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == FAILED\n+        }\n+\n+        when: \"Delete the ISL without the 'force' option\"\n+        northbound.deleteLink(islUtils.toLinkParameters(roundTripIsl))\n+\n+        then: \"The ISL is deleted\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert !islUtils.getIslInfo(links, roundTripIsl).present\n+        }\n+\n+        cleanup:\n+        !portDiscoveryIsEnabledOnSrcPort && northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dd6878c6d81dbfe5a40271b73e17c25f99b64cc"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4ODA4Ng==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3867#discussion_r546788086", "createdAt": "2020-12-21T16:01:11Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -288,4 +289,156 @@ round trip latency rule is removed on the dst switch\"() {\n             }\n         }\n     }\n+\n+    @Tidy\n+    @Tags([SMOKE_SWITCHES])\n+    def \"A round trip latency ISL goes down when portDiscovery property is disabled on the src/dst ports\"() {\n+        given: \"A round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        then: \"Isl is still DISCOVERED\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl,).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        when: \"Disable portDiscovery property on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"Status of the link is changed to FAILED\"\n+        //don't need to wait discoveryTimeout, disablePortDiscovery(on src/dst sides) == portDown\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def allLinks = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(allLinks, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(allLinks, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == FAILED\n+            assert islInfoForward.actualState == FAILED\n+            assert islInfoReverse.state == FAILED\n+            assert islInfoReverse.actualState == FAILED\n+        }\n+\n+        when: \"Enable portDiscovery on the src/dst ports\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: true))\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: true))\n+        portDiscoveryIsEnabledOnSrcPort = true\n+        portDiscoveryIsEnabledOnDstPort = true\n+\n+        then: \"ISL is rediscovered\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            def islInfoForward = islUtils.getIslInfo(links, roundTripIsl).get()\n+            def islInfoReverse = islUtils.getIslInfo(links, roundTripIsl.reversed).get()\n+            assert islInfoForward.state == DISCOVERED\n+            assert islInfoForward.actualState == DISCOVERED\n+            assert islInfoReverse.state == DISCOVERED\n+            assert islInfoReverse.actualState == DISCOVERED\n+        }\n+\n+        cleanup:\n+        !portDiscoveryIsEnabledOnSrcPort && northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId,\n+                roundTripIsl.srcPort, new PortPropertiesDto(discoveryEnabled: true))\n+        !portDiscoveryIsEnabledOnDstPort && northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId,\n+                roundTripIsl.dstPort, new PortPropertiesDto(discoveryEnabled: true))\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(roundTripIsl).get().state == DISCOVERED\n+            assert islUtils.getIslInfo(roundTripIsl.reversed).get().state == DISCOVERED\n+        }\n+    }\n+\n+    @Tidy\n+    def \"Able to delete failed ISL without force if it was discovered with disabled portDiscovery on a switch\"() {\n+        given: \"A deleted round trip latency ISL\"\n+        Isl roundTripIsl = topology.islsForActiveSwitches.find {\n+            it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        } ?: assumeTrue(\"Wasn't able to find a suitable link\", false)\n+\n+        antiflap.portDown(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == FAILED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == FAILED\n+        }\n+        def portIsUp = false\n+        northbound.deleteLink(islUtils.toLinkParameters(roundTripIsl))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert !islUtils.getIslInfo(links, roundTripIsl).present\n+        }\n+\n+        when: \"Disable portDiscovery on the srcPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnSrcPort = false\n+\n+        and: \"Revive the ISL back (bring switch port up)\"\n+        antiflap.portUp(roundTripIsl.srcSwitch.dpId, roundTripIsl.srcPort)\n+        portIsUp = true\n+\n+        then: \"The ISL is rediscovered\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == DISCOVERED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == DISCOVERED\n+        }\n+\n+        and: \"The src/dst switches are valid\"\n+        //https://github.com/telstra/open-kilda/issues/3906\n+//        [roundTripIsl.srcSwitch, roundTripIsl.dstSwitch].each {\n+//            def validateInfo = northbound.validateSwitch(it.dpId).rules\n+//            assert validateInfo.missing.empty\n+//            assert validateInfo.excess.empty\n+//            assert validateInfo.misconfigured.empty\n+//        }\n+\n+        when: \"Disable portDiscovery on the dstPort\"\n+        northboundV2.updatePortProperties(roundTripIsl.dstSwitch.dpId, roundTripIsl.dstPort,\n+                new PortPropertiesDto(discoveryEnabled: false))\n+        def portDiscoveryIsEnabledOnDstPort = false\n+\n+        then: \"The ISL is failed\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, roundTripIsl).get().state == FAILED\n+            assert islUtils.getIslInfo(links, roundTripIsl.reversed).get().state == FAILED\n+        }\n+\n+        when: \"Delete the ISL without the 'force' option\"\n+        northbound.deleteLink(islUtils.toLinkParameters(roundTripIsl))\n+\n+        then: \"The ISL is deleted\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert !islUtils.getIslInfo(links, roundTripIsl).present\n+        }\n+\n+        cleanup:\n+        !portDiscoveryIsEnabledOnSrcPort && northboundV2.updatePortProperties(roundTripIsl.srcSwitch.dpId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc3NTAxMw=="}, "originalCommit": {"oid": "5dd6878c6d81dbfe5a40271b73e17c25f99b64cc"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2308, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}