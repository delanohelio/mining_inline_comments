{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3NzcxNzI4", "number": 3554, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDowNjoxMVrOEHgjag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxMDo0MVrOEHgpMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzA4ODQyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDowNjoxMVrOGm6Mkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxMDoyNVrOGm6VdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MjU2Mw==", "bodyText": "Why do you need NOVIFLOW_COPY_FIELD? Do you need RTL for the non-connected link?\nIf so, let's add this info into the step description/assumeTrue", "url": "https://github.com/telstra/open-kilda/pull/3554#discussion_r443452563", "createdAt": "2020-06-22T10:06:11Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -21,11 +24,63 @@ import spock.lang.Narrative\n import java.util.concurrent.TimeUnit\n \n @Narrative(\"Verify scenarios around replugging ISLs between different switches/ports.\")\n+@Tags([TOPOLOGY_DEPENDENT])\n class IslReplugSpec extends HealthCheckSpecification {\n \n     @Value('${opentsdb.metric.prefix}')\n     String metricPrefix\n \n+    def \"Roundtrip ISL status changes to MOVED when replugging it into another switch\"() {\n+        given: \"A connected a-switch link, roundtrip-enabled\"\n+        def isl = topology.islsForActiveSwitches.find {\n+            it.aswitch?.inPort && it.aswitch?.outPort &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough of required a-switch links with round-trip\", isl.asBoolean())\n+\n+        and: \"A non-connected a-switch link\"\n+        def notConnectedIsl = topology.notConnectedIsls.find {\n+            it.srcSwitch != isl.srcSwitch &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "906b763dcd337998bc0c81c82fb5439d22d92a80"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1NDgzNg==", "bodyText": "changed to and: \"A non-connected a-switch link with round-trip support\"", "url": "https://github.com/telstra/open-kilda/pull/3554#discussion_r443454836", "createdAt": "2020-06-22T10:10:25Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -21,11 +24,63 @@ import spock.lang.Narrative\n import java.util.concurrent.TimeUnit\n \n @Narrative(\"Verify scenarios around replugging ISLs between different switches/ports.\")\n+@Tags([TOPOLOGY_DEPENDENT])\n class IslReplugSpec extends HealthCheckSpecification {\n \n     @Value('${opentsdb.metric.prefix}')\n     String metricPrefix\n \n+    def \"Roundtrip ISL status changes to MOVED when replugging it into another switch\"() {\n+        given: \"A connected a-switch link, roundtrip-enabled\"\n+        def isl = topology.islsForActiveSwitches.find {\n+            it.aswitch?.inPort && it.aswitch?.outPort &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough of required a-switch links with round-trip\", isl.asBoolean())\n+\n+        and: \"A non-connected a-switch link\"\n+        def notConnectedIsl = topology.notConnectedIsls.find {\n+            it.srcSwitch != isl.srcSwitch &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MjU2Mw=="}, "originalCommit": {"oid": "906b763dcd337998bc0c81c82fb5439d22d92a80"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzEwMzIzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxMDo0MVrOGm6V_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxNDozM1rOGm6dqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1NDk3NA==", "bodyText": "How about validating notConnectedIsl.srcSwitch ?", "url": "https://github.com/telstra/open-kilda/pull/3554#discussion_r443454974", "createdAt": "2020-06-22T10:10:41Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -21,11 +24,63 @@ import spock.lang.Narrative\n import java.util.concurrent.TimeUnit\n \n @Narrative(\"Verify scenarios around replugging ISLs between different switches/ports.\")\n+@Tags([TOPOLOGY_DEPENDENT])\n class IslReplugSpec extends HealthCheckSpecification {\n \n     @Value('${opentsdb.metric.prefix}')\n     String metricPrefix\n \n+    def \"Round-trip ISL status changes to MOVED when replugging it into another switch\"() {\n+        given: \"A connected a-switch link, round-trip-enabled\"\n+        def isl = topology.islsForActiveSwitches.find {\n+            it.aswitch?.inPort && it.aswitch?.outPort &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough of required a-switch links with round-trip\", isl.asBoolean())\n+\n+        and: \"A non-connected a-switch link with round-trip support\"\n+        def notConnectedIsl = topology.notConnectedIsls.find {\n+            it.srcSwitch != isl.srcSwitch &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough not connected a-switch links\", notConnectedIsl.asBoolean())\n+\n+        when: \"Replug one end of the connected link to the not connected one\"\n+        def newIsl = islUtils.replug(isl, false, notConnectedIsl, true, false)\n+\n+        then: \"Replugged ISL status changes to MOVED\"\n+        islUtils.waitForIslStatus([isl, isl.reversed], MOVED)\n+\n+        and: \"New ISL becomes DISCOVERED\"\n+        islUtils.waitForIslStatus([newIsl, newIsl.reversed], DISCOVERED)\n+\n+        when: \"Replug the link back where it was\"\n+        islUtils.replug(newIsl, true, isl, false, true)\n+\n+        then: \"Original ISL becomes DISCOVERED again\"\n+        islUtils.waitForIslStatus([isl, isl.reversed], DISCOVERED)\n+\n+        and: \"Replugged ISL status changes to MOVED\"\n+        islUtils.waitForIslStatus([newIsl, newIsl.reversed], MOVED)\n+\n+        when: \"Remove the MOVED ISL\"\n+        assert northbound.deleteLink(islUtils.toLinkParameters(newIsl)).size() == 2\n+\n+        then: \"Moved ISL is removed\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert !islUtils.getIslInfo(newIsl).isPresent()\n+            assert !islUtils.getIslInfo(newIsl.reversed).isPresent()\n+        }\n+\n+        and: \"The src and dst switches of the isl pass switch validation\"\n+        [isl.srcSwitch.dpId, isl.dstSwitch.dpId].each { swId ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eaca9a8dfabe748838fdce04aca7f02975336b02"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1NjkzNw==", "bodyText": "added", "url": "https://github.com/telstra/open-kilda/pull/3554#discussion_r443456937", "createdAt": "2020-06-22T10:14:33Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -21,11 +24,63 @@ import spock.lang.Narrative\n import java.util.concurrent.TimeUnit\n \n @Narrative(\"Verify scenarios around replugging ISLs between different switches/ports.\")\n+@Tags([TOPOLOGY_DEPENDENT])\n class IslReplugSpec extends HealthCheckSpecification {\n \n     @Value('${opentsdb.metric.prefix}')\n     String metricPrefix\n \n+    def \"Round-trip ISL status changes to MOVED when replugging it into another switch\"() {\n+        given: \"A connected a-switch link, round-trip-enabled\"\n+        def isl = topology.islsForActiveSwitches.find {\n+            it.aswitch?.inPort && it.aswitch?.outPort &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) &&\n+                    it.dstSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough of required a-switch links with round-trip\", isl.asBoolean())\n+\n+        and: \"A non-connected a-switch link with round-trip support\"\n+        def notConnectedIsl = topology.notConnectedIsls.find {\n+            it.srcSwitch != isl.srcSwitch &&\n+                    it.srcSwitch.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD)\n+        }\n+        assumeTrue(\"Wasn't able to find enough not connected a-switch links\", notConnectedIsl.asBoolean())\n+\n+        when: \"Replug one end of the connected link to the not connected one\"\n+        def newIsl = islUtils.replug(isl, false, notConnectedIsl, true, false)\n+\n+        then: \"Replugged ISL status changes to MOVED\"\n+        islUtils.waitForIslStatus([isl, isl.reversed], MOVED)\n+\n+        and: \"New ISL becomes DISCOVERED\"\n+        islUtils.waitForIslStatus([newIsl, newIsl.reversed], DISCOVERED)\n+\n+        when: \"Replug the link back where it was\"\n+        islUtils.replug(newIsl, true, isl, false, true)\n+\n+        then: \"Original ISL becomes DISCOVERED again\"\n+        islUtils.waitForIslStatus([isl, isl.reversed], DISCOVERED)\n+\n+        and: \"Replugged ISL status changes to MOVED\"\n+        islUtils.waitForIslStatus([newIsl, newIsl.reversed], MOVED)\n+\n+        when: \"Remove the MOVED ISL\"\n+        assert northbound.deleteLink(islUtils.toLinkParameters(newIsl)).size() == 2\n+\n+        then: \"Moved ISL is removed\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert !islUtils.getIslInfo(newIsl).isPresent()\n+            assert !islUtils.getIslInfo(newIsl.reversed).isPresent()\n+        }\n+\n+        and: \"The src and dst switches of the isl pass switch validation\"\n+        [isl.srcSwitch.dpId, isl.dstSwitch.dpId].each { swId ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1NDk3NA=="}, "originalCommit": {"oid": "eaca9a8dfabe748838fdce04aca7f02975336b02"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1879, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}