{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNDkzMjI4", "number": 3864, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzoyMzo1NlrOFAPXbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowMzo1OVrOFWDHxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Nzk2MDc5OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/ZooKeeperHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMzoyMzo1NlrOH-bd_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNToxMjo0MFrOH_VKfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyMzgwNQ==", "bodyText": "We have race condition here.\nTimeline:\n\nwe initialize watchDog and call subscribe\nwatch dog run new thread, read ZK and call handle()\nzkStateTracker still and handle() fails because of NPE\nWe initialize zkStateTracker in main thread", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r535223805", "createdAt": "2020-12-03T13:23:56Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/ZooKeeperHandler.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.kafka;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.zookeeper.KeeperException;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+@Slf4j\n+public class ZooKeeperHandler implements Runnable, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+\n+    @Getter\n+    private volatile LifecycleEvent event;\n+\n+    private ZkStateTracker zkStateTracker;\n+\n+    private long messageId = 0;\n+    private boolean awaitingShutdown = false;\n+\n+    public ZooKeeperHandler(String id, String serviceName, String connectionString) {\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder().id(id).serviceName(serviceName)\n+                    .connectionString(connectionString).build();\n+            watchDog.subscribe(this);\n+\n+            ZkWriter zkWriter = ZkWriter.builder().id(id).serviceName(serviceName)\n+                    .connectionString(connectionString).build();\n+            zkStateTracker = new ZkStateTracker(zkWriter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e75f6aa60631a02b69e82f5effa784c85336117b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2OTA4NA==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r536169084", "createdAt": "2020-12-04T15:12:40Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/ZooKeeperHandler.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.kafka;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.zookeeper.KeeperException;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+@Slf4j\n+public class ZooKeeperHandler implements Runnable, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+\n+    @Getter\n+    private volatile LifecycleEvent event;\n+\n+    private ZkStateTracker zkStateTracker;\n+\n+    private long messageId = 0;\n+    private boolean awaitingShutdown = false;\n+\n+    public ZooKeeperHandler(String id, String serviceName, String connectionString) {\n+        try {\n+            ZkWatchDog watchDog = ZkWatchDog.builder().id(id).serviceName(serviceName)\n+                    .connectionString(connectionString).build();\n+            watchDog.subscribe(this);\n+\n+            ZkWriter zkWriter = ZkWriter.builder().id(id).serviceName(serviceName)\n+                    .connectionString(connectionString).build();\n+            zkStateTracker = new ZkStateTracker(zkWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyMzgwNQ=="}, "originalCommit": {"oid": "e75f6aa60631a02b69e82f5effa784c85336117b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTUxMTQxOnYy", "diffSide": "RIGHT", "path": "docker/zookeeper/bin/create-zknode-and-start.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo1NTo0OVrOILdFYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo1NTo0OVrOILdFYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg4MTc2MA==", "bodyText": "maybe we should set empty state before START? It could be race condition.\n\nscript sends signal START\nFL receives this signal, handles it and sets state to 0\nscrips sets state to \"\"", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r548881760", "createdAt": "2020-12-25T14:55:49Z", "author": {"login": "niksv"}, "path": "docker/zookeeper/bin/create-zknode-and-start.sh", "diffHunk": "@@ -15,5 +15,14 @@ done\n \n # add default zkNode\n /opt/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181 create /${KILDA_ZKNODE} \"\"\n-\n+/opt/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181 create /${KILDA_ZKNODE}/floodlight \"\"\n+/opt/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181 create /${KILDA_ZKNODE}/floodlight/1 \"\"\n+/opt/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181 create /${KILDA_ZKNODE}/floodlight/1/signal \"START\"\n+/opt/zookeeper/bin/zkCli.sh -server 127.0.0.1:2181 create /${KILDA_ZKNODE}/floodlight/1/state \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "909c551f86b99701a9d7d81fd46e3ba9d8e56f3c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3NTUzMjM0OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/Consumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQwMDowNjozMVrOIdN3-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQwMDowNjozMVrOIdN3-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUwNjkzOA==", "bodyText": "I believe it should be final.", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r567506938", "createdAt": "2021-02-01T00:06:31Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/Consumer.java", "diffHunk": "@@ -51,6 +59,12 @@\n     private final KafkaUtilityService kafkaUtilityService;\n     private final ISwitchManager switchManager; // HACK alert.. adding to facilitate safeSwitchTick()\n \n+    private final Set<Future<?>> tasks = new HashSet<>();\n+\n+    private final ZooKeeperService zkService;\n+    private LifecycleEvent deferedShutdownEvent;\n+    private AtomicBoolean active = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "292b6562a40fbcc7a8066a21c1248f29051a40cb"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3NTUzNTk2OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/kafka/KafkaProducerService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQwMDowOToxM1rOIdN5rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQwMDowOToxM1rOIdN5rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUwNzM3Mw==", "bodyText": "This one should be final too.", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r567507373", "createdAt": "2021-02-01T00:09:13Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/kafka/KafkaProducerService.java", "diffHunk": "@@ -41,15 +47,23 @@\n     private Producer<String, String> producer;\n     private final ObjectMapper jsonObjectMapper = new ObjectMapper();\n \n+    private ZooKeeperService zkService;\n+    private AtomicBoolean active = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "292b6562a40fbcc7a8066a21c1248f29051a40cb"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3NTU0MDE5OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQwMDoxMzo1MVrOIdN76g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODoyODowOFrOIe2Okw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUwNzk0Ng==", "bodyText": "Please, consider a one of existing retry solution which support delays / backing off. E.g. FailSafe", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r567507946", "createdAt": "2021-02-01T00:13:51Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.service.zookeeper;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+import org.openkilda.floodlight.KafkaChannel;\n+import org.openkilda.floodlight.service.IService;\n+import org.openkilda.floodlight.service.kafka.KafkaUtilityService;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import net.floodlightcontroller.core.module.FloodlightModuleContext;\n+import net.floodlightcontroller.core.module.FloodlightModuleException;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Slf4j\n+public class ZooKeeperService implements IService, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+    public static final int ZK_CONNECTION_ATTEMPTS = 10;\n+\n+\n+    private final Set<ZooKeeperEventObserver> observers = new HashSet<>();\n+\n+    @Getter\n+    private ZkStateTracker zooKeeperStateTracker;\n+    private ZkWriter zkWriter;\n+    private ZkWatchDog watchDog;\n+\n+    private LifecycleEvent event;\n+\n+    private long messageId = 0;\n+\n+    @Override\n+    public void setup(FloodlightModuleContext moduleContext) throws FloodlightModuleException {\n+        KafkaChannel kafkaChannel = moduleContext.getServiceImpl(KafkaUtilityService.class).getKafkaChannel();\n+        String region = kafkaChannel.getRegion();\n+        String connectionString = kafkaChannel.getConfig().getZooKeeperConnectString();\n+        zkWriter = ZkWriter.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        zooKeeperStateTracker = new ZkStateTracker(zkWriter);\n+\n+        watchDog = ZkWatchDog.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        watchDog.subscribe(this);\n+    }\n+\n+    /**\n+     * Connects to zookeeper.\n+     */\n+    public void initZookeeper() {\n+        zkWriter.init();\n+        watchDog.init();\n+\n+        for (int i = 1; i <= ZK_CONNECTION_ATTEMPTS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "292b6562a40fbcc7a8066a21c1248f29051a40cb"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIxNjY1OQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r569216659", "createdAt": "2021-02-03T08:28:08Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.service.zookeeper;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+import org.openkilda.floodlight.KafkaChannel;\n+import org.openkilda.floodlight.service.IService;\n+import org.openkilda.floodlight.service.kafka.KafkaUtilityService;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import net.floodlightcontroller.core.module.FloodlightModuleContext;\n+import net.floodlightcontroller.core.module.FloodlightModuleException;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+@Slf4j\n+public class ZooKeeperService implements IService, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+    public static final int ZK_CONNECTION_ATTEMPTS = 10;\n+\n+\n+    private final Set<ZooKeeperEventObserver> observers = new HashSet<>();\n+\n+    @Getter\n+    private ZkStateTracker zooKeeperStateTracker;\n+    private ZkWriter zkWriter;\n+    private ZkWatchDog watchDog;\n+\n+    private LifecycleEvent event;\n+\n+    private long messageId = 0;\n+\n+    @Override\n+    public void setup(FloodlightModuleContext moduleContext) throws FloodlightModuleException {\n+        KafkaChannel kafkaChannel = moduleContext.getServiceImpl(KafkaUtilityService.class).getKafkaChannel();\n+        String region = kafkaChannel.getRegion();\n+        String connectionString = kafkaChannel.getConfig().getZooKeeperConnectString();\n+        zkWriter = ZkWriter.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        zooKeeperStateTracker = new ZkStateTracker(zkWriter);\n+\n+        watchDog = ZkWatchDog.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        watchDog.subscribe(this);\n+    }\n+\n+    /**\n+     * Connects to zookeeper.\n+     */\n+    public void initZookeeper() {\n+        zkWriter.init();\n+        watchDog.init();\n+\n+        for (int i = 1; i <= ZK_CONNECTION_ATTEMPTS", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzUwNzk0Ng=="}, "originalCommit": {"oid": "292b6562a40fbcc7a8066a21c1248f29051a40cb"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjYzMDM2OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowMDo0OVrOIe1Qvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowMDo0OVrOIe1Qvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIwMDgzMQ==", "bodyText": "why each attempt is error but final message \"we failed to connect\" is warn?\nMaybe attempts  should be warn and final message is error. Or even both should be error", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r569200831", "createdAt": "2021-02-03T08:00:49Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.service.zookeeper;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+import org.openkilda.floodlight.KafkaChannel;\n+import org.openkilda.floodlight.service.IService;\n+import org.openkilda.floodlight.service.kafka.KafkaUtilityService;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import net.floodlightcontroller.core.module.FloodlightModuleContext;\n+import net.floodlightcontroller.core.module.FloodlightModuleException;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import net.jodah.failsafe.SyncFailsafe;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+@Slf4j\n+public class ZooKeeperService implements IService, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+    public static final int ZK_CONNECTION_ATTEMPTS = 10;\n+\n+\n+    private final Set<ZooKeeperEventObserver> observers = new HashSet<>();\n+\n+    @Getter\n+    private ZkStateTracker zooKeeperStateTracker;\n+    private ZkWriter zkWriter;\n+    private ZkWatchDog watchDog;\n+\n+    private LifecycleEvent event;\n+\n+    private long messageId = 0;\n+\n+    @Override\n+    public void setup(FloodlightModuleContext moduleContext) throws FloodlightModuleException {\n+        KafkaChannel kafkaChannel = moduleContext.getServiceImpl(KafkaUtilityService.class).getKafkaChannel();\n+        String region = kafkaChannel.getRegion();\n+        String connectionString = kafkaChannel.getConfig().getZooKeeperConnectString();\n+        zkWriter = ZkWriter.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        zooKeeperStateTracker = new ZkStateTracker(zkWriter);\n+\n+        watchDog = ZkWatchDog.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        watchDog.subscribe(this);\n+    }\n+\n+    /**\n+     * Connects to zookeeper.\n+     */\n+    public void initZookeeper() {\n+        zkWriter.init();\n+        watchDog.init();\n+\n+        RetryPolicy retryPolicy = new RetryPolicy()\n+                .retryOn(IllegalStateException.class)\n+                .withDelay(100, TimeUnit.MILLISECONDS)\n+                .withMaxRetries(ZK_CONNECTION_ATTEMPTS);\n+\n+        SyncFailsafe failsafe = Failsafe.with(retryPolicy)\n+                .onRetry(e -> log.error(\"Failed to init zk clients, retrying...\", e))\n+                .onRetriesExceeded(e -> log.warn(\"Failure in zookeeper initialization. No more retries\", e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe041e7356e8b9819c15d8918d6e83f42d9770b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjY0MTM1OnYy", "diffSide": "RIGHT", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowMzo1OVrOIe1XJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowMzo1OVrOIe1XJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIwMjQ2OA==", "bodyText": "we want to add force read after connection. Are we sure that 10 attempts is enough? I don't know how may retries we need. But in Interceptors we have infinite retries", "url": "https://github.com/telstra/open-kilda/pull/3864#discussion_r569202468", "createdAt": "2021-02-03T08:03:59Z", "author": {"login": "niksv"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/zookeeper/ZooKeeperService.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.floodlight.service.zookeeper;\n+\n+import org.openkilda.bluegreen.LifeCycleObserver;\n+import org.openkilda.bluegreen.LifecycleEvent;\n+import org.openkilda.bluegreen.Signal;\n+import org.openkilda.bluegreen.ZkStateTracker;\n+import org.openkilda.bluegreen.ZkWatchDog;\n+import org.openkilda.bluegreen.ZkWriter;\n+import org.openkilda.floodlight.KafkaChannel;\n+import org.openkilda.floodlight.service.IService;\n+import org.openkilda.floodlight.service.kafka.KafkaUtilityService;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import net.floodlightcontroller.core.module.FloodlightModuleContext;\n+import net.floodlightcontroller.core.module.FloodlightModuleException;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import net.jodah.failsafe.SyncFailsafe;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+@Slf4j\n+public class ZooKeeperService implements IService, LifeCycleObserver {\n+\n+    public static final String ZK_COMPONENT_NAME = \"floodlight\";\n+    public static final int ZK_CONNECTION_ATTEMPTS = 10;\n+\n+\n+    private final Set<ZooKeeperEventObserver> observers = new HashSet<>();\n+\n+    @Getter\n+    private ZkStateTracker zooKeeperStateTracker;\n+    private ZkWriter zkWriter;\n+    private ZkWatchDog watchDog;\n+\n+    private LifecycleEvent event;\n+\n+    private long messageId = 0;\n+\n+    @Override\n+    public void setup(FloodlightModuleContext moduleContext) throws FloodlightModuleException {\n+        KafkaChannel kafkaChannel = moduleContext.getServiceImpl(KafkaUtilityService.class).getKafkaChannel();\n+        String region = kafkaChannel.getRegion();\n+        String connectionString = kafkaChannel.getConfig().getZooKeeperConnectString();\n+        zkWriter = ZkWriter.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        zooKeeperStateTracker = new ZkStateTracker(zkWriter);\n+\n+        watchDog = ZkWatchDog.builder().id(region).serviceName(ZK_COMPONENT_NAME)\n+                .connectionString(connectionString).build();\n+        watchDog.subscribe(this);\n+    }\n+\n+    /**\n+     * Connects to zookeeper.\n+     */\n+    public void initZookeeper() {\n+        zkWriter.init();\n+        watchDog.init();\n+\n+        RetryPolicy retryPolicy = new RetryPolicy()\n+                .retryOn(IllegalStateException.class)\n+                .withDelay(100, TimeUnit.MILLISECONDS)\n+                .withMaxRetries(ZK_CONNECTION_ATTEMPTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe041e7356e8b9819c15d8918d6e83f42d9770b"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2306, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}