{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NDY4NDI1", "number": 3473, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToxMToxMVrOD8y2VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNToyMjowN1rOD-ejBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDc0MjYxOnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOToxMToxMVrOGV819A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMzoyMDoxMFrOGZWzXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg==", "bodyText": "I think you cat remove it because name is the same", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425670132", "createdAt": "2020-05-15T09:11:11Z", "author": {"login": "niksv"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNDEyOA==", "bodyText": "Did you mean \"your cat\"?", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428824128", "createdAt": "2020-05-21T18:08:39Z", "author": {"login": "surabujin"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg=="}, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MTE4Mg==", "bodyText": ":)", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429241182", "createdAt": "2020-05-22T13:20:10Z", "author": {"login": "niksv"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY3MDEzMg=="}, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDg2OTEyOnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo0ODo0MFrOGV-GuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo0ODo0MFrOGV-GuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDgwOQ==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425690809", "createdAt": "2020-05-15T09:48:40Z", "author": {"login": "niksv"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")\n+    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n+    @Mapping(target = \"sourcePort\", source = \"srcPort\")\n+    @Mapping(target = \"sourceVlan\", source = \"srcVlan\")\n+    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n+    @Mapping(target = \"destinationPort\", source = \"destPort\")\n+    @Mapping(target = \"destinationVlan\", source = \"destVlan\")\n+    @Mapping(target = \"encapsulationType\", source = \"encapsulationType\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDg2OTk1OnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo0ODo1N1rOGV-HQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo0ODo1N1rOGV-HQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDk0Ng==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425690946", "createdAt": "2020-05-15T09:48:57Z", "author": {"login": "niksv"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/RequestedFlowMapper.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.share.mappers;\n+\n+import org.openkilda.messaging.command.flow.FlowRequest;\n+import org.openkilda.model.Flow;\n+\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.factory.Mappers;\n+\n+@Mapper\n+public abstract class RequestedFlowMapper {\n+\n+    public static final RequestedFlowMapper INSTANCE = Mappers.getMapper(RequestedFlowMapper.class);\n+\n+    /**\n+     * Convert {@link Flow} to {@link FlowRequest}.\n+     */\n+    @Mapping(target = \"flowId\", source = \"flowId\")\n+    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n+    @Mapping(target = \"sourcePort\", source = \"srcPort\")\n+    @Mapping(target = \"sourceVlan\", source = \"srcVlan\")\n+    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n+    @Mapping(target = \"destinationPort\", source = \"destPort\")\n+    @Mapping(target = \"destinationVlan\", source = \"destVlan\")\n+    @Mapping(target = \"encapsulationType\", source = \"encapsulationType\")\n+    @Mapping(target = \"pathComputationStrategy\",\n+            expression = \"java(java.util.Optional.ofNullable(flow.getPathComputationStrategy())\"\n+                    + \".map(pcs -> pcs.toString().toLowerCase())\"\n+                    + \".orElse(null))\")\n+    @Mapping(target = \"bandwidth\", source = \"bandwidth\")\n+    @Mapping(target = \"ignoreBandwidth\", source = \"ignoreBandwidth\")\n+    @Mapping(target = \"periodicPings\", source = \"periodicPings\")\n+    @Mapping(target = \"allocateProtectedPath\", source = \"allocateProtectedPath\")\n+    @Mapping(target = \"description\", source = \"description\")\n+    @Mapping(target = \"maxLatency\", source = \"maxLatency\")\n+    @Mapping(target = \"priority\", source = \"priority\")\n+    @Mapping(target = \"pinned\", source = \"pinned\")\n+    @Mapping(target = \"detectConnectedDevices\", source = \"detectConnectedDevices\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDg5NTAwOnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTo1Njo0MFrOGV-W-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTo1MjozMFrOGWBsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5NDk2OQ==", "bodyText": "what about:\n\ncomparing with current DiverseFlowId?\nsetting DiverseFlowId = null to do not diverse with any flow?", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425694969", "createdAt": "2020-05-15T09:56:40Z", "author": {"login": "niksv"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -330,42 +329,72 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n-        }\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;\n+\n+        boolean addedDiverseFlowId = flowPatch.getDiverseFlowId() != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0OTYxNA==", "bodyText": "Fixed", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r425749614", "createdAt": "2020-05-15T11:52:30Z", "author": {"login": "dpoltavets"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -330,42 +329,72 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n-        }\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;\n+\n+        boolean addedDiverseFlowId = flowPatch.getDiverseFlowId() != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5NDk2OQ=="}, "originalCommit": {"oid": "90fdc0399eca9e330aab1e1d186f942d6ad8428d"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTczMTA0OnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v1/FlowController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzo0MzoyNFrOGYMW4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzo0MzoyNFrOGYMW4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMTQ3Mw==", "bodyText": "Interesting fact: empty string is actually a valid name for a flow", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428021473", "createdAt": "2020-05-20T13:43:24Z", "author": {"login": "rtretyak"}, "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v1/FlowController.java", "diffHunk": "@@ -148,6 +148,9 @@\n     @PatchMapping(value = \"/{flow-id:.+}\")\n     @ResponseStatus(HttpStatus.OK)\n     public CompletableFuture<FlowResponsePayload> patchFlow(@PathVariable(name = \"flow-id\") String flowId,\n+                                                            @ApiParam(value = \"To remove flow from a diverse group, \"\n+                                                                    + \"need to pass the parameter \\\"diverse_flow_id\\\" \"\n+                                                                    + \"equal to the empty string.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTk3NDc2OnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowEndpointDto.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozMDoyNFrOGYOssQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozMDoyNFrOGYOssQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA1OTgyNQ==", "bodyText": "in v1 it is \"port-id\"\nin v2 it is \"port_number\"\nhere it is \"port_id\"\nI think this should be made consistent with v1 and read \"port-id\" as well", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428059825", "createdAt": "2020-05-20T14:30:24Z", "author": {"login": "rtretyak"}, "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowEndpointDto.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.northbound.dto.v1.flows;\n+\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy.SnakeCaseStrategy;\n+import com.fasterxml.jackson.databind.annotation.JsonNaming;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@JsonNaming(value = SnakeCaseStrategy.class)\n+public class FlowEndpointDto {\n+    private SwitchId switchId;\n+    private Integer portId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjA1MDYyOnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowPatchDto.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0NjoyMlrOGYPdSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0NjoyMlrOGYPdSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MjI2Ng==", "bodyText": "diverse-flowid in v1", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428072266", "createdAt": "2020-05-20T14:46:22Z", "author": {"login": "rtretyak"}, "path": "src-java/northbound-service/northbound-api/src/main/java/org/openkilda/northbound/dto/v1/flows/FlowPatchDto.java", "diffHunk": "@@ -36,14 +42,33 @@\n     @JsonProperty(\"target_path_computation_strategy\")\n     private String targetPathComputationStrategy;\n \n+    @JsonProperty(\"diverse_flow_id\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODM4Njg0OnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNToyMToyMVrOGYmh_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNzozMToxOFrOGZNcsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDMwMw==", "bodyText": "could be rewritten:\nupdateRequired = false;\nupdate Required |= flowPatch.getPathComputationStrategy() != null\n&& !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n&& !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\nno need in separate booleans from what I see here", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450303", "createdAt": "2020-05-21T05:21:21Z", "author": {"login": "timofei-durakov"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -334,42 +334,95 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch, updateFlowResult.getDiverseFlowId()));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NzkyMg==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087922", "createdAt": "2020-05-22T07:31:18Z", "author": {"login": "dpoltavets"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -334,42 +334,95 @@ public Flow updateFlow(FlowOperationsCarrier carrier, FlowDto flow) throws FlowN\n \n             return Optional.of(result.updatedFlow(currentFlow).build());\n \n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+        }).orElseThrow(() -> new FlowNotFoundException(flowPatch.getFlowId()));\n \n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n-            Set<IslEndpoint> affectedIslEndpoints =\n-                    Sets.newHashSet(new IslEndpoint(flow.getSourceSwitch(), flow.getSourcePort()),\n-                            new IslEndpoint(flow.getDestinationSwitch(), flow.getDestinationPort()));\n-            carrier.sendRerouteRequest(updatedFlow.getPaths(), affectedIslEndpoints,\n-                    updateFlowResult.getRerouteReason());\n+        Flow updatedFlow = updateFlowResult.getUpdatedFlow();\n+        if (updateFlowResult.isNeedUpdateFlow()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(updatedFlow);\n+            carrier.sendUpdateRequest(addChangedFields(flowRequest, flowPatch, updateFlowResult.getDiverseFlowId()));\n+        } else {\n+            carrier.sendNorthboundResponse(new FlowResponse(FlowMapper.INSTANCE.map(updatedFlow)));\n         }\n \n         return updateFlowResult.getUpdatedFlow();\n     }\n \n     @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowPatch flowPatch, Flow flow) {\n+        boolean changedStrategy = flowPatch.getPathComputationStrategy() != null\n+                && !flowPatch.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowPatch.getMaxLatency() != null\n+                && !flowPatch.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency =\n+                PathComputationStrategy.MAX_LATENCY.equals(flowPatch.getPathComputationStrategy())\n+                || flowPatch.getPathComputationStrategy() == null\n                 && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n+        boolean changedSourceSwitch = flowPatch.getSourceSwitch() != null\n+                && !flow.getSrcSwitch().getSwitchId().equals(flowPatch.getSourceSwitch());\n+        boolean changedSourcePort = flowPatch.getSourcePort() != null\n+                && flow.getSrcPort() != flowPatch.getSourcePort();\n+        boolean changedSourceVlan = flowPatch.getSourceVlan() != null\n+                && flow.getSrcVlan() != flowPatch.getSourceVlan();\n+        boolean changedSourceEndpoint = changedSourceSwitch || changedSourcePort || changedSourceVlan;\n+\n+        boolean changedDestinationSwitch = flowPatch.getDestinationSwitch() != null\n+                && !flow.getDestSwitch().getSwitchId().equals(flowPatch.getDestinationSwitch());\n+        boolean changedDestinationPort = flowPatch.getDestinationPort() != null\n+                && flow.getDestPort() != flowPatch.getDestinationPort();\n+        boolean changedDestinationVlan = flowPatch.getDestinationVlan() != null\n+                && flow.getDestVlan() != flowPatch.getDestinationVlan();\n+        boolean changedDestinationEndpoint\n+                = changedDestinationSwitch || changedDestinationPort || changedDestinationVlan;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDMwMw=="}, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODM4NzY1OnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNToyMjowMFrOGYmihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNzozMToyMlrOGZNc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQzNw==", "bodyText": "typo: FlowPatch", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450437", "createdAt": "2020-05-21T05:22:00Z", "author": {"login": "timofei-durakov"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -105,34 +107,34 @@ public void shouldUpdateMaxLatencyAndPriorityFlowFields() throws FlowNotFoundExc\n         flow.setStatus(FlowStatus.UP);\n         flowRepository.createOrUpdate(flow);\n \n-        FlowDto receivedFlow = FlowDto.builder()\n+        FlowPatch receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .maxLatency(maxLatency)\n                 .priority(priority)\n                 .targetPathComputationStrategy(pathComputationStrategy)\n                 .build();\n \n-        Flow updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        Flow updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n \n-        receivedFlow = FlowDto.builder()\n+        receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .build();\n-        updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n-        // given: FlowDto with COST strategy and Flow with MAX_LATENCY strategy\n+    public void shouldPrepareFlowUpdateResultWithChangedStrategy() {\n+        // given: FlowPath with COST strategy and Flow with MAX_LATENCY strategy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4Nzk1NQ==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087955", "createdAt": "2020-05-22T07:31:22Z", "author": {"login": "dpoltavets"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -105,34 +107,34 @@ public void shouldUpdateMaxLatencyAndPriorityFlowFields() throws FlowNotFoundExc\n         flow.setStatus(FlowStatus.UP);\n         flowRepository.createOrUpdate(flow);\n \n-        FlowDto receivedFlow = FlowDto.builder()\n+        FlowPatch receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .maxLatency(maxLatency)\n                 .priority(priority)\n                 .targetPathComputationStrategy(pathComputationStrategy)\n                 .build();\n \n-        Flow updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        Flow updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n \n-        receivedFlow = FlowDto.builder()\n+        receivedFlow = FlowPatch.builder()\n                 .flowId(testFlowId)\n                 .build();\n-        updatedFlow = flowOperationsService.updateFlow(null, receivedFlow);\n+        updatedFlow = flowOperationsService.updateFlow(new FlowCarrierImpl(), receivedFlow);\n \n         assertEquals(maxLatency, updatedFlow.getMaxLatency());\n         assertEquals(priority, updatedFlow.getPriority());\n         assertEquals(pathComputationStrategy, updatedFlow.getTargetPathComputationStrategy());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n-        // given: FlowDto with COST strategy and Flow with MAX_LATENCY strategy\n+    public void shouldPrepareFlowUpdateResultWithChangedStrategy() {\n+        // given: FlowPath with COST strategy and Flow with MAX_LATENCY strategy", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQzNw=="}, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODM4NzkxOnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNToyMjowN1rOGYmiqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNzozMToyN1rOGZNc9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQ3Mg==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r428450472", "createdAt": "2020-05-21T05:22:07Z", "author": {"login": "timofei-durakov"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -147,16 +149,15 @@ public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n         // when: compare this flows\n         UpdateFlowResult result = flowOperationsService.prepareFlowUpdateResult(flowDto, flow).build();\n \n-        // then: needRerouteFlow flag set to true and rerouteReason is \"path computation strategy was changed\"\n-        assertTrue(result.isNeedRerouteFlow());\n-        assertTrue(result.getRerouteReason().contains(\"path computation strategy was changed\"));\n+        // then: needUpdateFlow flag set to true\n+        assertTrue(result.isNeedUpdateFlow());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyReasonFirstCase() {\n-        // given: FlowDto with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency\n+    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyFirstCase() {\n+        // given: FlowPath with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4Nzk5MA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3473#discussion_r429087990", "createdAt": "2020-05-22T07:31:27Z", "author": {"login": "dpoltavets"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/test/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsServiceTest.java", "diffHunk": "@@ -147,16 +149,15 @@ public void shouldPrepareFlowUpdateResultWithChangedStrategyReason() {\n         // when: compare this flows\n         UpdateFlowResult result = flowOperationsService.prepareFlowUpdateResult(flowDto, flow).build();\n \n-        // then: needRerouteFlow flag set to true and rerouteReason is \"path computation strategy was changed\"\n-        assertTrue(result.isNeedRerouteFlow());\n-        assertTrue(result.getRerouteReason().contains(\"path computation strategy was changed\"));\n+        // then: needUpdateFlow flag set to true\n+        assertTrue(result.isNeedUpdateFlow());\n     }\n \n     @Test\n-    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyReasonFirstCase() {\n-        // given: FlowDto with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency\n+    public void shouldPrepareFlowUpdateResultWithChangedMaxLatencyFirstCase() {\n+        // given: FlowPath with max latency and no strategy and Flow with MAX_LATENCY strategy and no max latency", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1MDQ3Mg=="}, "originalCommit": {"oid": "b78642c704c8cb6aebc58eb58a96e3d72eb0996c"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1976, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}