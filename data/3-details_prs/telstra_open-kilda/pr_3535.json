{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDI4ODMz", "number": 3535, "title": "adjust func tests to work with full capability of qinq", "bodyText": "", "createdAt": "2020-06-09T19:51:23Z", "url": "https://github.com/telstra/open-kilda/pull/3535", "merged": true, "mergeCommit": {"oid": "4c8f44feacce54979fd4c7c535e3d3ff1f6fd27a"}, "closed": true, "closedAt": "2020-06-11T14:07:22Z", "author": {"login": "andriidovhan"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcp6AxjgBqjM0Mjk3NTk2Mjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqMOMeABqjM0MzM2NDExMjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/48ba1725a6023fed378c197e5fd1540bdd80fefb", "committedDate": "2020-06-09T16:28:10Z", "message": "adjust func tests to work with full capability of qinq"}, "afterCommit": {"oid": "b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "committedDate": "2020-06-10T13:51:52Z", "message": "Traffic counters in ingress/egress rules are reset on flow rerouting(multiTable mode)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/b62d86ea8afebf5346a3e74bb9247ad5a1c35fd3", "committedDate": "2020-06-10T13:51:52Z", "message": "Traffic counters in ingress/egress rules are reset on flow rerouting(multiTable mode)"}, "afterCommit": {"oid": "ed8afb2ffa02820da4d12714baad5d55177f72d7", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/ed8afb2ffa02820da4d12714baad5d55177f72d7", "committedDate": "2020-06-10T13:56:03Z", "message": "Traffic counters in ingress/egress rules are reset on flow rerouting(multiTable mode)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3ODI5MjMy", "url": "https://github.com/telstra/open-kilda/pull/3535#pullrequestreview-427829232", "createdAt": "2020-06-10T08:30:12Z", "commit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODozMDoxMlrOGhqgSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODo1MToxMlrOGhrSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1MjU4NA==", "bodyText": "very difficult verification. can you explain? If multitable is enabled we are not matching on vlan?", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437952584", "createdAt": "2020-06-10T08:30:12Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -946,7 +948,7 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n                 }.size() == 2\n                 def ingressRule = rules.find { it.cookie == flowInfoFromDb2.forwardPath.cookie.value }\n                 ingressRule.match.inPort == newPortNumber.toString()\n-                ingressRule.match.vlanVid == newVlanId.toString()\n+                isMultiTableEnabled ? !ingressRule.match.vlanVid : (ingressRule.match.vlanVid == newVlanId.toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NTk3Ng==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437955976", "createdAt": "2020-06-10T08:35:47Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/MetersSpec.groovy", "diffHunk": "@@ -317,14 +319,43 @@ meters in flow rules at all (#data.flowType flow)\"() {\n         srcSwFlowMeters.size() == 1\n         dstSwFlowMeters.size() == 1\n \n-        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries\n-        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries\n-        def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n-        def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n-                null)[0]\n+        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n+        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n \n-        srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n-        dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter\n+        if (northbound.getSwitchProperties(flow.source.switchId).multiTable) {\n+            def srcSwIngressFlowRules = srcSwitchRules.findAll { it.match.inPort == flow.source.portNumber.toString() }\n+            assert srcSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def srcSwIngressSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def srcSwIngressNonSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert srcSwIngressSharedRule.match.vlanVid == flow.source.vlanId.toString()\n+            assert !srcSwIngressSharedRule.instructions.goToMeter\n+            assert srcSwFlowMeters[0].meterId == srcSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n+            srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n+        }\n+\n+        if (northbound.getSwitchProperties(flow.destination.switchId).multiTable) {\n+            def dstSwIngressFlowRules = dstSwitchRules.findAll { it.match.inPort == flow.destination.portNumber.toString() }\n+            assert dstSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def dstSwIngressSharedRule = dstSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def dstSwIngressNonSharedRule = dstSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert dstSwIngressSharedRule.match.vlanVid == flow.destination.vlanId.toString()\n+            assert !dstSwIngressSharedRule.instructions.goToMeter\n+            assert dstSwFlowMeters[0].meterId == dstSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n+                    null)[0]\n+            dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NjAyNQ==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437956025", "createdAt": "2020-06-10T08:35:51Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/MetersSpec.groovy", "diffHunk": "@@ -317,14 +319,43 @@ meters in flow rules at all (#data.flowType flow)\"() {\n         srcSwFlowMeters.size() == 1\n         dstSwFlowMeters.size() == 1\n \n-        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries\n-        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries\n-        def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n-        def dstSwFlowIngressRule = filterRules(dstSwitchRules, flow.destination.portNumber, flow.destination.vlanId,\n-                null)[0]\n+        def srcSwitchRules = northbound.getSwitchRules(flow.source.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n+        def dstSwitchRules = northbound.getSwitchRules(flow.destination.switchId).flowEntries.findAll {  !Cookie.isDefaultRule(it.cookie) }\n \n-        srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter\n-        dstSwFlowMeters[0].meterId == dstSwFlowIngressRule.instructions.goToMeter\n+        if (northbound.getSwitchProperties(flow.source.switchId).multiTable) {\n+            def srcSwIngressFlowRules = srcSwitchRules.findAll { it.match.inPort == flow.source.portNumber.toString() }\n+            assert srcSwIngressFlowRules.size() == 2 //shared + simple ingress\n+            def srcSwIngressSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }\n+            def srcSwIngressNonSharedRule = srcSwIngressFlowRules.find {\n+                new Cookie(it.cookie).getType() != CookieType.SHARED_OF_FLOW\n+            }\n+            assert srcSwIngressSharedRule.match.vlanVid == flow.source.vlanId.toString()\n+            assert !srcSwIngressSharedRule.instructions.goToMeter\n+            assert srcSwFlowMeters[0].meterId == srcSwIngressNonSharedRule.instructions.goToMeter\n+        } else {\n+            def srcSwFlowIngressRule = filterRules(srcSwitchRules, flow.source.portNumber, flow.source.vlanId, null)[0]\n+            srcSwFlowMeters[0].meterId == srcSwFlowIngressRule.instructions.goToMeter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1NzE4NQ==", "bodyText": "isMultitableEnabled is not an appropriate name for an integer value. As far as I understand it represents amount of rules", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437957185", "createdAt": "2020-06-10T08:37:47Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSingleSwFlowSpec.groovy", "diffHunk": "@@ -124,8 +122,7 @@ class SwitchValidationSingleSwFlowSpec extends HealthCheckSpecification {\n         def sw = switches.first()\n \n         when: \"Create a flow\"\n-        def isMultitableEnabled = northbound.getSwitchProperties(sw.dpId).multiTable ?\n-                INGRESS_RULE_MULTI_TABLE_ID : SINGLE_TABLE_ID\n+        def isMultitableEnabled = northbound.getSwitchProperties(sw.dpId).multiTable ? 4 : 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1ODY4MA==", "bodyText": "this should not be required", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437958680", "createdAt": "2020-06-10T08:40:18Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -328,31 +330,43 @@ misconfigured\"\n         and: \"Remove created meter on the srcSwitch\"\n         def forwardCookies = getCookiesWithMeter(srcSwitch.dpId)\n         def reverseCookies = getCookiesWithMeter(dstSwitch.dpId)\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookiesOnSrcSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + sharedCookieOnSrcSw).sort() : reverseCookies\n+        def sharedCookieOnDstSw = northbound.getSwitchRules(dstSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def cookiesOnDstSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + forwardCookies + sharedCookieOnDstSw) : (reverseCookies + forwardCookies)\n         northbound.deleteMeter(srcSwitch.dpId, srcSwitchCreatedMeterIds[0])\n \n         then: \"Meters info/rules are moved into the 'missing' section on the srcSwitch\"\n-        verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n-            it.rules.missing == forwardCookies\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == reverseCookies//forward cookie's removed with meter\n-\n-            it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n-            it.meters.missing*.cookie == forwardCookies\n-\n-            Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n-            it.meters.missing.each {\n-                assert it.rate == flow.maximumBandwidth\n-                assert it.flowId == flow.flowId\n-                assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n-                switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+        Wrappers.wait(RULES_DELETION_TIME) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NDA5MQ==", "bodyText": "round brackets unnecessary", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437964091", "createdAt": "2020-06-10T08:49:01Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -328,31 +330,43 @@ misconfigured\"\n         and: \"Remove created meter on the srcSwitch\"\n         def forwardCookies = getCookiesWithMeter(srcSwitch.dpId)\n         def reverseCookies = getCookiesWithMeter(dstSwitch.dpId)\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookiesOnSrcSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + sharedCookieOnSrcSw).sort() : reverseCookies\n+        def sharedCookieOnDstSw = northbound.getSwitchRules(dstSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def cookiesOnDstSw = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            (reverseCookies + forwardCookies + sharedCookieOnDstSw) : (reverseCookies + forwardCookies)\n         northbound.deleteMeter(srcSwitch.dpId, srcSwitchCreatedMeterIds[0])\n \n         then: \"Meters info/rules are moved into the 'missing' section on the srcSwitch\"\n-        verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n-            it.rules.missing == forwardCookies\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == reverseCookies//forward cookie's removed with meter\n-\n-            it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n-            it.meters.missing*.cookie == forwardCookies\n-\n-            Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n-            it.meters.missing.each {\n-                assert it.rate == flow.maximumBandwidth\n-                assert it.flowId == flow.flowId\n-                assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n-                switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n+                it.rules.missing.sort() == forwardCookies\n+                it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.sort() == untouchedCookiesOnSrcSw//forward cookie's removed with meter\n+\n+                it.meters.missing*.meterId == srcSwitchCreatedMeterIds\n+                it.meters.missing*.cookie == forwardCookies\n+\n+                Long srcSwitchBurstSize = switchHelper.getExpectedBurst(srcSwitch.dpId, flow.maximumBandwidth)\n+                it.meters.missing.each {\n+                    assert it.rate == flow.maximumBandwidth\n+                    assert it.flowId == flow.flowId\n+                    assert [\"KBPS\", \"BURST\", \"STATS\"].containsAll(it.flags)\n+                    switchHelper.verifyBurstSizeIsCorrect(srcSwitch, srcSwitchBurstSize, it.burstSize)\n+                }\n+                switchHelper.verifyMeterSectionsAreEmpty(it, [\"proper\", \"misconfigured\", \"excess\"])\n+                switchHelper.verifyRuleSectionsAreEmpty(it, [\"excess\"])\n             }\n-            switchHelper.verifyMeterSectionsAreEmpty(it, [\"proper\", \"misconfigured\", \"excess\"])\n-            switchHelper.verifyRuleSectionsAreEmpty(it, [\"excess\"])\n         }\n \n         and: \"Meters info/rules are NOT moved into the 'missing' section on the dstSwitch\"\n         verifyAll(northbound.validateSwitch(dstSwitch.dpId)) {\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.size() == 2\n-            it.rules.proper.containsAll(forwardCookies + reverseCookies)\n+            it.rules.proper.findAll { !Cookie.isDefaultRule(it) }.size() == (cookiesOnDstSw).size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NTQ0Mg==", "bodyText": "Since you are already changing this place, better remove deprecated usage:\ndef cookie = new Cookie(it)\ncookie.getServiceFlag() || cookie.getType() == CookieType.SHARED_OF_FLOW", "url": "https://github.com/telstra/open-kilda/pull/3535#discussion_r437965442", "createdAt": "2020-06-10T08:51:12Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchValidationSpec.groovy", "diffHunk": "@@ -410,9 +424,16 @@ misconfigured\"\n         northbound.deleteSwitchRules(srcSwitch.dpId, ingressCookie)\n \n         then: \"Ingress rule is moved into the 'missing' section on the srcSwitch\"\n+        def sharedCookieOnSrcSw = northbound.getSwitchRules(srcSwitch.dpId).flowEntries.find {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }?.cookie\n+        def untouchedCookies = northbound.getSwitchProperties(srcSwitch.dpId).multiTable ?\n+            [egressCookie, sharedCookieOnSrcSw].sort() : [egressCookie]\n         verifyAll(northbound.validateSwitch(srcSwitch.dpId)) {\n             it.rules.missing == [ingressCookie]\n-            it.rules.proper.findAll { !Cookie.isDefaultRule(it) } == [egressCookie]\n+            it.rules.proper.findAll {\n+                !Cookie.isDefaultRule(it) || new Cookie(it).getType() == CookieType.SHARED_OF_FLOW", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ba1725a6023fed378c197e5fd1540bdd80fefb"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4ODAwNDEz", "url": "https://github.com/telstra/open-kilda/pull/3535#pullrequestreview-428800413", "createdAt": "2020-06-11T10:53:14Z", "commit": {"oid": "d6968937befe9ddb652b1a6618a399966db3421d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "committedDate": "2020-06-11T11:05:04Z", "message": "adjust func tests to work with full capability of qinq"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6968937befe9ddb652b1a6618a399966db3421d", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/d6968937befe9ddb652b1a6618a399966db3421d", "committedDate": "2020-06-11T10:08:30Z", "message": "fix review"}, "afterCommit": {"oid": "dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/dcd7aadcf55f78721b400e95abb964ad6b1a1bcc", "committedDate": "2020-06-11T11:05:04Z", "message": "adjust func tests to work with full capability of qinq"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3584, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}