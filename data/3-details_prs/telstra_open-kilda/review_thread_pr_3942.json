{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNTYxODQx", "number": 3942, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo0NDoxNVrOFJ_hnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwOTowMTo0NFrOFKABtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDIyMzAwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo0NDoxNVrOIMj5kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo0NDoxNVrOIMj5kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0MjAwMQ==", "bodyText": "needless import", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550042001", "createdAt": "2020-12-30T08:44:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -27,6 +28,7 @@ import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n import org.openkilda.testing.service.lockkeeper.model.TrafficControlData\n \n import groovy.util.logging.Slf4j\n+import spock.lang.Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI2MDk3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1MjowNlrOIMkSDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1MjowNlrOIMkSDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0ODI2OQ==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550048269", "createdAt": "2020-12-30T08:52:06Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI2OTQ3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1NDowNFrOIMkXyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwOToyNjowMlrOIMl3rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0OTczNw==", "bodyText": "shouldn't we do it in a legal way?\n\nif (swDown) {\n    database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.INACTIVE)\n    switchHelper.reviveSwitch(brokenSwitch, blockData)\n}\n\n\nas for me would be better to revive the switch and then delete the flow.", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550049737", "createdAt": "2020-12-30T08:54:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3NDI4NA==", "bodyText": "done\nI sometimes receive the 'flow is in progress' error when deleting the flow after reviving switch, so I intentionally did it this way", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550074284", "createdAt": "2020-12-30T09:26:02Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0OTczNw=="}, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI4NTI4OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1NzoyMVrOIMkiew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1NzoyMVrOIMkiew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1MjQ3NQ==", "bodyText": "The src and dst switches will be synced twice, I guess\n(currentSwitches + otherSwitches).unique { it.dpId }..each { ... }", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550052475", "createdAt": "2020-12-30T08:57:21Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI5MjM1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1ODo1MFrOIMknGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1ODo1MFrOIMknGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1MzY1OQ==", "bodyText": "delete print", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550053659", "createdAt": "2020-12-30T08:58:50Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI5MzY3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1OTowNlrOIMkn3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1OTowNlrOIMkn3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1Mzg1Mw==", "bodyText": "delete print", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550053853", "createdAt": "2020-12-30T08:59:06Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDI5NzAzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1OTo0OVrOIMkqGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo1OTo0OVrOIMkqGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1NDQyNw==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550054427", "createdAt": "2020-12-30T08:59:49Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"At least 2 reroute attempts happen, but more retries are about to go\"\n+        wait(WAIT_OFFSET * 2) {\n+            //wait for 2, max is 4\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 2\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MDMwNTE3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwOTowMTo0NFrOIMkvZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwOTozMjo0NFrOIMmNJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1NTc4Mw==", "bodyText": "The same as in the previous test\nShouldn't we do it in a legal way?\nI mean, set the real status for the switch and then invoke the reviveSwitch method", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550055783", "createdAt": "2020-12-30T09:01:44Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"At least 2 reroute attempts happen, but more retries are about to go\"\n+        wait(WAIT_OFFSET * 2) {\n+            //wait for 2, max is 4\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 2\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Switch one the new path becomes responsive and allows rule installation\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3OTc4Mg==", "bodyText": "I can agree with the previous situation where we do this in cleanup, but right here the whole situation is kinda illegal. We simulate the case when switch is active but we can't install rules on it - this is already illegal. And right here we simulate that one of the retries suddenly succeed. Switch should not officially go 'offline' in this particular scenario. It just became responsive again in the middle of retries. Making it officially offline may ruin the whole point of test", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550079782", "createdAt": "2020-12-30T09:32:44Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"At least 2 reroute attempts happen, but more retries are about to go\"\n+        wait(WAIT_OFFSET * 2) {\n+            //wait for 2, max is 4\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 2\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Switch one the new path becomes responsive and allows rule installation\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1NTc4Mw=="}, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2203, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}