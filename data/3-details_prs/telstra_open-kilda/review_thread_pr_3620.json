{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MjYyNzEz", "number": 3620, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0NzoyNlrOENNqGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0NzoyNlrOENNqGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjkwNzEzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwOTo0NzoyNlrOGvxJ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjo1MDowMVrOGv2EuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc0MTYyNw==", "bodyText": "Can we do this trick instead?\n        //All alternative paths for both flows are unavailable\n        def untouchableIsls = pathHelper.getInvolvedIsls(flowPath).collectMany { [it, it.reversed] }\n        def altPaths = switchPair.paths.findAll { [it, it.reverse()].every { it != flowPath }}\n        def islsToBreak = altPaths.collectMany { pathHelper.getInvolvedIsls(it) }\n                .collectMany { [it, it.reversed] }.unique()\n                .findAll { !untouchableIsls.contains(it) }.unique { [it, it.reversed].sort() }\n        withPool { islsToBreak.eachParallel { Isl isl -> antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort) } }\n        Wrappers.wait(WAIT_OFFSET) {\n            assert northbound.getAllLinks().findAll { it.state == FAILED }.size() == islsToBreak.size() * 2\n        }", "url": "https://github.com/telstra/open-kilda/pull/3620#discussion_r452741627", "createdAt": "2020-07-10T09:47:26Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy", "diffHunk": "@@ -896,35 +895,36 @@ class FlowCrudSpec extends HealthCheckSpecification {\n \n         and: \"Select path for further manipulation with it\"\n         def selectedPath = switchPair.paths.max { it.size() }\n-        def altPaths = switchPair.paths.findAll { it != selectedPath }\n-\n-        and: \"Make all alternative paths unavailable (bring ports down on the src/intermediate switches)\"\n-        List<PathNode> broughtDownPortsSrcSwitch = []\n-        altPaths.findAll { it.first().portNo != selectedPath.first().portNo }.unique { it.first() }.each { path ->\n-            def src = path.first()\n-            broughtDownPortsSrcSwitch.add(src)\n-            antiflap.portDown(src.switchId, src.portNo)\n-        }\n \n-        List<PathNode> broughtDownPortsIntermSwitch = []\n-        altPaths.findAll { it.first().portNo == selectedPath.first().portNo &&\n-                it[2].portNo != selectedPath[2].portNo && it[2].switchId == selectedPath[2].switchId\n-        }.unique { it[2] }.each { path ->\n-            def src = path[2]\n-            broughtDownPortsIntermSwitch.add(src)\n-            antiflap.portDown(src.switchId, src.portNo)\n+        and: \"Make all alternative paths unavailable (bring links down on the src/intermediate switches)\"\n+        List<Isl> broughtDownIsls = []\n+        def involvedIsl = pathHelper.getInvolvedIsls(selectedPath)\n+        //link to src switch\n+        topology.islsForActiveSwitches.findAll {\n+            (it.srcSwitch.dpId == selectedPath[0].switchId || it.dstSwitch.dpId == selectedPath[0].switchId) &&\n+                    (it != involvedIsl[0])\n+        }.each { isl ->\n+            broughtDownIsls.add(isl)\n+        }\n+        //link to intermediate switch\n+        topology.islsForActiveSwitches.findAll {\n+            (it.srcSwitch.dpId == selectedPath[2].switchId || it.dstSwitch.dpId == selectedPath[2].switchId) &&\n+                    !(it in involvedIsl[0..1])\n+        }.each { isl ->\n+            broughtDownIsls.add(isl)\n         }\n+        broughtDownIsls.each { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0952d98b1f3dcd7d351b609733fe7863b16d678d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMjIwMQ==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3620#discussion_r452822201", "createdAt": "2020-07-10T12:50:01Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudSpec.groovy", "diffHunk": "@@ -896,35 +895,36 @@ class FlowCrudSpec extends HealthCheckSpecification {\n \n         and: \"Select path for further manipulation with it\"\n         def selectedPath = switchPair.paths.max { it.size() }\n-        def altPaths = switchPair.paths.findAll { it != selectedPath }\n-\n-        and: \"Make all alternative paths unavailable (bring ports down on the src/intermediate switches)\"\n-        List<PathNode> broughtDownPortsSrcSwitch = []\n-        altPaths.findAll { it.first().portNo != selectedPath.first().portNo }.unique { it.first() }.each { path ->\n-            def src = path.first()\n-            broughtDownPortsSrcSwitch.add(src)\n-            antiflap.portDown(src.switchId, src.portNo)\n-        }\n \n-        List<PathNode> broughtDownPortsIntermSwitch = []\n-        altPaths.findAll { it.first().portNo == selectedPath.first().portNo &&\n-                it[2].portNo != selectedPath[2].portNo && it[2].switchId == selectedPath[2].switchId\n-        }.unique { it[2] }.each { path ->\n-            def src = path[2]\n-            broughtDownPortsIntermSwitch.add(src)\n-            antiflap.portDown(src.switchId, src.portNo)\n+        and: \"Make all alternative paths unavailable (bring links down on the src/intermediate switches)\"\n+        List<Isl> broughtDownIsls = []\n+        def involvedIsl = pathHelper.getInvolvedIsls(selectedPath)\n+        //link to src switch\n+        topology.islsForActiveSwitches.findAll {\n+            (it.srcSwitch.dpId == selectedPath[0].switchId || it.dstSwitch.dpId == selectedPath[0].switchId) &&\n+                    (it != involvedIsl[0])\n+        }.each { isl ->\n+            broughtDownIsls.add(isl)\n+        }\n+        //link to intermediate switch\n+        topology.islsForActiveSwitches.findAll {\n+            (it.srcSwitch.dpId == selectedPath[2].switchId || it.dstSwitch.dpId == selectedPath[2].switchId) &&\n+                    !(it in involvedIsl[0..1])\n+        }.each { isl ->\n+            broughtDownIsls.add(isl)\n         }\n+        broughtDownIsls.each { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc0MTYyNw=="}, "originalCommit": {"oid": "0952d98b1f3dcd7d351b609733fe7863b16d678d"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1770, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}