{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMTk3NjM5", "number": 3580, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNjoxNDoxM1rOEKwkrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoyODo0NVrOERtepA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzE3MDM5OnYy", "diffSide": "RIGHT", "path": "docs/design/fl-parallelism/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNjoxNDoxM1rOGr-xOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMzowOToxNlrOGx9R_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc3MDM2MQ==", "bodyText": "pRoxing?", "url": "https://github.com/telstra/open-kilda/pull/3580#discussion_r448770361", "createdAt": "2020-07-02T06:14:13Z", "author": {"login": "niksv"}, "path": "docs/design/fl-parallelism/README.md", "diffHunk": "@@ -7,83 +7,101 @@\n - Do high load testing\n \n ## Overall workflow\n-Create new service responsible to manage all particularity of multiple FL\n-communication. Lets call this service \"FL-router\".\n-\n-FL-router is going to be placed between FL(one or multiple) and all other\n-services. I.e. FL-router service will have incoming kafka-topic, used to \n-receive messages/commands designed for FL. On the other end it will have\n-N*2 kafka topics used to communicate with FL instances. Where N is the\n-number of FL. x2 appears because FL use 2 kafka-topics one for input(read)\n-and one for output(write).\n-\n-Actual response topic will be determined on FL-router side in same way as\n-it is done now into FL.\n-\n-One significant change will be made for message processing - each message\n-will have a response9at least one). In other word FL must send response\n-for each message(command) it receive. It can be a \"normal\" response or\n-error response. If FL do not produce response, FL-router will produce\n-error response by himself.\n+Each speaker-region is represented by speaker instance and the set of\n+\"incoming\" and the set of \"outgoing\" kafka-topics. Region's name is used as the\n+suffix for all these kafka-topic names.\n+\n+FL-router can be treated as the set of parallel streams responsible for poxing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c9473d950d81fb4353d31e2ff1b16887ac67887"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAzNzQzOA==", "bodyText": "pRoxYing then", "url": "https://github.com/telstra/open-kilda/pull/3580#discussion_r455037438", "createdAt": "2020-07-15T13:09:16Z", "author": {"login": "rtretyak"}, "path": "docs/design/fl-parallelism/README.md", "diffHunk": "@@ -7,83 +7,101 @@\n - Do high load testing\n \n ## Overall workflow\n-Create new service responsible to manage all particularity of multiple FL\n-communication. Lets call this service \"FL-router\".\n-\n-FL-router is going to be placed between FL(one or multiple) and all other\n-services. I.e. FL-router service will have incoming kafka-topic, used to \n-receive messages/commands designed for FL. On the other end it will have\n-N*2 kafka topics used to communicate with FL instances. Where N is the\n-number of FL. x2 appears because FL use 2 kafka-topics one for input(read)\n-and one for output(write).\n-\n-Actual response topic will be determined on FL-router side in same way as\n-it is done now into FL.\n-\n-One significant change will be made for message processing - each message\n-will have a response9at least one). In other word FL must send response\n-for each message(command) it receive. It can be a \"normal\" response or\n-error response. If FL do not produce response, FL-router will produce\n-error response by himself.\n+Each speaker-region is represented by speaker instance and the set of\n+\"incoming\" and the set of \"outgoing\" kafka-topics. Region's name is used as the\n+suffix for all these kafka-topic names.\n+\n+FL-router can be treated as the set of parallel streams responsible for poxing", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc3MDM2MQ=="}, "originalCommit": {"oid": "4c9473d950d81fb4353d31e2ff1b16887ac67887"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDA2MzcyOnYy", "diffSide": "RIGHT", "path": "docs/design/fl-parallelism/fl-alive-tracking.puml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoyODo0NVrOG2ka9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOToxNToyM1rOG6BwJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3MzAxNQ==", "bodyText": "nit: as for me I'd change flr and fls on a diagram to read it from left to right", "url": "https://github.com/telstra/open-kilda/pull/3580#discussion_r459873015", "createdAt": "2020-07-24T06:28:45Z", "author": {"login": "timofei-durakov"}, "path": "docs/design/fl-parallelism/fl-alive-tracking.puml", "diffHunk": "@@ -11,10 +11,6 @@ end box\n participant \"FL-router\" as fl_router", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8010e1cace19b1ec67e18f65369641e02f4851ab"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5OTMwMQ==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3580#discussion_r463499301", "createdAt": "2020-07-31T09:15:23Z", "author": {"login": "surabujin"}, "path": "docs/design/fl-parallelism/fl-alive-tracking.puml", "diffHunk": "@@ -11,10 +11,6 @@ end box\n participant \"FL-router\" as fl_router", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3MzAxNQ=="}, "originalCommit": {"oid": "8010e1cace19b1ec67e18f65369641e02f4851ab"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1896, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}