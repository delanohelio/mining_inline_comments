{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNjc2MzUx", "number": 3113, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxMDo0M1rODYGteg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyMDowOVrODYG4LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjAyMzYyOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxMDo0M1rOFdxZWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToxMDo0M1rOFdxZWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MjMzMQ==", "bodyText": "northbound.portUp(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\nnorthbound.portUp(commonIsl.srcSwitch.dpId, commonIsl.srcPort)", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366762331", "createdAt": "2020-01-15T09:10:43Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjA1MTAwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyMDowOVrOFdxqgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyMDowOVrOFdxqgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NjcyMw==", "bodyText": "flow && flowHelperV2.deleteFlow(flow.flowId)", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366766723", "createdAt": "2020-01-15T09:20:09Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2057, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}