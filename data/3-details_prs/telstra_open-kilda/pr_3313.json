{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNDQwMTUz", "number": 3313, "title": "Toolset for cookie bit manipulations", "bodyText": "Decouple different kind of cookies biit layout intto different\ntools(schemas).\n\n\nThis change is\u2002", "createdAt": "2020-03-18T13:36:28Z", "url": "https://github.com/telstra/open-kilda/pull/3313", "merged": true, "mergeCommit": {"oid": "13bd47d363c71bdda2d5bd959b57bcbf1df519d2"}, "closed": true, "closedAt": "2020-04-27T12:04:07Z", "author": {"login": "surabujin"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQbTsUgBqjMxNTQ0NTUwNTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcas2EyABqjMyNjgyOTQ5NzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5f9eb01e86ca47ab36b5fd41a3a1728591310180", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/5f9eb01e86ca47ab36b5fd41a3a1728591310180", "committedDate": "2020-03-18T13:31:25Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/97ddfaefcb8a3d297c9937caec65ca6114ac466e", "committedDate": "2020-03-23T08:47:04Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNTcwMDE0", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-383570014", "createdAt": "2020-03-30T06:50:10Z", "commit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjo1MDoxMFrOF9bszw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODo1MDo1MVrOF9fp1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTI5NQ==", "bodyText": "Why methods in Schema are not static? Are they have some state?\nWe have only 2 directions. Do we really need to pass direction emun every time? Maybe it's better to create 2 methods like: makeForward(long effectiveId) and makeReverse(long effectiveId)?\n\nBecause of these 2 points we have to use\nFlowSegmentCookieSchema.INSTANCE.make(cookie, FlowPathDirection.FORWARD)\ninstead of\nFlowSegmentCookieSchema.makeForward(cookie)", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399961295", "createdAt": "2020-03-30T06:50:10Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ==", "bodyText": "why effective? what does it mean?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399962339", "createdAt": "2020-03-30T06:52:49Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAwOQ==", "bodyText": "What if direction flag is NOT set? is it a valid case?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399963009", "createdAt": "2020-03-30T06:54:25Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjAwOA==", "bodyText": "Why LLDP type and ARP type have different naming?\nI guess it must be LLDP_INPUT_CUSTOMER_TYPE and ARP_INPUT_CUSTOMER_TYPE", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399966008", "createdAt": "2020-03-30T07:01:23Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        return resolveEnum(CookieType.values(), getRawType(cookie), CookieType.class);\n+    }\n+\n+    // TODO: drop?\n+    protected int getRawType(Cookie cookie) {\n+        return (int) getField(cookie.getValue(), TYPE_FIELD);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP(0x001),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NzUyNg==", "bodyText": "why effective? It is confusing. Do you mean \"unmasked cookie\" or something else?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399967526", "createdAt": "2020-03-30T07:04:54Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);\n+        return new Cookie(raw);\n+    }\n+\n+    public Cookie setFlowEffectiveId(Cookie cookie, long effectiveId) {\n+        return new Cookie(setField(cookie.getValue(), FLOW_EFFECTIVE_ID_FIELD, effectiveId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTk3Ng==", "bodyText": "maybe we need to add Method isForward()?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399969976", "createdAt": "2020-03-30T07:10:05Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java", "diffHunk": "@@ -40,7 +42,7 @@ public static FlowSideAdapter makeIngressAdapter(Flow flow, FlowPath path) {\n      * Determine \"forward\" direction for provided flow/path pair and create adapter to access dest endpoint.\n      */\n     public static FlowSideAdapter makeEgressAdapter(Flow flow, FlowPath path) {\n-        if (path.getCookie().isMaskedAsForward()) {\n+        if (FlowSegmentCookieSchema.INSTANCE.getValidatedDirection(path.getCookie()) == FlowPathDirection.FORWARD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjQzMg==", "bodyText": "Why do we need to set UNKNOWN direction? where it can be used?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399972432", "createdAt": "2020-03-30T07:15:13Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NjExOA==", "bodyText": "I think this is not a best way to set a field. Try to put setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward); into if (direction == FlowPathDirection.FORWARD) {\nSomething like this:\n        long raw = cookie.getValue();\n        if (direction == FlowPathDirection.FORWARD) {\n            raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.REVERSE) {\n            raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.UNKNOWN) {\n            // nothing to do\n        } else {\n            throw new IllegalArgumentException(String.format(\n                    \"Unable to map %s.%s into cookie direction bits\",\n                    FlowPathDirection.class.getSimpleName(), direction));\n        }\n\n        return new Cookie(raw);", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399976118", "createdAt": "2020-03-30T07:23:03Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTM3OQ==", "bodyText": "you can use @Test(expected = IllegalArgumentException.class) for such tests\n    @Test(expected = IllegalArgumentException.class)\n    public void ensureNoEmptyMasks() {\n             new BitField(0);\n    }", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009379", "createdAt": "2020-03-30T08:23:25Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTQ2OQ==", "bodyText": "same", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009469", "createdAt": "2020-03-30T08:23:33Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }\n+\n+    @Test\n+    public void ensureNoGapsInMask() {\n+        try {\n+            new BitField(5);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzgyMA==", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013820", "createdAt": "2020-03-30T08:30:54Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.MeterId;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceCookieSchema extends CookieSchema {\n+    public static final ServiceCookieSchema INSTANCE = new ServiceCookieSchema();\n+\n+    private static final Set<CookieType> allowedTypes = Stream.of(\n+            CookieType.SERVICE_OR_FLOW_SEGMENT,\n+            CookieType.LLDP,\n+            CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES,\n+            CookieType.MULTI_TABLE_INGRESS_RULES,\n+            CookieType.ARP_INPUT_CUSTOMER_TYPE\n+    ).collect(Collectors.toSet());\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                   used by generic cookie -> 0x9FF0_0000_0000_0000L", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzg4Mw==", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013883", "createdAt": "2020-03-30T08:31:00Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAyNjA3MA==", "bodyText": "Honestly I don't like the idea of creating so many classes (schemas, types, etc).\nCookie class is a one place were you can find all information related to cookie(types, subtypes, schema with description of all bits used in cookie)\nInformation from the left(which were removed ) is readable, complete and easy understandable.\nNow we have several classes, with several subtypes, placed in different files. It's hard to work with such number of classes. It's easy to make a mistake. Usage in code doesn't looks like a syntax sugar. Example\nWas:\nlong cookie = flowResources.getUnmaskedCookie();\nCookie.buildForwardCookie(cookie)\n\nNow:\nCookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();\nCookie flowCookie = FlowSegmentCookieSchema.INSTANCE.setFlowEffectiveId(\nblank, flowResources.getUnmaskedCookie());\nFlowSegmentCookieSchema.INSTANCE.setDirection(flowCookie, FlowPathDirection.FORWARD)\n\nMaybe we shouldn't make simple things difficult?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400026070", "createdAt": "2020-03-30T08:50:51Z", "author": {"login": "niksv"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -45,101 +47,110 @@\n  * </p>\n  */\n @Value\n+@EqualsAndHashCode(of = {\"value\"})\n public class Cookie implements Comparable<Cookie>, Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n-\n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n-\n-    private final long value;\n-\n-    /**\n-     * Create {@code Cookie} instance and perform it's validation.\n-     */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n-    }\n+    // FIXME(surabujin): get rid from this constants", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/97ddfaefcb8a3d297c9937caec65ca6114ac466e", "committedDate": "2020-03-23T08:47:04Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "committedDate": "2020-04-01T15:56:41Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "committedDate": "2020-04-01T15:56:41Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "4cf03b92f9d6af815863798c1b4a8216dd65f16a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/4cf03b92f9d6af815863798c1b4a8216dd65f16a", "committedDate": "2020-04-02T12:23:43Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4cf03b92f9d6af815863798c1b4a8216dd65f16a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/4cf03b92f9d6af815863798c1b4a8216dd65f16a", "committedDate": "2020-04-02T12:23:43Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "fad4c687d5a5138b887dd521e1d2356c2533828b", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/fad4c687d5a5138b887dd521e1d2356c2533828b", "committedDate": "2020-04-02T13:14:03Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fad4c687d5a5138b887dd521e1d2356c2533828b", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/fad4c687d5a5138b887dd521e1d2356c2533828b", "committedDate": "2020-04-02T13:14:03Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "5cf0df10539a775f8eace6e31727df522945edf6", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/5cf0df10539a775f8eace6e31727df522945edf6", "committedDate": "2020-04-02T17:36:23Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDY1NzIy", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-387065722", "createdAt": "2020-04-03T08:42:56Z", "commit": {"oid": "5cf0df10539a775f8eace6e31727df522945edf6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5cf0df10539a775f8eace6e31727df522945edf6", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/5cf0df10539a775f8eace6e31727df522945edf6", "committedDate": "2020-04-02T17:36:23Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "committedDate": "2020-04-06T11:14:52Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTE3MzEx", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-388917311", "createdAt": "2020-04-07T08:56:05Z", "commit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwODo1NjowNVrOGB5uTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOToxNDoyNVrOGB6bbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA==", "bodyText": "this approach will lead to issue in future, it's like using Maps instead of Class Objects", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404647500", "createdAt": "2020-04-07T08:56:05Z", "author": {"login": "timofei-durakov"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTcwMQ==", "bodyText": "why not switch/case?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404649701", "createdAt": "2020-04-07T08:59:24Z", "author": {"login": "timofei-durakov"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NTgzMA==", "bodyText": "this need a javadoc", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404655830", "createdAt": "2020-04-07T09:09:22Z", "author": {"login": "timofei-durakov"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1Njg4Ng==", "bodyText": "+1 to @niksv for me it doesn't meaningful, let's try to rename?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404656886", "createdAt": "2020-04-07T09:11:06Z", "author": {"login": "timofei-durakov"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ=="}, "originalCommit": {"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1OTA1NQ==", "bodyText": "No java doc", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404659055", "createdAt": "2020-04-07T09:14:25Z", "author": {"login": "timofei-durakov"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzU4MjY4", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-389758268", "createdAt": "2020-04-08T08:29:10Z", "commit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODoyOToxMVrOGCkfyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoxOTowMlrOGCskGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0ODI5OA==", "bodyText": "nit: This could be a part of the generatedMap.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405348298", "createdAt": "2020-04-08T08:29:11Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java", "diffHunk": "@@ -97,25 +99,18 @@\n      * Note: you have to additionally set {@link org.openkilda.wfm.share.history.model.FlowDumpData.DumpType}\n      * to the dump data.\n      */\n-    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n-    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n-    @Mapping(source = \"flow.srcPort\", target = \"sourcePort\")\n-    @Mapping(source = \"flow.destPort\", target = \"destinationPort\")\n-    @Mapping(source = \"flow.srcVlan\", target = \"sourceVlan\")\n-    @Mapping(source = \"flow.destVlan\", target = \"destinationVlan\")\n-    @Mapping(source = \"flow.flowId\", target = \"flowId\")\n-    @Mapping(source = \"flow.bandwidth\", target = \"bandwidth\")\n-    @Mapping(source = \"flow.ignoreBandwidth\", target = \"ignoreBandwidth\")\n-    @Mapping(target = \"forwardCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildForwardCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(target = \"reverseCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildReverseCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(source = \"resources.forward.meterId\", target = \"forwardMeterId\")\n-    @Mapping(source = \"resources.reverse.meterId\", target = \"reverseMeterId\")\n-    @Mapping(source = \"dumpType\", target = \"dumpType\")\n-    @BeanMapping(ignoreByDefault = true)\n-    public abstract FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType);\n+    public FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType) {\n+        FlowDumpData result = generatedMap(flow, resources, dumpType);\n+\n+        result.setSourceSwitch(flow.getSrcSwitch().getSwitchId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MDY5Mg==", "bodyText": "nit: although there's no such rule in OpenKilda code convention, comparing of enum values in reverse argument order (CookieType.XYZ == cookieType instead of cookieType == CookieType.XYZ) is a controversial practice, which has no benefits but leads to poor readability. BTW, the sonar rule doesn't list this variant as a compliant one - https://rules.sonarsource.com/java/RSPEC-4551", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405440692", "createdAt": "2020-04-08T11:03:06Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -710,27 +714,27 @@ private Long processInstallDefaultFlowByCookie(SwitchId switchId, long cookie) t\n             return switchManager.installArpPostIngressOneSwitchFlow(dpid);\n         } else if (cookie == ARP_TRANSIT_COOKIE) {\n             return switchManager.installArpTransitFlow(dpid);\n-        } else if (Cookie.isIngressRulePassThrough(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_INGRESS_RULES == cookieType) {\n+            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n             return switchManager.installIntermediateIngressRule(dpid, (int) port);\n-        } else if (Cookie.isIslVlanEgress(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES == cookieType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzY3OQ==", "bodyText": "Please, don't use internal or library-specific collection classes. In addition to standard java collections, we have 2 libraries in dependencies: apache commons and guava.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405443679", "createdAt": "2020-04-08T11:09:06Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0ODQ5Ng==", "bodyText": "If this is supposed to be a constant, then use an unmodifiable set and name the field in upper-case. Please, check guava's ImmutableSet.of.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405448496", "createdAt": "2020-04-08T11:18:53Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;\n import org.projectfloodlight.openflow.protocol.OFType;\n import org.projectfloodlight.openflow.types.U64;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Set;\n \n public class ConnectedDevicesService implements IService, IInputTranslator {\n     private static final Logger logger = LoggerFactory.getLogger(ConnectedDevicesService.class);\n \n+    private static final Set<ServiceCookieTag> lldpServiceTags = Collections.asSet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NjM2NA==", "bodyText": "What does the blank cookie mean from business logic standpoint? Shouldn't this be some kind of cookie builder?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405456364", "createdAt": "2020-04-08T11:34:40Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java", "diffHunk": "@@ -190,12 +192,17 @@ protected boolean isNotSamePath(PathPair pathPair, FlowPathPair flowPathPair) {\n \n     protected FlowPathPair createFlowPathPair(Flow flow, FlowPathPair pathsToReuseBandwidth,\n                                               PathPair pathPair, FlowResources flowResources) {\n-        long cookie = flowResources.getUnmaskedCookie();\n-        FlowPath newForwardPath = flowPathBuilder.buildFlowPath(flow, flowResources.getForward(),\n-                pathPair.getForward(), Cookie.buildForwardCookie(cookie));\n+        Cookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg==", "bodyText": "Could you please add javadoc with some explanation why UNKNOWN path direction is available / possible in Kilda data model?\nLooks like this value was introduced just to cover a specific case when a method can't determine a cookie direction, which not a reason to introduce a new direction into the model. Null or Optional.empty() may address this.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405465916", "createdAt": "2020-04-08T11:53:00Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+public enum FlowPathDirection {\n+    UNKNOWN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ==", "bodyText": "nit: Can't this be just as following?\nif (mask == 0) throw new IllegalArgumentException(\"Bit field mask must not be 0\");\nlong theBit = Long.lowestOneBit(mask);\nif (theBit != mask) throw new IllegalArgumentException(\"Illegal bit field mask\");\noffset = Long.numberOfTrailingZeros(theBit) + 1;", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405477819", "createdAt": "2020-04-08T12:14:17Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {\n+    private final long mask;\n+    private final int offset;\n+\n+    public BitField(long mask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng==", "bodyText": "Why did CookieSchema become a part of the bitops package? Shouldn't it be on the same level as the cookie entity? I'd propose to move the cookie and cookie schema under \"org.openkilda.model.cookie\".", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405479856", "createdAt": "2020-04-08T12:18:04Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4MDQ3NQ==", "bodyText": "+1 Please, consider introducing a cookie builder.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405480475", "createdAt": "2020-04-08T12:19:02Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA=="}, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTM5NDcx", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-389939471", "createdAt": "2020-04-08T12:47:19Z", "commit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjo0NzoyMFrOGCtkXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjo0NzoyMFrOGCtkXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NjkyNQ==", "bodyText": "nit: where is @OverRide?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405496925", "createdAt": "2020-04-08T12:47:20Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long type field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP_INPUT_CUSTOMER_TYPE(0x001),\n+        MULTI_TABLE_ISL_VLAN_EGRESS_RULES(0x002),\n+        MULTI_TABLE_ISL_VXLAN_EGRESS_RULES(0x003),\n+        MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES(0x004),\n+        MULTI_TABLE_INGRESS_RULES(0x005),\n+        ARP_INPUT_CUSTOMER_TYPE(0x006),\n+        INGRESS_SEGMENT(0x007),   // used for ingress flow segment and for one switch flow segments\n+        SHARED_OF_FLOW(0x008);\n+\n+        private int value;\n+\n+        CookieType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int getValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "committedDate": "2020-04-06T11:14:52Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/d18950867d8d842cfbda875554772e850533ec88", "committedDate": "2020-04-10T19:50:38Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNTk3MjM0", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-393597234", "createdAt": "2020-04-15T09:16:22Z", "commit": {"oid": "d18950867d8d842cfbda875554772e850533ec88"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOToxNjoyM1rOGFw-Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOToyNjo0NlrOGFxWiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5ODQwNw==", "bodyText": "It makes sense to declare the class as abstract. No need to allow instantiating it.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408698407", "createdAt": "2020-04-15T09:16:23Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw==", "bodyText": "You can allow the builder to set both value and type, but as for now use only the type.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408701747", "createdAt": "2020-04-15T09:22:05Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjI0NQ==", "bodyText": "Why is the value called \"blank\"?", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408702245", "createdAt": "2020-04-15T09:22:49Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {\n+        super(0, type);\n+    }\n \n     /**\n-     * Create {@code Cookie} instance and perform it's validation.\n+     * Conver existing {@link Cookie} instance into {@link CookieBuilder}.\n      */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n+    public CookieBuilder toBuilder() {\n+        return new CookieBuilder()\n+                .type(getType());\n     }\n \n-    @JsonCreator\n-    public Cookie(long value) {\n-        this.value = value;\n-    }\n-\n-    public static Cookie buildForwardCookie(long unmaskedCookie) {\n-        return new Cookie(unmaskedCookie | Cookie.FLOW_PATH_FORWARD_FLAG);\n+    protected Cookie(long blank, CookieType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDY0OQ==", "bodyText": "nit: I'd call it \"isValid\" and swap with \"validate\" to be overwritten by inheritors.", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408704649", "createdAt": "2020-04-15T09:26:46Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n+\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88"}, "originalPosition": 53}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d18950867d8d842cfbda875554772e850533ec88", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/d18950867d8d842cfbda875554772e850533ec88", "committedDate": "2020-04-10T19:50:38Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/72ec444294b5826d0b25ba4e1bddec7cad08452a", "committedDate": "2020-04-16T10:09:55Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/72ec444294b5826d0b25ba4e1bddec7cad08452a", "committedDate": "2020-04-16T10:09:55Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "committedDate": "2020-04-21T10:28:48Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "committedDate": "2020-04-21T10:28:48Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "committedDate": "2020-04-21T10:39:55Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODA3MzIy", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-397807322", "createdAt": "2020-04-22T02:53:42Z", "commit": {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODA3OTE2", "url": "https://github.com/telstra/open-kilda/pull/3313#pullrequestreview-397807916", "createdAt": "2020-04-22T02:55:39Z", "commit": {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "committedDate": "2020-04-21T10:39:55Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "c55abc7650b8adfd5e68f95844deac4c502e511e", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/c55abc7650b8adfd5e68f95844deac4c502e511e", "committedDate": "2020-04-23T13:00:05Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c55abc7650b8adfd5e68f95844deac4c502e511e", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/c55abc7650b8adfd5e68f95844deac4c502e511e", "committedDate": "2020-04-23T13:00:05Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "716fb4d1429b877edd0916e708bf5ce222b3ed59", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/716fb4d1429b877edd0916e708bf5ce222b3ed59", "committedDate": "2020-04-23T13:55:31Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "committedDate": "2020-04-24T08:02:43Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "716fb4d1429b877edd0916e708bf5ce222b3ed59", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/716fb4d1429b877edd0916e708bf5ce222b3ed59", "committedDate": "2020-04-23T13:55:31Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}, "afterCommit": {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "author": {"user": {"login": "surabujin", "name": "Dmitriy Bogun"}}, "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "committedDate": "2020-04-24T08:02:43Z", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas)."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3673, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}