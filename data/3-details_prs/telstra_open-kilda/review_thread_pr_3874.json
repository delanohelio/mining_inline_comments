{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NTUyNDY5", "number": 3874, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOToyNTo1OFrOE963eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOToyNTo1OFrOE963eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzYzMDY0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwOToyNTo1OFrOH624Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwOTozMToxMFrOH7yetQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODU3MA==", "bodyText": "this is fine I guess, but the only thing that actually changes between iterations is encapsulationType", "url": "https://github.com/telstra/open-kilda/pull/3874#discussion_r531478570", "createdAt": "2020-11-27T09:25:58Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1264,6 +1304,85 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         100    | 200         | FlowEncapsulationType.VXLAN\n     }\n \n+    @Unroll\n+    @Tags([SMOKE_SWITCHES])\n+    def \"Able to detect devices when two qinq single-switch different-port flows exist with the same outerVlanId\"() {\n+        given: \"Two flows between different ports on the same switch with the same outerVlanId\"\n+        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        def sw = topology.activeTraffGens*.switchConnected.first()\n+        def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n+\n+        def flow1 = flowHelperV2.singleSwitchFlow(sw, true)\n+        flow1.source.detectConnectedDevices.lldp = true\n+        flow1.source.detectConnectedDevices.arp = true\n+        flow1.source.vlanId = commonOuterVlanId\n+        flow1.source.innerVlanId = innerVlanIdFlow1\n+        flow1.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.singleSwitchFlow(sw, true, [flow1])\n+        flow2.source.detectConnectedDevices.lldp = true\n+        flow2.source.detectConnectedDevices.arp = true\n+        flow2.source.vlanId = commonOuterVlanId\n+        flow2.source.innerVlanId = innerVlanIdFlow2\n+        flow2.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow2)\n+\n+        when: \"Device connects to src endpoint and send lldp and arp packets for flow1 only\"\n+        def lldpData = LldpData.buildRandom()\n+        def arpData = ArpData.buildRandom()\n+        new ConnectedDevice(traffExamProvider.get(), topology.getTraffGen(sw.dpId),\n+                [flow1.source.vlanId, flow1.source.innerVlanId]).withCloseable {\n+            it.sendLldp(lldpData)\n+            it.sendArp(arpData)\n+        }\n+\n+        then: \"LLDP and ARP connected devices are recognized for flow1\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow1.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp[0], lldpData)\n+                verifyEquals(it.source.arp[0], arpData)\n+            }\n+        }\n+\n+        and: \"LLDP and ARP connected devices are not recognized for flow2\"\n+        verifyAll(northbound.getFlowConnectedDevices(flow2.flowId)) {\n+            it.source.lldp.empty\n+            it.source.arp.empty\n+            it.destination.lldp.empty\n+            it.destination.arp.empty\n+        }\n+\n+        and: \"Devices are registered on the switch\"\n+        verifyAll(northboundV2.getConnectedDevices(flow1.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow1.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow1.flowId\n+            it[0].lldp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].lldp.first(), lldpData)\n+            it[0].arp.size() == 1\n+            it[0].arp.first().flowId == flow1.flowId\n+            it[0].arp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].arp.first(), arpData)\n+        }\n+\n+        cleanup: \"Restore initial switch properties\"\n+        flow1 && flowHelperV2.deleteFlow(flow1.flowId)\n+        flow2 && flowHelperV2.deleteFlow(flow2.flowId)\n+        initialProps && restoreSwitchProperties(sw.dpId, initialProps)\n+        sw && database.removeConnectedDevices(sw.dpId)\n+\n+        where:\n+        commonOuterVlanId | innerVlanIdFlow1 | innerVlanIdFlow2 | encapsulationType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e535a1a3e97131d6ad52f7020976e706ae348f"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ1NTA5Mw==", "bodyText": "you are right,\nI just didn't want to extract them into separate variables or use magic numbers.", "url": "https://github.com/telstra/open-kilda/pull/3874#discussion_r532455093", "createdAt": "2020-11-30T09:31:10Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1264,6 +1304,85 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         100    | 200         | FlowEncapsulationType.VXLAN\n     }\n \n+    @Unroll\n+    @Tags([SMOKE_SWITCHES])\n+    def \"Able to detect devices when two qinq single-switch different-port flows exist with the same outerVlanId\"() {\n+        given: \"Two flows between different ports on the same switch with the same outerVlanId\"\n+        assumeTrue(\"Require at least 1 switch with connected traffgen\", topology.activeTraffGens.size() > 0)\n+        def sw = topology.activeTraffGens*.switchConnected.first()\n+        def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n+\n+        def flow1 = flowHelperV2.singleSwitchFlow(sw, true)\n+        flow1.source.detectConnectedDevices.lldp = true\n+        flow1.source.detectConnectedDevices.arp = true\n+        flow1.source.vlanId = commonOuterVlanId\n+        flow1.source.innerVlanId = innerVlanIdFlow1\n+        flow1.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow1)\n+\n+        def flow2 = flowHelperV2.singleSwitchFlow(sw, true, [flow1])\n+        flow2.source.detectConnectedDevices.lldp = true\n+        flow2.source.detectConnectedDevices.arp = true\n+        flow2.source.vlanId = commonOuterVlanId\n+        flow2.source.innerVlanId = innerVlanIdFlow2\n+        flow2.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow2)\n+\n+        when: \"Device connects to src endpoint and send lldp and arp packets for flow1 only\"\n+        def lldpData = LldpData.buildRandom()\n+        def arpData = ArpData.buildRandom()\n+        new ConnectedDevice(traffExamProvider.get(), topology.getTraffGen(sw.dpId),\n+                [flow1.source.vlanId, flow1.source.innerVlanId]).withCloseable {\n+            it.sendLldp(lldpData)\n+            it.sendArp(arpData)\n+        }\n+\n+        then: \"LLDP and ARP connected devices are recognized for flow1\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow1.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp[0], lldpData)\n+                verifyEquals(it.source.arp[0], arpData)\n+            }\n+        }\n+\n+        and: \"LLDP and ARP connected devices are not recognized for flow2\"\n+        verifyAll(northbound.getFlowConnectedDevices(flow2.flowId)) {\n+            it.source.lldp.empty\n+            it.source.arp.empty\n+            it.destination.lldp.empty\n+            it.destination.arp.empty\n+        }\n+\n+        and: \"Devices are registered on the switch\"\n+        verifyAll(northboundV2.getConnectedDevices(flow1.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow1.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow1.flowId\n+            it[0].lldp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].lldp.first(), lldpData)\n+            it[0].arp.size() == 1\n+            it[0].arp.first().flowId == flow1.flowId\n+            it[0].arp.first().vlan == commonOuterVlanId //due to issue 3475\n+            verifyEquals(it[0].arp.first(), arpData)\n+        }\n+\n+        cleanup: \"Restore initial switch properties\"\n+        flow1 && flowHelperV2.deleteFlow(flow1.flowId)\n+        flow2 && flowHelperV2.deleteFlow(flow2.flowId)\n+        initialProps && restoreSwitchProperties(sw.dpId, initialProps)\n+        sw && database.removeConnectedDevices(sw.dpId)\n+\n+        where:\n+        commonOuterVlanId | innerVlanIdFlow1 | innerVlanIdFlow2 | encapsulationType", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3ODU3MA=="}, "originalCommit": {"oid": "31e535a1a3e97131d6ad52f7020976e706ae348f"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2322, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}