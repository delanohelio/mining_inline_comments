{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NzI2NzE4", "number": 3452, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTozMzozMFrOD6hLYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTozMzozMFrOD6hLYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjg3NTg2OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTozMzozMFrOGSZovg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwOTo1MjoyM1rOGSgHcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0NzU4Mg==", "bodyText": "!northboundV2.getFlowStatus(flowId)\nit allows us to not fail if some flow already exist", "url": "https://github.com/telstra/open-kilda/pull/3452#discussion_r421947582", "createdAt": "2020-05-08T05:33:30Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -255,4 +257,32 @@ and at least 1 path must remain safe\"\n                 ]\n         ]\n     }\n+\n+    @Tidy\n+    def \"Flow is successfully deleted from the system even if some rule delete commands fail (no rollback for delete)\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Send delete request for the flow\"\n+        lockKeeper.shapeSwitchesTraffic([swPair.src], new TrafficControlData(1000))\n+        northboundV2.deleteFlow(flow.flowId)\n+\n+        and: \"One of the related switches does not respond\"\n+        def blockData = switchHelper.knockoutSwitch(swPair.src, mgmtFlManager)\n+\n+        then: \"Flow history shows failed delete rule retry attempts but flow deletion is successful at the end\"\n+        wait(WAIT_OFFSET) {\n+            def history = northbound.getFlowHistory(flow.flowId).last().histories\n+            //egress and ingress rule on a broken switch, 3 retries each = total 6\n+            assert history.count { it.details ==~ /Failed to remove the rule.*Retrying \\(attempt \\d+\\)/ } == 6\n+            assert history.last().action == DELETE_SUCCESS\n+        }\n+        northboundV2.getAllFlows().empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9232d685c0ad60de1e89f21d694c9c7c780c3c09"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1Mzc0NQ==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3452#discussion_r422053745", "createdAt": "2020-05-08T09:52:23Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -255,4 +257,32 @@ and at least 1 path must remain safe\"\n                 ]\n         ]\n     }\n+\n+    @Tidy\n+    def \"Flow is successfully deleted from the system even if some rule delete commands fail (no rollback for delete)\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Send delete request for the flow\"\n+        lockKeeper.shapeSwitchesTraffic([swPair.src], new TrafficControlData(1000))\n+        northboundV2.deleteFlow(flow.flowId)\n+\n+        and: \"One of the related switches does not respond\"\n+        def blockData = switchHelper.knockoutSwitch(swPair.src, mgmtFlManager)\n+\n+        then: \"Flow history shows failed delete rule retry attempts but flow deletion is successful at the end\"\n+        wait(WAIT_OFFSET) {\n+            def history = northbound.getFlowHistory(flow.flowId).last().histories\n+            //egress and ingress rule on a broken switch, 3 retries each = total 6\n+            assert history.count { it.details ==~ /Failed to remove the rule.*Retrying \\(attempt \\d+\\)/ } == 6\n+            assert history.last().action == DELETE_SUCCESS\n+        }\n+        northboundV2.getAllFlows().empty", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0NzU4Mg=="}, "originalCommit": {"oid": "9232d685c0ad60de1e89f21d694c9c7c780c3c09"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1968, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}