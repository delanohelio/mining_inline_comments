{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MzAzNzI4", "number": 3840, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMTo1NFrOE3RHWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMzo1MFrOE3RKzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mzg3NTQ3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMTo1NFrOHwgwfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoyNzo0MlrOHx0TGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMDM5Ng==", "bodyText": "Do we really need to wait WAIT_OFFSET * 2?", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r520630396", "createdAt": "2020-11-10T15:01:54Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTEzMQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r521999131", "createdAt": "2020-11-12T10:27:42Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMDM5Ng=="}, "originalCommit": {"oid": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mzg4NDMwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTowMzo1MFrOHwg2DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoyNzo0N1rOHx0TVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMTgyMQ==", "bodyText": "wait is needless here, I guess\nThe isl is already failed (L57-58)", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r520631821", "createdAt": "2020-11-10T15:03:50Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            assert northbound.getLink(isl).state == FAILED\n+            assert northbound.getLink(isl.reversed).state == FAILED\n+        }\n+\n+        when: \"Port up event happens, but traffic goes only in one direction\"\n+        lockKeeper.removeFlows([isl.aswitch])\n+        cleanupActions << { lockKeeper.addFlows([isl.aswitch]) }\n+        cleanupActions.pop().call() //antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"ISL is not getting discovered\"\n+        TimeUnit.SECONDS.sleep(discoveryInterval + 2)\n+        Wrappers.wait(WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTE4OQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r521999189", "createdAt": "2020-11-12T10:27:47Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            assert northbound.getLink(isl).state == FAILED\n+            assert northbound.getLink(isl.reversed).state == FAILED\n+        }\n+\n+        when: \"Port up event happens, but traffic goes only in one direction\"\n+        lockKeeper.removeFlows([isl.aswitch])\n+        cleanupActions << { lockKeeper.addFlows([isl.aswitch]) }\n+        cleanupActions.pop().call() //antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"ISL is not getting discovered\"\n+        TimeUnit.SECONDS.sleep(discoveryInterval + 2)\n+        Wrappers.wait(WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMTgyMQ=="}, "originalCommit": {"oid": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2278, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}