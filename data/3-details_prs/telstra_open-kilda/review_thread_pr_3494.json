{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMzYyMzI3", "number": 3494, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNTowN1rOD_TeTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNToyMDoxMVrOD_8ElA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzA1OTM1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNTowN1rOGZ5Bgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNTowN1rOGZ5Bgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTg1OA==", "bodyText": "looks like it is needless", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429801858", "createdAt": "2020-05-25T08:25:07Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/main/groovy/org/openkilda/functionaltests/helpers/FlowHelper.groovy", "diffHunk": "@@ -17,6 +17,7 @@ import org.openkilda.messaging.payload.flow.FlowEndpointPayload\n import org.openkilda.messaging.payload.flow.FlowPayload\n import org.openkilda.messaging.payload.flow.FlowState\n import org.openkilda.model.Flow\n+import org.openkilda.northbound.dto.v1.flows.FlowPatchDto", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Nzk5MTk4OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo1OTowOVrOGaCDHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzo1OTowOVrOGaCDHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0OTcyNQ==", "bodyText": "@Tidy?", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429949725", "createdAt": "2020-05-25T13:59:09Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -61,6 +137,74 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Unroll\n+    def \"Able to partially update flow #data.field which causes a reroute\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll { !Cookie.isDefaultRule(it.cookie) }\n+\n+        when: \"Request a flow partial update for a #field field\"\n+        def newValue = data.getNewValue(flow.\"$data.field\")\n+        def updateRequest = new FlowPatchV2().tap { it.\"$data.field\" = newValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.\"$data.field\" == newValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).\"$data.field\" == newValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll {\n+            !Cookie.isDefaultRule(it.cookie)\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        where:\n+        data << [\n+                [\n+                        field   : \"maximumBandwidth\",\n+                        getNewValue: { it + 100 }\n+                ],\n+                [\n+                        field   : \"allocateProtectedPath\",\n+                        getNewValue: { !it }\n+                ]\n+        ]\n+    }\n+\n+    def \"Able to turn on diversity feature using partial update\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODAzODU5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoxNDoyMlrOGaCgaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoxNDoyMlrOGaCgaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk1NzIyNA==", "bodyText": "#data.field ?", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429957224", "createdAt": "2020-05-25T14:14:22Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -24,6 +51,55 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n             Cookie.isIngressRulePassThrough(it.cookie) || !Cookie.isDefaultRule(it.cookie)\n         }*.cookie\n \n+        when: \"Request a flow partial update for a #field field\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODA2NDE3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyMjozMVrOGaCvxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyMjozMVrOGaCvxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MTE1OA==", "bodyText": "#data.field ?", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429961158", "createdAt": "2020-05-25T14:22:31Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -61,6 +137,74 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Unroll\n+    def \"Able to partially update flow #data.field which causes a reroute\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll { !Cookie.isDefaultRule(it.cookie) }\n+\n+        when: \"Request a flow partial update for a #field field\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODA3NjQ3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyNjozNFrOGaC3Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyNjozNFrOGaC3Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MzA3MQ==", "bodyText": "@Tidy ?", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429963071", "createdAt": "2020-05-25T14:26:34Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -89,7 +233,134 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n \n-    def \"Partial update with empty body does not actually update flow in any way\"() {\n+    @Tidy\n+    def \"Able to update a flow endpoint using partial update\"() {\n+        given: \"Three active switches\"\n+        def allSwitches = topology.activeSwitches\n+        assumeTrue(\"Unable to find three active switches\", allSwitches.size() >= 3)\n+        def srcSwitch = allSwitches[0]\n+        def dstSwitch = allSwitches[1]\n+\n+        and: \"A vlan flow\"\n+        def flow = flowHelperV2.randomFlow(srcSwitch, dstSwitch, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update the flow: port number and vlan id on the src endpoint\"\n+        def flowInfoFromDb1 = database.getFlow(flow.flowId)\n+        def newPortNumber = topology.getAllowedPortsForSwitch(topology.activeSwitches.find {\n+            it.dpId == flow.source.switchId\n+        }).last()\n+        def newVlanId = flow.destination.vlanId + 1\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            source = new FlowPatchEndpoint().tap {\n+                portNumber = newPortNumber\n+                vlanId = newVlanId\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == newPortNumber\n+            it.source.vlanId == newVlanId\n+        }\n+\n+        and: \"Flow rules are recreated\"\n+        def flowInfoFromDb2 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(srcSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb1.forwardPath.cookie.value, flowInfoFromDb1.reversePath.cookie.value]\n+                }.empty\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb2.forwardPath.cookie.value, flowInfoFromDb2.reversePath.cookie.value]\n+                }.size() == 2\n+                def ingressRule = rules.find { it.cookie == flowInfoFromDb2.forwardPath.cookie.value }\n+                ingressRule.match.inPort == newPortNumber.toString()\n+                ingressRule.match.vlanVid == newVlanId.toString()\n+            }\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The src switch passes switch validation\"\n+        with(northbound.validateSwitch(srcSwitch.dpId)) { validation ->\n+            validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+        def srcSwitchIsFine = true\n+\n+        when: \"Update the flow: switch id on the dst endpoint\"\n+        def newDstSwitch = allSwitches[2]\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            destination = new FlowPatchEndpoint().tap {\n+                switchId = newDstSwitch.dpId\n+                portNumber = newPortNumber\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.switchId == newDstSwitch.dpId\n+        }\n+\n+        and: \"Flow rules are removed from the old dst switch\"\n+        def flowInfoFromDb3 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            with(northbound.getSwitchRules(dstSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb2.forwardPath.cookie.value, flowInfoFromDb2.reversePath.cookie.value]\n+                }.empty\n+            }\n+        }\n+\n+        and: \"Flow rules are installed on the new dst switch\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(newDstSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {\n+                    it.cookie in [flowInfoFromDb3.forwardPath.cookie.value, flowInfoFromDb3.reversePath.cookie.value]\n+                }.size() == 2\n+            }\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The new and old dst switches pass switch validation\"\n+        Wrappers.wait(RULES_DELETION_TIME) {\n+            [dstSwitch, newDstSwitch]*.dpId.each { switchId ->\n+                with(northbound.validateSwitch(switchId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+        def dstSwitchesAreFine = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !srcSwitchIsFine && northbound.synchronizeSwitch(srcSwitch.dpId, true)\n+        !dstSwitchesAreFine && dstSwitch && newDstSwitch && [dstSwitch, newDstSwitch]*.dpId.each {\n+            northbound.synchronizeSwitch(it, true)\n+        }\n+    }\n+\n+    @Tags([LOW_PRIORITY])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODA4NDE1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyOTowNFrOGaC8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDoyOTowNFrOGaC8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NDM2MA==", "bodyText": "@Tidy ?", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429964360", "createdAt": "2020-05-25T14:29:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +384,213 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODA5ODYwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDozMzo1NFrOGaDFKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDozMzo1NFrOGaDFKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NjYzNA==", "bodyText": "in some test you use error.statusCode instead of exc.rawStatusCode\nas for me would be great to use the same verification everywhere\nfor example in this case  error.statusCode == HttpStatus.BAD_REQUEST", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429966634", "createdAt": "2020-05-25T14:33:54Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +384,213 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {\n+        given: \"A flow\"\n+        def swPair = topologyHelper.switchPairs.first()\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        def originalCookies = northbound.getSwitchRules(swPair.src.dpId).flowEntries.findAll {\n+            Cookie.isIngressRulePassThrough(it.cookie) || !Cookie.isDefaultRule(it.cookie)\n+        }*.cookie\n+\n+        when: \"Request a flow partial update without specifying any fields\"\n+        def flowBeforeUpdate = northboundV2.getFlow(flow.flowId)\n+        northboundV2.partialUpdate(flow.flowId, new FlowPatchV2())\n+\n+        then: \"Flow is left intact\"\n+        expect northboundV2.getFlow(flow.flowId), sameBeanAs(flowBeforeUpdate)\n+                .ignoring(\"lastUpdated\")\n+                .ignoring(\"diverseWith\")\n+\n+        and: \"Flow rules have not been reinstalled\"\n+        northbound.getSwitchRules(swPair.src.dpId).flowEntries*.cookie.containsAll(originalCookies)\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Unroll\n+    def \"Unable to partial update a flow in case new port is an isl port on a #data.switchType switch\"() {\n+        given: \"An isl\"\n+        Isl isl = topology.islsForActiveSwitches.find { it.aswitch && it.dstSwitch }\n+        assumeTrue(\"Unable to find required isl\", isl as boolean)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(isl.srcSwitch, isl.dstSwitch)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Try to edit port to isl port\"\n+        northboundV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            it.\"$data.switchType\" = new FlowPatchEndpoint().tap { it.portNumber = isl.\"$data.port\" }\n+        })\n+\n+        then: \"Error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.rawStatusCode == 400", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODE0NDk0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDo0OTo0NFrOGaDhuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNDo0OTo0NFrOGaDhuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3Mzk0Nw==", "bodyText": "To tell the truth I am afraid when the qinq feature is merged this verification can be really difficult\nHow about checking that flow allows traffic instead of checking specific fields in rules?\nI am not insist", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r429973947", "createdAt": "2020-05-25T14:49:44Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -89,7 +233,134 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n \n-    def \"Partial update with empty body does not actually update flow in any way\"() {\n+    @Tidy\n+    def \"Able to update a flow endpoint using partial update\"() {\n+        given: \"Three active switches\"\n+        def allSwitches = topology.activeSwitches\n+        assumeTrue(\"Unable to find three active switches\", allSwitches.size() >= 3)\n+        def srcSwitch = allSwitches[0]\n+        def dstSwitch = allSwitches[1]\n+\n+        and: \"A vlan flow\"\n+        def flow = flowHelperV2.randomFlow(srcSwitch, dstSwitch, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update the flow: port number and vlan id on the src endpoint\"\n+        def flowInfoFromDb1 = database.getFlow(flow.flowId)\n+        def newPortNumber = topology.getAllowedPortsForSwitch(topology.activeSwitches.find {\n+            it.dpId == flow.source.switchId\n+        }).last()\n+        def newVlanId = flow.destination.vlanId + 1\n+        flowHelperV2.partialUpdate(flow.flowId, new FlowPatchV2().tap {\n+            source = new FlowPatchEndpoint().tap {\n+                portNumber = newPortNumber\n+                vlanId = newVlanId\n+            }\n+        })\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == newPortNumber\n+            it.source.vlanId == newVlanId\n+        }\n+\n+        and: \"Flow rules are recreated\"\n+        def flowInfoFromDb2 = database.getFlow(flow.flowId)\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            with(northbound.getSwitchRules(srcSwitch.dpId).flowEntries.findAll {\n+                !Cookie.isDefaultRule(it.cookie)\n+            }) { rules ->\n+                rules.findAll {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23971f2acdf8baac58695280fbdac0cab276c780"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MzcxMDkyOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNToyMDoxMVrOGa5xFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNToyMDoxMVrOGa5xFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjYxNA==", "bodyText": "I guess this test can be marked as @Tidy", "url": "https://github.com/telstra/open-kilda/pull/3494#discussion_r430862614", "createdAt": "2020-05-27T05:20:11Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -113,4 +363,214 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         cleanup: \"Remove the flow\"\n         flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    def \"Partial update with empty body does not actually update flow in any way\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aece295fc8164c67cbb7115565646d5fed015cf4"}, "originalPosition": 326}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1835, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}