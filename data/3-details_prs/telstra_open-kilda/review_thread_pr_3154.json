{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MTA1NzUy", "number": 3154, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1Mjo1M1rODcNs4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDowMjowN1rODsmZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTExMjAyOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1Mjo1M1rOFkJMyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzozMDoyMVrOFkLWcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0Mzc4NA==", "bodyText": "This line is impossible to fire. Also, you can save all paths during swPair search in order to not repeat the same reduction here", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373443784", "createdAt": "2020-01-31T11:52:53Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3OTAyNw==", "bodyText": "it was refactored", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373479027", "createdAt": "2020-01-31T13:30:21Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0Mzc4NA=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTExNzQwOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1NTowOFrOFkJP-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzoxMjowOVrOFkK6_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDYwMQ==", "bodyText": "tr3 is for transit switch protected, right?", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373444601", "createdAt": "2020-01-31T11:55:08Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTk5Ng==", "bodyText": "you are right", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373471996", "createdAt": "2020-01-31T13:12:09Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDYwMQ=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTEyMDIzOnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1NjozMFrOFkJRxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjozMjo0NFrOFkKCdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTA2MQ==", "bodyText": "This does not correspond to your comment above. You should have dst in '4' and protected transit in '3'", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373445061", "createdAt": "2020-01-31T11:56:30Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NzUyNQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373457525", "createdAt": "2020-01-31T12:32:44Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTA2MQ=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTEyNTA5OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1ODo1MVrOFkJU5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODoyNDozOVrOF8nLFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTg2MQ==", "bodyText": "Can we use pathHelper.makePathNotPreferable(protectedPath)? May look much more readable", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373445861", "createdAt": "2020-01-31T11:58:51Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MjQ2MA==", "bodyText": "We can't do it.\nActually makePathNotPreferable sets too high value NOT_PREFERABLE_COST * 3, then as a result the test is going to fail.\nDifference  between totalCostOfNonPreferablePath and totalCostOfPreferablePath shouldn't be too big.\nI can't definitely say the value which is the border(especially for this test the border value is 3300 (it was found experimentally)).", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373462460", "createdAt": "2020-01-31T12:46:40Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTg2MQ=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ4NjY1NA==", "bodyText": "why? I mean how do you understand this is not a defect?", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373486654", "createdAt": "2020-01-31T13:48:12Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTg2MQ=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEwMDY5Mw==", "bodyText": "fixed, it should be clear now", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r399100693", "createdAt": "2020-03-27T08:24:39Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTg2MQ=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwOTE0ODE1OnYy", "diffSide": "RIGHT", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjowOTowOVrOFkJivg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzowNjoxM1rOFkKyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0OTQwNg==", "bodyText": "can you elaborate here please? I mean the reason why it picked 'tr3' path. It is really hard to follow all this pop logic without any pictures before eyes and with very brief comments. I mean I get it right now, but it will take me too much time to refresh the memory in a month or two. And the test must be a good helper here", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373449406", "createdAt": "2020-01-31T12:09:09Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }\n+\n+        when: \"Create a protected flow\"\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Main path is built through the preferable path(tr1 or tr2)\"\n+        def flowPaths = northbound.getFlowPath(flow.flowId)\n+        def realFlowPathInvolvedSwitches = pathHelper.getInvolvedSwitches(pathHelper.convert(flowPaths))*.dpId\n+        realFlowPathInvolvedSwitches == involvedSwP1 || realFlowPathInvolvedSwitches == involvedSwP2\n+\n+        and: \"Protected path is built through the non preferable path(tr3)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTc0NQ==", "bodyText": "left the comment", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373469745", "createdAt": "2020-01-31T13:06:13Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }\n+\n+        when: \"Create a protected flow\"\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Main path is built through the preferable path(tr1 or tr2)\"\n+        def flowPaths = northbound.getFlowPath(flow.flowId)\n+        def realFlowPathInvolvedSwitches = pathHelper.getInvolvedSwitches(pathHelper.convert(flowPaths))*.dpId\n+        realFlowPathInvolvedSwitches == involvedSwP1 || realFlowPathInvolvedSwitches == involvedSwP2\n+\n+        and: \"Protected path is built through the non preferable path(tr3)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0OTQwNg=="}, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDkxODQ3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTo1OTowN1rOF9iRnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMToxNzo1OVrOF9k92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA2OTAyMQ==", "bodyText": "replace 700 with named constant.\nyou can assume all ISLs are at the default cost at the start of the test and don't call northbound.getLink", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400069021", "createdAt": "2020-03-30T09:59:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMzExNA==", "bodyText": "done\nI would like to avoid assume in the test. Actually there are only two requests(northbound.getLink), so I guess it is not critical to leave it as is.", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400113114", "createdAt": "2020-03-30T11:17:59Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA2OTAyMQ=="}, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDkyODQzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDowMTo0MFrOF9iX6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMToyNDozNVrOF9lLeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDYzMw==", "bodyText": "the comment explains 2000, but I think it still makes sense to extract it into variables and make a clean self-explaining code totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400070633", "createdAt": "2020-03-30T10:01:40Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }\n+        def amountOfIlslsOnMainPath = involvedIslsOfMainPath.size()\n+        Integer newIslCost = ((totalCostOfMainPath + (amountOfIlslsOnMainPath * 2000) - 1) /", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNjYwMg==", "bodyText": "it makes sense to me.\ndone.", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400116602", "createdAt": "2020-03-30T11:24:35Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }\n+        def amountOfIlslsOnMainPath = involvedIslsOfMainPath.size()\n+        Integer newIslCost = ((totalCostOfMainPath + (amountOfIlslsOnMainPath * 2000) - 1) /", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDYzMw=="}, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDkyOTkwOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDowMjowN1rOF9iY4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDowMjowN1rOF9iY4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDg4Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400070882", "createdAt": "2020-03-30T10:02:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }\n+        def amountOfIlslsOnMainPath = involvedIslsOfMainPath.size()\n+        Integer newIslCost = ((totalCostOfMainPath + (amountOfIlslsOnMainPath * 2000) - 1) /\n+                pathHelper.getInvolvedIsls(protectedPath).size()).toInteger()\n+        log.debug(\"newCost: $newIslCost\")\n+\n+        islsToUpdate.unique().each { isl ->\n+            northbound.updateLinkProps([islUtils.toLinkProps(isl, [\"cost\": newIslCost.toString()])])\n+        }\n+\n+        when: \"Create a protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *             srcSwitch_POP_1\n+         *             /       |       \\\n+         *            / 700    | 700    \\ newIslCost\n+         *           /         |         \\\n+         *   trSw1_POP_2   trSw2_POP_2   trSw3_POP_3\n+         *          \\          |         /\n+         *           \\ 700     | 700    / newIslCost\n+         *            \\        |       /\n+         *             dstSwitch_POP_4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2109, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}