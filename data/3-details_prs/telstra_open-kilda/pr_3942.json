{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNTYxODQx", "number": 3942, "title": "Add func tests for #3940 and #3941", "bodyText": "", "createdAt": "2020-12-21T15:51:51Z", "url": "https://github.com/telstra/open-kilda/pull/3942", "merged": true, "mergeCommit": {"oid": "62e7bbabdc8584a4d1964b472bb2aea89593d6b2"}, "closed": true, "closedAt": "2021-03-24T09:14:57Z", "author": {"login": "rtretyak"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdqkwpFABqjQxNTE4MjY5MzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeDW21bABqjQ0NTgyMTA1Njk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86d6a2ea4708d18121f1b8f5dc19489a68eb2af2", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/86d6a2ea4708d18121f1b8f5dc19489a68eb2af2", "committedDate": "2020-12-21T15:51:02Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "2cacb2a9b70b9f104f52852d8ead95d9b7379924", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/2cacb2a9b70b9f104f52852d8ead95d9b7379924", "committedDate": "2020-12-28T11:51:21Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2cacb2a9b70b9f104f52852d8ead95d9b7379924", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/2cacb2a9b70b9f104f52852d8ead95d9b7379924", "committedDate": "2020-12-28T11:51:21Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "3bb965fa00df48df53388c1dcc75848ad807f379", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/3bb965fa00df48df53388c1dcc75848ad807f379", "committedDate": "2020-12-28T14:04:08Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3bb965fa00df48df53388c1dcc75848ad807f379", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/3bb965fa00df48df53388c1dcc75848ad807f379", "committedDate": "2020-12-28T14:04:08Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "8c9ecc2bc76d3505328c98881e558d619a07080d", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/8c9ecc2bc76d3505328c98881e558d619a07080d", "committedDate": "2020-12-29T15:40:48Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c9ecc2bc76d3505328c98881e558d619a07080d", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/8c9ecc2bc76d3505328c98881e558d619a07080d", "committedDate": "2020-12-29T15:40:48Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8", "committedDate": "2020-12-29T15:51:28Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5OTU2NjIz", "url": "https://github.com/telstra/open-kilda/pull/3942#pullrequestreview-559956623", "createdAt": "2020-12-30T08:44:15Z", "commit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODo0NDoxNVrOIMj5kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwOTowMTo0NFrOIMkvZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0MjAwMQ==", "bodyText": "needless import", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550042001", "createdAt": "2020-12-30T08:44:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -27,6 +28,7 @@ import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n import org.openkilda.testing.service.lockkeeper.model.TrafficControlData\n \n import groovy.util.logging.Slf4j\n+import spock.lang.Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0ODI2OQ==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550048269", "createdAt": "2020-12-30T08:52:06Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA0OTczNw==", "bodyText": "shouldn't we do it in a legal way?\n\nif (swDown) {\n    database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.INACTIVE)\n    switchHelper.reviveSwitch(brokenSwitch, blockData)\n}\n\n\nas for me would be better to revive the switch and then delete the flow.", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550049737", "createdAt": "2020-12-30T08:54:04Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1MjQ3NQ==", "bodyText": "The src and dst switches will be synced twice, I guess\n(currentSwitches + otherSwitches).unique { it.dpId }..each { ... }", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550052475", "createdAt": "2020-12-30T08:57:21Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1MzY1OQ==", "bodyText": "delete print", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550053659", "createdAt": "2020-12-30T08:58:50Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1Mzg1Mw==", "bodyText": "delete print", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550053853", "createdAt": "2020-12-30T08:59:06Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1NDQyNw==", "bodyText": "assert", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550054427", "createdAt": "2020-12-30T08:59:49Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"At least 2 reroute attempts happen, but more retries are about to go\"\n+        wait(WAIT_OFFSET * 2) {\n+            //wait for 2, max is 4\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 2\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1NTc4Mw==", "bodyText": "The same as in the previous test\nShouldn't we do it in a legal way?\nI mean, set the real status for the switch and then invoke the reviveSwitch method", "url": "https://github.com/telstra/open-kilda/pull/3942#discussion_r550055783", "createdAt": "2020-12-30T09:01:44Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RetriesSpec.groovy", "diffHunk": "@@ -446,4 +448,170 @@ and at least 1 path must remain safe\"\n         wait(WAIT_OFFSET) { northbound.activeLinks.size() == topology.islsForActiveSwitches.size() * 2 }\n         database.resetCosts()\n     }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is reverted back after table mode change (failed reroute)\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        def portDown = antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"After 4 reroute attempts flows goes Down\" //reroute + 3 retries\n+        wait(WAIT_OFFSET * 4) { //some long wait here, multiple retry attempts\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 4\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Original path becomes available again (ISL goes UP)\"\n+        def portUp = antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"Flow goes UP\"\n+        wait(WAIT_OFFSET) { assert northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Flow and switches are valid\"\n+        northbound.validateFlow(flow.flowId).every { it.asExpected }\n+        currentSwitches.each {\n+            def validation = northbound.validateSwitch(it.dpId)\n+            validation.verifyRuleSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+            validation.verifyMeterSectionsAreEmpty([\"excess\", \"missing\", \"misconfigured\"])\n+        }\n+        def done = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        swDown && switchHelper.reviveSwitch(brokenSwitch, blockData)\n+        originalMode && swPair.src.changeMultitable(originalMode)\n+        !done && currentSwitches && (currentSwitches + otherSwitches).each {\n+            northbound.synchronizeSwitch(it.dpId, true) }\n+        broughtDownIsls && broughtDownIsls.each { antiflap.portUp(it.srcSwitch.dpId, it.srcPort) }\n+        isl && portDown && !portUp && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        wait(WAIT_OFFSET * 2) {\n+            northbound.getAllLinks().each { assert it.state == IslChangeType.DISCOVERED } }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System remains in consistent state when flow is retries its reroute after table mode change\"() {\n+        given: \"A flow, with src switch supporting multi-table (currently in single-table)\"\n+        def swPair = topologyHelper.switchPairs.find {\n+            it.src.features.contains(SwitchFeature.MULTI_TABLE) && it.paths.size() > 1 &&\n+                    it.paths.find { it.size() > 2 }\n+        }\n+        assumeTrue(\"Couldn't find a switch pair with src sw supporting Multi-table, 2+ paths and at least 1 \" +\n+                \"path having transit switch\", swPair as boolean)\n+        def originalMode = swPair.src.changeMultitable(false)\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+        print flow.flowId\n+        def path = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        and: \"Only 1 alt path is available, that path has a transit switch\"\n+        def otherPath = swPair.paths.find { it != path && it.size() > 2 }\n+        List<Isl> islsToKill = []\n+        def involvedIsls = pathHelper.getInvolvedIsls(path) + pathHelper.getInvolvedIsls(otherPath)\n+        swPair.paths.findAll { it != path && it != otherPath }.each {\n+            pathHelper.getInvolvedIsls(it).findAll { !(it in involvedIsls || it.reversed in involvedIsls) }.each {\n+                islsToKill.add(it)\n+            }\n+        }\n+        def broughtDownIsls = islsToKill.unique { a, b -> a == b || a == b.reversed ? 0 : 1 }\n+        broughtDownIsls.every { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+        wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == islsToKill.size() * 2\n+        }\n+\n+        when: \"Change src switch mode to multi-table\"\n+        swPair.src.changeMultitable(true)\n+\n+        and: \"Transit switch on alt path is false-active, so that on reroute system fails to install rules and rollback\"\n+        def currentSwitches = pathHelper.getInvolvedSwitches(path)\n+        def otherSwitches = pathHelper.getInvolvedSwitches(otherPath)\n+        def brokenSwitch = otherSwitches.find { !currentSwitches.contains(it) }\n+        def blockData = switchHelper.knockoutSwitch(brokenSwitch, RW)\n+        def swDown = true\n+        database.setSwitchStatus(brokenSwitch.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Break ISL on current path to init a reroute\"\n+        def otherIsls = pathHelper.getInvolvedIsls(otherPath)\n+        def isl = pathHelper.getInvolvedIsls(path).find { !otherIsls.contains(it) }\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"At least 2 reroute attempts happen, but more retries are about to go\"\n+        wait(WAIT_OFFSET * 2) {\n+            //wait for 2, max is 4\n+            assert northbound.getFlowHistory(flow.flowId).count { it.action == REROUTE_ACTION } == 2\n+            northboundV2.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+        }\n+\n+        when: \"Switch one the new path becomes responsive and allows rule installation\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8"}, "originalPosition": 173}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/0ceedac72bb9f43677cbcd7c8f3fb48da9c8e9c8", "committedDate": "2020-12-29T15:51:28Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "3c2a8f8150d317789e615bdfc4033b9cafd2689d", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/3c2a8f8150d317789e615bdfc4033b9cafd2689d", "committedDate": "2020-12-30T09:37:09Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5OTc2NTU4", "url": "https://github.com/telstra/open-kilda/pull/3942#pullrequestreview-559976558", "createdAt": "2020-12-30T09:43:20Z", "commit": {"oid": "3c2a8f8150d317789e615bdfc4033b9cafd2689d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c2a8f8150d317789e615bdfc4033b9cafd2689d", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/3c2a8f8150d317789e615bdfc4033b9cafd2689d", "committedDate": "2020-12-30T09:37:09Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "c9d242feb74dd43ed3f3c42624627b1d3d98c7b6", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/c9d242feb74dd43ed3f3c42624627b1d3d98c7b6", "committedDate": "2021-01-04T10:17:17Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9d242feb74dd43ed3f3c42624627b1d3d98c7b6", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/c9d242feb74dd43ed3f3c42624627b1d3d98c7b6", "committedDate": "2021-01-04T10:17:17Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "4f22ff450cb0ee136e90ccc6d32764a9c9059152", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/4f22ff450cb0ee136e90ccc6d32764a9c9059152", "committedDate": "2021-01-04T10:59:58Z", "message": "Add func tests for #3940 and #3941"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "091d1e535a0f60e55a964b49fa12a51d3bd884f8", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/091d1e535a0f60e55a964b49fa12a51d3bd884f8", "committedDate": "2021-03-15T11:47:31Z", "message": "Add tests for #3940 #3941"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f22ff450cb0ee136e90ccc6d32764a9c9059152", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/4f22ff450cb0ee136e90ccc6d32764a9c9059152", "committedDate": "2021-01-04T10:59:58Z", "message": "Add func tests for #3940 and #3941"}, "afterCommit": {"oid": "091d1e535a0f60e55a964b49fa12a51d3bd884f8", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/091d1e535a0f60e55a964b49fa12a51d3bd884f8", "committedDate": "2021-03-15T11:47:31Z", "message": "Add tests for #3940 #3941"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3736, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}