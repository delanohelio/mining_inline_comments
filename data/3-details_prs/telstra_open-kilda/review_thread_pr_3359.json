{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NTExNjQx", "number": 3359, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo0OTowN1rODvB0iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjo0MjozNFrODv-YRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjM5NDk3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo0OTowN1rOGBNuig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTo1MjoyMFrOGBQHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNjY2Ng==", "bodyText": "already tested above", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403926666", "createdAt": "2020-04-06T08:49:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -48,6 +49,18 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n                 [\n                         field   : \"priority\",\n                         newValue: 654\n+                ],\n+                [\n+                        field   : \"maxLatency\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk2NTg3Nw==", "bodyText": "oops, my bad", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403965877", "createdAt": "2020-04-06T09:52:20Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -48,6 +49,18 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n                 [\n                         field   : \"priority\",\n                         newValue: 654\n+                ],\n+                [\n+                        field   : \"maxLatency\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNjY2Ng=="}, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjQwMTc1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo1MDo1OVrOGBNy6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMDowNTo1MFrOGBQoCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNzc4NA==", "bodyText": "end of test1\nstart of test2\nWe should not overuse long scenarios. Moreover in this case scenarios a pretty much isolated and don't depend on each other, don't see any benefits in keeping them in 1 test", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403927784", "createdAt": "2020-04-06T08:50:59Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk3NDE1Mg==", "bodyText": "done", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403974152", "createdAt": "2020-04-06T10:05:50Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNzc4NA=="}, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjQxNjM4OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo1NDozNlrOGBN73g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTozOTozNVrOGBPo0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzMDA3OA==", "bodyText": "What if latency and cost paths are the same? Will the update actually happen?", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403930078", "createdAt": "2020-04-06T08:54:36Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+\n+        when: \"Update path computation strategy(latency -> cost) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = costStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Reroute the flow\"\n+        northboundV2.rerouteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk1Nzk2OQ==", "bodyText": "it doesn't matter, the 'pathComputationStrategy'  will be updated anyway", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r403957969", "createdAt": "2020-04-06T09:39:35Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,74 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        then: \"Path computation strategy is not changed\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == costStrategy\n+            targetPathComputationStrategy == latencyStrategy\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Sync the flow\"\n+        northbound.synchronizeFlow(flow.flowId)\n+\n+        then: \"Path computation strategy is updated and targetPathComputationStrategy is deleted\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            pathComputationStrategy == latencyStrategy\n+            !targetPathComputationStrategy\n+        }\n+\n+        when: \"Update path computation strategy(latency -> cost) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = costStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"Reroute the flow\"\n+        northboundV2.rerouteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzMDA3OA=="}, "originalCommit": {"oid": "a4283a3e0623a87da03fac8de25825f4b27877e2"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjMxNjg3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjo0MjozNFrOGCtY-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjowNjoxNVrOGD4wew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDAwOQ==", "bodyText": "Partial update of targetPathComputationStrategy should not cause a flow status change. Can you recheck this place please? I think these waits can be removed", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r405494009", "createdAt": "2020-04-08T12:42:34Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,88 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f576f45abd43a680c3155124e7c17a1de7a47069"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODgyNw==", "bodyText": "you are completely right, fixed", "url": "https://github.com/telstra/open-kilda/pull/3359#discussion_r406728827", "createdAt": "2020-04-10T12:06:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathComputationSpec.groovy", "diffHunk": "@@ -102,4 +107,88 @@ class PathComputationSpec extends HealthCheckSpecification {\n         originalLatencies && originalLatencies.each { isl, latency -> database.updateIslLatency(isl, latency) }\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n+\n+    @Tidy\n+    def \"Target flow path computation strategy is not applied immediately in case flow was updated partially\"() {\n+        given: \"Switch pair with two paths at least\"\n+        def swPair = topologyHelper.switchPairs.find { it.paths.size() >= 2 }\n+\n+        and: \"A flow with cost strategy\"\n+        def latencyStrategy = PathComputationStrategy.LATENCY.toString().toLowerCase()\n+        def costStrategy = PathComputationStrategy.COST.toString().toLowerCase()\n+        def flow = flowHelperV2.randomFlow(swPair).tap { it.pathComputationStrategy = costStrategy }\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Update path computation strategy(cost -> latency) via partialUpdate\"\n+        northbound.partialUpdate(flow.flowId, new FlowPatchDto().tap {\n+            it.targetPathComputationStrategy = latencyStrategy\n+        })\n+        Wrappers.wait(WAIT_OFFSET / 2) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NDAwOQ=="}, "originalCommit": {"oid": "f576f45abd43a680c3155124e7c17a1de7a47069"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1913, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}