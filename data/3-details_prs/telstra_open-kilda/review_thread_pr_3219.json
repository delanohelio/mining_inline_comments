{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NzI4MjY2", "number": 3219, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMzo0NzoyNlrODhE1Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODowODowOFrODhbQxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MDA4NzQzOnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/CommandContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMzo0NzoyNlrOFroqkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMzo0NzoyNlrOFroqkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI5OTM0Ng==", "bodyText": "It's OK as a quick solution. But this bounds CommandContext to classes of the transport layer (kafka). All arguments constructor + a dedicated builder may handle the case better.", "url": "https://github.com/telstra/open-kilda/pull/3219#discussion_r381299346", "createdAt": "2020-02-19T13:47:26Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/CommandContext.java", "diffHunk": "@@ -18,35 +18,56 @@\n import org.openkilda.messaging.Message;\n \n import lombok.Data;\n+import org.apache.kafka.clients.consumer.ConsumerRecord;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbf30b09b75062e7d6ce2effcf879e91ae83f0e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Mzc2MDc1OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/topology/utils/GenericKafkaRecordTranslator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODowNzoxNFrOFsJhVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODowNzoxNFrOFsJhVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNzY1Mw==", "bodyText": "what's the purpose of this method?", "url": "https://github.com/telstra/open-kilda/pull/3219#discussion_r381837653", "createdAt": "2020-02-20T08:07:14Z", "author": {"login": "timofei-durakov"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/topology/utils/GenericKafkaRecordTranslator.java", "diffHunk": "@@ -23,26 +23,24 @@\n import org.apache.storm.tuple.Fields;\n import org.apache.storm.tuple.Values;\n \n-import java.util.List;\n-\n-abstract class GenericKafkaRecordTranslator<R, D> extends KafkaRecordTranslator<String, R> {\n+abstract class GenericKafkaRecordTranslator<D> extends KafkaRecordTranslator<String, D, D> {\n     // use FIELD_ID_KEY instead\n     @Deprecated\n     public static final String KEY_FIELD = FIELD_ID_KEY;\n     public static final Fields STREAM_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n \n     @Override\n-    public List<Object> apply(ConsumerRecord<String, R> record) {\n-        D payload = decodePayload(record.value());\n-        return new Values(record.key(), payload, makeContext(payload));\n+    public Fields getFieldsFor(String stream) {\n+        return STREAM_FIELDS;\n     }\n \n-    protected abstract D decodePayload(R payload);\n-\n-    protected abstract CommandContext makeContext(D payload);\n+    @Override\n+    protected D decodePayload(D payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbf30b09b75062e7d6ce2effcf879e91ae83f0e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Mzc2MjYzOnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/topology/utils/InfoDataTranslator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODowODowOFrOFsJigQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODowODowOFrOFsJigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzNzk1Mw==", "bodyText": "the same question", "url": "https://github.com/telstra/open-kilda/pull/3219#discussion_r381837953", "createdAt": "2020-02-20T08:08:08Z", "author": {"login": "timofei-durakov"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/topology/utils/InfoDataTranslator.java", "diffHunk": "@@ -16,23 +16,32 @@\n package org.openkilda.wfm.topology.utils;\n \n import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.CommandContext;\n \n import org.apache.kafka.clients.consumer.ConsumerRecord;\n import org.apache.storm.tuple.Fields;\n import org.apache.storm.tuple.Values;\n \n-import java.util.List;\n+public class InfoDataTranslator extends KafkaRecordTranslator<String, InfoData, InfoData> {\n+    public static final Fields STREAM_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n \n-public class InfoDataTranslator extends KafkaRecordTranslator<String, InfoData> {\n+    @Override\n+    public Fields getFieldsFor(String stream) {\n+        return STREAM_FIELDS;\n+    }\n \n     @Override\n-    public List<Object> apply(ConsumerRecord<String, InfoData> record) {\n-        InfoData data = record.value();\n-        return new Values(record.key(), data);\n+    protected InfoData decodePayload(InfoData payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbf30b09b75062e7d6ce2effcf879e91ae83f0e"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2154, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}