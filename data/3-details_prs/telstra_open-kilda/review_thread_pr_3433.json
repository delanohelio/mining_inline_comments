{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMDcwMjI5", "number": 3433, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToxOTo0N1rOEACySw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzowNDoxOFrOEAFDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDgxMDk5OnYy", "diffSide": "RIGHT", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FeatureToggles.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMToxOTo0N1rOGbEvrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo1NzowMFrOHNFkyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MjQ3OQ==", "bodyText": "Why for we need builder API here(in all such files)? This class can be instantiated only inside constructor of FeatureToggles - so we can use it's constructor directly. It will simplify refactoring (idea can add arguments in all existing method call(constructor) call, but it can't do anything with the builder.", "url": "https://github.com/telstra/open-kilda/pull/3433#discussion_r431042479", "createdAt": "2020-05-27T11:19:47Z", "author": {"login": "surabujin"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FeatureToggles.java", "diffHunk": "@@ -15,100 +15,246 @@\n \n package org.openkilda.model;\n \n-import lombok.AccessLevel;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import lombok.AllArgsConstructor;\n import lombok.Builder;\n import lombok.Data;\n-import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.NoArgsConstructor;\n+import lombok.NonNull;\n import lombok.Setter;\n-import org.neo4j.ogm.annotation.GeneratedValue;\n-import org.neo4j.ogm.annotation.Id;\n-import org.neo4j.ogm.annotation.NodeEntity;\n-import org.neo4j.ogm.annotation.Property;\n-\n-@Data\n-@NoArgsConstructor\n-@AllArgsConstructor\n-@Builder(toBuilder = true)\n-@EqualsAndHashCode(exclude = \"entityId\")\n-@NodeEntity(label = \"config\")\n-public class FeatureToggles {\n-\n-    public static final FeatureToggles DEFAULTS = new FeatureToggles(\n-            null,  // ID\n-            false, // flows_reroute_on_isl_discovery\n-            false, // create_flow\n-            false, // update_flow\n-            false, // delete_flow\n-            false, // push_flow\n-            false, // unpush_flow\n-            true, // use_bfd_for_isl_integrity_check\n-            true, // floodlight_router_periodic_sync\n-            false, // flows_reroute_via_flowhs\n-            false, // flows_reroute_using_default_encap_type\n-            false // collect_grpc_stats\n-    );\n-\n-    // Hidden as needed for OGM only.\n-    @Id\n-    @GeneratedValue\n-    @Setter(AccessLevel.NONE)\n-    @Getter(AccessLevel.NONE)\n-    private Long entityId;\n-\n-    @Property(name = \"flows_reroute_on_isl_discovery\")\n-    private Boolean flowsRerouteOnIslDiscoveryEnabled;\n-\n-    @Property(name = \"create_flow\")\n-    private Boolean createFlowEnabled;\n-\n-    @Property(name = \"update_flow\")\n-    private Boolean updateFlowEnabled;\n-\n-    @Property(name = \"delete_flow\")\n-    private Boolean deleteFlowEnabled;\n-\n-    @Property(name = \"push_flow\")\n-    private Boolean pushFlowEnabled;\n-\n-    @Property(name = \"unpush_flow\")\n-    private Boolean unpushFlowEnabled;\n-\n-    @Property(name = \"use_bfd_for_isl_integrity_check\")\n-    private Boolean useBfdForIslIntegrityCheck;\n-\n-    @Property(name = \"floodlight_router_periodic_sync\")\n-    private Boolean floodlightRoutePeriodicSync;\n-\n-    @Property(name = \"flows_reroute_via_flowhs\")\n-    private Boolean flowsRerouteViaFlowHs;\n-\n-    @Property(name = \"flows_reroute_using_default_encap_type\")\n-    private Boolean flowsRerouteUsingDefaultEncapType;\n-\n-    @Property(name = \"collect_grpc_stats\")\n-    private Boolean collectGrpcStats;\n+import lombok.ToString;\n+import lombok.experimental.Delegate;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.MappingTarget;\n+import org.mapstruct.NullValuePropertyMappingStrategy;\n+import org.mapstruct.factory.Mappers;\n+\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@ToString\n+public class FeatureToggles implements CompositeDataEntity<FeatureToggles.FeatureTogglesData> {\n+    public static final FeatureToggles DEFAULTS = FeatureToggles.builder()\n+            .flowsRerouteOnIslDiscoveryEnabled(false)\n+            .createFlowEnabled(false)\n+            .updateFlowEnabled(false)\n+            .deleteFlowEnabled(false)\n+            .pushFlowEnabled(false)\n+            .unpushFlowEnabled(false)\n+            .useBfdForIslIntegrityCheck(true)\n+            .floodlightRoutePeriodicSync(true)\n+            .flowsRerouteViaFlowHs(false)\n+            .flowsRerouteUsingDefaultEncapType(false)\n+            .collectGrpcStats(false)\n+            .build();\n+\n+    @Getter\n+    @Setter\n+    @Delegate\n+    @JsonIgnore\n+    private FeatureTogglesData data;\n+\n+    /**\n+     * No args constructor for deserialization purpose.\n+     */\n+    private FeatureToggles() {\n+        data = new FeatureTogglesDataImpl();\n+    }\n+\n+    /**\n+     * Cloning constructor which performs deep copy of the toggles.\n+     *\n+     * @param entityToClone the entity to copy toggles data from.\n+     */\n+    public FeatureToggles(@NonNull FeatureToggles entityToClone) {\n+        data = FeatureTogglesCloner.INSTANCE.copy(entityToClone.getData());\n+    }\n+\n+    @Builder\n+    public FeatureToggles(Boolean flowsRerouteOnIslDiscoveryEnabled, Boolean createFlowEnabled,\n+                          Boolean updateFlowEnabled, Boolean deleteFlowEnabled, Boolean pushFlowEnabled,\n+                          Boolean unpushFlowEnabled, Boolean useBfdForIslIntegrityCheck,\n+                          Boolean floodlightRoutePeriodicSync, Boolean flowsRerouteViaFlowHs,\n+                          Boolean flowsRerouteUsingDefaultEncapType, Boolean collectGrpcStats) {\n+        data = FeatureTogglesDataImpl.builder()\n+                .flowsRerouteOnIslDiscoveryEnabled(flowsRerouteOnIslDiscoveryEnabled)\n+                .createFlowEnabled(createFlowEnabled).updateFlowEnabled(updateFlowEnabled)\n+                .deleteFlowEnabled(deleteFlowEnabled).pushFlowEnabled(pushFlowEnabled)\n+                .unpushFlowEnabled(unpushFlowEnabled).useBfdForIslIntegrityCheck(useBfdForIslIntegrityCheck)\n+                .floodlightRoutePeriodicSync(floodlightRoutePeriodicSync).flowsRerouteViaFlowHs(flowsRerouteViaFlowHs)\n+                .flowsRerouteUsingDefaultEncapType(flowsRerouteUsingDefaultEncapType)\n+                .collectGrpcStats(collectGrpcStats)\n+                .build();\n+    }\n+\n+    public FeatureToggles(@NonNull FeatureTogglesData data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeatureToggles that = (FeatureToggles) o;\n+        return new EqualsBuilder()\n+                .append(getFlowsRerouteOnIslDiscoveryEnabled(), that.getFlowsRerouteOnIslDiscoveryEnabled())\n+                .append(getCreateFlowEnabled(), that.getCreateFlowEnabled())\n+                .append(getUpdateFlowEnabled(), that.getUpdateFlowEnabled())\n+                .append(getDeleteFlowEnabled(), that.getDeleteFlowEnabled())\n+                .append(getPushFlowEnabled(), that.getPushFlowEnabled())\n+                .append(getUnpushFlowEnabled(), that.getUnpushFlowEnabled())\n+                .append(getUseBfdForIslIntegrityCheck(), that.getUseBfdForIslIntegrityCheck())\n+                .append(getFloodlightRoutePeriodicSync(), that.getFloodlightRoutePeriodicSync())\n+                .append(getFlowsRerouteViaFlowHs(), that.getFlowsRerouteViaFlowHs())\n+                .append(getFlowsRerouteUsingDefaultEncapType(), that.getFlowsRerouteUsingDefaultEncapType())\n+                .append(getCollectGrpcStats(), that.getCollectGrpcStats())\n+                .isEquals();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getFlowsRerouteOnIslDiscoveryEnabled(), getCreateFlowEnabled(),\n+                getUpdateFlowEnabled(), getDeleteFlowEnabled(), getPushFlowEnabled(), getUnpushFlowEnabled(),\n+                getUseBfdForIslIntegrityCheck(), getFloodlightRoutePeriodicSync(), getFlowsRerouteViaFlowHs(),\n+                getFlowsRerouteUsingDefaultEncapType(), getCollectGrpcStats());\n+    }\n+\n+    /**\n+     * Defines persistable data of the FeatureToggles.\n+     */\n+    public interface FeatureTogglesData {\n+        Boolean getFlowsRerouteOnIslDiscoveryEnabled();\n+\n+        void setFlowsRerouteOnIslDiscoveryEnabled(Boolean flowsRerouteOnIslDiscoveryEnabled);\n+\n+        Boolean getCreateFlowEnabled();\n+\n+        void setCreateFlowEnabled(Boolean createFlowEnabled);\n+\n+        Boolean getUpdateFlowEnabled();\n+\n+        void setUpdateFlowEnabled(Boolean updateFlowEnabled);\n+\n+        Boolean getDeleteFlowEnabled();\n+\n+        void setDeleteFlowEnabled(Boolean deleteFlowEnabled);\n+\n+        Boolean getPushFlowEnabled();\n+\n+        void setPushFlowEnabled(Boolean pushFlowEnabled);\n+\n+        Boolean getUnpushFlowEnabled();\n+\n+        void setUnpushFlowEnabled(Boolean unpushFlowEnabled);\n+\n+        Boolean getUseBfdForIslIntegrityCheck();\n+\n+        void setUseBfdForIslIntegrityCheck(Boolean useBfdForIslIntegrityCheck);\n+\n+        Boolean getFloodlightRoutePeriodicSync();\n+\n+        void setFloodlightRoutePeriodicSync(Boolean floodlightRoutePeriodicSync);\n+\n+        Boolean getFlowsRerouteViaFlowHs();\n+\n+        void setFlowsRerouteViaFlowHs(Boolean flowsRerouteViaFlowHs);\n+\n+        Boolean getFlowsRerouteUsingDefaultEncapType();\n+\n+        void setFlowsRerouteUsingDefaultEncapType(Boolean flowsRerouteUsingDefaultEncapType);\n+\n+        Boolean getCollectGrpcStats();\n+\n+        void setCollectGrpcStats(Boolean collectGrpcStats);\n+    }\n \n     /**\n-     * Constructor prevents initialization of entityId field.\n+     * POJO implementation of FeatureTogglesData.\n      */\n-    @Builder(toBuilder = true)\n-    FeatureToggles(Boolean flowsRerouteOnIslDiscoveryEnabled, Boolean createFlowEnabled, Boolean updateFlowEnabled,\n-                   Boolean deleteFlowEnabled, Boolean pushFlowEnabled, Boolean unpushFlowEnabled,\n-                   Boolean useBfdForIslIntegrityCheck, Boolean floodlightRoutePeriodicSync,\n-                   Boolean flowsRerouteViaFlowHs, Boolean flowsRerouteUsingDefaultEncapType, Boolean collectGrpcStats) {\n-        this.flowsRerouteOnIslDiscoveryEnabled = flowsRerouteOnIslDiscoveryEnabled;\n-        this.createFlowEnabled = createFlowEnabled;\n-        this.updateFlowEnabled = updateFlowEnabled;\n-        this.deleteFlowEnabled = deleteFlowEnabled;\n-        this.pushFlowEnabled = pushFlowEnabled;\n-        this.unpushFlowEnabled = unpushFlowEnabled;\n-        this.useBfdForIslIntegrityCheck = useBfdForIslIntegrityCheck;\n-        this.floodlightRoutePeriodicSync = floodlightRoutePeriodicSync;\n-        this.flowsRerouteViaFlowHs = flowsRerouteViaFlowHs;\n-        this.flowsRerouteUsingDefaultEncapType = flowsRerouteUsingDefaultEncapType;\n-        this.collectGrpcStats = collectGrpcStats;\n+    @Data\n+    @Builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5444f8a671dc7181ab34e3e5042bfb69acc1513"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ4NDg3Mw==", "bodyText": "Right, it can be just a constructor. But IDEA will not help with pulling constructor arguments from FeatureTogglesDataImpl up to FeatureToggles constructor. Developers have to do it manually. And idea behind usage of builders here - to avoid mixing up the arguments (with a builder, you see the names)", "url": "https://github.com/telstra/open-kilda/pull/3433#discussion_r483484873", "createdAt": "2020-09-04T08:57:00Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FeatureToggles.java", "diffHunk": "@@ -15,100 +15,246 @@\n \n package org.openkilda.model;\n \n-import lombok.AccessLevel;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n import lombok.AllArgsConstructor;\n import lombok.Builder;\n import lombok.Data;\n-import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.NoArgsConstructor;\n+import lombok.NonNull;\n import lombok.Setter;\n-import org.neo4j.ogm.annotation.GeneratedValue;\n-import org.neo4j.ogm.annotation.Id;\n-import org.neo4j.ogm.annotation.NodeEntity;\n-import org.neo4j.ogm.annotation.Property;\n-\n-@Data\n-@NoArgsConstructor\n-@AllArgsConstructor\n-@Builder(toBuilder = true)\n-@EqualsAndHashCode(exclude = \"entityId\")\n-@NodeEntity(label = \"config\")\n-public class FeatureToggles {\n-\n-    public static final FeatureToggles DEFAULTS = new FeatureToggles(\n-            null,  // ID\n-            false, // flows_reroute_on_isl_discovery\n-            false, // create_flow\n-            false, // update_flow\n-            false, // delete_flow\n-            false, // push_flow\n-            false, // unpush_flow\n-            true, // use_bfd_for_isl_integrity_check\n-            true, // floodlight_router_periodic_sync\n-            false, // flows_reroute_via_flowhs\n-            false, // flows_reroute_using_default_encap_type\n-            false // collect_grpc_stats\n-    );\n-\n-    // Hidden as needed for OGM only.\n-    @Id\n-    @GeneratedValue\n-    @Setter(AccessLevel.NONE)\n-    @Getter(AccessLevel.NONE)\n-    private Long entityId;\n-\n-    @Property(name = \"flows_reroute_on_isl_discovery\")\n-    private Boolean flowsRerouteOnIslDiscoveryEnabled;\n-\n-    @Property(name = \"create_flow\")\n-    private Boolean createFlowEnabled;\n-\n-    @Property(name = \"update_flow\")\n-    private Boolean updateFlowEnabled;\n-\n-    @Property(name = \"delete_flow\")\n-    private Boolean deleteFlowEnabled;\n-\n-    @Property(name = \"push_flow\")\n-    private Boolean pushFlowEnabled;\n-\n-    @Property(name = \"unpush_flow\")\n-    private Boolean unpushFlowEnabled;\n-\n-    @Property(name = \"use_bfd_for_isl_integrity_check\")\n-    private Boolean useBfdForIslIntegrityCheck;\n-\n-    @Property(name = \"floodlight_router_periodic_sync\")\n-    private Boolean floodlightRoutePeriodicSync;\n-\n-    @Property(name = \"flows_reroute_via_flowhs\")\n-    private Boolean flowsRerouteViaFlowHs;\n-\n-    @Property(name = \"flows_reroute_using_default_encap_type\")\n-    private Boolean flowsRerouteUsingDefaultEncapType;\n-\n-    @Property(name = \"collect_grpc_stats\")\n-    private Boolean collectGrpcStats;\n+import lombok.ToString;\n+import lombok.experimental.Delegate;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.MappingTarget;\n+import org.mapstruct.NullValuePropertyMappingStrategy;\n+import org.mapstruct.factory.Mappers;\n+\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@ToString\n+public class FeatureToggles implements CompositeDataEntity<FeatureToggles.FeatureTogglesData> {\n+    public static final FeatureToggles DEFAULTS = FeatureToggles.builder()\n+            .flowsRerouteOnIslDiscoveryEnabled(false)\n+            .createFlowEnabled(false)\n+            .updateFlowEnabled(false)\n+            .deleteFlowEnabled(false)\n+            .pushFlowEnabled(false)\n+            .unpushFlowEnabled(false)\n+            .useBfdForIslIntegrityCheck(true)\n+            .floodlightRoutePeriodicSync(true)\n+            .flowsRerouteViaFlowHs(false)\n+            .flowsRerouteUsingDefaultEncapType(false)\n+            .collectGrpcStats(false)\n+            .build();\n+\n+    @Getter\n+    @Setter\n+    @Delegate\n+    @JsonIgnore\n+    private FeatureTogglesData data;\n+\n+    /**\n+     * No args constructor for deserialization purpose.\n+     */\n+    private FeatureToggles() {\n+        data = new FeatureTogglesDataImpl();\n+    }\n+\n+    /**\n+     * Cloning constructor which performs deep copy of the toggles.\n+     *\n+     * @param entityToClone the entity to copy toggles data from.\n+     */\n+    public FeatureToggles(@NonNull FeatureToggles entityToClone) {\n+        data = FeatureTogglesCloner.INSTANCE.copy(entityToClone.getData());\n+    }\n+\n+    @Builder\n+    public FeatureToggles(Boolean flowsRerouteOnIslDiscoveryEnabled, Boolean createFlowEnabled,\n+                          Boolean updateFlowEnabled, Boolean deleteFlowEnabled, Boolean pushFlowEnabled,\n+                          Boolean unpushFlowEnabled, Boolean useBfdForIslIntegrityCheck,\n+                          Boolean floodlightRoutePeriodicSync, Boolean flowsRerouteViaFlowHs,\n+                          Boolean flowsRerouteUsingDefaultEncapType, Boolean collectGrpcStats) {\n+        data = FeatureTogglesDataImpl.builder()\n+                .flowsRerouteOnIslDiscoveryEnabled(flowsRerouteOnIslDiscoveryEnabled)\n+                .createFlowEnabled(createFlowEnabled).updateFlowEnabled(updateFlowEnabled)\n+                .deleteFlowEnabled(deleteFlowEnabled).pushFlowEnabled(pushFlowEnabled)\n+                .unpushFlowEnabled(unpushFlowEnabled).useBfdForIslIntegrityCheck(useBfdForIslIntegrityCheck)\n+                .floodlightRoutePeriodicSync(floodlightRoutePeriodicSync).flowsRerouteViaFlowHs(flowsRerouteViaFlowHs)\n+                .flowsRerouteUsingDefaultEncapType(flowsRerouteUsingDefaultEncapType)\n+                .collectGrpcStats(collectGrpcStats)\n+                .build();\n+    }\n+\n+    public FeatureToggles(@NonNull FeatureTogglesData data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeatureToggles that = (FeatureToggles) o;\n+        return new EqualsBuilder()\n+                .append(getFlowsRerouteOnIslDiscoveryEnabled(), that.getFlowsRerouteOnIslDiscoveryEnabled())\n+                .append(getCreateFlowEnabled(), that.getCreateFlowEnabled())\n+                .append(getUpdateFlowEnabled(), that.getUpdateFlowEnabled())\n+                .append(getDeleteFlowEnabled(), that.getDeleteFlowEnabled())\n+                .append(getPushFlowEnabled(), that.getPushFlowEnabled())\n+                .append(getUnpushFlowEnabled(), that.getUnpushFlowEnabled())\n+                .append(getUseBfdForIslIntegrityCheck(), that.getUseBfdForIslIntegrityCheck())\n+                .append(getFloodlightRoutePeriodicSync(), that.getFloodlightRoutePeriodicSync())\n+                .append(getFlowsRerouteViaFlowHs(), that.getFlowsRerouteViaFlowHs())\n+                .append(getFlowsRerouteUsingDefaultEncapType(), that.getFlowsRerouteUsingDefaultEncapType())\n+                .append(getCollectGrpcStats(), that.getCollectGrpcStats())\n+                .isEquals();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getFlowsRerouteOnIslDiscoveryEnabled(), getCreateFlowEnabled(),\n+                getUpdateFlowEnabled(), getDeleteFlowEnabled(), getPushFlowEnabled(), getUnpushFlowEnabled(),\n+                getUseBfdForIslIntegrityCheck(), getFloodlightRoutePeriodicSync(), getFlowsRerouteViaFlowHs(),\n+                getFlowsRerouteUsingDefaultEncapType(), getCollectGrpcStats());\n+    }\n+\n+    /**\n+     * Defines persistable data of the FeatureToggles.\n+     */\n+    public interface FeatureTogglesData {\n+        Boolean getFlowsRerouteOnIslDiscoveryEnabled();\n+\n+        void setFlowsRerouteOnIslDiscoveryEnabled(Boolean flowsRerouteOnIslDiscoveryEnabled);\n+\n+        Boolean getCreateFlowEnabled();\n+\n+        void setCreateFlowEnabled(Boolean createFlowEnabled);\n+\n+        Boolean getUpdateFlowEnabled();\n+\n+        void setUpdateFlowEnabled(Boolean updateFlowEnabled);\n+\n+        Boolean getDeleteFlowEnabled();\n+\n+        void setDeleteFlowEnabled(Boolean deleteFlowEnabled);\n+\n+        Boolean getPushFlowEnabled();\n+\n+        void setPushFlowEnabled(Boolean pushFlowEnabled);\n+\n+        Boolean getUnpushFlowEnabled();\n+\n+        void setUnpushFlowEnabled(Boolean unpushFlowEnabled);\n+\n+        Boolean getUseBfdForIslIntegrityCheck();\n+\n+        void setUseBfdForIslIntegrityCheck(Boolean useBfdForIslIntegrityCheck);\n+\n+        Boolean getFloodlightRoutePeriodicSync();\n+\n+        void setFloodlightRoutePeriodicSync(Boolean floodlightRoutePeriodicSync);\n+\n+        Boolean getFlowsRerouteViaFlowHs();\n+\n+        void setFlowsRerouteViaFlowHs(Boolean flowsRerouteViaFlowHs);\n+\n+        Boolean getFlowsRerouteUsingDefaultEncapType();\n+\n+        void setFlowsRerouteUsingDefaultEncapType(Boolean flowsRerouteUsingDefaultEncapType);\n+\n+        Boolean getCollectGrpcStats();\n+\n+        void setCollectGrpcStats(Boolean collectGrpcStats);\n+    }\n \n     /**\n-     * Constructor prevents initialization of entityId field.\n+     * POJO implementation of FeatureTogglesData.\n      */\n-    @Builder(toBuilder = true)\n-    FeatureToggles(Boolean flowsRerouteOnIslDiscoveryEnabled, Boolean createFlowEnabled, Boolean updateFlowEnabled,\n-                   Boolean deleteFlowEnabled, Boolean pushFlowEnabled, Boolean unpushFlowEnabled,\n-                   Boolean useBfdForIslIntegrityCheck, Boolean floodlightRoutePeriodicSync,\n-                   Boolean flowsRerouteViaFlowHs, Boolean flowsRerouteUsingDefaultEncapType, Boolean collectGrpcStats) {\n-        this.flowsRerouteOnIslDiscoveryEnabled = flowsRerouteOnIslDiscoveryEnabled;\n-        this.createFlowEnabled = createFlowEnabled;\n-        this.updateFlowEnabled = updateFlowEnabled;\n-        this.deleteFlowEnabled = deleteFlowEnabled;\n-        this.pushFlowEnabled = pushFlowEnabled;\n-        this.unpushFlowEnabled = unpushFlowEnabled;\n-        this.useBfdForIslIntegrityCheck = useBfdForIslIntegrityCheck;\n-        this.floodlightRoutePeriodicSync = floodlightRoutePeriodicSync;\n-        this.flowsRerouteViaFlowHs = flowsRerouteViaFlowHs;\n-        this.flowsRerouteUsingDefaultEncapType = flowsRerouteUsingDefaultEncapType;\n-        this.collectGrpcStats = collectGrpcStats;\n+    @Data\n+    @Builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MjQ3OQ=="}, "originalCommit": {"oid": "b5444f8a671dc7181ab34e3e5042bfb69acc1513"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTE4MjYyOnYy", "diffSide": "RIGHT", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/BfdSession.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzowNDoxOFrOGbIfDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo0NTozNFrOHNHKBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTEwMzc1OQ==", "bodyText": "Why you prefer interface as the base for mapper? If it will be abstract class, it will allow restricting access to method that can be restricted (there is not too many such methods now, but they exists). Also in opposite to weird syntax hack (default methods in interfaces), code in methods of abstract classes are natural.", "url": "https://github.com/telstra/open-kilda/pull/3433#discussion_r431103759", "createdAt": "2020-05-27T13:04:18Z", "author": {"login": "surabujin"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/BfdSession.java", "diffHunk": "@@ -15,83 +15,138 @@\n \n package org.openkilda.model;\n \n-import lombok.AccessLevel;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n import lombok.Data;\n+import lombok.Getter;\n import lombok.NoArgsConstructor;\n import lombok.NonNull;\n import lombok.Setter;\n-import org.neo4j.ogm.annotation.GeneratedValue;\n-import org.neo4j.ogm.annotation.Id;\n-import org.neo4j.ogm.annotation.Index;\n-import org.neo4j.ogm.annotation.NodeEntity;\n-import org.neo4j.ogm.annotation.Property;\n-import org.neo4j.ogm.annotation.typeconversion.Convert;\n-\n-@Data\n-@NoArgsConstructor\n-@NodeEntity(label = \"bfd_session\")\n-public class BfdSession {\n-\n-    public static final String SWITCH_PROPERTY_NAME = \"switch\";\n-    public static final String IP_ADDRESS_PROPERTY_NAME = \"ip_address\";\n-    public static final String REMOTE_SWITCH_PROPERTY_NAME = \"remote_switch\";\n-    public static final String REMOVE_IP_ADDRESS_PROPERTY_NAME = \"remote_ip_address\";\n-    public static final String PORT_PROPERTY_NAME = \"port\";\n-    public static final String DISCRIMINATOR_PROPERTY_NAME = \"discriminator\";\n-\n-    // Hidden as needed for OGM only.\n-    @Id\n-    @GeneratedValue\n-    @Setter(AccessLevel.NONE)\n-    private Long entityId;\n-\n-    @NonNull\n-    @Property(name = SWITCH_PROPERTY_NAME)\n-    @Convert(graphPropertyType = String.class)\n-    private SwitchId switchId;\n-\n-    @Property(name = IP_ADDRESS_PROPERTY_NAME)\n-    private String ipAddress;\n-\n-    @Property(name = REMOTE_SWITCH_PROPERTY_NAME)\n-    @Convert(graphPropertyType = String.class)\n-    private SwitchId remoteSwitchId;\n-\n-    @Property(name = REMOVE_IP_ADDRESS_PROPERTY_NAME)\n-    private String remoteIpAddress;\n-\n-    @NonNull\n-    @Property(name = PORT_PROPERTY_NAME)\n-    private Integer port;\n-\n-    @Property(name = DISCRIMINATOR_PROPERTY_NAME)\n-    @Index(unique = true)\n-    private Integer discriminator;\n-\n-    public BfdSession(@NonNull SwitchId switchId,\n-                      @NonNull Integer port) {\n-        this(switchId, null, null, null, port, null);\n+import lombok.ToString;\n+import lombok.experimental.Delegate;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.MappingTarget;\n+import org.mapstruct.factory.Mappers;\n+\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@ToString\n+public class BfdSession implements CompositeDataEntity<BfdSession.BfdSessionData> {\n+    @Getter\n+    @Setter\n+    @Delegate\n+    @JsonIgnore\n+    private BfdSessionData data;\n+\n+    /**\n+     * No args constructor for deserialization purpose.\n+     */\n+    private BfdSession() {\n+        data = new BfdSessionDataImpl();\n     }\n \n     @Builder\n-    private BfdSession(SwitchId switchId, String ipAddress, SwitchId remoteSwitchId, String remoteIpAddress,\n-                         Integer port, Integer discriminator) {\n-        this.switchId = switchId;\n-        this.ipAddress = ipAddress;\n-        this.remoteSwitchId = remoteSwitchId;\n-        this.remoteIpAddress = remoteIpAddress;\n-        this.port = port;\n-        this.discriminator = discriminator;\n+    public BfdSession(@NonNull SwitchId switchId, String ipAddress, SwitchId remoteSwitchId,\n+                      String remoteIpAddress, @NonNull Integer port, Integer discriminator) {\n+        data = BfdSessionDataImpl.builder()\n+                .switchId(switchId).ipAddress(ipAddress).remoteSwitchId(remoteSwitchId)\n+                .remoteIpAddress(remoteIpAddress).port(port).discriminator(discriminator).build();\n+    }\n+\n+    public BfdSession(@NonNull BfdSessionData data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        BfdSession that = (BfdSession) o;\n+        return new EqualsBuilder()\n+                .append(getSwitchId(), that.getSwitchId())\n+                .append(getIpAddress(), that.getIpAddress())\n+                .append(getRemoteSwitchId(), that.getRemoteSwitchId())\n+                .append(getRemoteIpAddress(), that.getRemoteIpAddress())\n+                .append(getPort(), that.getPort())\n+                .append(getDiscriminator(), that.getDiscriminator())\n+                .isEquals();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getSwitchId(), getIpAddress(), getRemoteSwitchId(), getRemoteIpAddress(),\n+                getPort(), getDiscriminator());\n     }\n \n     /**\n-     * BfdSession builder with prefilled mandatory fields.\n+     * Defines persistable data of the BfdSession.\n      */\n-    public static BfdSessionBuilder builder(@NonNull SwitchId switchId,\n-                                            @NonNull Integer port) {\n-        return new BfdSessionBuilder()\n-                .switchId(switchId)\n-                .port(port);\n+    public interface BfdSessionData {\n+        SwitchId getSwitchId();\n+\n+        void setSwitchId(SwitchId switchId);\n+\n+        String getIpAddress();\n+\n+        void setIpAddress(String ipAddress);\n+\n+        SwitchId getRemoteSwitchId();\n+\n+        void setRemoteSwitchId(SwitchId remoteSwitchId);\n+\n+        String getRemoteIpAddress();\n+\n+        void setRemoteIpAddress(String remoteIpAddress);\n+\n+        Integer getPort();\n+\n+        void setPort(Integer port);\n+\n+        Integer getDiscriminator();\n+\n+        void setDiscriminator(Integer discriminator);\n+    }\n+\n+    /**\n+     * POJO implementation of BfdSessionData.\n+     */\n+    @Data\n+    @Builder\n+    @NoArgsConstructor\n+    @AllArgsConstructor\n+    static final class BfdSessionDataImpl implements BfdSessionData, Serializable {\n+        private static final long serialVersionUID = 1L;\n+        @NonNull SwitchId switchId;\n+        String ipAddress;\n+        SwitchId remoteSwitchId;\n+        String remoteIpAddress;\n+        @NonNull Integer port;\n+        Integer discriminator;\n+    }\n+\n+    /**\n+     * A cloner for BfdSession entity.\n+     */\n+    @Mapper\n+    public interface BfdSessionCloner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5444f8a671dc7181ab34e3e5042bfb69acc1513"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMDc4OA==", "bodyText": "With interfaces it's a bit less verbose:\n    public interface BfdSessionCloner {\n        BfdSessionCloner INSTANCE = Mappers.getMapper(BfdSessionCloner.class);\n\n        void copy(BfdSessionData source, @MappingTarget BfdSessionData target);\n\n        default BfdSessionData copy(BfdSessionData source) {\n            ...\n        }\n    }\n\nvs\n    public static abstract class BfdSessionCloner {\n        public static final BfdSessionCloner INSTANCE = Mappers.getMapper(BfdSessionCloner.class);\n\n        public abstract void copy(BfdSessionData source, @MappingTarget BfdSessionData target);\n\n        public BfdSessionData copy(BfdSessionData source) {\n            ...\n        }\n    }\n\nNo other preferences. Also, I found only 2 entities where we need non-public methods in a cloner - those can be changed to abstract classes.", "url": "https://github.com/telstra/open-kilda/pull/3433#discussion_r483510788", "createdAt": "2020-09-04T09:45:34Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/kilda-model/src/main/java/org/openkilda/model/BfdSession.java", "diffHunk": "@@ -15,83 +15,138 @@\n \n package org.openkilda.model;\n \n-import lombok.AccessLevel;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n import lombok.Data;\n+import lombok.Getter;\n import lombok.NoArgsConstructor;\n import lombok.NonNull;\n import lombok.Setter;\n-import org.neo4j.ogm.annotation.GeneratedValue;\n-import org.neo4j.ogm.annotation.Id;\n-import org.neo4j.ogm.annotation.Index;\n-import org.neo4j.ogm.annotation.NodeEntity;\n-import org.neo4j.ogm.annotation.Property;\n-import org.neo4j.ogm.annotation.typeconversion.Convert;\n-\n-@Data\n-@NoArgsConstructor\n-@NodeEntity(label = \"bfd_session\")\n-public class BfdSession {\n-\n-    public static final String SWITCH_PROPERTY_NAME = \"switch\";\n-    public static final String IP_ADDRESS_PROPERTY_NAME = \"ip_address\";\n-    public static final String REMOTE_SWITCH_PROPERTY_NAME = \"remote_switch\";\n-    public static final String REMOVE_IP_ADDRESS_PROPERTY_NAME = \"remote_ip_address\";\n-    public static final String PORT_PROPERTY_NAME = \"port\";\n-    public static final String DISCRIMINATOR_PROPERTY_NAME = \"discriminator\";\n-\n-    // Hidden as needed for OGM only.\n-    @Id\n-    @GeneratedValue\n-    @Setter(AccessLevel.NONE)\n-    private Long entityId;\n-\n-    @NonNull\n-    @Property(name = SWITCH_PROPERTY_NAME)\n-    @Convert(graphPropertyType = String.class)\n-    private SwitchId switchId;\n-\n-    @Property(name = IP_ADDRESS_PROPERTY_NAME)\n-    private String ipAddress;\n-\n-    @Property(name = REMOTE_SWITCH_PROPERTY_NAME)\n-    @Convert(graphPropertyType = String.class)\n-    private SwitchId remoteSwitchId;\n-\n-    @Property(name = REMOVE_IP_ADDRESS_PROPERTY_NAME)\n-    private String remoteIpAddress;\n-\n-    @NonNull\n-    @Property(name = PORT_PROPERTY_NAME)\n-    private Integer port;\n-\n-    @Property(name = DISCRIMINATOR_PROPERTY_NAME)\n-    @Index(unique = true)\n-    private Integer discriminator;\n-\n-    public BfdSession(@NonNull SwitchId switchId,\n-                      @NonNull Integer port) {\n-        this(switchId, null, null, null, port, null);\n+import lombok.ToString;\n+import lombok.experimental.Delegate;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.MappingTarget;\n+import org.mapstruct.factory.Mappers;\n+\n+import java.io.Serializable;\n+import java.util.Objects;\n+\n+@ToString\n+public class BfdSession implements CompositeDataEntity<BfdSession.BfdSessionData> {\n+    @Getter\n+    @Setter\n+    @Delegate\n+    @JsonIgnore\n+    private BfdSessionData data;\n+\n+    /**\n+     * No args constructor for deserialization purpose.\n+     */\n+    private BfdSession() {\n+        data = new BfdSessionDataImpl();\n     }\n \n     @Builder\n-    private BfdSession(SwitchId switchId, String ipAddress, SwitchId remoteSwitchId, String remoteIpAddress,\n-                         Integer port, Integer discriminator) {\n-        this.switchId = switchId;\n-        this.ipAddress = ipAddress;\n-        this.remoteSwitchId = remoteSwitchId;\n-        this.remoteIpAddress = remoteIpAddress;\n-        this.port = port;\n-        this.discriminator = discriminator;\n+    public BfdSession(@NonNull SwitchId switchId, String ipAddress, SwitchId remoteSwitchId,\n+                      String remoteIpAddress, @NonNull Integer port, Integer discriminator) {\n+        data = BfdSessionDataImpl.builder()\n+                .switchId(switchId).ipAddress(ipAddress).remoteSwitchId(remoteSwitchId)\n+                .remoteIpAddress(remoteIpAddress).port(port).discriminator(discriminator).build();\n+    }\n+\n+    public BfdSession(@NonNull BfdSessionData data) {\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        BfdSession that = (BfdSession) o;\n+        return new EqualsBuilder()\n+                .append(getSwitchId(), that.getSwitchId())\n+                .append(getIpAddress(), that.getIpAddress())\n+                .append(getRemoteSwitchId(), that.getRemoteSwitchId())\n+                .append(getRemoteIpAddress(), that.getRemoteIpAddress())\n+                .append(getPort(), that.getPort())\n+                .append(getDiscriminator(), that.getDiscriminator())\n+                .isEquals();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getSwitchId(), getIpAddress(), getRemoteSwitchId(), getRemoteIpAddress(),\n+                getPort(), getDiscriminator());\n     }\n \n     /**\n-     * BfdSession builder with prefilled mandatory fields.\n+     * Defines persistable data of the BfdSession.\n      */\n-    public static BfdSessionBuilder builder(@NonNull SwitchId switchId,\n-                                            @NonNull Integer port) {\n-        return new BfdSessionBuilder()\n-                .switchId(switchId)\n-                .port(port);\n+    public interface BfdSessionData {\n+        SwitchId getSwitchId();\n+\n+        void setSwitchId(SwitchId switchId);\n+\n+        String getIpAddress();\n+\n+        void setIpAddress(String ipAddress);\n+\n+        SwitchId getRemoteSwitchId();\n+\n+        void setRemoteSwitchId(SwitchId remoteSwitchId);\n+\n+        String getRemoteIpAddress();\n+\n+        void setRemoteIpAddress(String remoteIpAddress);\n+\n+        Integer getPort();\n+\n+        void setPort(Integer port);\n+\n+        Integer getDiscriminator();\n+\n+        void setDiscriminator(Integer discriminator);\n+    }\n+\n+    /**\n+     * POJO implementation of BfdSessionData.\n+     */\n+    @Data\n+    @Builder\n+    @NoArgsConstructor\n+    @AllArgsConstructor\n+    static final class BfdSessionDataImpl implements BfdSessionData, Serializable {\n+        private static final long serialVersionUID = 1L;\n+        @NonNull SwitchId switchId;\n+        String ipAddress;\n+        SwitchId remoteSwitchId;\n+        String remoteIpAddress;\n+        @NonNull Integer port;\n+        Integer discriminator;\n+    }\n+\n+    /**\n+     * A cloner for BfdSession entity.\n+     */\n+    @Mapper\n+    public interface BfdSessionCloner {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTEwMzc1OQ=="}, "originalCommit": {"oid": "b5444f8a671dc7181ab34e3e5042bfb69acc1513"}, "originalPosition": 190}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1955, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}