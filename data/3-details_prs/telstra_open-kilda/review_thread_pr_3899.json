{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMDA0MjQw", "number": 3899, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODozOTowNVrOFDWpYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo0MjoyM1rOFDWvFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDYxMDg5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODozOTowNVrOIC9fjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMDoxMTozNFrOIDBf4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3NTU2NQ==", "bodyText": "not sure why it's required here. I don't see any vxlan context in this test", "url": "https://github.com/telstra/open-kilda/pull/3899#discussion_r539975565", "createdAt": "2020-12-10T08:39:05Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -842,7 +842,9 @@ class QinQFlowSpec extends HealthCheckSpecification {\n         assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n         def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n             [it.src, it.dst].every { sw ->\n-                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable &&\n+                        northbound.getSwitchProperties(sw.dpId).supportedTransitEncapsulation\n+                                .contains(FlowEncapsulationType.VXLAN.toString().toLowerCase())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51a5bbc628a609d28885ec6f2acab005aab11425"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA0MTE4Nw==", "bodyText": "looks like my mistake. fixed", "url": "https://github.com/telstra/open-kilda/pull/3899#discussion_r540041187", "createdAt": "2020-12-10T10:11:34Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -842,7 +842,9 @@ class QinQFlowSpec extends HealthCheckSpecification {\n         assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n         def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n             [it.src, it.dst].every { sw ->\n-                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable &&\n+                        northbound.getSwitchProperties(sw.dpId).supportedTransitEncapsulation\n+                                .contains(FlowEncapsulationType.VXLAN.toString().toLowerCase())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3NTU2NQ=="}, "originalCommit": {"oid": "51a5bbc628a609d28885ec6f2acab005aab11425"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDYyNTUxOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/VxlanFlowV2Spec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo0MjoyM1rOIC9nxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMDoxNToxNVrOIDBrqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3NzY3MQ==", "bodyText": "isVxlanEnabled ?", "url": "https://github.com/telstra/open-kilda/pull/3899#discussion_r539977671", "createdAt": "2020-12-10T08:42:23Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/VxlanFlowV2Spec.groovy", "diffHunk": "@@ -241,14 +242,18 @@ class VxlanFlowV2Spec extends HealthCheckSpecification {\n     @Tidy\n     @Tags(HARDWARE)\n     def \"Able to CRUD a vxlan flow with protected path\"() {\n-        given: \"Two active Noviflow switches with two available path at least\"\n-        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n-            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164 &&\n-                    it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        given: \"Two active VXLAN supported switches with two available path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            [swP.src, swP.dst].every { sw -> isVxlanEnabled(sw.dpId) } && swP.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n         } ?: assumeTrue(\"No suiting switches found\", false)\n \n         def availablePaths = switchPair.paths.findAll { path ->\n-            pathHelper.getInvolvedSwitches(path).every { it.noviflow && !it.wb5164 }\n+            pathHelper.getInvolvedSwitches(path).every {\n+                northbound.getSwitchProperties(it.dpId).supportedTransitEncapsulation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51a5bbc628a609d28885ec6f2acab005aab11425"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA0NDIwMQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3899#discussion_r540044201", "createdAt": "2020-12-10T10:15:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/VxlanFlowV2Spec.groovy", "diffHunk": "@@ -241,14 +242,18 @@ class VxlanFlowV2Spec extends HealthCheckSpecification {\n     @Tidy\n     @Tags(HARDWARE)\n     def \"Able to CRUD a vxlan flow with protected path\"() {\n-        given: \"Two active Noviflow switches with two available path at least\"\n-        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n-            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164 &&\n-                    it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        given: \"Two active VXLAN supported switches with two available path at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            [swP.src, swP.dst].every { sw -> isVxlanEnabled(sw.dpId) } && swP.paths.unique(false) {\n+                a, b -> a.intersect(b) == [] ? 1 : 0\n+            }.size() >= 2\n         } ?: assumeTrue(\"No suiting switches found\", false)\n \n         def availablePaths = switchPair.paths.findAll { path ->\n-            pathHelper.getInvolvedSwitches(path).every { it.noviflow && !it.wb5164 }\n+            pathHelper.getInvolvedSwitches(path).every {\n+                northbound.getSwitchProperties(it.dpId).supportedTransitEncapsulation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3NzY3MQ=="}, "originalCommit": {"oid": "51a5bbc628a609d28885ec6f2acab005aab11425"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2351, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}