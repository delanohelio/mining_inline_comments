{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NTc0MTcw", "number": 3889, "title": "add flowLoop tests for singleSwFlow", "bodyText": "", "createdAt": "2020-11-30T14:08:42Z", "url": "https://github.com/telstra/open-kilda/pull/3889", "merged": true, "mergeCommit": {"oid": "75f2061eda9f8af0017164a8686d5d9c477926ea"}, "closed": true, "closedAt": "2020-12-09T21:48:37Z", "author": {"login": "andriidovhan"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh2WOSgBqjQwNTYwMDI2OTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkatFUgFqTU0Nzk1Mzg0MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0080185e518343d349294176beb4305d4466ae1", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/b0080185e518343d349294176beb4305d4466ae1", "committedDate": "2020-11-30T14:05:50Z", "message": "add flowLoop tests for singleSwFlow"}, "afterCommit": {"oid": "bad437a6096905b4c0c82a3d8ac7904615aa6e18", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/bad437a6096905b4c0c82a3d8ac7904615aa6e18", "committedDate": "2020-12-01T09:13:48Z", "message": "add flowLoop tests for singleSwFlow"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bad437a6096905b4c0c82a3d8ac7904615aa6e18", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/bad437a6096905b4c0c82a3d8ac7904615aa6e18", "committedDate": "2020-12-01T09:13:48Z", "message": "add flowLoop tests for singleSwFlow"}, "afterCommit": {"oid": "3b7474a1556620c99462c9ff63125ad12c2b9464", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/3b7474a1556620c99462c9ff63125ad12c2b9464", "committedDate": "2020-12-03T11:15:45Z", "message": "add flowLoop tests for singleSwFlow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41a94a2639b845111bc03630a860b820d6bbbcf6", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/41a94a2639b845111bc03630a860b820d6bbbcf6", "committedDate": "2020-12-07T18:10:49Z", "message": "add tests for flowLoop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62aeb784e6bef351aba0235f267352b81de0676b", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/62aeb784e6bef351aba0235f267352b81de0676b", "committedDate": "2020-12-07T18:10:49Z", "message": "unignore qinq and multiTable in flowLoopSpec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/4f4094319bcea79440b1a9de4f7df77d4f76312d", "committedDate": "2020-12-07T18:10:49Z", "message": "add flowLoop tests for singleSwFlow"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b7474a1556620c99462c9ff63125ad12c2b9464", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/3b7474a1556620c99462c9ff63125ad12c2b9464", "committedDate": "2020-12-03T11:15:45Z", "message": "add flowLoop tests for singleSwFlow"}, "afterCommit": {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/4f4094319bcea79440b1a9de4f7df77d4f76312d", "committedDate": "2020-12-07T18:10:49Z", "message": "add flowLoop tests for singleSwFlow"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3OTUzODQw", "url": "https://github.com/telstra/open-kilda/pull/3889#pullrequestreview-547953840", "createdAt": "2020-12-09T08:44:22Z", "commit": {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOICI5CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOICI5CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMzczNw==", "bodyText": "Tbh I still don't understand the point of this feature. Flow loop rule will be exactly the same as the actual flow rule", "url": "https://github.com/telstra/open-kilda/pull/3889#discussion_r539113737", "createdAt": "2020-12-09T08:44:22Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -523,6 +523,108 @@ class FlowLoopSpec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        and: \"The switch is valid\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(sw.dpId).size() == 2\n+            northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are deleted from the switch\"\n+        assert getFlowLoopRules(sw.dpId).empty\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3781, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}