{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MzY1Mjcw", "number": 3132, "title": "Add test for #3128", "bodyText": "Reproduces #3128", "createdAt": "2020-01-21T15:28:32Z", "url": "https://github.com/telstra/open-kilda/pull/3132", "merged": true, "mergeCommit": {"oid": "188ba106503afe3f7345b07d4beed8e3996f92a8"}, "closed": true, "closedAt": "2020-02-04T11:19:37Z", "author": {"login": "rtretyak"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8ynn1gBqjI5NjkzNTg0NDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcA-R3xgH2gAyMzY1MzY1MjcwOmNkZTg0YTMzMjE0MzgxNzFlZWJmMDZkOGUzZmIxOGU0ODYxY2IzYmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c3ca26fce9d45b216c6f59cf87891037cafa3bc", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/5c3ca26fce9d45b216c6f59cf87891037cafa3bc", "committedDate": "2020-01-21T15:25:31Z", "message": "Add test for #3128"}, "afterCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "committedDate": "2020-01-22T09:48:36Z", "message": "Add test for #3128"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MjAyMjI3", "url": "https://github.com/telstra/open-kilda/pull/3132#pullrequestreview-347202227", "createdAt": "2020-01-23T10:42:06Z", "commit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0MjowNlrOFg5yIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMToxMzo1OVrOFg6o6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0NTQ3Mg==", "bodyText": "I guess we can omit it.reversed", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370045472", "createdAt": "2020-01-23T10:42:06Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODA3NA==", "bodyText": "how about checking that flowPath is the same as mainPath?", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370048074", "createdAt": "2020-01-23T10:47:29Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1ODg0Mw==", "bodyText": "misconfigured ?", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370058843", "createdAt": "2020-01-23T11:12:38Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1OTQ5Nw==", "bodyText": "northbound.deleteLinkProps(northbound.getAllLinkProps())", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370059497", "createdAt": "2020-01-23T11:13:59Z", "author": {"login": "andriidovhan"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])\n+        }\n+\n+        cleanup:\n+        if(switchIsOut) {\n+            database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.INACTIVE)\n+            lockKeeper.reviveSwitch(switchToBreak)\n+            Wrappers.wait(WAIT_OFFSET) {\n+                assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.ACTIVATED\n+            }\n+        }\n+        if(portDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+                assert northbound.getLink(islToBreak).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        flow && flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447"}, "originalPosition": 105}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "committedDate": "2020-01-22T09:48:36Z", "message": "Add test for #3128"}, "afterCommit": {"oid": "afb043507b6d349a48c4463457451c313c47b89a", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/afb043507b6d349a48c4463457451c313c47b89a", "committedDate": "2020-01-23T14:43:46Z", "message": "Add test for #3128"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODA3NTQ3", "url": "https://github.com/telstra/open-kilda/pull/3132#pullrequestreview-347807547", "createdAt": "2020-01-24T08:38:14Z", "commit": {"oid": "afb043507b6d349a48c4463457451c313c47b89a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afb043507b6d349a48c4463457451c313c47b89a", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/afb043507b6d349a48c4463457451c313c47b89a", "committedDate": "2020-01-23T14:43:46Z", "message": "Add test for #3128"}, "afterCommit": {"oid": "b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "committedDate": "2020-01-27T14:46:59Z", "message": "Add test for #3128"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "committedDate": "2020-01-27T14:46:59Z", "message": "Add test for #3128"}, "afterCommit": {"oid": "8f274e6d2ef0402db4f0ab79fdd25f407bf35fc3", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/8f274e6d2ef0402db4f0ab79fdd25f407bf35fc3", "committedDate": "2020-02-03T17:31:30Z", "message": "Add test for #3128"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f939d5da66c2f300a3268409f183de217c9b2386", "author": {"user": {"login": "rtretyak", "name": "Roman Tretiak"}}, "url": "https://github.com/telstra/open-kilda/commit/f939d5da66c2f300a3268409f183de217c9b2386", "committedDate": "2020-02-04T08:16:41Z", "message": "Add test for #3128"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "650ee92de63ef888e407b94fe8dcdca15a3c4b34", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/650ee92de63ef888e407b94fe8dcdca15a3c4b34", "committedDate": "2020-02-04T08:18:05Z", "message": "fix \"Flow in Down status is rerouted after switchUp event\" according to #3162"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "772de17a3678e57c3afde5255eaf8eb7801e3adf", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/772de17a3678e57c3afde5255eaf8eb7801e3adf", "committedDate": "2020-02-04T08:14:06Z", "message": "fix \"Flow in Down status is rerouted after switchUp event\" according to #3162"}, "afterCommit": {"oid": "650ee92de63ef888e407b94fe8dcdca15a3c4b34", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/650ee92de63ef888e407b94fe8dcdca15a3c4b34", "committedDate": "2020-02-04T08:18:05Z", "message": "fix \"Flow in Down status is rerouted after switchUp event\" according to #3162"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde84a3321438171eebf06d8e3fb18e4861cb3be", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/cde84a3321438171eebf06d8e3fb18e4861cb3be", "committedDate": "2020-02-04T09:39:43Z", "message": "improve tests according to reroute on switchUp event"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3688, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}