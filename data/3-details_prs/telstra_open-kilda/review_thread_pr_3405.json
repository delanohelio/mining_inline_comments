{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MTAzMDk2", "number": 3405, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozMDo0NVrOD0qK6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozODoxNlrOD0qYPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQzNDY3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozMDo0NVrOGJs0OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzoyNDoxN1rOGJ2N_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNDYzMg==", "bodyText": "just make a pinned flow instead?", "url": "https://github.com/telstra/open-kilda/pull/3405#discussion_r412824632", "createdAt": "2020-04-22T09:30:45Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -662,6 +664,119 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    def \"Unable to delete inactive link with flowPath\"() {\n+        given: \"An inactive link with flow on it\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        // \"Make all alternative paths unavailable (bring ports down on the source switch)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc429fdcd242d774ac345af7a7bf419911473dbf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3ODY4Ng==", "bodyText": "good idea, fixed", "url": "https://github.com/telstra/open-kilda/pull/3405#discussion_r412978686", "createdAt": "2020-04-22T13:24:17Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -662,6 +664,119 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    def \"Unable to delete inactive link with flowPath\"() {\n+        given: \"An inactive link with flow on it\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        // \"Make all alternative paths unavailable (bring ports down on the source switch)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNDYzMg=="}, "originalCommit": {"oid": "cc429fdcd242d774ac345af7a7bf419911473dbf"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQ2ODc4OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTozODoxNlrOGJtIig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzoyMzoyN1rOGJ2Lcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyOTgzNA==", "bodyText": "if (linkIsDeleted)", "url": "https://github.com/telstra/open-kilda/pull/3405#discussion_r412829834", "createdAt": "2020-04-22T09:38:16Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -662,6 +664,119 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    def \"Unable to delete inactive link with flowPath\"() {\n+        given: \"An inactive link with flow on it\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        // \"Make all alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        switchPair.paths.findAll { it != flowPath }.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        def isl = pathHelper.getInvolvedIsls(flowPath)[0]\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(isl).actualState == IslChangeType.FAILED\n+        }\n+\n+        when: \"Try to delete the link\"\n+        northbound.deleteLink(islUtils.toLinkParameters(isl))\n+        def linkIsActive = false\n+\n+        then: \"Get 400 BadRequest error because the link with flow path\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.rawStatusCode == 400\n+        exc.responseBodyAsString.contains(\"This ISL is busy by flow paths.\")\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !linkIsActive && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        broughtDownPorts.every { antiflap.portUp(it.switchId, it.portNo)}\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"Able to delete an active link with flowPath if using force delete\"() {\n+        given: \"Two active neighboring switches and two possible paths at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"An active link with flow on it\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def isl = pathHelper.getInvolvedIsls(flowPath)[0]\n+\n+        when: \"Delete the link using force\"\n+        def response = northbound.deleteLink(islUtils.toLinkParameters(isl), true)\n+        def linkIsDeleted = true\n+\n+        then: \"The link is actually deleted\"\n+        response.size() == 2\n+        Wrappers.wait(2) {\n+            assert !islUtils.getIslInfo(isl)\n+            assert !islUtils.getIslInfo(isl.reversed)\n+        }\n+\n+        and: \"Flow is not rerouted and UP\"\n+        pathHelper.convert(northbound.getFlowPath(flow.flowId)) == flowPath\n+        northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Removed link becomes active again (port brought DOWN/UP)\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        linkIsDeleted = false\n+\n+        then: \"The link is rediscovered in both directions\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, isl.reversed).get().state == IslChangeType.DISCOVERED\n+            assert islUtils.getIslInfo(links, isl).get().state == IslChangeType.DISCOVERED\n+        }\n+\n+        and: \"Source and destination switches pass switch validation\"\n+        withPool {\n+            [switchPair.src.dpId, switchPair.dst.dpId].eachParallel { SwitchId swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!linkIsDeleted) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc429fdcd242d774ac345af7a7bf419911473dbf"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3ODAzNQ==", "bodyText": "thx, fixed", "url": "https://github.com/telstra/open-kilda/pull/3405#discussion_r412978035", "createdAt": "2020-04-22T13:23:27Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/LinkSpec.groovy", "diffHunk": "@@ -662,6 +664,119 @@ class LinkSpec extends HealthCheckSpecification {\n         getIsl().srcSwitch.dpId | getIsl().srcPort | getIsl().dstSwitch.dpId | null      | \"dst_port\"\n     }\n \n+    @Tidy\n+    def \"Unable to delete inactive link with flowPath\"() {\n+        given: \"An inactive link with flow on it\"\n+        def switchPair = topologyHelper.getNeighboringSwitchPair()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+\n+        // \"Make all alternative paths unavailable (bring ports down on the source switch)\"\n+        List<PathNode> broughtDownPorts = []\n+        switchPair.paths.findAll { it != flowPath }.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        def isl = pathHelper.getInvolvedIsls(flowPath)[0]\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(isl).actualState == IslChangeType.FAILED\n+        }\n+\n+        when: \"Try to delete the link\"\n+        northbound.deleteLink(islUtils.toLinkParameters(isl))\n+        def linkIsActive = false\n+\n+        then: \"Get 400 BadRequest error because the link with flow path\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.rawStatusCode == 400\n+        exc.responseBodyAsString.contains(\"This ISL is busy by flow paths.\")\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !linkIsActive && antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        broughtDownPorts.every { antiflap.portUp(it.switchId, it.portNo)}\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"Able to delete an active link with flowPath if using force delete\"() {\n+        given: \"Two active neighboring switches and two possible paths at least\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }.size() >= 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"An active link with flow on it\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        def flowPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def isl = pathHelper.getInvolvedIsls(flowPath)[0]\n+\n+        when: \"Delete the link using force\"\n+        def response = northbound.deleteLink(islUtils.toLinkParameters(isl), true)\n+        def linkIsDeleted = true\n+\n+        then: \"The link is actually deleted\"\n+        response.size() == 2\n+        Wrappers.wait(2) {\n+            assert !islUtils.getIslInfo(isl)\n+            assert !islUtils.getIslInfo(isl.reversed)\n+        }\n+\n+        and: \"Flow is not rerouted and UP\"\n+        pathHelper.convert(northbound.getFlowPath(flow.flowId)) == flowPath\n+        northboundV2.getFlowStatus(flow.flowId).status == FlowState.UP\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        when: \"Removed link becomes active again (port brought DOWN/UP)\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+        linkIsDeleted = false\n+\n+        then: \"The link is rediscovered in both directions\"\n+        Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+            def links = northbound.getAllLinks()\n+            assert islUtils.getIslInfo(links, isl.reversed).get().state == IslChangeType.DISCOVERED\n+            assert islUtils.getIslInfo(links, isl).get().state == IslChangeType.DISCOVERED\n+        }\n+\n+        and: \"Source and destination switches pass switch validation\"\n+        withPool {\n+            [switchPair.src.dpId, switchPair.dst.dpId].eachParallel { SwitchId swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        if (!linkIsDeleted) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyOTgzNA=="}, "originalCommit": {"oid": "cc429fdcd242d774ac345af7a7bf419911473dbf"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1940, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}