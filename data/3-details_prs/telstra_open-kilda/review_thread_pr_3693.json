{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMDM1NzQ4", "number": 3693, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1OTo0OFrOEeTAjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzo0MDo1N1rOEuoFkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjA0MTczOnYy", "diffSide": "RIGHT", "path": "docs/design/hub-and-spoke/reroute/retry/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjo1OTo0OFrOHJ3xlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNDoxOTowMFrOHM-93A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExMzA0NQ==", "bodyText": "Remove extra space before dot.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480113045", "createdAt": "2020-08-31T12:59:48Z", "author": {"login": "rozdy"}, "path": "docs/design/hub-and-spoke/reroute/retry/README.md", "diffHunk": "@@ -13,13 +15,18 @@ This solution is aimed to fix mentioned above issues.\n \n ![Flow reroute retry](flow-reroute-retry.png \"Flow reroute retry\")\n \n-FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n+FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine \n+time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n \n | flow-id | in-progress | pending  | throttling |\n | ---     | ---         | ---      | ---        |\n | 1       | request1    | request2 | request3   |\n \n-Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and retry counter to decide will system emit reroute retry request or not.\n+Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and \n+retry counter to decide will system emit reroute retry request or not.\n \n ![Flow reroute queue service](flow-reroute-queue-service.png \"Flow reroute queue service\")\n \n+OperationQueueBolt is needed for sequential execution of operations supplied by Reroute Topology for a flow .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NjYwNA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r483376604", "createdAt": "2020-09-04T04:19:00Z", "author": {"login": "dpoltavets"}, "path": "docs/design/hub-and-spoke/reroute/retry/README.md", "diffHunk": "@@ -13,13 +15,18 @@ This solution is aimed to fix mentioned above issues.\n \n ![Flow reroute retry](flow-reroute-retry.png \"Flow reroute retry\")\n \n-FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n+FlowRerouteQueueBolt is a single point for flow reroute requests queuing and merging. New reroute queue should combine \n+time-based throttling and in-progress reroute tracking. For this purpose following data structure is used:\n \n | flow-id | in-progress | pending  | throttling |\n | ---     | ---         | ---      | ---        |\n | 1       | request1    | request2 | request3   |\n \n-Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and retry counter to decide will system emit reroute retry request or not.\n+Flow reroute FSM should save error reason with retryable flag and FlowRerouteQueueService will check this flag and \n+retry counter to decide will system emit reroute retry request or not.\n \n ![Flow reroute queue service](flow-reroute-queue-service.png \"Flow reroute queue service\")\n \n+OperationQueueBolt is needed for sequential execution of operations supplied by Reroute Topology for a flow .", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDExMzA0NQ=="}, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzAzNTkwOnYy", "diffSide": "RIGHT", "path": "docs/design/hub-and-spoke/reroute/retry/flow-operation-queue.puml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzowNjowNFrOHKBIrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNDoxOTowOFrOHM--AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2NjQxNQ==", "bodyText": "queue", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480266415", "createdAt": "2020-08-31T17:06:04Z", "author": {"login": "rozdy"}, "path": "docs/design/hub-and-spoke/reroute/retry/flow-operation-queue.puml", "diffHunk": "@@ -0,0 +1,46 @@\n+@startuml\n+title Flow operation queue\n+\n+box \"Reroute Topology\" #LightGreen\n+    participant RerouteBolt\n+    participant FlowRerouteQueueBolt\n+    participant OperationQueueBolt\n+    participant CoordinatorBolt\n+end box\n+participant \"Flow H&S Topology\" as FlowHS\n+\n+== Request to OperationQueueBolt ==\n+RerouteBolt -> OperationQueueBolt : Path swap command\n+activate OperationQueueBolt\n+RerouteBolt -> FlowRerouteQueueBolt : Reroute command\n+FlowRerouteQueueBolt -> OperationQueueBolt: Reroute command\n+OperationQueueBolt -> OperationQueueBolt : add command to the queue\n+OperationQueueBolt -> FlowHS : command\n+OperationQueueBolt -> CoordinatorBolt : register callback\n+deactivate OperationQueueBolt\n+\n+== Flow HS response ==\n+FlowHS -> OperationQueueBolt : operation result\n+activate OperationQueueBolt\n+OperationQueueBolt -> CoordinatorBolt : cancel callback\n+alt reroute response\n+    OperationQueueBolt -> FlowRerouteQueueBolt : operation result\n+end\n+\n+alt there is an command in the queue\n+    OperationQueueBolt -> FlowHS : command\n+    OperationQueueBolt -> CoordinatorBolt : register callback\n+    deactivate OperationQueueBolt\n+end\n+\n+== Timeout ==\n+CoordinatorBolt -> OperationQueueBolt : operation timeout\n+activate OperationQueueBolt\n+\n+alt there is an command in the queu", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NjY0MA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r483376640", "createdAt": "2020-09-04T04:19:08Z", "author": {"login": "dpoltavets"}, "path": "docs/design/hub-and-spoke/reroute/retry/flow-operation-queue.puml", "diffHunk": "@@ -0,0 +1,46 @@\n+@startuml\n+title Flow operation queue\n+\n+box \"Reroute Topology\" #LightGreen\n+    participant RerouteBolt\n+    participant FlowRerouteQueueBolt\n+    participant OperationQueueBolt\n+    participant CoordinatorBolt\n+end box\n+participant \"Flow H&S Topology\" as FlowHS\n+\n+== Request to OperationQueueBolt ==\n+RerouteBolt -> OperationQueueBolt : Path swap command\n+activate OperationQueueBolt\n+RerouteBolt -> FlowRerouteQueueBolt : Reroute command\n+FlowRerouteQueueBolt -> OperationQueueBolt: Reroute command\n+OperationQueueBolt -> OperationQueueBolt : add command to the queue\n+OperationQueueBolt -> FlowHS : command\n+OperationQueueBolt -> CoordinatorBolt : register callback\n+deactivate OperationQueueBolt\n+\n+== Flow HS response ==\n+FlowHS -> OperationQueueBolt : operation result\n+activate OperationQueueBolt\n+OperationQueueBolt -> CoordinatorBolt : cancel callback\n+alt reroute response\n+    OperationQueueBolt -> FlowRerouteQueueBolt : operation result\n+end\n+\n+alt there is an command in the queue\n+    OperationQueueBolt -> FlowHS : command\n+    OperationQueueBolt -> CoordinatorBolt : register callback\n+    deactivate OperationQueueBolt\n+end\n+\n+== Timeout ==\n+CoordinatorBolt -> OperationQueueBolt : operation timeout\n+activate OperationQueueBolt\n+\n+alt there is an command in the queu", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2NjQxNQ=="}, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzA5NzgzOnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzoyNTowNFrOHKBuiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzoyNTowNFrOHKBuiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NjEwNQ==", "bodyText": "Do we need success field in PathSwapResult only to log it here? We already logged it in H&S.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r480276105", "createdAt": "2020-08-31T17:25:04Z", "author": {"login": "rozdy"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODkwMzU5OnYy", "diffSide": "RIGHT", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/pathswap/action/OnFinishedWithErrorAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOToyNzo0OFrOHMeKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNDoxODo1MVrOHM-9wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzOTA2Ng==", "bodyText": "maybe we should use warn/error log level here?", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r482839066", "createdAt": "2020-09-03T09:27:48Z", "author": {"login": "niksv"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/pathswap/action/OnFinishedWithErrorAction.java", "diffHunk": "@@ -36,5 +36,9 @@ public OnFinishedWithErrorAction(FlowOperationsDashboardLogger dashboardLogger)\n     public void execute(State from, State to, Event event, FlowPathSwapContext context, FlowPathSwapFsm stateMachine) {\n         dashboardLogger.onFailedFlowUpdate(stateMachine.getFlowId(), stateMachine.getErrorReason());\n         stateMachine.saveActionToHistory(\"Failed to swap paths for the flow\", stateMachine.getErrorReason());\n+\n+        log.info(\"Flow {} path swap failed\", stateMachine.getFlowId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NjU3Nw==", "bodyText": "The warn level is now used here.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r483376577", "createdAt": "2020-09-04T04:18:51Z", "author": {"login": "dpoltavets"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/pathswap/action/OnFinishedWithErrorAction.java", "diffHunk": "@@ -36,5 +36,9 @@ public OnFinishedWithErrorAction(FlowOperationsDashboardLogger dashboardLogger)\n     public void execute(State from, State to, Event event, FlowPathSwapContext context, FlowPathSwapFsm stateMachine) {\n         dashboardLogger.onFailedFlowUpdate(stateMachine.getFlowId(), stateMachine.getErrorReason());\n         stateMachine.saveActionToHistory(\"Failed to swap paths for the flow\", stateMachine.getErrorReason());\n+\n+        log.info(\"Flow {} path swap failed\", stateMachine.getFlowId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzOTA2Ng=="}, "originalCommit": {"oid": "d2b30c872db1a0847b00e5028eca03bd93b9a7f0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzEzOTg4OnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/FlowRerouteQueueBolt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzowNTo1MlrOHjI2sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNToxNjo1MVrOHj9dQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwNzI4Mw==", "bodyText": "Do we really want to use anchored emit here (getCurrentTuple())?", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506607283", "createdAt": "2020-10-16T17:05:52Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/FlowRerouteQueueBolt.java", "diffHunk": "@@ -106,15 +110,15 @@ protected void init() {\n     public void declareOutputFields(OutputFieldsDeclarer declarer) {\n         super.declareOutputFields(declarer);\n         declarer.declareStream(TimeWindowBolt.STREAM_TIME_WINDOW_EVENT_ID, new Fields(FIELD_ID_CONTEXT));\n-        declarer.declareStream(STREAM_FLOWHS_ID, RerouteTopology.KAFKA_FIELDS);\n+        declarer.declareStream(STREAM_OPERATION_QUEUE_ID, FIELDS_OPERATION_QUEUE);\n         declarer.declareStream(STREAM_NORTHBOUND_ID, RerouteTopology.KAFKA_FIELDS);\n     }\n \n     @Override\n     public void sendRerouteRequest(String correlationId, FlowRerouteRequest request) {\n         log.info(\"Send reroute request {} with correlationId {}\", request, correlationId);\n-        getOutput().emit(STREAM_FLOWHS_ID, getCurrentTuple(),\n-                new Values(correlationId, new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+        emit(STREAM_OPERATION_QUEUE_ID, getCurrentTuple(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ2OTEyMA==", "bodyText": "Anchor has been removed.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r507469120", "createdAt": "2020-10-19T05:16:51Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/FlowRerouteQueueBolt.java", "diffHunk": "@@ -106,15 +110,15 @@ protected void init() {\n     public void declareOutputFields(OutputFieldsDeclarer declarer) {\n         super.declareOutputFields(declarer);\n         declarer.declareStream(TimeWindowBolt.STREAM_TIME_WINDOW_EVENT_ID, new Fields(FIELD_ID_CONTEXT));\n-        declarer.declareStream(STREAM_FLOWHS_ID, RerouteTopology.KAFKA_FIELDS);\n+        declarer.declareStream(STREAM_OPERATION_QUEUE_ID, FIELDS_OPERATION_QUEUE);\n         declarer.declareStream(STREAM_NORTHBOUND_ID, RerouteTopology.KAFKA_FIELDS);\n     }\n \n     @Override\n     public void sendRerouteRequest(String correlationId, FlowRerouteRequest request) {\n         log.info(\"Send reroute request {} with correlationId {}\", request, correlationId);\n-        getOutput().emit(STREAM_FLOWHS_ID, getCurrentTuple(),\n-                new Values(correlationId, new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+        emit(STREAM_OPERATION_QUEUE_ID, getCurrentTuple(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwNzI4Mw=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzE0OTAzOnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzowODo0OVrOHjI8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNzoxMVrOHjNAiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwODcyNA==", "bodyText": "... code is better without this garbage.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506608724", "createdAt": "2020-10-16T17:08:49Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTMzNg==", "bodyText": "Removed.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675336", "createdAt": "2020-10-16T19:17:11Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYwODcyNA=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzE3MDI2OnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzoxNDo0MFrOHjJJ-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToyMTo0NlrOHjNIlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxMjIxOA==", "bodyText": "Why you use 2 arguments if you read the first argument value from the second argument value?\nPS Other service calls have the same issue with flowId arguments.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506612218", "createdAt": "2020-10-16T17:14:40Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void init() {\n+        this.service = new OperationQueueService(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void handleInput(Tuple tuple) throws PipelineException {\n+        CommandContext context = pullContext(tuple);\n+        MessageData data = pullValue(tuple, FIELD_ID_PAYLOAD, MessageData.class);\n+        if (data instanceof FlowPathSwapRequest) {\n+            FlowPathSwapRequest flowPathSwapRequest = (FlowPathSwapRequest) data;\n+            service.addFirst(flowPathSwapRequest.getFlowId(), context.getCorrelationId(), flowPathSwapRequest);\n+        } else if (data instanceof FlowRerouteRequest) {\n+            FlowRerouteRequest flowRerouteRequest = (FlowRerouteRequest) data;\n+            service.addLast(flowRerouteRequest.getFlowId(), context.getCorrelationId(), flowRerouteRequest);\n+        } else if (data instanceof RerouteResultInfoData) {\n+            RerouteResultInfoData rerouteResultInfoData = (RerouteResultInfoData) data;\n+            service.operationCompleted(rerouteResultInfoData.getFlowId(), rerouteResultInfoData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NzM5OA==", "bodyText": "We cannot get flowId from the second argument in the method itself, because the methods require InfoData or CommandData, which do not contain this field.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506677398", "createdAt": "2020-10-16T19:21:46Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/OperationQueueBolt.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.bolts;\n+\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_KEY;\n+import static org.openkilda.wfm.topology.utils.KafkaRecordTranslator.FIELD_ID_PAYLOAD;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.command.CommandMessage;\n+import org.openkilda.messaging.command.flow.FlowPathSwapRequest;\n+import org.openkilda.messaging.command.flow.FlowRerouteRequest;\n+import org.openkilda.messaging.info.reroute.PathSwapResult;\n+import org.openkilda.messaging.info.reroute.RerouteResultInfoData;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.error.PipelineException;\n+import org.openkilda.wfm.share.hubandspoke.CoordinatedBolt;\n+import org.openkilda.wfm.topology.reroute.service.OperationQueueService;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+@Slf4j\n+public class OperationQueueBolt extends CoordinatedBolt implements OperationQueueCarrier {\n+    public static final String BOLT_ID = \"operation-queue\";\n+\n+    public static final String FLOW_ID_FIELD = RerouteBolt.FLOW_ID_FIELD;\n+\n+    public static final String REROUTE_QUEUE_STREAM = \"reroute-queue-stream\";\n+    public static final Fields REROUTE_QUEUE_FIELDS = new Fields(FLOW_ID_FIELD, FIELD_ID_PAYLOAD, FIELD_ID_CONTEXT);\n+\n+    public static final Fields FLOW_HS_FIELDS = new Fields(FIELD_ID_KEY, FIELD_ID_PAYLOAD);\n+\n+    private transient OperationQueueService service;\n+\n+    public OperationQueueBolt(int defaultTimeout) {\n+        super(true, defaultTimeout);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void init() {\n+        this.service = new OperationQueueService(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void handleInput(Tuple tuple) throws PipelineException {\n+        CommandContext context = pullContext(tuple);\n+        MessageData data = pullValue(tuple, FIELD_ID_PAYLOAD, MessageData.class);\n+        if (data instanceof FlowPathSwapRequest) {\n+            FlowPathSwapRequest flowPathSwapRequest = (FlowPathSwapRequest) data;\n+            service.addFirst(flowPathSwapRequest.getFlowId(), context.getCorrelationId(), flowPathSwapRequest);\n+        } else if (data instanceof FlowRerouteRequest) {\n+            FlowRerouteRequest flowRerouteRequest = (FlowRerouteRequest) data;\n+            service.addLast(flowRerouteRequest.getFlowId(), context.getCorrelationId(), flowRerouteRequest);\n+        } else if (data instanceof RerouteResultInfoData) {\n+            RerouteResultInfoData rerouteResultInfoData = (RerouteResultInfoData) data;\n+            service.operationCompleted(rerouteResultInfoData.getFlowId(), rerouteResultInfoData);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxMjIxOA=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzIwNzgwOnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/RerouteBolt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzoyNToyMFrOHjJhPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNzowMVrOHjNAOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODE3Mw==", "bodyText": "newContext ... looks extremely weird. Can we have just context? Or just redefine correlationId, while we don't need context itself.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506618173", "createdAt": "2020-10-16T17:25:20Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/RerouteBolt.java", "diffHunk": "@@ -158,29 +163,25 @@ public void emitManualRerouteCommand(String flowId, FlowThrottlingData flowThrot\n      * Emit swap command for consumer.\n      *\n      * @param correlationId correlation id to pass through\n-     * @param path affected paths\n-     * @param reason initial reason of reroute\n+     * @param flowId flow\n+     * @param reason initial reason of path swap\n      */\n     @Override\n-    public void emitPathSwapCommand(String correlationId, FlowPath path, String reason) {\n-        FlowPathSwapRequest request = new FlowPathSwapRequest(path.getFlow().getFlowId(), path.getPathId());\n-        getOutput().emit(STREAM_SWAP_ID, getCurrentTuple(), new Values(correlationId,\n-                new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+    public void emitPathSwapCommand(String correlationId, String flowId, String reason) {\n+        CommandContext newContext = new CommandContext(correlationId).fork(UUID.randomUUID().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTI1Nw==", "bodyText": "Renamed to context.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675257", "createdAt": "2020-10-16T19:17:01Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/bolts/RerouteBolt.java", "diffHunk": "@@ -158,29 +163,25 @@ public void emitManualRerouteCommand(String flowId, FlowThrottlingData flowThrot\n      * Emit swap command for consumer.\n      *\n      * @param correlationId correlation id to pass through\n-     * @param path affected paths\n-     * @param reason initial reason of reroute\n+     * @param flowId flow\n+     * @param reason initial reason of path swap\n      */\n     @Override\n-    public void emitPathSwapCommand(String correlationId, FlowPath path, String reason) {\n-        FlowPathSwapRequest request = new FlowPathSwapRequest(path.getFlow().getFlowId(), path.getPathId());\n-        getOutput().emit(STREAM_SWAP_ID, getCurrentTuple(), new Values(correlationId,\n-                new CommandMessage(request, System.currentTimeMillis(), correlationId)));\n+    public void emitPathSwapCommand(String correlationId, String flowId, String reason) {\n+        CommandContext newContext = new CommandContext(correlationId).fork(UUID.randomUUID().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODE3Mw=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzIyODc1OnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzozMToxMFrOHjJt-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNjozMVrOHjM_QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTQzMw==", "bodyText": "Why warn? Ther is normal to have no such records due to race condition on timeout remove request.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506621433", "createdAt": "2020-10-16T17:31:10Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTAwOA==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506675008", "createdAt": "2020-10-16T19:16:31Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTQzMw=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MzI2NzM5OnYy", "diffSide": "RIGHT", "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzo0MDo1N1rOHjKFuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOToxNjoxOFrOHjM-9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNzUxMw==", "bodyText": "Have we ever clean up this map? This approach creates a memory leak that can be triggered/used via NB API (you need to produce reroute requests for not existing/unique flowId... endlessly).", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506627513", "createdAt": "2020-10-16T17:40:57Z", "author": {"login": "surabujin"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);\n+        queueData.setTaskInProgress(null);\n+        processQueue(queueData);\n+    }\n+\n+    private void processQueue(FlowQueueData queueData) {\n+        if (!queueData.getQueue().isEmpty() && !queueData.isOperationInProgress()) {\n+            OperationData operationData = queueData.getQueue().pop();\n+            carrier.emitRequest(operationData.getCorrelationId(), operationData.getCommandData());\n+            queueData.setTaskInProgress(operationData.getCorrelationId());\n+            log.info(\"Flow command {} has been sent\", operationData.getCommandData());\n+        }\n+    }\n+\n+    private FlowQueueData getFlowQueueData(String flowId) {\n+        return flowCommands.computeIfAbsent(flowId, v -> new FlowQueueData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDkzNA==", "bodyText": "Good point! Clean up has been added.", "url": "https://github.com/telstra/open-kilda/pull/3693#discussion_r506674934", "createdAt": "2020-10-16T19:16:18Z", "author": {"login": "dpoltavets"}, "path": "src-java/reroute-topology/reroute-storm-topology/src/main/java/org/openkilda/wfm/topology/reroute/service/OperationQueueService.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.reroute.service;\n+\n+import org.openkilda.messaging.command.CommandData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.topology.reroute.bolts.OperationQueueCarrier;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OperationQueueService {\n+    private final OperationQueueCarrier carrier;\n+\n+    private final Map<String, FlowQueueData> flowCommands = new HashMap<>();\n+\n+    public OperationQueueService(OperationQueueCarrier carrier) {\n+        this.carrier = carrier;\n+    }\n+\n+    /**\n+     * Add command to the front of the queue.\n+     */\n+    public void addFirst(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addFirst(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Add command to the end of the queue.\n+     */\n+    public void addLast(String flowId, String correlationId, CommandData data) {\n+        log.info(\"Flow command {} has been added to the queue for flow {} with correlation id {}\",\n+                data, flowId, correlationId);\n+        FlowQueueData queueData = getFlowQueueData(flowId);\n+        queueData.getQueue().addLast(new OperationData(correlationId, data));\n+        processQueue(queueData);\n+    }\n+\n+    /**\n+     * Handle timeout.\n+     */\n+    public void handleTimeout(String correlationId) {\n+        log.warn(\"Operation with correlationId {} has timed out\", correlationId);\n+        Collection<FlowQueueData> foundQueueData = flowCommands.values().stream()\n+                .filter(flowQueueData -> correlationId.equals(flowQueueData.getTaskInProgress()))\n+                .collect(Collectors.toList());\n+\n+        if (foundQueueData.isEmpty()) {\n+            log.warn(\"No queue data with correlationId {} found. Timeout event skipped.\", correlationId);\n+        } else if (foundQueueData.size() > 1) {\n+            log.error(\"Found more than one queue data with correlationId {}. Timed out all of them.\", correlationId);\n+        }\n+\n+        foundQueueData.forEach(queueData -> operationCompleted(queueData, null));\n+    }\n+\n+    public void operationCompleted(String flowId, InfoData response) {\n+        operationCompleted(getFlowQueueData(flowId), response);\n+    }\n+\n+    private void operationCompleted(FlowQueueData queueData, InfoData response) {\n+        log.info(\"Flow command {} has been completed with response {}\", queueData.getTaskInProgress(), response);\n+        queueData.setTaskInProgress(null);\n+        processQueue(queueData);\n+    }\n+\n+    private void processQueue(FlowQueueData queueData) {\n+        if (!queueData.getQueue().isEmpty() && !queueData.isOperationInProgress()) {\n+            OperationData operationData = queueData.getQueue().pop();\n+            carrier.emitRequest(operationData.getCorrelationId(), operationData.getCommandData());\n+            queueData.setTaskInProgress(operationData.getCorrelationId());\n+            log.info(\"Flow command {} has been sent\", operationData.getCommandData());\n+        }\n+    }\n+\n+    private FlowQueueData getFlowQueueData(String flowId) {\n+        return flowCommands.computeIfAbsent(flowId, v -> new FlowQueueData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNzUxMw=="}, "originalCommit": {"oid": "3315800259b82775cc21a509656551945c906cec"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1810, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}