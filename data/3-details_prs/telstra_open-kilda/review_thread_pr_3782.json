{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMjg1MDMw", "number": 3782, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToxMTo0MFrOExVUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTo0ODoxNFrOExWmXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTY1MDYzOnYy", "diffSide": "RIGHT", "path": "src-java/grpc-speaker/grpc-service/src/main/java/org/openkilda/grpc/speaker/messaging/MessageProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToxMTo0MFrOHnanaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwNzozNTo0NVrOHoDgBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5MjU4NQ==", "bodyText": "Why not make \"topic\" final instead of a new variable?", "url": "https://github.com/telstra/open-kilda/pull/3782#discussion_r511092585", "createdAt": "2020-10-23T19:11:40Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/grpc-speaker/grpc-service/src/main/java/org/openkilda/grpc/speaker/messaging/MessageProcessor.java", "diffHunk": "@@ -83,85 +87,105 @@ public void processRequest(Message message, String key) {\n     private void handleCommandMessage(CommandMessage command, String key) {\n         CommandData data = command.getData();\n         String correlationId = command.getCorrelationId();\n+        String topic = grpcResponseTopic;\n+\n+        CompletableFuture<MessageData> result;\n \n         if (data instanceof CreateLogicalPortRequest) {\n-            handleCreateLogicalPortRequest((CreateLogicalPortRequest) data, correlationId, key);\n+            result = handleCreateLogicalPortRequest((CreateLogicalPortRequest) data);\n         } else if (data instanceof DumpLogicalPortsRequest) {\n-            handleDumpLogicalPortsRequest((DumpLogicalPortsRequest) data, correlationId, key);\n+            result = handleDumpLogicalPortsRequest((DumpLogicalPortsRequest) data);\n         } else if (data instanceof GetSwitchInfoRequest) {\n-            handleGetSwitchInfoRequest((GetSwitchInfoRequest) data, correlationId, key);\n+            result = handleGetSwitchInfoRequest((GetSwitchInfoRequest) data);\n         } else if (data instanceof GetPacketInOutStatsRequest) {\n-            handleGetPacketInOutStatsRequest((GetPacketInOutStatsRequest) data, correlationId, key);\n+            result = handleGetPacketInOutStatsRequest((GetPacketInOutStatsRequest) data);\n+            topic = statsTopic;\n         } else if (data instanceof DeleteLogicalPortRequest) {\n-            handleDeleteLogicalPortRequest((DeleteLogicalPortRequest) data, command.getCorrelationId(), key);\n+            result = handleDeleteLogicalPortRequest((DeleteLogicalPortRequest) data);\n         } else {\n-            unhandledMessage(command);\n+            result = unhandledMessage(command);\n         }\n+\n+        final String responseTopic = topic;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9597d1e5e50bc4ac2417035e74fc8693c90ef8bf"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc2MjQzOA==", "bodyText": "Because it is changed for one message type - line 102 :(\nI have reworked the way how we manage the response topic into MessageProcessor.", "url": "https://github.com/telstra/open-kilda/pull/3782#discussion_r511762438", "createdAt": "2020-10-26T07:35:45Z", "author": {"login": "surabujin"}, "path": "src-java/grpc-speaker/grpc-service/src/main/java/org/openkilda/grpc/speaker/messaging/MessageProcessor.java", "diffHunk": "@@ -83,85 +87,105 @@ public void processRequest(Message message, String key) {\n     private void handleCommandMessage(CommandMessage command, String key) {\n         CommandData data = command.getData();\n         String correlationId = command.getCorrelationId();\n+        String topic = grpcResponseTopic;\n+\n+        CompletableFuture<MessageData> result;\n \n         if (data instanceof CreateLogicalPortRequest) {\n-            handleCreateLogicalPortRequest((CreateLogicalPortRequest) data, correlationId, key);\n+            result = handleCreateLogicalPortRequest((CreateLogicalPortRequest) data);\n         } else if (data instanceof DumpLogicalPortsRequest) {\n-            handleDumpLogicalPortsRequest((DumpLogicalPortsRequest) data, correlationId, key);\n+            result = handleDumpLogicalPortsRequest((DumpLogicalPortsRequest) data);\n         } else if (data instanceof GetSwitchInfoRequest) {\n-            handleGetSwitchInfoRequest((GetSwitchInfoRequest) data, correlationId, key);\n+            result = handleGetSwitchInfoRequest((GetSwitchInfoRequest) data);\n         } else if (data instanceof GetPacketInOutStatsRequest) {\n-            handleGetPacketInOutStatsRequest((GetPacketInOutStatsRequest) data, correlationId, key);\n+            result = handleGetPacketInOutStatsRequest((GetPacketInOutStatsRequest) data);\n+            topic = statsTopic;\n         } else if (data instanceof DeleteLogicalPortRequest) {\n-            handleDeleteLogicalPortRequest((DeleteLogicalPortRequest) data, command.getCorrelationId(), key);\n+            result = handleDeleteLogicalPortRequest((DeleteLogicalPortRequest) data);\n         } else {\n-            unhandledMessage(command);\n+            result = unhandledMessage(command);\n         }\n+\n+        final String responseTopic = topic;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA5MjU4NQ=="}, "originalCommit": {"oid": "9597d1e5e50bc4ac2417035e74fc8693c90ef8bf"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTg1OTQ4OnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdLogicalPortFsm.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTo0ODoxNFrOHncU4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0NDoxMVrOHoNynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyMDYxMA==", "bodyText": "I'd reconsider the naming for these log methods to help others understand when to use them. E.g. logDebugWithPrefix...", "url": "https://github.com/telstra/open-kilda/pull/3782#discussion_r511120610", "createdAt": "2020-10-23T19:48:14Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdLogicalPortFsm.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.bfd;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.error.ErrorData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.share.utils.AbstractBaseFsm;\n+import org.openkilda.wfm.share.utils.FsmExecutor;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.BfdLogicalPortFsmContext;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.Event;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.State;\n+import org.openkilda.wfm.topology.network.model.BfdSessionData;\n+import org.openkilda.wfm.topology.network.service.IBfdLogicalPortCarrier;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.squirrelframework.foundation.fsm.StateMachineBuilder;\n+import org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;\n+import org.squirrelframework.foundation.fsm.StateMachineLogger;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@Slf4j\n+public class BfdLogicalPortFsm extends AbstractBaseFsm<BfdLogicalPortFsm, State, Event, BfdLogicalPortFsmContext> {\n+    private final IBfdLogicalPortCarrier carrier;\n+\n+    private final SwitchStatusMonitor switchStatusMonitor;\n+\n+    private final Set<String> activeRequest = new HashSet<>();\n+\n+    @Getter\n+    private final Endpoint physicalEndpoint;\n+\n+    private final int logicalPortNumber;\n+\n+    private BfdSessionData sessionData;\n+\n+    public BfdLogicalPortFsm(\n+            IBfdLogicalPortCarrier carrier, SwitchStatusMonitor switchStatusMonitor,\n+            Endpoint physicalEndpoint, Integer logicalPortNumber) {\n+        this.carrier = carrier;\n+        this.switchStatusMonitor = switchStatusMonitor;\n+        this.physicalEndpoint = physicalEndpoint;\n+        this.logicalPortNumber = logicalPortNumber;\n+\n+        switchStatusMonitor.addController(this);\n+        carrier.logicalPortControllerAddNotification(physicalEndpoint);\n+    }\n+\n+    // -- external API --\n+\n+    public static BfdLogicalPortFsmFactory factory(IBfdLogicalPortCarrier carrier) {\n+        return new BfdLogicalPortFsmFactory(carrier);\n+    }\n+\n+    public void processWorkerSuccess(String requestId, InfoData response) {\n+        if (activeRequest.remove(requestId)) {\n+            logInfo(\"receive worker success response: {}\", response);\n+            BfdLogicalPortFsmContext context = BfdLogicalPortFsmContext.builder()\n+                    .workerResponse(response)\n+                    .build();\n+            BfdLogicalPortFsmFactory.EXECUTOR.fire(this, Event.WORKER_SUCCESS, context);\n+        } else {\n+            reportWorkerResponseIgnored(requestId, response);\n+        }\n+    }\n+\n+    public void processWorkerError(String requestId, ErrorData response) {\n+        if (activeRequest.remove(requestId)) {\n+            String errorMessage = response == null ? \"timeout\" : response.getErrorMessage();\n+            logError(\"receive worker error response: {}\", errorMessage);\n+            BfdLogicalPortFsmContext context = BfdLogicalPortFsmContext.builder()\n+                    .workerError(response)\n+                    .build();\n+            BfdLogicalPortFsmFactory.EXECUTOR.fire(this, Event.WORKER_ERROR, context);\n+        } else {\n+            reportWorkerResponseIgnored(requestId, response);\n+        }\n+    }\n+\n+    public Endpoint getLogicalEndpoint() {\n+        return Endpoint.of(physicalEndpoint.getDatapath(), logicalPortNumber);\n+    }\n+\n+    // -- FSM actions --\n+\n+    public void prepareEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        activeRequest.clear();\n+        saveSessionData(context);\n+    }\n+\n+    public void readyEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sessionData = null;\n+    }\n+\n+    public void creatingEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortCreateRequest();\n+    }\n+\n+    public void creatingExitAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        activeRequest.clear();\n+    }\n+\n+    public void operationalEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        carrier.createSession(getLogicalEndpoint(), physicalEndpoint.getPortNumber());\n+        if (sessionData != null) {\n+            sendSessionEnableUpdateRequest();\n+        }\n+    }\n+\n+    public void removingEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortDeleteRequest();\n+    }\n+\n+    public void stopEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        carrier.logicalPortControllerDelNotification(physicalEndpoint);\n+    }\n+\n+    public void sendPortCreateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortCreateRequest();\n+    }\n+\n+    public void renewPortCreateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sessionData = context.getSessionData();\n+        sendPortCreateRequest();\n+    }\n+\n+    public void reportWorkerSuccessAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        logInfo(\"success worker response {}\", context.getWorkerResponse());\n+    }\n+\n+    public void sendPortDeleteAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortDeleteRequest();\n+    }\n+\n+    public void sendSessionEnableUpdateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionEnableUpdateRequest(context.getSessionData());\n+    }\n+\n+    public void sendSessionDisableAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionDisableRequest();\n+    }\n+\n+    public void sendSessionDeleteAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionRemoveRequest();\n+    }\n+\n+    public void sendSessionFailureAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionFailNotification();\n+    }\n+\n+    public void sendSessionOfflineAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        updateSessionOnlineStatus(false);\n+    }\n+\n+    public void sendSessionOnlineAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        updateSessionOnlineStatus(true);\n+    }\n+\n+    public void saveSessionDataAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        saveSessionData(context);\n+    }\n+\n+    // -- private/service methods --\n+\n+    private void saveSessionData(BfdLogicalPortFsmContext context) {\n+        sessionData = context.getSessionData();\n+    }\n+\n+    private void sendPortCreateRequest() {\n+        Endpoint logical = getLogicalEndpoint();\n+        if (switchStatusMonitor.isOnline()) {\n+            activeRequest.add(carrier.createLogicalPort(logical, physicalEndpoint.getPortNumber()));\n+        } else {\n+            log.debug(\"Do not send logical port {} create request because the switch is offline now\", logical);\n+        }\n+    }\n+\n+    private void sendPortDeleteRequest() {\n+        Endpoint logical = getLogicalEndpoint();\n+        if (switchStatusMonitor.isOnline()) {\n+            activeRequest.add(carrier.deleteLogicalPort(logical));\n+        } else {\n+            log.debug(\"Do not send logical port {} delete request because the switch is offline now\", logical);\n+        }\n+    }\n+\n+    private void sendSessionFailNotification() {\n+        carrier.bfdKillNotification(physicalEndpoint);\n+    }\n+\n+    private void sendSessionEnableUpdateRequest() {\n+        sendSessionEnableUpdateRequest(sessionData);\n+    }\n+\n+    private void sendSessionEnableUpdateRequest(BfdSessionData data) {\n+        carrier.enableUpdateSession(physicalEndpoint, data.getReference(), data.getProperties());\n+    }\n+\n+    private void sendSessionDisableRequest() {\n+        carrier.disableSession(physicalEndpoint);\n+    }\n+\n+    private void sendSessionRemoveRequest() {\n+        carrier.deleteSession(getLogicalEndpoint());\n+    }\n+\n+    private void updateSessionOnlineStatus(boolean isOnline) {\n+        carrier.updateSessionOnlineStatus(getLogicalEndpoint(), isOnline);\n+    }\n+\n+    private void reportWorkerResponseIgnored(String requestId, MessageData response) {\n+        logDebug(\"ignore response {} with id \\\"{}\\\" in state {}, active requests: {}\",\n+                response, requestId, getCurrentState(), activeRequest);\n+    }\n+\n+    private void logDebug(String format, Object... args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9597d1e5e50bc4ac2417035e74fc8693c90ef8bf"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMTAzNw==", "bodyText": "These wrappers are supposed to use for all log requests. Their goal is to identify specific FSM in logs, so they must be used always.", "url": "https://github.com/telstra/open-kilda/pull/3782#discussion_r511931037", "createdAt": "2020-10-26T12:44:11Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/bfd/BfdLogicalPortFsm.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.bfd;\n+\n+import org.openkilda.messaging.MessageData;\n+import org.openkilda.messaging.error.ErrorData;\n+import org.openkilda.messaging.info.InfoData;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.share.utils.AbstractBaseFsm;\n+import org.openkilda.wfm.share.utils.FsmExecutor;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.BfdLogicalPortFsmContext;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.Event;\n+import org.openkilda.wfm.topology.network.controller.bfd.BfdLogicalPortFsm.State;\n+import org.openkilda.wfm.topology.network.model.BfdSessionData;\n+import org.openkilda.wfm.topology.network.service.IBfdLogicalPortCarrier;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.squirrelframework.foundation.fsm.StateMachineBuilder;\n+import org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;\n+import org.squirrelframework.foundation.fsm.StateMachineLogger;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@Slf4j\n+public class BfdLogicalPortFsm extends AbstractBaseFsm<BfdLogicalPortFsm, State, Event, BfdLogicalPortFsmContext> {\n+    private final IBfdLogicalPortCarrier carrier;\n+\n+    private final SwitchStatusMonitor switchStatusMonitor;\n+\n+    private final Set<String> activeRequest = new HashSet<>();\n+\n+    @Getter\n+    private final Endpoint physicalEndpoint;\n+\n+    private final int logicalPortNumber;\n+\n+    private BfdSessionData sessionData;\n+\n+    public BfdLogicalPortFsm(\n+            IBfdLogicalPortCarrier carrier, SwitchStatusMonitor switchStatusMonitor,\n+            Endpoint physicalEndpoint, Integer logicalPortNumber) {\n+        this.carrier = carrier;\n+        this.switchStatusMonitor = switchStatusMonitor;\n+        this.physicalEndpoint = physicalEndpoint;\n+        this.logicalPortNumber = logicalPortNumber;\n+\n+        switchStatusMonitor.addController(this);\n+        carrier.logicalPortControllerAddNotification(physicalEndpoint);\n+    }\n+\n+    // -- external API --\n+\n+    public static BfdLogicalPortFsmFactory factory(IBfdLogicalPortCarrier carrier) {\n+        return new BfdLogicalPortFsmFactory(carrier);\n+    }\n+\n+    public void processWorkerSuccess(String requestId, InfoData response) {\n+        if (activeRequest.remove(requestId)) {\n+            logInfo(\"receive worker success response: {}\", response);\n+            BfdLogicalPortFsmContext context = BfdLogicalPortFsmContext.builder()\n+                    .workerResponse(response)\n+                    .build();\n+            BfdLogicalPortFsmFactory.EXECUTOR.fire(this, Event.WORKER_SUCCESS, context);\n+        } else {\n+            reportWorkerResponseIgnored(requestId, response);\n+        }\n+    }\n+\n+    public void processWorkerError(String requestId, ErrorData response) {\n+        if (activeRequest.remove(requestId)) {\n+            String errorMessage = response == null ? \"timeout\" : response.getErrorMessage();\n+            logError(\"receive worker error response: {}\", errorMessage);\n+            BfdLogicalPortFsmContext context = BfdLogicalPortFsmContext.builder()\n+                    .workerError(response)\n+                    .build();\n+            BfdLogicalPortFsmFactory.EXECUTOR.fire(this, Event.WORKER_ERROR, context);\n+        } else {\n+            reportWorkerResponseIgnored(requestId, response);\n+        }\n+    }\n+\n+    public Endpoint getLogicalEndpoint() {\n+        return Endpoint.of(physicalEndpoint.getDatapath(), logicalPortNumber);\n+    }\n+\n+    // -- FSM actions --\n+\n+    public void prepareEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        activeRequest.clear();\n+        saveSessionData(context);\n+    }\n+\n+    public void readyEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sessionData = null;\n+    }\n+\n+    public void creatingEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortCreateRequest();\n+    }\n+\n+    public void creatingExitAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        activeRequest.clear();\n+    }\n+\n+    public void operationalEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        carrier.createSession(getLogicalEndpoint(), physicalEndpoint.getPortNumber());\n+        if (sessionData != null) {\n+            sendSessionEnableUpdateRequest();\n+        }\n+    }\n+\n+    public void removingEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortDeleteRequest();\n+    }\n+\n+    public void stopEnterAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        carrier.logicalPortControllerDelNotification(physicalEndpoint);\n+    }\n+\n+    public void sendPortCreateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortCreateRequest();\n+    }\n+\n+    public void renewPortCreateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sessionData = context.getSessionData();\n+        sendPortCreateRequest();\n+    }\n+\n+    public void reportWorkerSuccessAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        logInfo(\"success worker response {}\", context.getWorkerResponse());\n+    }\n+\n+    public void sendPortDeleteAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendPortDeleteRequest();\n+    }\n+\n+    public void sendSessionEnableUpdateAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionEnableUpdateRequest(context.getSessionData());\n+    }\n+\n+    public void sendSessionDisableAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionDisableRequest();\n+    }\n+\n+    public void sendSessionDeleteAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionRemoveRequest();\n+    }\n+\n+    public void sendSessionFailureAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        sendSessionFailNotification();\n+    }\n+\n+    public void sendSessionOfflineAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        updateSessionOnlineStatus(false);\n+    }\n+\n+    public void sendSessionOnlineAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        updateSessionOnlineStatus(true);\n+    }\n+\n+    public void saveSessionDataAction(State from, State to, Event event, BfdLogicalPortFsmContext context) {\n+        saveSessionData(context);\n+    }\n+\n+    // -- private/service methods --\n+\n+    private void saveSessionData(BfdLogicalPortFsmContext context) {\n+        sessionData = context.getSessionData();\n+    }\n+\n+    private void sendPortCreateRequest() {\n+        Endpoint logical = getLogicalEndpoint();\n+        if (switchStatusMonitor.isOnline()) {\n+            activeRequest.add(carrier.createLogicalPort(logical, physicalEndpoint.getPortNumber()));\n+        } else {\n+            log.debug(\"Do not send logical port {} create request because the switch is offline now\", logical);\n+        }\n+    }\n+\n+    private void sendPortDeleteRequest() {\n+        Endpoint logical = getLogicalEndpoint();\n+        if (switchStatusMonitor.isOnline()) {\n+            activeRequest.add(carrier.deleteLogicalPort(logical));\n+        } else {\n+            log.debug(\"Do not send logical port {} delete request because the switch is offline now\", logical);\n+        }\n+    }\n+\n+    private void sendSessionFailNotification() {\n+        carrier.bfdKillNotification(physicalEndpoint);\n+    }\n+\n+    private void sendSessionEnableUpdateRequest() {\n+        sendSessionEnableUpdateRequest(sessionData);\n+    }\n+\n+    private void sendSessionEnableUpdateRequest(BfdSessionData data) {\n+        carrier.enableUpdateSession(physicalEndpoint, data.getReference(), data.getProperties());\n+    }\n+\n+    private void sendSessionDisableRequest() {\n+        carrier.disableSession(physicalEndpoint);\n+    }\n+\n+    private void sendSessionRemoveRequest() {\n+        carrier.deleteSession(getLogicalEndpoint());\n+    }\n+\n+    private void updateSessionOnlineStatus(boolean isOnline) {\n+        carrier.updateSessionOnlineStatus(getLogicalEndpoint(), isOnline);\n+    }\n+\n+    private void reportWorkerResponseIgnored(String requestId, MessageData response) {\n+        logDebug(\"ignore response {} with id \\\"{}\\\" in state {}, active requests: {}\",\n+                response, requestId, getCurrentState(), activeRequest);\n+    }\n+\n+    private void logDebug(String format, Object... args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyMDYxMA=="}, "originalCommit": {"oid": "9597d1e5e50bc4ac2417035e74fc8693c90ef8bf"}, "originalPosition": 235}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2227, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}