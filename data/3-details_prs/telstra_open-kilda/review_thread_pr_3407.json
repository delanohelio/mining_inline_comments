{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NDE4NDc0", "number": 3407, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzowMDozMFrOD5fsOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoxMTozOFrOD5hW6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjE0NjQ4OnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/DiscoveryBfdMonitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzowMDozMVrOGQy8Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0Mzo1N1rOGRJZ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NTAzMA==", "bodyText": "Maybe simplify to\nboolean isEnabled = discoveryData.stream().allMatch(IslEndpointBfdStatus::isEnabled); boolean isUp = discoveryData.stream().anyMatch(status -> status.getStatus() == IslStatus.ACTIVE);", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420265030", "createdAt": "2020-05-05T17:00:31Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/DiscoveryBfdMonitor.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.isl;\n+\n+import org.openkilda.model.Isl;\n+import org.openkilda.model.IslDownReason;\n+import org.openkilda.model.IslStatus;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.share.model.IslReference;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmContext;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmEvent;\n+import org.openkilda.wfm.topology.network.model.IslEndpointBfdStatus;\n+\n+import java.util.Iterator;\n+import java.util.Optional;\n+\n+public class DiscoveryBfdMonitor extends DiscoveryMonitor<IslEndpointBfdStatus> {\n+    public DiscoveryBfdMonitor(IslReference reference) {\n+        super(reference);\n+\n+        IslEndpointBfdStatus dummy = new IslEndpointBfdStatus();\n+        discoveryData.putBoth(dummy);\n+        cache.putBoth(dummy);\n+    }\n+\n+    @Override\n+    public Optional<IslStatus> evaluateStatus() {\n+        boolean isEnabled = true;\n+        boolean isUp = false;\n+\n+        for (Iterator<IslEndpointBfdStatus> it = discoveryData.stream().iterator(); it.hasNext(); ) {\n+            IslEndpointBfdStatus entry = it.next();\n+\n+            isEnabled &= entry.isEnabled();  // only if both endpoint are BFD capable we can use BFD statuses\n+            isUp |= entry.getStatus() == IslStatus.ACTIVE;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzA2MQ==", "bodyText": "It is not simplification - you travel 2 times for each entry i.e. use 2 consecutive loops.", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420633061", "createdAt": "2020-05-06T08:43:57Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/DiscoveryBfdMonitor.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.network.controller.isl;\n+\n+import org.openkilda.model.Isl;\n+import org.openkilda.model.IslDownReason;\n+import org.openkilda.model.IslStatus;\n+import org.openkilda.wfm.share.model.Endpoint;\n+import org.openkilda.wfm.share.model.IslReference;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmContext;\n+import org.openkilda.wfm.topology.network.controller.isl.IslFsm.IslFsmEvent;\n+import org.openkilda.wfm.topology.network.model.IslEndpointBfdStatus;\n+\n+import java.util.Iterator;\n+import java.util.Optional;\n+\n+public class DiscoveryBfdMonitor extends DiscoveryMonitor<IslEndpointBfdStatus> {\n+    public DiscoveryBfdMonitor(IslReference reference) {\n+        super(reference);\n+\n+        IslEndpointBfdStatus dummy = new IslEndpointBfdStatus();\n+        discoveryData.putBoth(dummy);\n+        cache.putBoth(dummy);\n+    }\n+\n+    @Override\n+    public Optional<IslStatus> evaluateStatus() {\n+        boolean isEnabled = true;\n+        boolean isUp = false;\n+\n+        for (Iterator<IslEndpointBfdStatus> it = discoveryData.stream().iterator(); it.hasNext(); ) {\n+            IslEndpointBfdStatus entry = it.next();\n+\n+            isEnabled &= entry.isEnabled();  // only if both endpoint are BFD capable we can use BFD statuses\n+            isUp |= entry.getStatus() == IslStatus.ACTIVE;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NTAzMA=="}, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjMwNDAzOnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/IslFsm.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo0MToyMFrOGQ0gNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0NDozNlrOGRJbYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDYxMw==", "bodyText": "resoruces -> resources", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420290613", "createdAt": "2020-05-05T17:41:20Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/IslFsm.java", "diffHunk": "@@ -126,278 +125,229 @@ public IslFsm(Clock clock, PersistenceManager persistenceManager, IslReportFsm r\n         featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n         switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n \n-        roundTripExpirationTime = Duration.ofNanos(options.getDiscoveryTimeout());\n-\n-        this.reference = reference;\n-\n-        endpointStatus = new BiIslDataHolder<>(reference);\n-        endpointStatus.putBoth(new IslEndpointStatus(IslEndpointStatus.Status.DOWN));\n-\n-        endpointRoundTripStatus = new BiIslDataHolder<>(reference);\n-        endpointRoundTripStatus.put(reference.getSource(), new IslEndpointRoundTripStatus());\n-        endpointRoundTripStatus.put(reference.getDest(), new IslEndpointRoundTripStatus());\n-\n-        discoveryFacts = new DiscoveryFacts(reference);\n-        this.options = options;\n+        transactionManager = persistenceManager.getTransactionManager();\n+        transactionRetryPolicy = transactionManager.makeRetryPolicyBlank()\n+                .withMaxDuration(options.getDbRepeatMaxDurationSeconds(), TimeUnit.SECONDS);\n     }\n \n     // -- FSM actions --\n \n-    public void handleHistory(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        applyHistory(context.getHistory());\n+    public void operationalEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        monitorsByPriority = ImmutableList.of(\n+                new DiscoveryPortStatusMonitor(reference),\n+                new DiscoveryBfdMonitor(reference),\n+                new DiscoveryRoundTripMonitor(reference, clock, options),\n+                new DiscoveryPollMonitor(reference));\n \n-        IslFsmEvent route;\n-        IslEndpointStatus.Status status = getAggregatedStatus();\n-        switch (status) {\n-            case UP:\n-                route = IslFsmEvent._HISTORY_UP;\n-                ignoreRerouteOnUp = true;\n-                break;\n-            case DOWN:\n-                route = IslFsmEvent._HISTORY_DOWN;\n-                break;\n-            case MOVED:\n-                route = IslFsmEvent._HISTORY_MOVED;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(makeInvalidMappingMessage(\n-                        status.getClass(), IslFsmEvent.class, status));\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            loadPersistentData(reference.getSource(), reference.getDest());\n+            loadPersistentData(reference.getDest(), reference.getSource());\n+        });\n \n-        fire(route, context);\n-    }\n+        evaluateStatus();\n \n-    public void historyRestoreUp(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        sendBfdEnable(context.getOutput());\n+        if (effectiveStatus == IslStatus.ACTIVE) {\n+            sendBfdEnable(context.getOutput());\n+        }\n     }\n \n-    public void handleInitialDiscovery(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+    public void operationalExit(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        bfdManager.disable(context.getOutput());\n     }\n \n-    public void updateEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-    }\n+    public void updateMonitorsAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        boolean isSyncRequired = false;\n+        for (DiscoveryMonitor<?> entry : monitorsByPriority) {\n+            isSyncRequired |= entry.update(event, context);\n+        }\n \n-    public void updateAndPersistEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event,\n-                                               IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+        if (evaluateStatus()) {\n+            fireBecomeStateEvent(context);\n+        } else if (isSyncRequired) {\n+            fire(IslFsmEvent._FLUSH);\n+        }\n     }\n \n-    public void downEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_DOWN);\n-\n-        saveStatusTransaction();\n-        sendIslStatusUpdateNotification(context, IslStatus.INACTIVE);\n+    public void flushAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        flushTransaction();\n     }\n \n-    public void handleUpAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-\n-        IslFsmEvent route;\n-        if (getAggregatedStatus() == IslEndpointStatus.Status.UP) {\n-            route = IslFsmEvent._UP_ATTEMPT_SUCCESS;\n-        } else {\n-            route = IslFsmEvent._UP_ATTEMPT_FAIL;\n+    public void removeAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (effectiveStatus != IslStatus.ACTIVE) {\n+            fire(IslFsmEvent._REMOVE_CONFIRMED, context);\n         }\n-        fire(route, context);\n     }\n \n     public void setUpResourcesEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        log.info(\"ISL {} become {}\", discoveryFacts.getReference(), to);\n+        log.info(\"ISL {} initiate speaker resources setup process\", reference);\n+\n         islRulesAttempts = options.getRulesSynchronizationAttempts();\n-        sendInstallMultitable(context);\n-    }\n+        endpointMultiTableManagementCompleteStatus.putBoth(false);\n \n-    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to install rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendInstallMultitable(context);\n-        } else {\n-            log.warn(\"Failed to install rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(true);\n-            endpointStatus.getReverse().setHasIslRules(true);\n-            fire(IslFsmEvent.ISL_UP, context);\n-        }\n-    }\n+        sendInstallMultiTable(context.getOutput());\n \n-    public void cleanUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to remove rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendRemoveMultitable(context);\n-        } else {\n-            log.warn(\"Failed to remove rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(false);\n-            endpointStatus.getReverse().setHasIslRules(false);\n-            fire(IslFsmEvent.ISL_REMOVE_FINISHED, context);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n         }\n     }\n \n-    public void upEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_UP);\n-\n-        saveAllTransaction();\n-        sendBfdEnable(context.getOutput());\n-\n-        if (!ignoreRerouteOnUp) {\n-            // Do not produce reroute during recovery system state from DB\n-            triggerDownFlowReroute(context);\n-        } else {\n-            ignoreRerouteOnUp = false;\n+    // FIXME(surabujin): protect from stale responses\n+    public void handleInstalledRule(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        Endpoint endpoint = context.getInstalledRulesEndpoint();\n+        if (endpoint == null) {\n+            throw new IllegalArgumentException(makeInvalidResourceManipulationResponseMessage());\n         }\n-    }\n \n-    public void upHandlePhysicalDown(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusAndSetIslUnstableTimeTransaction();\n+        log.info(\"Receive response on ISL resource allocation request for {} (from {})\",\n+                reference, endpoint.getDatapath());\n+        endpointMultiTableManagementCompleteStatus.put(endpoint, true);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n+        }\n     }\n \n-    public void upHandlePollEvent(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n-\n-        if (getAggregatedStatus() != IslEndpointStatus.Status.UP) {\n-            fire(IslFsmEvent._BECOME_DOWN, context);\n+    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (--islRulesAttempts >= 0) {\n+            log.info(\"Retrying ISL resoruces setup for {} (attempts lefs:{})\", reference, islRulesAttempts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzQ0Mg==", "bodyText": "nice catch", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420633442", "createdAt": "2020-05-06T08:44:36Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/controller/isl/IslFsm.java", "diffHunk": "@@ -126,278 +125,229 @@ public IslFsm(Clock clock, PersistenceManager persistenceManager, IslReportFsm r\n         featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n         switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n \n-        roundTripExpirationTime = Duration.ofNanos(options.getDiscoveryTimeout());\n-\n-        this.reference = reference;\n-\n-        endpointStatus = new BiIslDataHolder<>(reference);\n-        endpointStatus.putBoth(new IslEndpointStatus(IslEndpointStatus.Status.DOWN));\n-\n-        endpointRoundTripStatus = new BiIslDataHolder<>(reference);\n-        endpointRoundTripStatus.put(reference.getSource(), new IslEndpointRoundTripStatus());\n-        endpointRoundTripStatus.put(reference.getDest(), new IslEndpointRoundTripStatus());\n-\n-        discoveryFacts = new DiscoveryFacts(reference);\n-        this.options = options;\n+        transactionManager = persistenceManager.getTransactionManager();\n+        transactionRetryPolicy = transactionManager.makeRetryPolicyBlank()\n+                .withMaxDuration(options.getDbRepeatMaxDurationSeconds(), TimeUnit.SECONDS);\n     }\n \n     // -- FSM actions --\n \n-    public void handleHistory(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        applyHistory(context.getHistory());\n+    public void operationalEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        monitorsByPriority = ImmutableList.of(\n+                new DiscoveryPortStatusMonitor(reference),\n+                new DiscoveryBfdMonitor(reference),\n+                new DiscoveryRoundTripMonitor(reference, clock, options),\n+                new DiscoveryPollMonitor(reference));\n \n-        IslFsmEvent route;\n-        IslEndpointStatus.Status status = getAggregatedStatus();\n-        switch (status) {\n-            case UP:\n-                route = IslFsmEvent._HISTORY_UP;\n-                ignoreRerouteOnUp = true;\n-                break;\n-            case DOWN:\n-                route = IslFsmEvent._HISTORY_DOWN;\n-                break;\n-            case MOVED:\n-                route = IslFsmEvent._HISTORY_MOVED;\n-                break;\n-            default:\n-                throw new IllegalArgumentException(makeInvalidMappingMessage(\n-                        status.getClass(), IslFsmEvent.class, status));\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            loadPersistentData(reference.getSource(), reference.getDest());\n+            loadPersistentData(reference.getDest(), reference.getSource());\n+        });\n \n-        fire(route, context);\n-    }\n+        evaluateStatus();\n \n-    public void historyRestoreUp(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        sendBfdEnable(context.getOutput());\n+        if (effectiveStatus == IslStatus.ACTIVE) {\n+            sendBfdEnable(context.getOutput());\n+        }\n     }\n \n-    public void handleInitialDiscovery(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+    public void operationalExit(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        bfdManager.disable(context.getOutput());\n     }\n \n-    public void updateEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-    }\n+    public void updateMonitorsAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        boolean isSyncRequired = false;\n+        for (DiscoveryMonitor<?> entry : monitorsByPriority) {\n+            isSyncRequired |= entry.update(event, context);\n+        }\n \n-    public void updateAndPersistEndpointStatus(IslFsmState from, IslFsmState to, IslFsmEvent event,\n-                                               IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n+        if (evaluateStatus()) {\n+            fireBecomeStateEvent(context);\n+        } else if (isSyncRequired) {\n+            fire(IslFsmEvent._FLUSH);\n+        }\n     }\n \n-    public void downEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_DOWN);\n-\n-        saveStatusTransaction();\n-        sendIslStatusUpdateNotification(context, IslStatus.INACTIVE);\n+    public void flushAction(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        flushTransaction();\n     }\n \n-    public void handleUpAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateLinkData(context.getEndpoint(), context.getIslData());\n-\n-        IslFsmEvent route;\n-        if (getAggregatedStatus() == IslEndpointStatus.Status.UP) {\n-            route = IslFsmEvent._UP_ATTEMPT_SUCCESS;\n-        } else {\n-            route = IslFsmEvent._UP_ATTEMPT_FAIL;\n+    public void removeAttempt(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (effectiveStatus != IslStatus.ACTIVE) {\n+            fire(IslFsmEvent._REMOVE_CONFIRMED, context);\n         }\n-        fire(route, context);\n     }\n \n     public void setUpResourcesEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        log.info(\"ISL {} become {}\", discoveryFacts.getReference(), to);\n+        log.info(\"ISL {} initiate speaker resources setup process\", reference);\n+\n         islRulesAttempts = options.getRulesSynchronizationAttempts();\n-        sendInstallMultitable(context);\n-    }\n+        endpointMultiTableManagementCompleteStatus.putBoth(false);\n \n-    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to install rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendInstallMultitable(context);\n-        } else {\n-            log.warn(\"Failed to install rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(true);\n-            endpointStatus.getReverse().setHasIslRules(true);\n-            fire(IslFsmEvent.ISL_UP, context);\n-        }\n-    }\n+        sendInstallMultiTable(context.getOutput());\n \n-    public void cleanUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        islRulesAttempts -= 1;\n-        if (islRulesAttempts >= 0) {\n-            log.info(\"Retrying to remove rules for multi table mode on isl {}\", discoveryFacts.getReference());\n-            sendRemoveMultitable(context);\n-        } else {\n-            log.warn(\"Failed to remove rules for multi table mode on isl {}, required manual rule sync\",\n-                    discoveryFacts.getReference());\n-            endpointStatus.getForward().setHasIslRules(false);\n-            endpointStatus.getReverse().setHasIslRules(false);\n-            fire(IslFsmEvent.ISL_REMOVE_FINISHED, context);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n         }\n     }\n \n-    public void upEnter(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        reportFsm.fire(IslReportFsm.Event.BECOME_UP);\n-\n-        saveAllTransaction();\n-        sendBfdEnable(context.getOutput());\n-\n-        if (!ignoreRerouteOnUp) {\n-            // Do not produce reroute during recovery system state from DB\n-            triggerDownFlowReroute(context);\n-        } else {\n-            ignoreRerouteOnUp = false;\n+    // FIXME(surabujin): protect from stale responses\n+    public void handleInstalledRule(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        Endpoint endpoint = context.getInstalledRulesEndpoint();\n+        if (endpoint == null) {\n+            throw new IllegalArgumentException(makeInvalidResourceManipulationResponseMessage());\n         }\n-    }\n \n-    public void upHandlePhysicalDown(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusAndSetIslUnstableTimeTransaction();\n+        log.info(\"Receive response on ISL resource allocation request for {} (from {})\",\n+                reference, endpoint.getDatapath());\n+        endpointMultiTableManagementCompleteStatus.put(endpoint, true);\n+        if (isMultiTableManagementCompleted()) {\n+            fire(IslFsmEvent._RESOURCES_DONE, context);\n+        }\n     }\n \n-    public void upHandlePollEvent(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n-        updateEndpointStatusByEvent(event, context);\n-        saveStatusTransaction();\n-\n-        if (getAggregatedStatus() != IslEndpointStatus.Status.UP) {\n-            fire(IslFsmEvent._BECOME_DOWN, context);\n+    public void setUpResourcesTimeout(IslFsmState from, IslFsmState to, IslFsmEvent event, IslFsmContext context) {\n+        if (--islRulesAttempts >= 0) {\n+            log.info(\"Retrying ISL resoruces setup for {} (attempts lefs:{})\", reference, islRulesAttempts);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDYxMw=="}, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjM5NDEwOnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/TickClock.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowNDo0MFrOGQ1YQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo1MDoxOFrOGRJnoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDk2MA==", "bodyText": "Why not to delete this class right now?", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420304960", "createdAt": "2020-05-05T18:04:40Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/TickClock.java", "diffHunk": "@@ -17,6 +17,7 @@\n \n import lombok.Getter;\n \n+// TODO - del", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNjU3Ng==", "bodyText": "It is not related to the current change. This is my own reminder, it should not appear in final commit.", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420636576", "createdAt": "2020-05-06T08:50:18Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/TickClock.java", "diffHunk": "@@ -17,6 +17,7 @@\n \n import lombok.Getter;\n \n+// TODO - del", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDk2MA=="}, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjM5NzQzOnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/IslEndpointStatus.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowNTozNVrOGQ1agQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo1MzoxMFrOGRJt9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNTUzNw==", "bodyText": "Why not to delete this class right now?", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420305537", "createdAt": "2020-05-05T18:05:35Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/IslEndpointStatus.java", "diffHunk": "@@ -20,6 +20,7 @@\n import lombok.Data;\n import lombok.Getter;\n \n+// TODO - del?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzODE5OA==", "bodyText": "same here", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420638198", "createdAt": "2020-05-06T08:53:10Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/model/IslEndpointStatus.java", "diffHunk": "@@ -20,6 +20,7 @@\n import lombok.Data;\n import lombok.Getter;\n \n+// TODO - del?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNTUzNw=="}, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjQxOTYyOnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/storm/bolt/isl/IslHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoxMTozOFrOGQ1orw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowMToyMFrOGRKAUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTE2Nw==", "bodyText": "Didn't get it. Add some details please.", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420309167", "createdAt": "2020-05-05T18:11:38Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/storm/bolt/isl/IslHandler.java", "diffHunk": "@@ -160,12 +161,14 @@ public void islDefaultRulesDelete(Endpoint source, Endpoint destination) {\n         emit(STREAM_SPEAKER_RULES_ID, getCurrentTuple(), makeIslRulesDeleteTuple(source, destination));\n     }\n \n+    // FIXME(surabujin) - storm handler design violation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0Mjg5Ng==", "bodyText": "Original design supposes for storm bolt to have makeStreamNameTuple methods for each stream. Here we define 2 such methods for 1 stream.", "url": "https://github.com/telstra/open-kilda/pull/3407#discussion_r420642896", "createdAt": "2020-05-06T09:01:20Z", "author": {"login": "surabujin"}, "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/storm/bolt/isl/IslHandler.java", "diffHunk": "@@ -160,12 +161,14 @@ public void islDefaultRulesDelete(Endpoint source, Endpoint destination) {\n         emit(STREAM_SPEAKER_RULES_ID, getCurrentTuple(), makeIslRulesDeleteTuple(source, destination));\n     }\n \n+    // FIXME(surabujin) - storm handler design violation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTE2Nw=="}, "originalCommit": {"oid": "b29ae1b71ee299e1a6661841c81b0ae4a0c8a4c4"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1943, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}