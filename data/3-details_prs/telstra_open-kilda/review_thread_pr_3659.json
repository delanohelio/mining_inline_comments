{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MjI5NzE4", "number": 3659, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDo0MDo0NlrOEToCrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDo1NToxM1rOEToTrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDE0NDQ3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDo0MDo0NlrOG5dt2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOToxMDowMFrOG6Bl6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkwODg4OA==", "bodyText": "'flow' may be null in case of assumption error", "url": "https://github.com/telstra/open-kilda/pull/3659#discussion_r462908888", "createdAt": "2020-07-30T10:40:46Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -529,6 +551,92 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"Able to update flow encapsulationType using partial update\"() {\n+        given: \"A flow with a 'transit_vlan' encapsulation\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164\n+        }\n+        assumeTrue(\"Unable to find required switches in topology\", switchPair as boolean)\n+\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.encapsulationType = FlowEncapsulationType.TRANSIT_VLAN\n+        flowHelperV2.addFlow(flow)\n+\n+        def originalCookies = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }\n+\n+        when: \"Request a flow partial update for an encapsulationType field(vxlan)\"\n+        def newEncapsulationTypeValue = FlowEncapsulationType.VXLAN.toString().toLowerCase()\n+        def updateRequest = new FlowPatchV2().tap { it.encapsulationType = newEncapsulationTypeValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da7b28e0fc6f79063bfd140d2309a53b22d57cca"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5NjY4MQ==", "bodyText": "fixed", "url": "https://github.com/telstra/open-kilda/pull/3659#discussion_r463496681", "createdAt": "2020-07-31T09:10:00Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -529,6 +551,92 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"Able to update flow encapsulationType using partial update\"() {\n+        given: \"A flow with a 'transit_vlan' encapsulation\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164\n+        }\n+        assumeTrue(\"Unable to find required switches in topology\", switchPair as boolean)\n+\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.encapsulationType = FlowEncapsulationType.TRANSIT_VLAN\n+        flowHelperV2.addFlow(flow)\n+\n+        def originalCookies = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }\n+\n+        when: \"Request a flow partial update for an encapsulationType field(vxlan)\"\n+        def newEncapsulationTypeValue = FlowEncapsulationType.VXLAN.toString().toLowerCase()\n+        def updateRequest = new FlowPatchV2().tap { it.encapsulationType = newEncapsulationTypeValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkwODg4OA=="}, "originalCommit": {"oid": "da7b28e0fc6f79063bfd140d2309a53b22d57cca"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDE4Nzk5OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDo1NToxM1rOG5eIXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwOToxMDoxNVrOG6Bmcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxNTY3Nw==", "bodyText": "we have 20+ qinq tests that do updates and verify them. Can we use partial update in some of those tests instead?", "url": "https://github.com/telstra/open-kilda/pull/3659#discussion_r462915677", "createdAt": "2020-07-30T10:55:13Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -529,6 +551,92 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"Able to update flow encapsulationType using partial update\"() {\n+        given: \"A flow with a 'transit_vlan' encapsulation\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164\n+        }\n+        assumeTrue(\"Unable to find required switches in topology\", switchPair as boolean)\n+\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.encapsulationType = FlowEncapsulationType.TRANSIT_VLAN\n+        flowHelperV2.addFlow(flow)\n+\n+        def originalCookies = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }\n+\n+        when: \"Request a flow partial update for an encapsulationType field(vxlan)\"\n+        def newEncapsulationTypeValue = FlowEncapsulationType.VXLAN.toString().toLowerCase()\n+        def updateRequest = new FlowPatchV2().tap { it.encapsulationType = newEncapsulationTypeValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    def \"Able to update innerVlanId/vlanId using partial update\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da7b28e0fc6f79063bfd140d2309a53b22d57cca"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5NjgxOQ==", "bodyText": "it makes sense. fixed", "url": "https://github.com/telstra/open-kilda/pull/3659#discussion_r463496819", "createdAt": "2020-07-31T09:10:15Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/PartialUpdateSpec.groovy", "diffHunk": "@@ -529,6 +551,92 @@ class PartialUpdateSpec extends HealthCheckSpecification {\n         ]\n     }\n \n+    @Tidy\n+    @Tags(HARDWARE)\n+    def \"Able to update flow encapsulationType using partial update\"() {\n+        given: \"A flow with a 'transit_vlan' encapsulation\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.noviflow && !it.src.wb5164 && it.dst.noviflow && !it.dst.wb5164\n+        }\n+        assumeTrue(\"Unable to find required switches in topology\", switchPair as boolean)\n+\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.encapsulationType = FlowEncapsulationType.TRANSIT_VLAN\n+        flowHelperV2.addFlow(flow)\n+\n+        def originalCookies = northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }\n+\n+        when: \"Request a flow partial update for an encapsulationType field(vxlan)\"\n+        def newEncapsulationTypeValue = FlowEncapsulationType.VXLAN.toString().toLowerCase()\n+        def updateRequest = new FlowPatchV2().tap { it.encapsulationType = newEncapsulationTypeValue }\n+        def response = flowHelperV2.partialUpdate(flow.flowId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Changes actually took place\"\n+        northboundV2.getFlow(flow.flowId).encapsulationType == newEncapsulationTypeValue\n+\n+        and: \"Flow rules have been reinstalled\"\n+        !northbound.getSwitchRules(switchPair.src.dpId).flowEntries.findAll {\n+            !new Cookie(it.cookie).serviceFlag\n+        }.any { it in originalCookies }\n+\n+        cleanup: \"Remove the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    def \"Able to update innerVlanId/vlanId using partial update\"() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxNTY3Nw=="}, "originalCommit": {"oid": "da7b28e0fc6f79063bfd140d2309a53b22d57cca"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1785, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}