{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0Mzk5NjUy", "number": 3598, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDowNjoyOFrOEMF_xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjozNDoyMFrOEMWYew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTE2NjE0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDowNjoyOFrOGuAN0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDowNjoyOFrOGuAN0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTIxNw==", "bodyText": "no 'both flows' here", "url": "https://github.com/telstra/open-kilda/pull/3598#discussion_r450891217", "createdAt": "2020-07-07T14:06:28Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -603,12 +610,26 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         def switchToManipulate = topology.activeSwitches.find { !(it.dpId in involvedSwitches) }\n         def blockData = switchHelper.knockoutSwitch(switchToManipulate, mgmtFlManager)\n         def isSwitchActivated = false\n+        wait(WAIT_OFFSET) {\n+            def prevHistorySize = northbound.getFlowHistory(flow.flowId).size()\n+            Wrappers.timedLoop(4) {\n+                //history size should no longer change for both flows, all retries should give up", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0596f8b5420d405bc92360fcf3bc5ea537415e67"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTE2OTM3OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDowNzowOVrOGuAPyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDowNzowOVrOGuAPyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5MTcyMw==", "bodyText": "withPool can be removed. It is a wrapper that allows parallel operations like 'eachParallel'", "url": "https://github.com/telstra/open-kilda/pull/3598#discussion_r450891723", "createdAt": "2020-07-07T14:07:09Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -603,12 +610,26 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         def switchToManipulate = topology.activeSwitches.find { !(it.dpId in involvedSwitches) }\n         def blockData = switchHelper.knockoutSwitch(switchToManipulate, mgmtFlManager)\n         def isSwitchActivated = false\n+        wait(WAIT_OFFSET) {\n+            def prevHistorySize = northbound.getFlowHistory(flow.flowId).size()\n+            Wrappers.timedLoop(4) {\n+                //history size should no longer change for both flows, all retries should give up\n+                def newHistorySize = northbound.getFlowHistory(flow.flowId).size()\n+                assert newHistorySize == prevHistorySize\n+                withPool {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0596f8b5420d405bc92360fcf3bc5ea537415e67"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTE4NDg1OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxMDozN1rOGuAZ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxMDozN1rOGuAZ4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5NDMwNQ==", "bodyText": "I think its safer to save the timestamp before calling reviveSwitch", "url": "https://github.com/telstra/open-kilda/pull/3598#discussion_r450894305", "createdAt": "2020-07-07T14:10:37Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -603,12 +610,26 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         def switchToManipulate = topology.activeSwitches.find { !(it.dpId in involvedSwitches) }\n         def blockData = switchHelper.knockoutSwitch(switchToManipulate, mgmtFlManager)\n         def isSwitchActivated = false\n+        wait(WAIT_OFFSET) {\n+            def prevHistorySize = northbound.getFlowHistory(flow.flowId).size()\n+            Wrappers.timedLoop(4) {\n+                //history size should no longer change for both flows, all retries should give up\n+                def newHistorySize = northbound.getFlowHistory(flow.flowId).size()\n+                assert newHistorySize == prevHistorySize\n+                withPool {\n+                    assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+                }\n+            sleep(500)\n+            }\n+        }\n         switchHelper.reviveSwitch(switchToManipulate, blockData)\n+        def expectedZeroReroutesTimestamp = System.currentTimeSeconds()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0596f8b5420d405bc92360fcf3bc5ea537415e67"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg1MDgzOnYy", "diffSide": "RIGHT", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/reroute/actions/UpdateFlowStatusAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjozNDoyMFrOGuaAIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0NzowNFrOGuaTGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxMzY5OA==", "bodyText": "In the current implementation, we have DEGRADED status only when we could not find the protected path. But in this case, this status is set for another reason. Therefore, the message Couldn't find non overlapping protected path in status_info will be incorrect.", "url": "https://github.com/telstra/open-kilda/pull/3598#discussion_r451313698", "createdAt": "2020-07-08T06:34:20Z", "author": {"login": "dpoltavets"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/reroute/actions/UpdateFlowStatusAction.java", "diffHunk": "@@ -48,6 +48,9 @@ protected void perform(State from, State to, Event event, FlowRerouteContext con\n         FlowStatus resultStatus = persistenceManager.getTransactionManager().doInTransaction(() -> {\n             Flow flow = getFlow(flowId, FetchStrategy.DIRECT_RELATIONS);\n             FlowStatus flowStatus = flow.computeFlowStatus();\n+            if (stateMachine.isIgnoreBandwidth() && flowStatus == FlowStatus.UP) {\n+                flowStatus = FlowStatus.DEGRADED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2094b9aeded74275c2c93e7805f797fc6660b2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxODU1NA==", "bodyText": "good catch, haven't seen this before rebase, fixed", "url": "https://github.com/telstra/open-kilda/pull/3598#discussion_r451318554", "createdAt": "2020-07-08T06:47:04Z", "author": {"login": "timofei-durakov"}, "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/reroute/actions/UpdateFlowStatusAction.java", "diffHunk": "@@ -48,6 +48,9 @@ protected void perform(State from, State to, Event event, FlowRerouteContext con\n         FlowStatus resultStatus = persistenceManager.getTransactionManager().doInTransaction(() -> {\n             Flow flow = getFlow(flowId, FetchStrategy.DIRECT_RELATIONS);\n             FlowStatus flowStatus = flow.computeFlowStatus();\n+            if (stateMachine.isIgnoreBandwidth() && flowStatus == FlowStatus.UP) {\n+                flowStatus = FlowStatus.DEGRADED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxMzY5OA=="}, "originalCommit": {"oid": "6d2094b9aeded74275c2c93e7805f797fc6660b2"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1903, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}