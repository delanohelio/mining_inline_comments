{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MTA1NzUy", "number": 3154, "title": "add tests for pop and protected path", "bodyText": "", "createdAt": "2020-01-30T14:31:08Z", "url": "https://github.com/telstra/open-kilda/pull/3154", "merged": true, "mergeCommit": {"oid": "21131de5f68346954e1b1bcadb11cb1f5459066b"}, "closed": true, "closedAt": "2020-04-07T11:18:06Z", "author": {"login": "andriidovhan"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_sX8YABqjI5OTY1MzI1MjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVRcdnAFqTM4OTAxODQyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96ccb9db9ac261c7809f08f46694125f83eb0136", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/96ccb9db9ac261c7809f08f46694125f83eb0136", "committedDate": "2020-01-30T14:30:45Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/6b249c112e4dd9cfbdf4513557a97c2a9d542680", "committedDate": "2020-01-31T10:13:50Z", "message": "add test for pop and protected path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNDU2Nzc3", "url": "https://github.com/telstra/open-kilda/pull/3154#pullrequestreview-351456777", "createdAt": "2020-01-31T11:52:53Z", "commit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTo1Mjo1M1rOFkJMyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMjowOTowOVrOFkJivg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0Mzc4NA==", "bodyText": "This line is impossible to fire. Also, you can save all paths during swPair search in order to not repeat the same reduction here", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373443784", "createdAt": "2020-01-31T11:52:53Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDYwMQ==", "bodyText": "tr3 is for transit switch protected, right?", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373444601", "createdAt": "2020-01-31T11:55:08Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTA2MQ==", "bodyText": "This does not correspond to your comment above. You should have dst in '4' and protected transit in '3'", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373445061", "createdAt": "2020-01-31T11:56:30Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTg2MQ==", "bodyText": "Can we use pathHelper.makePathNotPreferable(protectedPath)? May look much more readable", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373445861", "createdAt": "2020-01-31T11:58:51Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0OTQwNg==", "bodyText": "can you elaborate here please? I mean the reason why it picked 'tr3' path. It is really hard to follow all this pop logic without any pictures before eyes and with very brief comments. I mean I get it right now, but it will take me too much time to refresh the memory in a month or two. And the test must be a good helper here", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r373449406", "createdAt": "2020-01-31T12:09:09Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1183,6 +1184,68 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swPair ->\n+            swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //find out all paths with 3 switches\n+        def allPaths = swPair.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+        def allPathCandidates = allPaths.unique(false) { a, b ->\n+            a.intersect(b) == [] ? 1 : 0\n+        }\n+        assumeTrue(\"Not enough amount of diverse paths\", allPathCandidates.size() >= 3)\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"3\")\n+        database.setSwitchPop(involvedSwProtected[1], \"4\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                northbound.updateLinkProps([islUtils.toLinkProps(it,\n+                        [\"cost\": (database.getIslCost(it) + 10).toString()])])\n+            }\n+        }\n+\n+        when: \"Create a protected flow\"\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flow.allocateProtectedPath = true\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Main path is built through the preferable path(tr1 or tr2)\"\n+        def flowPaths = northbound.getFlowPath(flow.flowId)\n+        def realFlowPathInvolvedSwitches = pathHelper.getInvolvedSwitches(pathHelper.convert(flowPaths))*.dpId\n+        realFlowPathInvolvedSwitches == involvedSwP1 || realFlowPathInvolvedSwitches == involvedSwP2\n+\n+        and: \"Protected path is built through the non preferable path(tr3)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680"}, "originalPosition": 61}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b249c112e4dd9cfbdf4513557a97c2a9d542680", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/6b249c112e4dd9cfbdf4513557a97c2a9d542680", "committedDate": "2020-01-31T10:13:50Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "a22adef637794a3d010ff7e09e4e81f0d2c0da5a", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/a22adef637794a3d010ff7e09e4e81f0d2c0da5a", "committedDate": "2020-01-31T13:29:02Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a22adef637794a3d010ff7e09e4e81f0d2c0da5a", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/a22adef637794a3d010ff7e09e4e81f0d2c0da5a", "committedDate": "2020-01-31T13:29:02Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "89371bfdd9b62881fe9be055fe40ff79aafa848d", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/89371bfdd9b62881fe9be055fe40ff79aafa848d", "committedDate": "2020-01-31T13:41:31Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89371bfdd9b62881fe9be055fe40ff79aafa848d", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/89371bfdd9b62881fe9be055fe40ff79aafa848d", "committedDate": "2020-01-31T13:41:31Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "936f1d99fd151cf352b5d49bfd47f366b5b5e4d5", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/936f1d99fd151cf352b5d49bfd47f366b5b5e4d5", "committedDate": "2020-03-23T08:54:02Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "936f1d99fd151cf352b5d49bfd47f366b5b5e4d5", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/936f1d99fd151cf352b5d49bfd47f366b5b5e4d5", "committedDate": "2020-03-23T08:54:02Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "ed4d7d01376f644450fba7643d8d6dbce7a559e3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/ed4d7d01376f644450fba7643d8d6dbce7a559e3", "committedDate": "2020-03-25T12:17:28Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed4d7d01376f644450fba7643d8d6dbce7a559e3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/ed4d7d01376f644450fba7643d8d6dbce7a559e3", "committedDate": "2020-03-25T12:17:28Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/03ca9ddb133aaabaccaae27af3494305f633691e", "committedDate": "2020-03-26T15:24:01Z", "message": "add test for pop and protected path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNzAxODY0", "url": "https://github.com/telstra/open-kilda/pull/3154#pullrequestreview-383701864", "createdAt": "2020-03-30T09:59:07Z", "commit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTo1OTowN1rOF9iRnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDowMjowN1rOF9iY4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA2OTAyMQ==", "bodyText": "replace 700 with named constant.\nyou can assume all ISLs are at the default cost at the start of the test and don't call northbound.getLink", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400069021", "createdAt": "2020-03-30T09:59:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDYzMw==", "bodyText": "the comment explains 2000, but I think it still makes sense to extract it into variables and make a clean self-explaining code totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400070633", "createdAt": "2020-03-30T10:01:40Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }\n+        def amountOfIlslsOnMainPath = involvedIslsOfMainPath.size()\n+        Integer newIslCost = ((totalCostOfMainPath + (amountOfIlslsOnMainPath * 2000) - 1) /", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDg4Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/telstra/open-kilda/pull/3154#discussion_r400070882", "createdAt": "2020-03-30T10:02:07Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathV2Spec.groovy", "diffHunk": "@@ -1303,6 +1304,106 @@ class ProtectedPathV2Spec extends HealthCheckSpecification {\n         northbound.deleteLinkProps(northbound.getAllLinkProps())\n     }\n \n+    @Tidy\n+    def \"Protected path is created in different POP even if this path is not preferable\"(){\n+        given: \"Not neighboring switch pair with three diverse paths at least\"\n+        def allPaths //all possible paths with 3 involved switches\n+        def allPathCandidates // 3 diverse paths at least\n+        def swPair = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            allPaths = swP.paths.findAll { pathHelper.getInvolvedSwitches(it).size() == 3 }\n+            allPathCandidates = allPaths.unique(false) { a, b ->\n+                a.intersect(b) == [] ? 1 : 0\n+            } // just to avoid parallel links\n+            allPaths.unique(false) { a, b ->\n+                def p1 = pathHelper.getInvolvedSwitches(a)[1..-2]*.dpId\n+                def p2 = pathHelper.getInvolvedSwitches(b)[1..-2]*.dpId\n+                p1.intersect(p2) == [] ? 1 : 0\n+            }.size() >= 3\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //select paths for further manipulations\n+        def mainPath1 = allPathCandidates.first()\n+        def mainPath2 = allPathCandidates.find { it != mainPath1 }\n+        def protectedPath = allPathCandidates.find { it != mainPath1 && it != mainPath2}\n+        def involvedSwP1 = pathHelper.getInvolvedSwitches(mainPath1)*.dpId\n+        def involvedSwP2 = pathHelper.getInvolvedSwitches(mainPath2)*.dpId\n+        def involvedSwProtected = pathHelper.getInvolvedSwitches(protectedPath)*.dpId\n+\n+        and: \"Src, dst and transit switches belongs to different POPs(src:1, dst:4, tr1/tr2:2, tr3:3)\"\n+        // tr1/tr2 for the main path and tr3 for the protected path\n+        database.setSwitchPop(swPair.src.dpId, \"1\")\n+        [involvedSwP1[1], involvedSwP2[1]].each { swId -> database.setSwitchPop(swId, \"2\") }\n+        database.setSwitchPop(swPair.dst.dpId, \"4\")\n+        database.setSwitchPop(involvedSwProtected[1], \"3\")\n+\n+        and: \"Path which contains tr3 is non preferable\"\n+        /** There is not possibility to use the 'makePathNotPreferable' method,\n+         * because it sets too high value for protectedPath.\n+         *\n+         *  totalCostOFProtectedPath should be the following:\n+         *  totalCostOfMainPath + (amountOfInvolvedIsls * diversity.pop.isl.cost * diversityGroupPerPopUseCounter) - 1,\n+         *  where:\n+         *  diversity.pop.isl.cost = 1000\n+         *  diversityGroupPerPopUseCounter = amount of switches in the same POP\n+         *  (in this test there are two switches in the same POP) */\n+        List<Isl> islsToUpdate = []\n+        allPaths.findAll { involvedSwProtected[1] in pathHelper.getInvolvedSwitches(it)*.dpId }.each {\n+            pathHelper.getInvolvedIsls(it).each {\n+                islsToUpdate << it\n+            }\n+        }\n+        def involvedIslsOfMainPath = pathHelper.getInvolvedIsls(mainPath1)\n+        def totalCostOfMainPath = involvedIslsOfMainPath.sum { northbound.getLink(it).cost ?: 700 }\n+        def amountOfIlslsOnMainPath = involvedIslsOfMainPath.size()\n+        Integer newIslCost = ((totalCostOfMainPath + (amountOfIlslsOnMainPath * 2000) - 1) /\n+                pathHelper.getInvolvedIsls(protectedPath).size()).toInteger()\n+        log.debug(\"newCost: $newIslCost\")\n+\n+        islsToUpdate.unique().each { isl ->\n+            northbound.updateLinkProps([islUtils.toLinkProps(isl, [\"cost\": newIslCost.toString()])])\n+        }\n+\n+        when: \"Create a protected flow\"\n+        /** At this point we have the following topology:\n+         *\n+         *             srcSwitch_POP_1\n+         *             /       |       \\\n+         *            / 700    | 700    \\ newIslCost\n+         *           /         |         \\\n+         *   trSw1_POP_2   trSw2_POP_2   trSw3_POP_3\n+         *          \\          |         /\n+         *           \\ 700     | 700    / newIslCost\n+         *            \\        |       /\n+         *             dstSwitch_POP_4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e"}, "originalPosition": 82}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "03ca9ddb133aaabaccaae27af3494305f633691e", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/03ca9ddb133aaabaccaae27af3494305f633691e", "committedDate": "2020-03-26T15:24:01Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "612c07992d80e49c8ec9192ff4d7cac2fb3f8a91", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/612c07992d80e49c8ec9192ff4d7cac2fb3f8a91", "committedDate": "2020-03-30T11:54:34Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "612c07992d80e49c8ec9192ff4d7cac2fb3f8a91", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/612c07992d80e49c8ec9192ff4d7cac2fb3f8a91", "committedDate": "2020-03-30T11:54:34Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "f398e43d3773ec8ad8f732c5941f40e5df1b62e1", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/f398e43d3773ec8ad8f732c5941f40e5df1b62e1", "committedDate": "2020-03-30T15:32:33Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f398e43d3773ec8ad8f732c5941f40e5df1b62e1", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/f398e43d3773ec8ad8f732c5941f40e5df1b62e1", "committedDate": "2020-03-30T15:32:33Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "ed54b51d06f42968ae50b6d2266e440ef9b7c601", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/ed54b51d06f42968ae50b6d2266e440ef9b7c601", "committedDate": "2020-04-03T12:15:32Z", "message": "add test for pop and protected path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bceaa8419f3e9e0eb04f276a7033707b61d4defe", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/bceaa8419f3e9e0eb04f276a7033707b61d4defe", "committedDate": "2020-04-06T07:45:30Z", "message": "add test for pop and protected path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed54b51d06f42968ae50b6d2266e440ef9b7c601", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/ed54b51d06f42968ae50b6d2266e440ef9b7c601", "committedDate": "2020-04-03T12:15:32Z", "message": "add test for pop and protected path"}, "afterCommit": {"oid": "bceaa8419f3e9e0eb04f276a7033707b61d4defe", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/bceaa8419f3e9e0eb04f276a7033707b61d4defe", "committedDate": "2020-04-06T07:45:30Z", "message": "add test for pop and protected path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDE4NDIy", "url": "https://github.com/telstra/open-kilda/pull/3154#pullrequestreview-389018422", "createdAt": "2020-04-07T11:17:58Z", "commit": {"oid": "bceaa8419f3e9e0eb04f276a7033707b61d4defe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3700, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}