{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxNzAxMDA3", "number": 3735, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1NjowNFrOEsj6Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1NjowNFrOEsj6Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTYxMTY2OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathsSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwOTo1NjowNFrOHf3p-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMzozNzowMVrOHf_FOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE3OTc2OA==", "bodyText": "any", "url": "https://github.com/telstra/open-kilda/pull/3735#discussion_r503179768", "createdAt": "2020-10-12T09:56:04Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathsSpec.groovy", "diffHunk": "@@ -59,10 +62,32 @@ class PathsSpec extends HealthCheckSpecification {\n         def sw = topology.getActiveSwitches()[0]\n \n         when: \"Try to get paths between real switch and nonexistent switch\"\n-        northbound.getPaths(sw.dpId, NON_EXISTENT_SWITCH_ID)\n+        northbound.getPaths(sw.dpId, NON_EXISTENT_SWITCH_ID, null, null)\n \n         then: \"Get 404 NotFound error\"\n         def exc = thrown(HttpClientErrorException)\n         exc.rawStatusCode == 404\n     }\n+\n+    def \"Unable to get a path for a 'vxlan' flowEncapsulationType when flow when switches do not support it\"() {\n+        given: \"Two active not supported 'vxlan' flowEncapsulationType switches\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7736ed9be2e27b4239158f984ecb2ab3f886861b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwMTQzNA==", "bodyText": "it makes sense to me, thx", "url": "https://github.com/telstra/open-kilda/pull/3735#discussion_r503301434", "createdAt": "2020-10-12T13:37:01Z", "author": {"login": "andriidovhan"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/network/PathsSpec.groovy", "diffHunk": "@@ -59,10 +62,32 @@ class PathsSpec extends HealthCheckSpecification {\n         def sw = topology.getActiveSwitches()[0]\n \n         when: \"Try to get paths between real switch and nonexistent switch\"\n-        northbound.getPaths(sw.dpId, NON_EXISTENT_SWITCH_ID)\n+        northbound.getPaths(sw.dpId, NON_EXISTENT_SWITCH_ID, null, null)\n \n         then: \"Get 404 NotFound error\"\n         def exc = thrown(HttpClientErrorException)\n         exc.rawStatusCode == 404\n     }\n+\n+    def \"Unable to get a path for a 'vxlan' flowEncapsulationType when flow when switches do not support it\"() {\n+        given: \"Two active not supported 'vxlan' flowEncapsulationType switches\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE3OTc2OA=="}, "originalCommit": {"oid": "7736ed9be2e27b4239158f984ecb2ab3f886861b"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1827, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}