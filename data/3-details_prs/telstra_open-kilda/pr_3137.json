{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1ODY4OTc5", "number": 3137, "title": "Test/reroute on switch up", "bodyText": "Covers: #3131", "createdAt": "2020-01-22T13:59:22Z", "url": "https://github.com/telstra/open-kilda/pull/3137", "merged": true, "mergeCommit": {"oid": "5bdedf2ce5033ed14e6b09d4c1bd213e4b67ba5f"}, "closed": true, "closedAt": "2020-01-27T13:58:14Z", "author": {"login": "andriidovhan"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9Hhe4gBqjI5NzMxNDQwNDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-dDwZgFqTM0ODY3MzMzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b3af15670fd9fed9e17fd9f3f381bd9ffd3fe25", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/5b3af15670fd9fed9e17fd9f3f381bd9ffd3fe25", "committedDate": "2020-01-22T13:58:14Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "e2cee7a3907312f0943bb826e7d4f282194580e6", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/e2cee7a3907312f0943bb826e7d4f282194580e6", "committedDate": "2020-01-23T10:09:39Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2cee7a3907312f0943bb826e7d4f282194580e6", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/e2cee7a3907312f0943bb826e7d4f282194580e6", "committedDate": "2020-01-23T10:09:39Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/360c546b2dbd8a16f96d78d99c18b5915b7296e3", "committedDate": "2020-01-23T10:25:57Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MjA1Nzg3", "url": "https://github.com/telstra/open-kilda/pull/3137#pullrequestreview-347205787", "createdAt": "2020-01-23T10:48:08Z", "commit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDo0ODowOFrOFg59hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTowMzo0OFrOFg6Y0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODM4OQ==", "bodyText": "I don't think this wait is required", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048389", "createdAt": "2020-01-23T10:48:08Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODgyMA==", "bodyText": "explain this, or use a meaningful name for the variable", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370048820", "createdAt": "2020-01-23T10:49:01Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDE5NA==", "bodyText": "So the flow status is still UP at this point, am I correct?", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050194", "createdAt": "2020-01-23T10:52:05Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MDkzNQ==", "bodyText": "please prefer northbound.getLink(isltToBreak)... over your construction. IslUtils implementation will request all isls, while my call will only request one", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370050935", "createdAt": "2020-01-23T10:53:39Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MjU0Mw==", "bodyText": "any chance for tidy cleanup?", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370052543", "createdAt": "2020-01-23T10:57:06Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzY2Mw==", "bodyText": "If you decide to do a tidy cleanup, I suggest to remove the flow as a first step, so that just in case it ended up in 'Down' state, we don't trigger it to 'in progress' by bringing above ports to up status", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370053663", "createdAt": "2020-01-23T10:59:41Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        and: \"All alternative paths are unavailable (bring ports down on the srcSwitch)\"\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        and: \"Main path more preferable than the backup \"\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow on the main path\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and:  \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        sleep(4000)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert islUtils.getIslInfo(islToBreak).get().state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert islUtils.getIslInfo(islToReroute).get().state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+\n+        then: \"Flow is rerouted\"\n+        Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+        }\n+\n+        //and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+\n+        and: \"Restore topology, delete the flow and reset costs\"\n+        antiflap.portUp(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+        broughtDownPorts.each { antiflap.portUp(it.switchId, it.portNo) }\n+        flowHelperV2.deleteFlow(flow.flowId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTM3Ng==", "bodyText": "Please don't get too keen on commenting the code whith given/when/then. These blocks must describe the test case, not the code. You can comment code using regular //comment comments", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r370055376", "createdAt": "2020-01-23T11:03:48Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -441,6 +403,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links\"\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"Main and backup paths for further manipulation with them\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "360c546b2dbd8a16f96d78d99c18b5915b7296e3", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/360c546b2dbd8a16f96d78d99c18b5915b7296e3", "committedDate": "2020-01-23T10:25:57Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "b97d66744e46f468748b5e83decd301b889e3579", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/b97d66744e46f468748b5e83decd301b889e3579", "committedDate": "2020-01-24T09:50:46Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b97d66744e46f468748b5e83decd301b889e3579", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/b97d66744e46f468748b5e83decd301b889e3579", "committedDate": "2020-01-24T09:50:46Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "fb804be5890c9105de0b9f064a3fad43f32b1b9e", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/fb804be5890c9105de0b9f064a3fad43f32b1b9e", "committedDate": "2020-01-24T15:15:41Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb804be5890c9105de0b9f064a3fad43f32b1b9e", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/fb804be5890c9105de0b9f064a3fad43f32b1b9e", "committedDate": "2020-01-24T15:15:41Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "committedDate": "2020-01-24T15:55:07Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "committedDate": "2020-01-27T09:22:54Z", "message": "add test: Flow is rerouted after switchUp event"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/8c5c93ca2be612d06b9e9e3f241736495e0e7f17", "committedDate": "2020-01-24T15:55:07Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "03ac7e54558b35af89d492058584fbd21a5956f6", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/03ac7e54558b35af89d492058584fbd21a5956f6", "committedDate": "2020-01-27T09:22:54Z", "message": "update database helper by setSwitchStatus"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "03ac7e54558b35af89d492058584fbd21a5956f6", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/03ac7e54558b35af89d492058584fbd21a5956f6", "committedDate": "2020-01-27T09:22:54Z", "message": "update database helper by setSwitchStatus"}, "afterCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "author": {"user": {"login": "andriidovhan", "name": "AndriiDovhan"}}, "url": "https://github.com/telstra/open-kilda/commit/38f8144afebe25141083d7c6cf3f3e9fc7e1ead4", "committedDate": "2020-01-27T09:22:54Z", "message": "add test: Flow is rerouted after switchUp event"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NTY5NDIx", "url": "https://github.com/telstra/open-kilda/pull/3137#pullrequestreview-348569421", "createdAt": "2020-01-27T10:41:12Z", "commit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NjU3ODMz", "url": "https://github.com/telstra/open-kilda/pull/3137#pullrequestreview-348657833", "createdAt": "2020-01-27T13:25:21Z", "commit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzoyNToyMVrOFiCgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzoyNToyMVrOFiCgew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw==", "bodyText": "While we don't have a history verification that the reroute reason was 'switch up event', I'd like to see an explicit assert that all the switch-related isls are up before this action (or at least one?). Otherwise - I'm not sure what was the reason of reroute and it is very easy to receive a false-successful run.", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371236987", "createdAt": "2020-01-27T13:25:21Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NjczMzM4", "url": "https://github.com/telstra/open-kilda/pull/3137#pullrequestreview-348673338", "createdAt": "2020-01-27T13:49:31Z", "commit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0OTozMVrOFiDOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0OTozMVrOFiDOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0ODcyNQ==", "bodyText": "OK, didn't realize that islToReroute belongs to switch to break. It's fine then", "url": "https://github.com/telstra/open-kilda/pull/3137#discussion_r371248725", "createdAt": "2020-01-27T13:49:31Z", "author": {"login": "rtretyak"}, "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +407,90 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(VIRTUAL)\n+    def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n+        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() > 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        //Main and backup paths for further manipulation with them\n+        def mainPath = switchPair.paths.min { it.size() }\n+        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n+        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+\n+        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPaths.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == IslChangeType.FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //Main path more preferable than the backup\n+        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+\n+        when: \"Disconnect the src switch from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair.src)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+\n+        and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+\n+        and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n+        antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n+\n+        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getLink(islToBreak).state == FAILED\n+            // just to be sure that backup ISL is not failed\n+            assert northbound.getLink(islToReroute).state == DISCOVERED\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n+            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        }\n+\n+        when: \"Connect the switch back to the controller\"\n+        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair.src)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIzNjk4Nw=="}, "originalCommit": {"oid": "38f8144afebe25141083d7c6cf3f3e9fc7e1ead4"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3691, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}