{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNTM1NDcx", "number": 3508, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMzo0Njo0MlrOEiICDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToyNjowN1rOEpoqlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjE4NjM2OnYy", "diffSide": "RIGHT", "path": "src-gui/src/main/resources/ui/index.html", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMzo0Njo0MlrOHP0pWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo1ODowM1rOHRqeGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM1MzI0Mw==", "bodyText": "Changes in gui?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486353243", "createdAt": "2020-09-10T13:46:42Z", "author": {"login": "rozdy"}, "path": "src-gui/src/main/resources/ui/index.html", "diffHunk": "@@ -3,7 +3,7 @@\n <head>\r\n   <meta charset=\"utf-8\">\r\n   <title>OPEN KILDA</title>\r\n-  <base href=\"/openkilda/\">\n+  <base href=\"/openkilda/\">\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MzY3NA==", "bodyText": "Nope. Merge issue. Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488283674", "createdAt": "2020-09-14T22:58:03Z", "author": {"login": "sergii-iakovenko"}, "path": "src-gui/src/main/resources/ui/index.html", "diffHunk": "@@ -3,7 +3,7 @@\n <head>\r\n   <meta charset=\"utf-8\">\r\n   <title>OPEN KILDA</title>\r\n-  <base href=\"/openkilda/\">\n+  <base href=\"/openkilda/\">\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM1MzI0Mw=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjIyODU4OnYy", "diffSide": "RIGHT", "path": "docker/orientdb/config/odb3/orientdb-server-log.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMzo1MzoyN1rOHP1GvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo1ODoyNVrOHRqekg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2MDc2NA==", "bodyText": "Is it possible to keep one copy of configs for all 3 containers?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486360764", "createdAt": "2020-09-10T13:53:27Z", "author": {"login": "rozdy"}, "path": "docker/orientdb/config/odb3/orientdb-server-log.properties", "diffHunk": "@@ -0,0 +1,46 @@\n+#\n+# /*\n+#  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)\n+#  *\n+#  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+#  *  you may not use this file except in compliance with the License.\n+#  *  You may obtain a copy of the License at\n+#  *\n+#  *       http://www.apache.org/licenses/LICENSE-2.0\n+#  *\n+#  *  Unless required by applicable law or agreed to in writing, software\n+#  *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  *  See the License for the specific language governing permissions and\n+#  *  limitations under the License.\n+#  *\n+#  * For more information: http://www.orientechnologies.com\n+#  */\n+#\n+\n+# Specify the handlers to create in the root logger\n+# (all loggers are children of the root logger)\n+# The following creates two handlers\n+handlers = java.util.logging.ConsoleHandler, java.util.logging.FileHandler\n+\n+# Set the default logging level for the root logger\n+.level = INFO\n+com.orientechnologies.level = INFO\n+com.orientechnologies.orient.server.distributed.level = INFO\n+\n+# Set the default logging level for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.level = INFO\n+# Set the default formatter for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.formatter = com.orientechnologies.common.log.OAnsiLogFormatter\n+\n+# Set the default logging level for new FileHandler instances\n+java.util.logging.FileHandler.level = INFO\n+# Naming style for the output file\n+java.util.logging.FileHandler.pattern=../log/orient-server.log\n+# Set the default formatter for new FileHandler instances\n+java.util.logging.FileHandler.formatter = com.orientechnologies.common.log.OLogFormatter\n+# Limiting size of output file in bytes:\n+java.util.logging.FileHandler.limit=10000000\n+# Number of output files to cycle through, by appending an\n+# integer to the base file name:\n+java.util.logging.FileHandler.count=10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Mzc5NA==", "bodyText": "Refactored.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488283794", "createdAt": "2020-09-14T22:58:25Z", "author": {"login": "sergii-iakovenko"}, "path": "docker/orientdb/config/odb3/orientdb-server-log.properties", "diffHunk": "@@ -0,0 +1,46 @@\n+#\n+# /*\n+#  *  Copyright 2014 Orient Technologies LTD (info(at)orientechnologies.com)\n+#  *\n+#  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+#  *  you may not use this file except in compliance with the License.\n+#  *  You may obtain a copy of the License at\n+#  *\n+#  *       http://www.apache.org/licenses/LICENSE-2.0\n+#  *\n+#  *  Unless required by applicable law or agreed to in writing, software\n+#  *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  *  See the License for the specific language governing permissions and\n+#  *  limitations under the License.\n+#  *\n+#  * For more information: http://www.orientechnologies.com\n+#  */\n+#\n+\n+# Specify the handlers to create in the root logger\n+# (all loggers are children of the root logger)\n+# The following creates two handlers\n+handlers = java.util.logging.ConsoleHandler, java.util.logging.FileHandler\n+\n+# Set the default logging level for the root logger\n+.level = INFO\n+com.orientechnologies.level = INFO\n+com.orientechnologies.orient.server.distributed.level = INFO\n+\n+# Set the default logging level for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.level = INFO\n+# Set the default formatter for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.formatter = com.orientechnologies.common.log.OAnsiLogFormatter\n+\n+# Set the default logging level for new FileHandler instances\n+java.util.logging.FileHandler.level = INFO\n+# Naming style for the output file\n+java.util.logging.FileHandler.pattern=../log/orient-server.log\n+# Set the default formatter for new FileHandler instances\n+java.util.logging.FileHandler.formatter = com.orientechnologies.common.log.OLogFormatter\n+# Limiting size of output file in bytes:\n+java.util.logging.FileHandler.limit=10000000\n+# Number of output files to cycle through, by appending an\n+# integer to the base file name:\n+java.util.logging.FileHandler.count=10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2MDc2NA=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjMxNzQ3OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoxMDozOVrOHP1_XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0Nzo1MFrOHRbgGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA==", "bodyText": "cookie -> meter", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486375260", "createdAt": "2020-09-10T14:10:39Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java", "diffHunk": "@@ -42,60 +44,78 @@\n public class MeterPool {\n     private final TransactionManager transactionManager;\n     private final FlowMeterRepository flowMeterRepository;\n-    private final SwitchRepository switchRepository;\n \n     private final MeterId minMeterId;\n     private final MeterId maxMeterId;\n+    private final int poolSize;\n \n-    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId) {\n+    private Map<SwitchId, MeterId> nextMeters = new HashMap<>();\n+\n+    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId, int poolSize) {\n         transactionManager = persistenceManager.getTransactionManager();\n         RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n         flowMeterRepository = repositoryFactory.createFlowMeterRepository();\n-        switchRepository = repositoryFactory.createSwitchRepository();\n \n         this.minMeterId = minMeterId;\n         this.maxMeterId = maxMeterId;\n+        this.poolSize = poolSize;\n     }\n \n     /**\n      * Allocates a meter for the flow path.\n      */\n+    @TransactionRequired\n     public MeterId allocate(SwitchId switchId, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            Switch theSwitch = switchRepository.findById(switchId)\n-                    .orElseThrow(() ->\n-                            new ResourceNotAvailableException(format(\"No switch for meter allocation: %s\", switchId)));\n-            return allocate(theSwitch, flowId, pathId);\n-        });\n-    }\n-\n-    /**\n-     * Allocates a meter for the flow path.\n-     */\n-    public MeterId allocate(Switch theSwitch, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            String noMetersErrorMessage = format(\"No meter available for switch %s\", theSwitch);\n-\n-            MeterId startMeterId = new MeterId(\n-                    ResourceUtils.computeStartValue(minMeterId.getValue(), maxMeterId.getValue()));\n-            SwitchId switchId = theSwitch.getSwitchId();\n-            MeterId availableMeterId = flowMeterRepository.findUnassignedMeterId(switchId, startMeterId, maxMeterId)\n-                    .orElse(flowMeterRepository.findUnassignedMeterId(switchId, minMeterId, maxMeterId)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(noMetersErrorMessage)));\n-            if (availableMeterId.compareTo(maxMeterId) > 0) {\n-                throw new ResourceNotAvailableException(noMetersErrorMessage);\n+        MeterId nextMeter = nextMeters.get(switchId);\n+        if (nextMeter != null && nextMeter.getValue() > 0) {\n+            if (nextMeter.compareTo(maxMeterId) <= 0 && !flowMeterRepository.exists(switchId, nextMeter)) {\n+                addMeter(flowId, pathId, switchId, nextMeter);\n+                nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                return nextMeter;\n+            } else {\n+                nextMeters.remove(switchId);\n             }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (!nextMeters.containsKey(switchId)) {\n+            long numOfPools = (maxMeterId.getValue() - minMeterId.getValue()) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<MeterId> availableMeter = flowMeterRepository.findFirstUnassignedMeter(switchId,\n+                        new MeterId(minMeterId.getValue() + poolToTake * poolSize),\n+                        new MeterId(minMeterId.getValue() + (poolToTake + 1) * poolSize - 1));\n+                if (availableMeter.isPresent()) {\n+                    nextMeter = availableMeter.get();\n+                    addMeter(flowId, pathId, switchId, nextMeter);\n+                    nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                    return nextMeter;\n+                }\n+            }\n+            // The pool requires full scan.\n+            nextMeter = new MeterId(-1);\n+            nextMeters.put(switchId, nextMeter);\n+        }\n+        if (nextMeter != null && nextMeter.getValue() == -1) {\n+            Optional<MeterId> availableCookie = flowMeterRepository.findFirstUnassignedMeter(switchId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODQyNQ==", "bodyText": "Nice catch. Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038425", "createdAt": "2020-09-14T15:47:50Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java", "diffHunk": "@@ -42,60 +44,78 @@\n public class MeterPool {\n     private final TransactionManager transactionManager;\n     private final FlowMeterRepository flowMeterRepository;\n-    private final SwitchRepository switchRepository;\n \n     private final MeterId minMeterId;\n     private final MeterId maxMeterId;\n+    private final int poolSize;\n \n-    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId) {\n+    private Map<SwitchId, MeterId> nextMeters = new HashMap<>();\n+\n+    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId, int poolSize) {\n         transactionManager = persistenceManager.getTransactionManager();\n         RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n         flowMeterRepository = repositoryFactory.createFlowMeterRepository();\n-        switchRepository = repositoryFactory.createSwitchRepository();\n \n         this.minMeterId = minMeterId;\n         this.maxMeterId = maxMeterId;\n+        this.poolSize = poolSize;\n     }\n \n     /**\n      * Allocates a meter for the flow path.\n      */\n+    @TransactionRequired\n     public MeterId allocate(SwitchId switchId, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            Switch theSwitch = switchRepository.findById(switchId)\n-                    .orElseThrow(() ->\n-                            new ResourceNotAvailableException(format(\"No switch for meter allocation: %s\", switchId)));\n-            return allocate(theSwitch, flowId, pathId);\n-        });\n-    }\n-\n-    /**\n-     * Allocates a meter for the flow path.\n-     */\n-    public MeterId allocate(Switch theSwitch, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            String noMetersErrorMessage = format(\"No meter available for switch %s\", theSwitch);\n-\n-            MeterId startMeterId = new MeterId(\n-                    ResourceUtils.computeStartValue(minMeterId.getValue(), maxMeterId.getValue()));\n-            SwitchId switchId = theSwitch.getSwitchId();\n-            MeterId availableMeterId = flowMeterRepository.findUnassignedMeterId(switchId, startMeterId, maxMeterId)\n-                    .orElse(flowMeterRepository.findUnassignedMeterId(switchId, minMeterId, maxMeterId)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(noMetersErrorMessage)));\n-            if (availableMeterId.compareTo(maxMeterId) > 0) {\n-                throw new ResourceNotAvailableException(noMetersErrorMessage);\n+        MeterId nextMeter = nextMeters.get(switchId);\n+        if (nextMeter != null && nextMeter.getValue() > 0) {\n+            if (nextMeter.compareTo(maxMeterId) <= 0 && !flowMeterRepository.exists(switchId, nextMeter)) {\n+                addMeter(flowId, pathId, switchId, nextMeter);\n+                nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                return nextMeter;\n+            } else {\n+                nextMeters.remove(switchId);\n             }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (!nextMeters.containsKey(switchId)) {\n+            long numOfPools = (maxMeterId.getValue() - minMeterId.getValue()) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<MeterId> availableMeter = flowMeterRepository.findFirstUnassignedMeter(switchId,\n+                        new MeterId(minMeterId.getValue() + poolToTake * poolSize),\n+                        new MeterId(minMeterId.getValue() + (poolToTake + 1) * poolSize - 1));\n+                if (availableMeter.isPresent()) {\n+                    nextMeter = availableMeter.get();\n+                    addMeter(flowId, pathId, switchId, nextMeter);\n+                    nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                    return nextMeter;\n+                }\n+            }\n+            // The pool requires full scan.\n+            nextMeter = new MeterId(-1);\n+            nextMeters.put(switchId, nextMeter);\n+        }\n+        if (nextMeter != null && nextMeter.getValue() == -1) {\n+            Optional<MeterId> availableCookie = flowMeterRepository.findFirstUnassignedMeter(switchId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjMyNDQ4OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoxMjowM1rOHP2Diw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0ODoyNVrOHRbhqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ==", "bodyText": "cookie -> vlan", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486376331", "createdAt": "2020-09-10T14:12:03Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java", "diffHunk": "@@ -60,27 +66,53 @@ public TransitVlanEncapsulation allocate(Flow flow, PathId pathId, PathId opposi\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private TransitVlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minTransitVlan, maxTransitVlan);\n-            int availableVlan = transitVlanRepository.findUnassignedTransitVlan(startValue, maxTransitVlan)\n-                    .orElse(transitVlanRepository.findUnassignedTransitVlan(minTransitVlan, maxTransitVlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vlan available\")));\n-            if (availableVlan > maxTransitVlan) {\n-                throw new ResourceNotAvailableException(\"No vlan available\");\n+        if (nextVlan > 0) {\n+            if (nextVlan <= maxTransitVlan && !transitVlanRepository.exists(nextVlan)) {\n+                return addVlan(flow, pathId, nextVlan++);\n+            } else {\n+                nextVlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVlan == 0) {\n+            long numOfPools = (maxTransitVlan - minTransitVlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = transitVlanRepository.findFirstUnassignedVlan(\n+                        minTransitVlan + (int) poolToTake * poolSize,\n+                        minTransitVlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVlan = availableVlan.get();\n+                    return addVlan(flow, pathId, nextVlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVlan = -1;\n+        }\n+        if (nextVlan == -1) {\n+            Optional<Integer> availableCookie = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODgyNQ==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038825", "createdAt": "2020-09-14T15:48:25Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java", "diffHunk": "@@ -60,27 +66,53 @@ public TransitVlanEncapsulation allocate(Flow flow, PathId pathId, PathId opposi\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private TransitVlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minTransitVlan, maxTransitVlan);\n-            int availableVlan = transitVlanRepository.findUnassignedTransitVlan(startValue, maxTransitVlan)\n-                    .orElse(transitVlanRepository.findUnassignedTransitVlan(minTransitVlan, maxTransitVlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vlan available\")));\n-            if (availableVlan > maxTransitVlan) {\n-                throw new ResourceNotAvailableException(\"No vlan available\");\n+        if (nextVlan > 0) {\n+            if (nextVlan <= maxTransitVlan && !transitVlanRepository.exists(nextVlan)) {\n+                return addVlan(flow, pathId, nextVlan++);\n+            } else {\n+                nextVlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVlan == 0) {\n+            long numOfPools = (maxTransitVlan - minTransitVlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = transitVlanRepository.findFirstUnassignedVlan(\n+                        minTransitVlan + (int) poolToTake * poolSize,\n+                        minTransitVlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVlan = availableVlan.get();\n+                    return addVlan(flow, pathId, nextVlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVlan = -1;\n+        }\n+        if (nextVlan == -1) {\n+            Optional<Integer> availableCookie = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjMzMTU1OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoxMzozNlrOHP2IMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0ODo1OVrOHRbjFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ==", "bodyText": "vlan -> vxlan", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377521", "createdAt": "2020-09-10T14:13:36Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTE4OQ==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488039189", "createdAt": "2020-09-14T15:48:59Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjMzMzY0OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoxNDowM1rOHP2Jjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo1OTozM1rOHRqgGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA==", "bodyText": "cookie -> vxlan", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377870", "createdAt": "2020-09-10T14:14:03Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                        minVxlan + (int) poolToTake * poolSize,\n+                        minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVxlan = availableVlan.get();\n+                    return addVxlan(flow, pathId, nextVxlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVxlan = -1;\n+        }\n+        if (nextVxlan == -1) {\n+            Optional<Integer> availableCookie = vxlanRepository.findFirstUnassignedVxlan(minVxlan,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDE4Nw==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284187", "createdAt": "2020-09-14T22:59:33Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                        minVxlan + (int) poolToTake * poolSize,\n+                        minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVxlan = availableVlan.get();\n+                    return addVxlan(flow, pathId, nextVxlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVxlan = -1;\n+        }\n+        if (nextVxlan == -1) {\n+            Optional<Integer> availableCookie = vxlanRepository.findFirstUnassignedVxlan(minVxlan,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjM2MjIxOnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoyMDowMVrOHP2bjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowMToyMFrOHRqiaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw==", "bodyText": "You can chain this calls as it is builder now.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486382477", "createdAt": "2020-09-10T14:20:01Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java", "diffHunk": "@@ -72,29 +72,29 @@ public IslInfoData map(Isl isl) {\n             return null;\n         }\n \n-        Isl isl = new Isl();\n-\n+        Isl.IslBuilder isl = Isl.builder();\n         PathNode sourcePathNode = islInfoData.getSource();\n         if (sourcePathNode != null) {\n-            isl.setSrcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n-            isl.setSrcPort(sourcePathNode.getPortNo());\n+            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n+            isl.srcPort(sourcePathNode.getPortNo());\n         }\n \n         PathNode destinationPathNode = islInfoData.getDestination();\n         if (destinationPathNode != null) {\n-            isl.setDestSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n-            isl.setDestPort(destinationPathNode.getPortNo());\n+            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n+            isl.destPort(destinationPathNode.getPortNo());\n         }\n-        isl.setLatency((int) islInfoData.getLatency());\n-        isl.setSpeed(islInfoData.getSpeed());\n-        isl.setAvailableBandwidth(islInfoData.getAvailableBandwidth());\n-        isl.setStatus(map(islInfoData.getState()));\n-        isl.setCost(islInfoData.getCost());\n-        isl.setUnderMaintenance(islInfoData.isUnderMaintenance());\n-        isl.setEnableBfd(islInfoData.isEnableBfd());\n-        isl.setBfdSessionStatus(islInfoData.getBfdSessionStatus());\n-\n-        return isl;\n+\n+        isl.latency((int) islInfoData.getLatency());\n+        isl.speed(islInfoData.getSpeed());\n+        isl.availableBandwidth(islInfoData.getAvailableBandwidth());\n+        isl.status(map(islInfoData.getState()));\n+        isl.cost(islInfoData.getCost());\n+        isl.underMaintenance(islInfoData.isUnderMaintenance());\n+        isl.enableBfd(islInfoData.isEnableBfd());\n+        isl.bfdSessionStatus(islInfoData.getBfdSessionStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDc3Ng==", "bodyText": "Make sense. Refactored.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284776", "createdAt": "2020-09-14T23:01:20Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java", "diffHunk": "@@ -72,29 +72,29 @@ public IslInfoData map(Isl isl) {\n             return null;\n         }\n \n-        Isl isl = new Isl();\n-\n+        Isl.IslBuilder isl = Isl.builder();\n         PathNode sourcePathNode = islInfoData.getSource();\n         if (sourcePathNode != null) {\n-            isl.setSrcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n-            isl.setSrcPort(sourcePathNode.getPortNo());\n+            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n+            isl.srcPort(sourcePathNode.getPortNo());\n         }\n \n         PathNode destinationPathNode = islInfoData.getDestination();\n         if (destinationPathNode != null) {\n-            isl.setDestSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n-            isl.setDestPort(destinationPathNode.getPortNo());\n+            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n+            isl.destPort(destinationPathNode.getPortNo());\n         }\n-        isl.setLatency((int) islInfoData.getLatency());\n-        isl.setSpeed(islInfoData.getSpeed());\n-        isl.setAvailableBandwidth(islInfoData.getAvailableBandwidth());\n-        isl.setStatus(map(islInfoData.getState()));\n-        isl.setCost(islInfoData.getCost());\n-        isl.setUnderMaintenance(islInfoData.isUnderMaintenance());\n-        isl.setEnableBfd(islInfoData.isEnableBfd());\n-        isl.setBfdSessionStatus(islInfoData.getBfdSessionStatus());\n-\n-        return isl;\n+\n+        isl.latency((int) islInfoData.getLatency());\n+        isl.speed(islInfoData.getSpeed());\n+        isl.availableBandwidth(islInfoData.getAvailableBandwidth());\n+        isl.status(map(islInfoData.getState()));\n+        isl.cost(islInfoData.getCost());\n+        isl.underMaintenance(islInfoData.isUnderMaintenance());\n+        isl.enableBfd(islInfoData.isEnableBfd());\n+        isl.bfdSessionStatus(islInfoData.getBfdSessionStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MjQwMDU4OnYy", "diffSide": "RIGHT", "path": "src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoyNzo0M1rOHP2zng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowMjo0NFrOHRqkGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA==", "bodyText": "vlans -> vxlans", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486388638", "createdAt": "2020-09-10T14:27:43Z", "author": {"login": "rozdy"}, "path": "src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java", "diffHunk": "@@ -53,48 +52,52 @@\n \n     @Before\n     public void setUp() {\n-        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN);\n+        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN, 1);\n         vxlanRepository = persistenceManager.getRepositoryFactory().createVxlanRepository();\n-\n-        SwitchRepository switchRepository = persistenceManager.getRepositoryFactory().createSwitchRepository();\n-        switchRepository.createOrUpdate(SWITCH_A);\n-        switchRepository.createOrUpdate(SWITCH_B);\n     }\n \n     @Test\n     public void vxlanIdPool() {\n-        Set<Integer> vxlans = new HashSet<>();\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            vxlans.add(vxlanPool.allocate(\n-                    flow,\n-                    new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n-        }\n-        assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n-        vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        transactionManager.doInTransaction(() -> {\n+            Set<Integer> vxlans = new HashSet<>();\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                vxlans.add(vxlanPool.allocate(\n+                        flow,\n+                        new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n+            }\n+            assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n+            vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        });\n     }\n \n \n     @Test(expected = ResourceNotAvailableException.class)\n     public void vxlanPoolFullTest() {\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n+            }\n+        });\n     }\n \n     @Test\n     public void deallocateVxlanTest() {\n-        vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n-        vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n-        int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n-        assertEquals(2, vxlanRepository.findAll().size());\n+        transactionManager.doInTransaction(() -> {\n+            vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n+            vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n+            int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n+            assertEquals(2, vxlanRepository.findAll().size());\n \n-        vxlanPool.deallocate(PATH_ID_1);\n-        Collection<Vxlan> transitVlans = vxlanRepository.findAll();\n-        assertEquals(1, transitVlans.size());\n-        assertEquals(vni, transitVlans.iterator().next().getVni());\n+            vxlanPool.deallocate(PATH_ID_1);\n+            Collection<Vxlan> transitVlans = vxlanRepository.findAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NTIxMQ==", "bodyText": "Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488285211", "createdAt": "2020-09-14T23:02:44Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java", "diffHunk": "@@ -53,48 +52,52 @@\n \n     @Before\n     public void setUp() {\n-        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN);\n+        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN, 1);\n         vxlanRepository = persistenceManager.getRepositoryFactory().createVxlanRepository();\n-\n-        SwitchRepository switchRepository = persistenceManager.getRepositoryFactory().createSwitchRepository();\n-        switchRepository.createOrUpdate(SWITCH_A);\n-        switchRepository.createOrUpdate(SWITCH_B);\n     }\n \n     @Test\n     public void vxlanIdPool() {\n-        Set<Integer> vxlans = new HashSet<>();\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            vxlans.add(vxlanPool.allocate(\n-                    flow,\n-                    new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n-        }\n-        assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n-        vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        transactionManager.doInTransaction(() -> {\n+            Set<Integer> vxlans = new HashSet<>();\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                vxlans.add(vxlanPool.allocate(\n+                        flow,\n+                        new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n+            }\n+            assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n+            vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        });\n     }\n \n \n     @Test(expected = ResourceNotAvailableException.class)\n     public void vxlanPoolFullTest() {\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n+            }\n+        });\n     }\n \n     @Test\n     public void deallocateVxlanTest() {\n-        vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n-        vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n-        int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n-        assertEquals(2, vxlanRepository.findAll().size());\n+        transactionManager.doInTransaction(() -> {\n+            vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n+            vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n+            int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n+            assertEquals(2, vxlanRepository.findAll().size());\n \n-        vxlanPool.deallocate(PATH_ID_1);\n-        Collection<Vxlan> transitVlans = vxlanRepository.findAll();\n-        assertEquals(1, transitVlans.size());\n-        assertEquals(vni, transitVlans.iterator().next().getVni());\n+            vxlanPool.deallocate(PATH_ID_1);\n+            Collection<Vxlan> transitVlans = vxlanRepository.findAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mjk2NzE0OnYy", "diffSide": "RIGHT", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjozMjozOVrOHP8Xxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowNjo0NlrOHRqpIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA==", "bodyText": "Why we need do detach if we already used copying constructor?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486479814", "createdAt": "2020-09-10T16:32:39Z", "author": {"login": "rozdy"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java", "diffHunk": "@@ -95,8 +95,11 @@ public SwitchOperationsService(RepositoryFactory repositoryFactory,\n      * @param switchId switch id.\n      */\n     public GetSwitchResponse getSwitch(SwitchId switchId) throws SwitchNotFoundException {\n-        return new GetSwitchResponse(\n-                switchRepository.findById(switchId).orElseThrow(() -> new SwitchNotFoundException(switchId)));\n+        Switch sw = switchRepository.findById(switchId)\n+                .map(Switch::new)\n+                .orElseThrow(() -> new SwitchNotFoundException(switchId));\n+        switchRepository.detach(sw);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjQ5OQ==", "bodyText": "Nice catch! Fixed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488286499", "createdAt": "2020-09-14T23:06:46Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java", "diffHunk": "@@ -95,8 +95,11 @@ public SwitchOperationsService(RepositoryFactory repositoryFactory,\n      * @param switchId switch id.\n      */\n     public GetSwitchResponse getSwitch(SwitchId switchId) throws SwitchNotFoundException {\n-        return new GetSwitchResponse(\n-                switchRepository.findById(switchId).orElseThrow(() -> new SwitchNotFoundException(switchId)));\n+        Switch sw = switchRepository.findById(switchId)\n+                .map(Switch::new)\n+                .orElseThrow(() -> new SwitchNotFoundException(switchId));\n+        switchRepository.detach(sw);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzAxNDI1OnYy", "diffSide": "RIGHT", "path": "src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo0NDo1NFrOHP81YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1MDo0M1rOHRbnug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw==", "bodyText": "What is sf?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486487393", "createdAt": "2020-09-10T16:44:54Z", "author": {"login": "rozdy"}, "path": "src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java", "diffHunk": "@@ -907,9 +903,7 @@ private void verifyNewSwitchAfterSwitchSync(List<SpeakerSwitchPortView> ports) {\n                 LinkStatus.of(ports.get(0).getState()));\n         verify(carrier).sendAffectedFlowRerouteRequest(alphaDatapath);\n \n-        verify(switchRepository).createOrUpdate(argThat(sw ->\n-                sw.getStatus() == SwitchStatus.INACTIVE && sw.getSwitchId() == alphaDatapath));\n-        verify(switchPropertiesRepository).createOrUpdate(argThat(sf ->\n+        verify(switchPropertiesRepository).add(argThat(sf ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDM3OA==", "bodyText": "No idea. It wasn't changed in this PR. However, I'll rename it to \"s\".", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488040378", "createdAt": "2020-09-14T15:50:43Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java", "diffHunk": "@@ -907,9 +903,7 @@ private void verifyNewSwitchAfterSwitchSync(List<SpeakerSwitchPortView> ports) {\n                 LinkStatus.of(ports.get(0).getState()));\n         verify(carrier).sendAffectedFlowRerouteRequest(alphaDatapath);\n \n-        verify(switchRepository).createOrUpdate(argThat(sw ->\n-                sw.getStatus() == SwitchStatus.INACTIVE && sw.getSwitchId() == alphaDatapath));\n-        verify(switchPropertiesRepository).createOrUpdate(argThat(sf ->\n+        verify(switchPropertiesRepository).add(argThat(sf ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzAzMTMwOnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound/src/main/resources/northbound.properties.example", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo0OToyM1rOHP8_1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1MzozOVrOHRbvuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MDA2OQ==", "bodyText": "Do we need to connect from northbound to DB?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486490069", "createdAt": "2020-09-10T16:49:23Z", "author": {"login": "rozdy"}, "path": "src-java/northbound-service/northbound/src/main/resources/northbound.properties.example", "diffHunk": "@@ -18,6 +18,6 @@ northbound.messages.expiration.minutes=15\n northbound.kafka.listener.threads=10\n northbound.kafka.session.timeout=30000\n \n-neo4j.uri = bolt://neo4j.pendev:7687\n-neo4j.user = neo4j\n-neo4j.password = temppass\n+orientdb.url = remote:odb1.pendev,odb2.pendev,odb3.pendev/kilda\n+orientdb.user = root\n+orientdb.password = root", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MjQyNw==", "bodyText": "We shouldn't. But there's a dependency on \"kilda-persistence...\" in Northbound. So we need to cleanup it, but not in this PR.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488042427", "createdAt": "2020-09-14T15:53:39Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/northbound-service/northbound/src/main/resources/northbound.properties.example", "diffHunk": "@@ -18,6 +18,6 @@ northbound.messages.expiration.minutes=15\n northbound.kafka.listener.threads=10\n northbound.kafka.session.timeout=30000\n \n-neo4j.uri = bolt://neo4j.pendev:7687\n-neo4j.user = neo4j\n-neo4j.password = temppass\n+orientdb.url = remote:odb1.pendev,odb2.pendev,odb3.pendev/kilda\n+orientdb.user = root\n+orientdb.password = root", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MDA2OQ=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzA0NDc0OnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo1MzoxMFrOHP9IcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoxMTowMlrOHRquVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg==", "bodyText": "Looks like we don't need this inheritance.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492272", "createdAt": "2020-09-10T16:53:10Z", "author": {"login": "rozdy"}, "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java", "diffHunk": "@@ -64,7 +64,7 @@\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n @TestPropertySource(\"classpath:northbound.properties\")\n-public class FlowControllerTest extends NorthboundBaseTest {\n+public class FlowControllerTest extends InMemoryGraphBasedTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NzgyOQ==", "bodyText": "Right. Removed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287829", "createdAt": "2020-09-14T23:11:02Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java", "diffHunk": "@@ -64,7 +64,7 @@\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n @TestPropertySource(\"classpath:northbound.properties\")\n-public class FlowControllerTest extends NorthboundBaseTest {\n+public class FlowControllerTest extends InMemoryGraphBasedTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzA0NjEyOnYy", "diffSide": "RIGHT", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo1MzoyNlrOHP9JQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoxMTowOVrOHRquiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ==", "bodyText": "And here.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492481", "createdAt": "2020-09-10T16:53:26Z", "author": {"login": "rozdy"}, "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java", "diffHunk": "@@ -53,7 +53,7 @@\n @RunWith(SpringJUnit4ClassRunner.class)\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n-public class SwitchControllerTest extends NorthboundBaseTest {\n+public class SwitchControllerTest extends InMemoryGraphBasedTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Nzg4MA==", "bodyText": "Right. Removed.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287880", "createdAt": "2020-09-14T23:11:09Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java", "diffHunk": "@@ -53,7 +53,7 @@\n @RunWith(SpringJUnit4ClassRunner.class)\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n-public class SwitchControllerTest extends NorthboundBaseTest {\n+public class SwitchControllerTest extends InMemoryGraphBasedTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzA4NTUzOnYy", "diffSide": "RIGHT", "path": "src-java/testing/performance-tests/kilda.properties.example", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNzowMzo0M1rOHP9h7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowNzoyMlrOHRqp4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5ODc5Ng==", "bodyText": "Is it intended change?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486498796", "createdAt": "2020-09-10T17:03:43Z", "author": {"login": "rozdy"}, "path": "src-java/testing/performance-tests/kilda.properties.example", "diffHunk": "@@ -68,7 +68,7 @@ grpc.remote.log.server.ip=1.1.1.1\n grpc.remote.log.server.port=321\n \n use.hs=true\n-use.multitable=true\n+use.multitable=false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjY4OQ==", "bodyText": "Reverted.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488286689", "createdAt": "2020-09-14T23:07:22Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/testing/performance-tests/kilda.properties.example", "diffHunk": "@@ -68,7 +68,7 @@ grpc.remote.log.server.ip=1.1.1.1\n grpc.remote.log.server.port=321\n \n use.hs=true\n-use.multitable=true\n+use.multitable=false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5ODc5Ng=="}, "originalCommit": {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTE3NjQxOnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/StormLcmSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwOToyODoxNlrOHUFUsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjo0MDo1NlrOHbSs2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgyMDc4Ng==", "bodyText": "Why ignoring 'features'? You may be masking a real problem here. We had a defect related to 'features' inconsistency in database switch objects after restarting topologies (related to mfl patch), but it should be fixed in the latest develop", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r490820786", "createdAt": "2020-09-18T09:28:16Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/StormLcmSpec.groovy", "diffHunk": "@@ -67,8 +67,8 @@ class StormLcmSpec extends HealthCheckSpecification {\n         then: \"Database nodes and relations are unchanged\"\n         def newRelation = database.dumpAllRelations()\n         def newSwitches = database.dumpAllSwitches()\n-        expect newSwitches, sameBeanAs(switchesDump)\n-        expect newRelation, sameBeanAs(relationsDump).ignoring(\"time_modify\").ignoring(\"latency\")\n+        expect newSwitches, sameBeanAs(switchesDump).ignoring(\"data.timeModify\").ignoring(\"data.features\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c75729c529676f470cd51a0b1302b8d3d63809f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3OTk5Mw==", "bodyText": "Good catch. No need to ignore the features. I removed it.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498379993", "createdAt": "2020-10-01T16:40:56Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/StormLcmSpec.groovy", "diffHunk": "@@ -67,8 +67,8 @@ class StormLcmSpec extends HealthCheckSpecification {\n         then: \"Database nodes and relations are unchanged\"\n         def newRelation = database.dumpAllRelations()\n         def newSwitches = database.dumpAllSwitches()\n-        expect newSwitches, sameBeanAs(switchesDump)\n-        expect newRelation, sameBeanAs(relationsDump).ignoring(\"time_modify\").ignoring(\"latency\")\n+        expect newSwitches, sameBeanAs(switchesDump).ignoring(\"data.timeModify\").ignoring(\"data.features\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgyMDc4Ng=="}, "originalCommit": {"oid": "5c75729c529676f470cd51a0b1302b8d3d63809f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDkxMTE0OnYy", "diffSide": "LEFT", "path": "src-java/connecteddevices-topology/connecteddevices-storm-topology/src/main/java/org/openkilda/wfm/topology/connecteddevices/service/PacketService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxNjozNVrOHbbGpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwODoyMjowNFrOHblE9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA==", "bodyText": "I'm not very familiar with new DB but how it should work? After changing local Instance of device it will be saved in DB automatically?", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498517670", "createdAt": "2020-10-01T21:16:35Z", "author": {"login": "niksv"}, "path": "src-java/connecteddevices-topology/connecteddevices-storm-topology/src/main/java/org/openkilda/wfm/topology/connecteddevices/service/PacketService.java", "diffHunk": "@@ -97,8 +97,6 @@ public void handleLldpData(LldpInfoData data) {\n             device.setTimeLastSeen(Instant.ofEpochMilli(data.getTimestamp()));\n             device.setFlowId(flowRelatedData.flowId);\n             device.setSource(flowRelatedData.source);\n-\n-            switchConnectedDeviceRepository.createOrUpdate(device);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4MTA3OQ==", "bodyText": "The implementation relies on the concept of persistence context (persistence-layer). When the entity instance is in the persistent state, all changes that you make to this instance will be applied to the corresponding storage records upon committing of the transaction or closing the persistence context. This means that you don't have to call save, update or other repository methods to get these changes to the storage.\nThe same approach is used in JPA, Hibernate and many other solutions.", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498681079", "createdAt": "2020-10-02T08:22:04Z", "author": {"login": "sergii-iakovenko"}, "path": "src-java/connecteddevices-topology/connecteddevices-storm-topology/src/main/java/org/openkilda/wfm/topology/connecteddevices/service/PacketService.java", "diffHunk": "@@ -97,8 +97,6 @@ public void handleLldpData(LldpInfoData data) {\n             device.setTimeLastSeen(Instant.ofEpochMilli(data.getTimestamp()));\n             device.setFlowId(flowRelatedData.flowId);\n             device.setSource(flowRelatedData.source);\n-\n-            switchConnectedDeviceRepository.createOrUpdate(device);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA=="}, "originalCommit": {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDkzMzM0OnYy", "diffSide": "RIGHT", "path": "docker/orientdb/init/create-db-with-schema.osql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToyNjowN1rOHbbVBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwODoyOToxMVrOHblS5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTM1MA==", "bodyText": "Why we do not have a unique index for field group? like for flow_meter:\nCREATE INDEX flow_meter_unique on flow_meter (switch_id, meter_id) UNIQUE;\nPreviously it was something like\nprivate void calculateUniqueIndex() {\n        switch (type) {\n            case LLDP:\n                uniqueIndex = format(\"%s_%s_%s_%s_%s_%s_%s\",\n                        switchObj.getSwitchId(), portNumber, vlan, macAddress, type, chassisId, portId);\n                break;\n            case ARP:\n                uniqueIndex = format(\"%s_%s_%s_%s_%s_%s\",\n                        switchObj.getSwitchId(), portNumber, vlan, macAddress, type, ipAddress);\n                break;\n            default:\n                throw new IllegalArgumentException(format(\"Unknown connected device type %s\", type));\n        }\n    }", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498521350", "createdAt": "2020-10-01T21:26:07Z", "author": {"login": "niksv"}, "path": "docker/orientdb/init/create-db-with-schema.osql", "diffHunk": "@@ -0,0 +1,232 @@\n+CREATE DATABASE remote:localhost/kilda root root PLOCAL GRAPH;\n+\n+CREATE CLASS kilda_configuration IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY kilda_configuration.unique IF NOT EXISTS STRING;\n+CREATE INDEX kilda_configuration.unique UNIQUE_HASH_INDEX;\n+\n+CREATE CLASS feature_toggles IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY feature_toggles.unique IF NOT EXISTS STRING;\n+CREATE INDEX feature_toggles.unique UNIQUE_HASH_INDEX;\n+\n+CREATE CLASS switch IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY switch.name IF NOT EXISTS STRING;\n+CREATE PROPERTY switch.state IF NOT EXISTS STRING;\n+CREATE PROPERTY switch.features IF NOT EXISTS EMBEDDEDSET STRING;\n+CREATE INDEX switch.name UNIQUE_HASH_INDEX;\n+CREATE INDEX switch.state NOTUNIQUE_HASH_INDEX;\n+\n+CREATE CLASS switch_connected_device IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY switch_connected_device.flow_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.switch_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.port_number IF NOT EXISTS INTEGER;\n+CREATE PROPERTY switch_connected_device.vlan IF NOT EXISTS INTEGER;\n+CREATE PROPERTY switch_connected_device.mac_address IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.type IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.chassis_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.port_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.ip_address IF NOT EXISTS STRING;\n+CREATE INDEX switch_connected_device.flow_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.switch_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.port_number NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.vlan NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.mac_address NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.type NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.chassis_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.port_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.ip_address NOTUNIQUE_HASH_INDEX;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4NDY0Nw==", "bodyText": "Agree. The index should be re-introduced. The issue has been reported - #3760", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498684647", "createdAt": "2020-10-02T08:29:11Z", "author": {"login": "sergii-iakovenko"}, "path": "docker/orientdb/init/create-db-with-schema.osql", "diffHunk": "@@ -0,0 +1,232 @@\n+CREATE DATABASE remote:localhost/kilda root root PLOCAL GRAPH;\n+\n+CREATE CLASS kilda_configuration IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY kilda_configuration.unique IF NOT EXISTS STRING;\n+CREATE INDEX kilda_configuration.unique UNIQUE_HASH_INDEX;\n+\n+CREATE CLASS feature_toggles IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY feature_toggles.unique IF NOT EXISTS STRING;\n+CREATE INDEX feature_toggles.unique UNIQUE_HASH_INDEX;\n+\n+CREATE CLASS switch IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY switch.name IF NOT EXISTS STRING;\n+CREATE PROPERTY switch.state IF NOT EXISTS STRING;\n+CREATE PROPERTY switch.features IF NOT EXISTS EMBEDDEDSET STRING;\n+CREATE INDEX switch.name UNIQUE_HASH_INDEX;\n+CREATE INDEX switch.state NOTUNIQUE_HASH_INDEX;\n+\n+CREATE CLASS switch_connected_device IF NOT EXISTS EXTENDS V;\n+CREATE PROPERTY switch_connected_device.flow_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.switch_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.port_number IF NOT EXISTS INTEGER;\n+CREATE PROPERTY switch_connected_device.vlan IF NOT EXISTS INTEGER;\n+CREATE PROPERTY switch_connected_device.mac_address IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.type IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.chassis_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.port_id IF NOT EXISTS STRING;\n+CREATE PROPERTY switch_connected_device.ip_address IF NOT EXISTS STRING;\n+CREATE INDEX switch_connected_device.flow_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.switch_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.port_number NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.vlan NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.mac_address NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.type NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.chassis_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.port_id NOTUNIQUE_HASH_INDEX;\n+CREATE INDEX switch_connected_device.ip_address NOTUNIQUE_HASH_INDEX;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTM1MA=="}, "originalCommit": {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1842, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}