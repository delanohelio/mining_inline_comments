{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NTc0MTcw", "number": 3889, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOFCzU2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOFCzU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDgyMzk0OnYy", "diffSide": "RIGHT", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOICI5CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo0NDoyMlrOICI5CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMzczNw==", "bodyText": "Tbh I still don't understand the point of this feature. Flow loop rule will be exactly the same as the actual flow rule", "url": "https://github.com/telstra/open-kilda/pull/3889#discussion_r539113737", "createdAt": "2020-12-09T08:44:22Z", "author": {"login": "rtretyak"}, "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -523,6 +523,108 @@ class FlowLoopSpec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        and: \"The switch is valid\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(sw.dpId).size() == 2\n+            northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are deleted from the switch\"\n+        assert getFlowLoopRules(sw.dpId).empty\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2338, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}