{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0Njc2MzQx", "number": 697, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjoxNjozMlrODfba2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMToyOTowMFrODgghBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MjgxNjg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/Requester.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjoxNjozMlrOFpIITw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNjoxNjozMlrOFpIITw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2OTEzNQ==", "bodyText": "This is the really the summary of this change - a refactoring from GitHub and Requester being monolithic centers of work to having the work split between GitHubClient, GitHubRequest, GitHubRequest.Builder, GitHubResponse, GitHubResponse.ResponseInfo, and various *Iterables and *Iterators.  Requester still remains as a thin helper and GitHub is still large but is mostly customer facing methods with GitHubClient handling internals.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r378669135", "createdAt": "2020-02-13T06:16:32Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/Requester.java", "diffHunk": "@@ -23,368 +23,24 @@\n  */\n package org.kohsuke.github;\n \n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import org.apache.commons.io.IOUtils;\n-import org.apache.commons.lang3.StringUtils;\n-\n-import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.InterruptedIOException;\n-import java.io.Reader;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.net.HttpURLConnection;\n-import java.net.MalformedURLException;\n-import java.net.ProtocolException;\n-import java.net.SocketException;\n-import java.net.SocketTimeoutException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n import java.util.function.Consumer;\n-import java.util.logging.Logger;\n-import java.util.zip.GZIPInputStream;\n \n-import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n-import javax.annotation.WillClose;\n-import javax.net.ssl.SSLHandshakeException;\n-\n-import static java.util.Arrays.asList;\n-import static java.util.logging.Level.*;\n-import static org.apache.commons.lang3.StringUtils.defaultString;\n-import static org.kohsuke.github.GitHub.MAPPER;\n-import static org.kohsuke.github.GitHub.connect;\n \n /**\n- * A builder pattern for making HTTP call and parsing its output.\n+ * A thin helper for {@link GitHubRequest.Builder} that includes {@link GitHubClient}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "759121541d2d91285b1cf8083ed57444a16fb424"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzAyMTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHub.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzo1ODo1MFrOFpKBBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzo1ODo1MFrOFpKBBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwMDAzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                GHMyself getMyself() throws IOException {\n          \n          \n            \n                public GHMyself getMyself() throws IOException {", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r378700039", "createdAt": "2020-02-13T07:58:50Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHub.java", "diffHunk": "@@ -535,17 +403,21 @@ public GHRateLimit rateLimit() throws IOException {\n      *             the io exception\n      */\n     @WithBridgeMethods(GHUser.class)\n-    public GHMyself getMyself() throws IOException {\n-        requireCredential();\n+    GHMyself getMyself() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c6959cb4afe1838ef8c3540d3eb54858d4fd7cc"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTI1NTA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMDozNTowNFrOFqVKuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNDoyNToyOFrOFqYL9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMTMyMw==", "bodyText": "Is there a circumstance where tailApiUrl will not start with a \"/\"? I didn't see any tests in GitHubConnectionTest that behave this way, so just wondering how we'd run up against this, and what it looks like when we do.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379931323", "createdAt": "2020-02-16T20:35:04Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4MDc5MQ==", "bodyText": "Good question.  There are a small number of cases where the API returns a URL that is then used for other things.\nhttps://github.com/github-api/github-api/pull/697/files#diff-64dfb4dfbe21520e8735454a113c45a7R548-R560\nhttps://github.com/github-api/github-api/blob/ff3136df7069d22d937daa8f2cddc357c777e07e/src/main/java/org/kohsuke/github/GHContent.java#L225-L227\nhttps://github.com/github-api/github-api/blob/ff3136df7069d22d937daa8f2cddc357c777e07e/src/main/java/org/kohsuke/github/GHContent.java#L236-L240\nAlso, for paginated result, the full url for the next page is provided in the Link header , so when we call getApiURL we want to use that url, whatever it happens to be.\nhttps://github.com/github-api/github-api/blob/dc33e28452532b94c6d46e435c192ae043849ca9/src/main/java/org/kohsuke/github/GitHubPageResponseIterator.java#L68-L77\nI don't love this lack of clarity, but I didn't feel confident that I had tests for all cases where that URL didn't start with /, so I've kept the behavior where this method just handles it.  That said, I should change L77 to use setRawUrl.  Thanks!", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379980791", "createdAt": "2020-02-17T04:25:28Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMTMyMw=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTI2NDQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMDo1Mzo1MVrOFqVPhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNDo1ODo0MFrOFqYhFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjU0OQ==", "bodyText": "Comments like this are super helpful. :)\nAre there other places where we might need to do such a conversion? I only see one instance of replace('_', '-') in the whole plugin. Might be fine, it just surprised me that there aren't more.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379932549", "createdAt": "2020-02-16T20:53:51Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4MjU1OA==", "bodyText": "The other places are mostly done automatically by Jackson.\nhttps://github.com/github-api/github-api/pull/697/files#diff-04099021093ec34af9d55a855cc1e6fdR85-R90\nHm, the toLowerCase may not be needed due to line 88.  And line 89 means that, given a field like create_date, Jackson will automatically look for a field with the name createdDate and then fall back to create_date if it doesn't find one.\nHowever, this setting was only added recently, there are still a lot private fields with underscores in them.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379982558", "createdAt": "2020-02-17T04:37:11Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjU0OQ=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4NjE5OA==", "bodyText": "Opened #700 to clean this up.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379986198", "createdAt": "2020-02-17T04:58:40Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjU0OQ=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTI2Njk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMDo1ODozNlrOFqVQ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNDo0NTo1MFrOFqYYWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjg4MA==", "bodyText": "This is a somewhat arbitrary place for me to put this question, but it's as good as any. There are a lot of with(thing, thing) methods here with different parameters. Why is that? I mean, I'm sure there's a perfectly good reason for it, I just am having trouble putting it together on my own.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379932880", "createdAt": "2020-02-16T20:58:36Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');\n+    }\n+\n+    /**\n+     * The method for this request, such as \"GET\", \"PATCH\", or \"DELETE\".\n+     *\n+     * @return the request method.\n+     */\n+    @Nonnull\n+    public String method() {\n+        return method;\n+    }\n+\n+    /**\n+     * The arguments for this request. Depending on the {@link #method()} and {@code #inBody()} these maybe added to the\n+     * url or to the request body.\n+     *\n+     * @return the {@link List<Entry>} of arguments\n+     */\n+    @Nonnull\n+    public List<Entry> args() {\n+        return args;\n+    }\n+\n+    /**\n+     * The headers for this request.\n+     *\n+     * @return the {@link Map} of headers\n+     */\n+    @Nonnull\n+    public Map<String, String> headers() {\n+        return headers;\n+    }\n+\n+    /**\n+     * The base GitHub API URL for this request represented as a {@link String}\n+     * \n+     * @return the url string\n+     */\n+    @Nonnull\n+    public String apiUrl() {\n+        return apiUrl;\n+    }\n+\n+    /**\n+     * The url path to be added to the {@link #apiUrl()} for this request. If this does not start with a \"/\", it instead\n+     * represents the full url string for this request.\n+     * \n+     * @return a url path or full url string\n+     */\n+    @Nonnull\n+    public String urlPath() {\n+        return urlPath;\n+    }\n+\n+    /**\n+     * The content type to to be sent by this request.\n+     * \n+     * @return the content type.\n+     */\n+    @Nonnull\n+    public String contentType() {\n+        return headers.get(\"Content-type\");\n+    }\n+\n+    /**\n+     * The {@link InputStream} to be sent as the body of this request.\n+     * \n+     * @return the {@link InputStream}.\n+     */\n+    @CheckForNull\n+    public InputStream body() {\n+        return body;\n+    }\n+\n+    /**\n+     * The {@link URL} for this request. This is the actual URL the {@link GitHubClient} will send this request to.\n+     * \n+     * @return the request {@link URL}\n+     */\n+    @Nonnull\n+    public URL url() {\n+        return url;\n+    }\n+\n+    /**\n+     * Whether arguments for this request should be included in the URL or in the body of the request.\n+     * \n+     * @return true if the arguements should be sent in the body of the request.\n+     */\n+    public boolean inBody() {\n+        return forceBody || !METHODS_WITHOUT_BODY.contains(method);\n+    }\n+\n+    /**\n+     * Create a {@link Builder} from this request. Initial values of the builder will be the same as this\n+     * {@link GitHubRequest}.\n+     * \n+     * @return a {@link Builder} based on this request.\n+     */\n+    public Builder<?> toBuilder() {\n+        return new Builder<>(args, headers, apiUrl, urlPath, method, body, forceBody);\n+    }\n+\n+    private String buildTailApiUrl() {\n+        String tailApiUrl = urlPath;\n+        if (!inBody() && !args.isEmpty() && tailApiUrl.startsWith(\"/\")) {\n+            try {\n+                StringBuilder argString = new StringBuilder();\n+                boolean questionMarkFound = tailApiUrl.indexOf('?') != -1;\n+                argString.append(questionMarkFound ? '&' : '?');\n+\n+                for (Iterator<Entry> it = args.listIterator(); it.hasNext();) {\n+                    Entry arg = it.next();\n+                    argString.append(URLEncoder.encode(arg.key, StandardCharsets.UTF_8.name()));\n+                    argString.append('=');\n+                    argString.append(URLEncoder.encode(arg.value.toString(), StandardCharsets.UTF_8.name()));\n+                    if (it.hasNext()) {\n+                        argString.append('&');\n+                    }\n+                }\n+                tailApiUrl += argString;\n+            } catch (UnsupportedEncodingException e) {\n+                throw new GHException(\"UTF-8 encoding required\", e);\n+            }\n+        }\n+        return tailApiUrl;\n+    }\n+\n+    /**\n+     * Class {@link Builder} follows the builder pattern for {@link GitHubRequest}.\n+     *\n+     * @param <B>\n+     *            The type of {@link Builder} to return from the various \"with*\" methods.\n+     */\n+    static class Builder<B extends Builder<B>> {\n+\n+        @Nonnull\n+        private final List<Entry> args;\n+\n+        /**\n+         * The header values for this request.\n+         */\n+        @Nonnull\n+        private final Map<String, String> headers;\n+\n+        /**\n+         * The base GitHub API for this request.\n+         */\n+        @Nonnull\n+        private String apiUrl;\n+\n+        @Nonnull\n+        private String urlPath;\n+        /**\n+         * Request method.\n+         */\n+        @Nonnull\n+        private String method;\n+        private InputStream body;\n+        private boolean forceBody;\n+\n+        /**\n+         * Create a new {@link GitHubRequest.Builder}\n+         */\n+        protected Builder() {\n+            this(new ArrayList<>(), new LinkedHashMap<>(), GitHubClient.GITHUB_URL, \"/\", \"GET\", null, false);\n+        }\n+\n+        private Builder(@Nonnull List<Entry> args,\n+                @Nonnull Map<String, String> headers,\n+                @Nonnull String apiUrl,\n+                @Nonnull String urlPath,\n+                @Nonnull String method,\n+                @CheckForNull @WillClose InputStream body,\n+                boolean forceBody) {\n+            this.args = new ArrayList<>(args);\n+            this.headers = new LinkedHashMap<>(headers);\n+            this.apiUrl = apiUrl;\n+            this.urlPath = urlPath;\n+            this.method = method;\n+            this.body = body;\n+            this.forceBody = forceBody;\n+        }\n+\n+        /**\n+         * Builds a {@link GitHubRequest} from this builder.\n+         * \n+         * @return a {@link GitHubRequest}\n+         * @throws MalformedURLException\n+         *             if the GitHub API URL cannot be constructed\n+         */\n+        public GitHubRequest build() throws MalformedURLException {\n+            return new GitHubRequest(args, headers, apiUrl, urlPath, method, body, forceBody);\n+        }\n+\n+        /**\n+         * Creates {@link PagedIterable <R>} from this builder using the provided {@link Consumer<R>}. This method and\n+         * the {@link PagedIterable <R>} do not actually begin fetching data until {@link Iterator#next()} or\n+         * {@link Iterator#hasNext()} are called.\n+         *\n+         * @param client\n+         *            the {@link GitHubClient} to be used for this {@link PagedIterable<R>}\n+         * @param type\n+         *            the type of the pages to retrieve.\n+         * @param itemInitializer\n+         *            the consumer to execute on each paged item retrieved.\n+         * @param <R>\n+         *            the element type for the pages returned from\n+         * @return the {@link PagedIterable} for this builder.\n+         */\n+        public <R> PagedIterable<R> toIterable(GitHubClient client, Class<R[]> type, Consumer<R> itemInitializer) {\n+            try {\n+                return new GitHubPageContentsIterable<>(client, build(), type, itemInitializer);\n+            } catch (MalformedURLException e) {\n+                throw new GHException(e.getMessage(), e);\n+            }\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param url\n+         *            the url\n+         * @return the request builder\n+         */\n+        public B withApiUrl(String url) {\n+            this.apiUrl = url;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * Sets the request HTTP header.\n+         * <p>\n+         * If a header of the same name is already set, this method overrides it.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         */\n+        public void setHeader(String name, String value) {\n+            headers.put(name, value);\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withHeader(String name, String value) {\n+            setHeader(name, value);\n+            return (B) this;\n+        }\n+\n+        public B withPreview(String name) {\n+            return withHeader(\"Accept\", name);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, int value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, long value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, boolean value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param e\n+         *            the e\n+         * @return the request builder\n+         */\n+        public B with(String key, Enum<?> e) {\n+            if (e == null)\n+                return with(key, (Object) null);\n+            return with(key, transformEnum(e));\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, String value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Collection<?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Map<?, ?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param body\n+         *            the body\n+         * @return the request builder\n+         */\n+        public B with(@WillClose /* later */ InputStream body) {\n+            this.body = body;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With nullable requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withNullable(String key, Object value) {\n+            args.add(new Entry(key, value));\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Object value) {\n+            if (value != null) {\n+                args.add(new Entry(key, value));\n+            }\n+            return (B) this;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 503}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3Nzg2OA==", "bodyText": "I'm not sure.  These were here when I arrived.  I'm not sure it they are still all needed, per se.  I think I tried to remove them at one point and started getting errors ... but I don't remember now.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379977868", "createdAt": "2020-02-17T04:06:14Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');\n+    }\n+\n+    /**\n+     * The method for this request, such as \"GET\", \"PATCH\", or \"DELETE\".\n+     *\n+     * @return the request method.\n+     */\n+    @Nonnull\n+    public String method() {\n+        return method;\n+    }\n+\n+    /**\n+     * The arguments for this request. Depending on the {@link #method()} and {@code #inBody()} these maybe added to the\n+     * url or to the request body.\n+     *\n+     * @return the {@link List<Entry>} of arguments\n+     */\n+    @Nonnull\n+    public List<Entry> args() {\n+        return args;\n+    }\n+\n+    /**\n+     * The headers for this request.\n+     *\n+     * @return the {@link Map} of headers\n+     */\n+    @Nonnull\n+    public Map<String, String> headers() {\n+        return headers;\n+    }\n+\n+    /**\n+     * The base GitHub API URL for this request represented as a {@link String}\n+     * \n+     * @return the url string\n+     */\n+    @Nonnull\n+    public String apiUrl() {\n+        return apiUrl;\n+    }\n+\n+    /**\n+     * The url path to be added to the {@link #apiUrl()} for this request. If this does not start with a \"/\", it instead\n+     * represents the full url string for this request.\n+     * \n+     * @return a url path or full url string\n+     */\n+    @Nonnull\n+    public String urlPath() {\n+        return urlPath;\n+    }\n+\n+    /**\n+     * The content type to to be sent by this request.\n+     * \n+     * @return the content type.\n+     */\n+    @Nonnull\n+    public String contentType() {\n+        return headers.get(\"Content-type\");\n+    }\n+\n+    /**\n+     * The {@link InputStream} to be sent as the body of this request.\n+     * \n+     * @return the {@link InputStream}.\n+     */\n+    @CheckForNull\n+    public InputStream body() {\n+        return body;\n+    }\n+\n+    /**\n+     * The {@link URL} for this request. This is the actual URL the {@link GitHubClient} will send this request to.\n+     * \n+     * @return the request {@link URL}\n+     */\n+    @Nonnull\n+    public URL url() {\n+        return url;\n+    }\n+\n+    /**\n+     * Whether arguments for this request should be included in the URL or in the body of the request.\n+     * \n+     * @return true if the arguements should be sent in the body of the request.\n+     */\n+    public boolean inBody() {\n+        return forceBody || !METHODS_WITHOUT_BODY.contains(method);\n+    }\n+\n+    /**\n+     * Create a {@link Builder} from this request. Initial values of the builder will be the same as this\n+     * {@link GitHubRequest}.\n+     * \n+     * @return a {@link Builder} based on this request.\n+     */\n+    public Builder<?> toBuilder() {\n+        return new Builder<>(args, headers, apiUrl, urlPath, method, body, forceBody);\n+    }\n+\n+    private String buildTailApiUrl() {\n+        String tailApiUrl = urlPath;\n+        if (!inBody() && !args.isEmpty() && tailApiUrl.startsWith(\"/\")) {\n+            try {\n+                StringBuilder argString = new StringBuilder();\n+                boolean questionMarkFound = tailApiUrl.indexOf('?') != -1;\n+                argString.append(questionMarkFound ? '&' : '?');\n+\n+                for (Iterator<Entry> it = args.listIterator(); it.hasNext();) {\n+                    Entry arg = it.next();\n+                    argString.append(URLEncoder.encode(arg.key, StandardCharsets.UTF_8.name()));\n+                    argString.append('=');\n+                    argString.append(URLEncoder.encode(arg.value.toString(), StandardCharsets.UTF_8.name()));\n+                    if (it.hasNext()) {\n+                        argString.append('&');\n+                    }\n+                }\n+                tailApiUrl += argString;\n+            } catch (UnsupportedEncodingException e) {\n+                throw new GHException(\"UTF-8 encoding required\", e);\n+            }\n+        }\n+        return tailApiUrl;\n+    }\n+\n+    /**\n+     * Class {@link Builder} follows the builder pattern for {@link GitHubRequest}.\n+     *\n+     * @param <B>\n+     *            The type of {@link Builder} to return from the various \"with*\" methods.\n+     */\n+    static class Builder<B extends Builder<B>> {\n+\n+        @Nonnull\n+        private final List<Entry> args;\n+\n+        /**\n+         * The header values for this request.\n+         */\n+        @Nonnull\n+        private final Map<String, String> headers;\n+\n+        /**\n+         * The base GitHub API for this request.\n+         */\n+        @Nonnull\n+        private String apiUrl;\n+\n+        @Nonnull\n+        private String urlPath;\n+        /**\n+         * Request method.\n+         */\n+        @Nonnull\n+        private String method;\n+        private InputStream body;\n+        private boolean forceBody;\n+\n+        /**\n+         * Create a new {@link GitHubRequest.Builder}\n+         */\n+        protected Builder() {\n+            this(new ArrayList<>(), new LinkedHashMap<>(), GitHubClient.GITHUB_URL, \"/\", \"GET\", null, false);\n+        }\n+\n+        private Builder(@Nonnull List<Entry> args,\n+                @Nonnull Map<String, String> headers,\n+                @Nonnull String apiUrl,\n+                @Nonnull String urlPath,\n+                @Nonnull String method,\n+                @CheckForNull @WillClose InputStream body,\n+                boolean forceBody) {\n+            this.args = new ArrayList<>(args);\n+            this.headers = new LinkedHashMap<>(headers);\n+            this.apiUrl = apiUrl;\n+            this.urlPath = urlPath;\n+            this.method = method;\n+            this.body = body;\n+            this.forceBody = forceBody;\n+        }\n+\n+        /**\n+         * Builds a {@link GitHubRequest} from this builder.\n+         * \n+         * @return a {@link GitHubRequest}\n+         * @throws MalformedURLException\n+         *             if the GitHub API URL cannot be constructed\n+         */\n+        public GitHubRequest build() throws MalformedURLException {\n+            return new GitHubRequest(args, headers, apiUrl, urlPath, method, body, forceBody);\n+        }\n+\n+        /**\n+         * Creates {@link PagedIterable <R>} from this builder using the provided {@link Consumer<R>}. This method and\n+         * the {@link PagedIterable <R>} do not actually begin fetching data until {@link Iterator#next()} or\n+         * {@link Iterator#hasNext()} are called.\n+         *\n+         * @param client\n+         *            the {@link GitHubClient} to be used for this {@link PagedIterable<R>}\n+         * @param type\n+         *            the type of the pages to retrieve.\n+         * @param itemInitializer\n+         *            the consumer to execute on each paged item retrieved.\n+         * @param <R>\n+         *            the element type for the pages returned from\n+         * @return the {@link PagedIterable} for this builder.\n+         */\n+        public <R> PagedIterable<R> toIterable(GitHubClient client, Class<R[]> type, Consumer<R> itemInitializer) {\n+            try {\n+                return new GitHubPageContentsIterable<>(client, build(), type, itemInitializer);\n+            } catch (MalformedURLException e) {\n+                throw new GHException(e.getMessage(), e);\n+            }\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param url\n+         *            the url\n+         * @return the request builder\n+         */\n+        public B withApiUrl(String url) {\n+            this.apiUrl = url;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * Sets the request HTTP header.\n+         * <p>\n+         * If a header of the same name is already set, this method overrides it.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         */\n+        public void setHeader(String name, String value) {\n+            headers.put(name, value);\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withHeader(String name, String value) {\n+            setHeader(name, value);\n+            return (B) this;\n+        }\n+\n+        public B withPreview(String name) {\n+            return withHeader(\"Accept\", name);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, int value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, long value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, boolean value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param e\n+         *            the e\n+         * @return the request builder\n+         */\n+        public B with(String key, Enum<?> e) {\n+            if (e == null)\n+                return with(key, (Object) null);\n+            return with(key, transformEnum(e));\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, String value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Collection<?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Map<?, ?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param body\n+         *            the body\n+         * @return the request builder\n+         */\n+        public B with(@WillClose /* later */ InputStream body) {\n+            this.body = body;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With nullable requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withNullable(String key, Object value) {\n+            args.add(new Entry(key, value));\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Object value) {\n+            if (value != null) {\n+                args.add(new Entry(key, value));\n+            }\n+            return (B) this;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjg4MA=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 503}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk4Mzk2MQ==", "bodyText": "Opened #699 to come back to this.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379983961", "createdAt": "2020-02-17T04:45:50Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRequest.java", "diffHunk": "@@ -0,0 +1,651 @@\n+package org.kohsuke.github;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.WillClose;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Class {@link GitHubRequest} represents an immutable instance used by the client to determine what information to\n+ * retrieve from a GitHub server. Use the {@link Builder} construct a {@link GitHubRequest}.\n+ * <p>\n+ * NOTE: {@link GitHubRequest} should include the data type to be returned. Any use cases where the same request should\n+ * be used to return different types of data could be handled in some other way. However, the return type is currently\n+ * not specified until late in the building process, so this is still untyped.\n+ * </p>\n+ */\n+class GitHubRequest {\n+\n+    private static final List<String> METHODS_WITHOUT_BODY = asList(\"GET\", \"DELETE\");\n+    private final List<Entry> args;\n+    private final Map<String, String> headers;\n+    private final String apiUrl;\n+    private final String urlPath;\n+    private final String method;\n+    private final InputStream body;\n+    private final boolean forceBody;\n+\n+    private final URL url;\n+\n+    private GitHubRequest(@Nonnull List<Entry> args,\n+            @Nonnull Map<String, String> headers,\n+            @Nonnull String apiUrl,\n+            @Nonnull String urlPath,\n+            @Nonnull String method,\n+            @CheckForNull InputStream body,\n+            boolean forceBody) throws MalformedURLException {\n+        this.args = Collections.unmodifiableList(new ArrayList<>(args));\n+        this.headers = Collections.unmodifiableMap(new LinkedHashMap<>(headers));\n+        this.apiUrl = apiUrl;\n+        this.urlPath = urlPath;\n+        this.method = method;\n+        this.body = body;\n+        this.forceBody = forceBody;\n+        String tailApiUrl = buildTailApiUrl();\n+        url = getApiURL(apiUrl, tailApiUrl);\n+    }\n+\n+    /**\n+     * Create a new {@link Builder}.\n+     * \n+     * @return a new {@link Builder}.\n+     */\n+    public static Builder<?> newBuilder() {\n+        return new Builder<>();\n+    }\n+\n+    /**\n+     * Gets the final GitHub API URL.\n+     */\n+    @Nonnull\n+    static URL getApiURL(String apiUrl, String tailApiUrl) throws MalformedURLException {\n+        if (tailApiUrl.startsWith(\"/\")) {\n+            if (\"github.com\".equals(apiUrl)) {// backward compatibility\n+                return new URL(GitHubClient.GITHUB_URL + tailApiUrl);\n+            } else {\n+                return new URL(apiUrl + tailApiUrl);\n+            }\n+        } else {\n+            return new URL(tailApiUrl);\n+        }\n+    }\n+\n+    /**\n+     * Transform Java Enum into Github constants given its conventions\n+     *\n+     * @param en\n+     *            Enum to be transformed\n+     * @return a String containing the value of a Github constant\n+     */\n+    static String transformEnum(Enum<?> en) {\n+        // by convention Java constant names are upper cases, but github uses\n+        // lower-case constants. GitHub also uses '-', which in Java we always\n+        // replace with '_'\n+        return en.toString().toLowerCase(Locale.ENGLISH).replace('_', '-');\n+    }\n+\n+    /**\n+     * The method for this request, such as \"GET\", \"PATCH\", or \"DELETE\".\n+     *\n+     * @return the request method.\n+     */\n+    @Nonnull\n+    public String method() {\n+        return method;\n+    }\n+\n+    /**\n+     * The arguments for this request. Depending on the {@link #method()} and {@code #inBody()} these maybe added to the\n+     * url or to the request body.\n+     *\n+     * @return the {@link List<Entry>} of arguments\n+     */\n+    @Nonnull\n+    public List<Entry> args() {\n+        return args;\n+    }\n+\n+    /**\n+     * The headers for this request.\n+     *\n+     * @return the {@link Map} of headers\n+     */\n+    @Nonnull\n+    public Map<String, String> headers() {\n+        return headers;\n+    }\n+\n+    /**\n+     * The base GitHub API URL for this request represented as a {@link String}\n+     * \n+     * @return the url string\n+     */\n+    @Nonnull\n+    public String apiUrl() {\n+        return apiUrl;\n+    }\n+\n+    /**\n+     * The url path to be added to the {@link #apiUrl()} for this request. If this does not start with a \"/\", it instead\n+     * represents the full url string for this request.\n+     * \n+     * @return a url path or full url string\n+     */\n+    @Nonnull\n+    public String urlPath() {\n+        return urlPath;\n+    }\n+\n+    /**\n+     * The content type to to be sent by this request.\n+     * \n+     * @return the content type.\n+     */\n+    @Nonnull\n+    public String contentType() {\n+        return headers.get(\"Content-type\");\n+    }\n+\n+    /**\n+     * The {@link InputStream} to be sent as the body of this request.\n+     * \n+     * @return the {@link InputStream}.\n+     */\n+    @CheckForNull\n+    public InputStream body() {\n+        return body;\n+    }\n+\n+    /**\n+     * The {@link URL} for this request. This is the actual URL the {@link GitHubClient} will send this request to.\n+     * \n+     * @return the request {@link URL}\n+     */\n+    @Nonnull\n+    public URL url() {\n+        return url;\n+    }\n+\n+    /**\n+     * Whether arguments for this request should be included in the URL or in the body of the request.\n+     * \n+     * @return true if the arguements should be sent in the body of the request.\n+     */\n+    public boolean inBody() {\n+        return forceBody || !METHODS_WITHOUT_BODY.contains(method);\n+    }\n+\n+    /**\n+     * Create a {@link Builder} from this request. Initial values of the builder will be the same as this\n+     * {@link GitHubRequest}.\n+     * \n+     * @return a {@link Builder} based on this request.\n+     */\n+    public Builder<?> toBuilder() {\n+        return new Builder<>(args, headers, apiUrl, urlPath, method, body, forceBody);\n+    }\n+\n+    private String buildTailApiUrl() {\n+        String tailApiUrl = urlPath;\n+        if (!inBody() && !args.isEmpty() && tailApiUrl.startsWith(\"/\")) {\n+            try {\n+                StringBuilder argString = new StringBuilder();\n+                boolean questionMarkFound = tailApiUrl.indexOf('?') != -1;\n+                argString.append(questionMarkFound ? '&' : '?');\n+\n+                for (Iterator<Entry> it = args.listIterator(); it.hasNext();) {\n+                    Entry arg = it.next();\n+                    argString.append(URLEncoder.encode(arg.key, StandardCharsets.UTF_8.name()));\n+                    argString.append('=');\n+                    argString.append(URLEncoder.encode(arg.value.toString(), StandardCharsets.UTF_8.name()));\n+                    if (it.hasNext()) {\n+                        argString.append('&');\n+                    }\n+                }\n+                tailApiUrl += argString;\n+            } catch (UnsupportedEncodingException e) {\n+                throw new GHException(\"UTF-8 encoding required\", e);\n+            }\n+        }\n+        return tailApiUrl;\n+    }\n+\n+    /**\n+     * Class {@link Builder} follows the builder pattern for {@link GitHubRequest}.\n+     *\n+     * @param <B>\n+     *            The type of {@link Builder} to return from the various \"with*\" methods.\n+     */\n+    static class Builder<B extends Builder<B>> {\n+\n+        @Nonnull\n+        private final List<Entry> args;\n+\n+        /**\n+         * The header values for this request.\n+         */\n+        @Nonnull\n+        private final Map<String, String> headers;\n+\n+        /**\n+         * The base GitHub API for this request.\n+         */\n+        @Nonnull\n+        private String apiUrl;\n+\n+        @Nonnull\n+        private String urlPath;\n+        /**\n+         * Request method.\n+         */\n+        @Nonnull\n+        private String method;\n+        private InputStream body;\n+        private boolean forceBody;\n+\n+        /**\n+         * Create a new {@link GitHubRequest.Builder}\n+         */\n+        protected Builder() {\n+            this(new ArrayList<>(), new LinkedHashMap<>(), GitHubClient.GITHUB_URL, \"/\", \"GET\", null, false);\n+        }\n+\n+        private Builder(@Nonnull List<Entry> args,\n+                @Nonnull Map<String, String> headers,\n+                @Nonnull String apiUrl,\n+                @Nonnull String urlPath,\n+                @Nonnull String method,\n+                @CheckForNull @WillClose InputStream body,\n+                boolean forceBody) {\n+            this.args = new ArrayList<>(args);\n+            this.headers = new LinkedHashMap<>(headers);\n+            this.apiUrl = apiUrl;\n+            this.urlPath = urlPath;\n+            this.method = method;\n+            this.body = body;\n+            this.forceBody = forceBody;\n+        }\n+\n+        /**\n+         * Builds a {@link GitHubRequest} from this builder.\n+         * \n+         * @return a {@link GitHubRequest}\n+         * @throws MalformedURLException\n+         *             if the GitHub API URL cannot be constructed\n+         */\n+        public GitHubRequest build() throws MalformedURLException {\n+            return new GitHubRequest(args, headers, apiUrl, urlPath, method, body, forceBody);\n+        }\n+\n+        /**\n+         * Creates {@link PagedIterable <R>} from this builder using the provided {@link Consumer<R>}. This method and\n+         * the {@link PagedIterable <R>} do not actually begin fetching data until {@link Iterator#next()} or\n+         * {@link Iterator#hasNext()} are called.\n+         *\n+         * @param client\n+         *            the {@link GitHubClient} to be used for this {@link PagedIterable<R>}\n+         * @param type\n+         *            the type of the pages to retrieve.\n+         * @param itemInitializer\n+         *            the consumer to execute on each paged item retrieved.\n+         * @param <R>\n+         *            the element type for the pages returned from\n+         * @return the {@link PagedIterable} for this builder.\n+         */\n+        public <R> PagedIterable<R> toIterable(GitHubClient client, Class<R[]> type, Consumer<R> itemInitializer) {\n+            try {\n+                return new GitHubPageContentsIterable<>(client, build(), type, itemInitializer);\n+            } catch (MalformedURLException e) {\n+                throw new GHException(e.getMessage(), e);\n+            }\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param url\n+         *            the url\n+         * @return the request builder\n+         */\n+        public B withApiUrl(String url) {\n+            this.apiUrl = url;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * Sets the request HTTP header.\n+         * <p>\n+         * If a header of the same name is already set, this method overrides it.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         */\n+        public void setHeader(String name, String value) {\n+            headers.put(name, value);\n+        }\n+\n+        /**\n+         * With header requester.\n+         *\n+         * @param name\n+         *            the name\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withHeader(String name, String value) {\n+            setHeader(name, value);\n+            return (B) this;\n+        }\n+\n+        public B withPreview(String name) {\n+            return withHeader(\"Accept\", name);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, int value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, long value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, boolean value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param e\n+         *            the e\n+         * @return the request builder\n+         */\n+        public B with(String key, Enum<?> e) {\n+            if (e == null)\n+                return with(key, (Object) null);\n+            return with(key, transformEnum(e));\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, String value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Collection<?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Map<?, ?> value) {\n+            return with(key, (Object) value);\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param body\n+         *            the body\n+         * @return the request builder\n+         */\n+        public B with(@WillClose /* later */ InputStream body) {\n+            this.body = body;\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With nullable requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B withNullable(String key, Object value) {\n+            args.add(new Entry(key, value));\n+            return (B) this;\n+        }\n+\n+        /**\n+         * With requester.\n+         *\n+         * @param key\n+         *            the key\n+         * @param value\n+         *            the value\n+         * @return the request builder\n+         */\n+        public B with(String key, Object value) {\n+            if (value != null) {\n+                args.add(new Entry(key, value));\n+            }\n+            return (B) this;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMjg4MA=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 503}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTI3NDQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/PagedIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMToxNDozNFrOFqVUvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwNDowMDo0NVrOFqX9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMzg4Nw==", "bodyText": "Not really specific to this PR, but, I could use a quick overview of the relationships between current, pos, and base. I thought I had it figured out for a minute but I guess I don't.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379933887", "createdAt": "2020-02-16T21:14:34Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/PagedIterator.java", "diffHunk": "@@ -38,29 +42,23 @@\n \n     public boolean hasNext() {\n         fetch();\n-        return current != null;\n+        return current.length > pos;\n     }\n \n     public T next() {\n-        fetch();\n-        if (current == null)\n+        if (!hasNext())\n             throw new NoSuchElementException();\n         return current[pos++];\n     }\n \n     private void fetch() {\n-        while (current == null || current.length <= pos) {\n-            if (!base.hasNext()) {// no more to retrieve\n-                current = null;\n-                pos = 0;\n-                return;\n-            }\n-\n-            current = base.next();\n-            wrapUp(current);\n+        if ((current == null || current.length <= pos) && base.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NzAzNQ==", "bodyText": "I can pick better names for these and give them a little more commenting.", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r379977035", "createdAt": "2020-02-17T04:00:45Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/PagedIterator.java", "diffHunk": "@@ -38,29 +42,23 @@\n \n     public boolean hasNext() {\n         fetch();\n-        return current != null;\n+        return current.length > pos;\n     }\n \n     public T next() {\n-        fetch();\n-        if (current == null)\n+        if (!hasNext())\n             throw new NoSuchElementException();\n         return current[pos++];\n     }\n \n     private void fetch() {\n-        while (current == null || current.length <= pos) {\n-            if (!base.hasNext()) {// no more to retrieve\n-                current = null;\n-                pos = 0;\n-                return;\n-            }\n-\n-            current = base.next();\n-            wrapUp(current);\n+        if ((current == null || current.length <= pos) && base.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzMzg4Nw=="}, "originalCommit": {"oid": "dc33e28452532b94c6d46e435c192ae043849ca9"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDEzMDI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubPageIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMToyNDoxMVrOFqv94Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMToyNDoxMVrOFqv94Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3MDQwMQ==", "bodyText": "Pedantic documentation hat, engage: replace \"need\" with \"needed.\"", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r380370401", "createdAt": "2020-02-17T21:24:11Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/GitHubPageIterator.java", "diffHunk": "@@ -52,37 +76,104 @@ public GitHubPageIterator(GitHubClient client, Class<T> type, GitHubRequest requ\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean hasNext() {\n-        return delegate.hasNext();\n+        synchronized (this) {\n+            fetch();\n+            return next != null;\n+        }\n     }\n \n     /**\n      * Gets the next page.\n-     * \n+     *\n      * @return the next page.\n      */\n     @Nonnull\n     public T next() {\n-        return Objects.requireNonNull(nextResponse().body());\n+        synchronized (this) {\n+            fetch();\n+            T result = next;\n+            if (result == null)\n+                throw new NoSuchElementException();\n+            // If this is the last page, keep the response\n+            next = null;\n+            return result;\n+        }\n     }\n \n     /**\n-     * Gets the next response page.\n-     * \n-     * @return the next response page.\n+     * On rare occasions the final response from iterating is needed.\n+     *\n+     * @return the final response of the iterator.\n      */\n-    @Nonnull\n-    public GitHubResponse<T> nextResponse() {\n-        GitHubResponse<T> result = Objects.requireNonNull(delegate.next());\n-        lastResponse = result;\n-        return result;\n+    public GitHubResponse<T> finalResponse() {\n+        if (hasNext()) {\n+            throw new GHException(\"Final response is not available until after iterator is done.\");\n+        }\n+        return finalResponse;\n     }\n \n     public void remove() {\n         throw new UnsupportedOperationException();\n     }\n \n-    public GitHubResponse<T> lastResponse() {\n-        return lastResponse;\n+    /**\n+     * Fetch is called at the start of {@link #hasNext()} or {@link #next()} to fetch another page of data if it is\n+     * needed.\n+     * <p>\n+     * If {@link #next} is not {@code null}, no further action is need. If {@link #next} is {@code null} and\n+     * {@link #nextRequest} is {@code null}, there are no more pages to fetch.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc5a89dff9e1a41ee35379e40ccd4e6ba3198d0"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDEzNzY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubPageIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMToyOTowMFrOFqwCkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMToyOTowMFrOFqwCkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3MTYwMA==", "bodyText": "Pedantic documentation hat once more: replace \"check\" with \"checked.\"", "url": "https://github.com/hub4j/github-api/pull/697#discussion_r380371600", "createdAt": "2020-02-17T21:29:00Z", "author": {"login": "kshultzCB"}, "path": "src/main/java/org/kohsuke/github/GitHubPageIterator.java", "diffHunk": "@@ -52,37 +76,104 @@ public GitHubPageIterator(GitHubClient client, Class<T> type, GitHubRequest requ\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean hasNext() {\n-        return delegate.hasNext();\n+        synchronized (this) {\n+            fetch();\n+            return next != null;\n+        }\n     }\n \n     /**\n      * Gets the next page.\n-     * \n+     *\n      * @return the next page.\n      */\n     @Nonnull\n     public T next() {\n-        return Objects.requireNonNull(nextResponse().body());\n+        synchronized (this) {\n+            fetch();\n+            T result = next;\n+            if (result == null)\n+                throw new NoSuchElementException();\n+            // If this is the last page, keep the response\n+            next = null;\n+            return result;\n+        }\n     }\n \n     /**\n-     * Gets the next response page.\n-     * \n-     * @return the next response page.\n+     * On rare occasions the final response from iterating is needed.\n+     *\n+     * @return the final response of the iterator.\n      */\n-    @Nonnull\n-    public GitHubResponse<T> nextResponse() {\n-        GitHubResponse<T> result = Objects.requireNonNull(delegate.next());\n-        lastResponse = result;\n-        return result;\n+    public GitHubResponse<T> finalResponse() {\n+        if (hasNext()) {\n+            throw new GHException(\"Final response is not available until after iterator is done.\");\n+        }\n+        return finalResponse;\n     }\n \n     public void remove() {\n         throw new UnsupportedOperationException();\n     }\n \n-    public GitHubResponse<T> lastResponse() {\n-        return lastResponse;\n+    /**\n+     * Fetch is called at the start of {@link #hasNext()} or {@link #next()} to fetch another page of data if it is\n+     * needed.\n+     * <p>\n+     * If {@link #next} is not {@code null}, no further action is need. If {@link #next} is {@code null} and\n+     * {@link #nextRequest} is {@code null}, there are no more pages to fetch.\n+     * </p>\n+     * <p>\n+     * Otherwise, a new response page is fetched using {@link #nextRequest}. The response is then check to see if there", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc5a89dff9e1a41ee35379e40ccd4e6ba3198d0"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1859, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}