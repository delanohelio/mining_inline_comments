{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyOTY4OTUx", "number": 945, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxMjozN1rOEnlwIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDowNzoxMlrOFO1VvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTQ4NDQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxMjozN1rOHYRKaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoyMzo1MVrOHYRcPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwOTA2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.credentialProvider = new ImmutableCredentialProvider(String.format(\"token %s\", oauthAccessToken));\n          \n          \n            \n                        this.credentialProvider = ImmutableCredentialProvider.fromOAuthToken(String.format(\"token %s\", oauthAccessToken));", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r495209067", "createdAt": "2020-09-25T20:12:37Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -112,25 +108,26 @@\n         this.connector = connector;\n \n         if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+            this.credentialProvider = new ImmutableCredentialProvider(String.format(\"token %s\", oauthAccessToken));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05863acbcd111cd187f8f54d43394335c6a2a99d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxMzYyOA==", "bodyText": "I would also suggest moving all these into GitHubBuilder and have a method GitHubBuilder.withCredentialProvider(CredentialProvider) which can be internal for now.  Then this constructor just sets this.credentialProvider = credentialProvider pass from the builder.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r495213628", "createdAt": "2020-09-25T20:23:51Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -112,25 +108,26 @@\n         this.connector = connector;\n \n         if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+            this.credentialProvider = new ImmutableCredentialProvider(String.format(\"token %s\", oauthAccessToken));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwOTA2Nw=="}, "originalCommit": {"oid": "05863acbcd111cd187f8f54d43394335c6a2a99d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTQ4ODM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxNDoxNVrOHYRM2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxNDoxNVrOHYRM2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwOTY4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String authorization = (login + ':' + password);\n          \n          \n            \n                            String charsetName = StandardCharsets.UTF_8.name();\n          \n          \n            \n                            encodedAuthorization = \"Basic \"\n          \n          \n            \n                            String encodedAuthorization = \"Basic \"\n          \n          \n            \n                                    + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n          \n          \n            \n                            this.credentialProvider = new ImmutableCredentialProvider(encodedAuthorization);\n          \n          \n            \n            this.credentialProvider = ImmutableCredentialProvider.fromLoginAndPassword(login, password);", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r495209689", "createdAt": "2020-09-25T20:14:15Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -112,25 +108,26 @@\n         this.connector = connector;\n \n         if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+            this.credentialProvider = new ImmutableCredentialProvider(String.format(\"token %s\", oauthAccessToken));\n         } else {\n             if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n+                this.credentialProvider = new ImmutableCredentialProvider(String.format(\"Bearer %s\", jwtToken));\n             } else if (password != null) {\n                 String authorization = (login + ':' + password);\n                 String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n+                String encodedAuthorization = \"Basic \"\n                         + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n+                this.credentialProvider = new ImmutableCredentialProvider(encodedAuthorization);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05863acbcd111cd187f8f54d43394335c6a2a99d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTQ5MjI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxNTo0MlrOHYRPQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxNTo0MlrOHYRPQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxMDMwNw==", "bodyText": "Create a static final instance for this.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.credentialProvider = new ImmutableCredentialProvider(null);\n          \n          \n            \n                            this.credentialProvider = ImmutableCredentialProvider.ANONYMOUS;", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r495210307", "createdAt": "2020-09-25T20:15:42Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -112,25 +108,26 @@\n         this.connector = connector;\n \n         if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+            this.credentialProvider = new ImmutableCredentialProvider(String.format(\"token %s\", oauthAccessToken));\n         } else {\n             if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n+                this.credentialProvider = new ImmutableCredentialProvider(String.format(\"Bearer %s\", jwtToken));\n             } else if (password != null) {\n                 String authorization = (login + ':' + password);\n                 String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n+                String encodedAuthorization = \"Basic \"\n                         + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n+                this.credentialProvider = new ImmutableCredentialProvider(encodedAuthorization);\n             } else {// anonymous access\n-                encodedAuthorization = null;\n+                this.credentialProvider = new ImmutableCredentialProvider(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05863acbcd111cd187f8f54d43394335c6a2a99d"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTQ5NDQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoyMzoxNlrOHZ_xtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTowMjo1MFrOIIIrzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTM2NQ==", "bodyText": "I'd like to see all the other credential methods call this one.\nFor example:\n    public GitHubBuilder withOAuthToken(String oauthToken, String user) {\n        withCredentialProvider(ImmutableCredentialProvider.fromOauthToken(oauthToken));\n        this.user = user;\n        return this;\n    }\n\nThat would let us remove the oauthToken and password instance fields from the class (and down the call chain).", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r497021365", "createdAt": "2020-09-29T20:23:16Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubBuilder.java", "diffHunk": "@@ -278,6 +279,11 @@ public GitHubBuilder withOAuthToken(String oauthToken, String user) {\n         return this;\n     }\n \n+    public GitHubBuilder withCredentialProvider(final CredentialProvider credentialProvider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NDIzOQ==", "bodyText": "If we do this we lose the ability to know what kind of credentials we are using, and we will have to (I think) request the user to know if the current credentials are \"user-aware\" (GET \"/user\"). This will break a ton of tests that don't have the mapping for that call (not a big deal IMO), but also add another API call on GHBuilder#build(), and this does change semantics. We could potentially make it \"lazy\", so that we only lookup the user when it's actually requested, and not on setup, but I have to look into this.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r497554239", "createdAt": "2020-09-30T14:27:21Z", "author": {"login": "MarcosCela"}, "path": "src/main/java/org/kohsuke/github/GitHubBuilder.java", "diffHunk": "@@ -278,6 +279,11 @@ public GitHubBuilder withOAuthToken(String oauthToken, String user) {\n         return this;\n     }\n \n+    public GitHubBuilder withCredentialProvider(final CredentialProvider credentialProvider) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTM2NQ=="}, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTgwNA==", "bodyText": "@MarcosCela\n\nIf we do this we lose the ability to know what kind of credentials we are using\n\nI feel like this isn't true.  There should be some way to do this. I might not be explaining myself well though.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545401804", "createdAt": "2020-12-17T21:02:50Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubBuilder.java", "diffHunk": "@@ -278,6 +279,11 @@ public GitHubBuilder withOAuthToken(String oauthToken, String user) {\n         return this;\n     }\n \n+    public GitHubBuilder withCredentialProvider(final CredentialProvider credentialProvider) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTM2NQ=="}, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTUwMzM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoyNTo0NFrOHZ_28A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1OToxOVrOIIKbxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMjcwNA==", "bodyText": "Why add this try-catch?  It changes the user visible behavior.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r497022704", "createdAt": "2020-09-29T20:25:44Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -111,33 +93,45 @@\n         this.apiUrl = apiUrl;\n         this.connector = connector;\n \n-        if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+        // Prefer credential configuration via provider\n+        if (credentialProvider != null) {\n+            this.credentialProvider = credentialProvider;\n         } else {\n-            if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n-            } else if (password != null) {\n-                String authorization = (login + ':' + password);\n-                String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n-                        + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n-            } else {// anonymous access\n-                encodedAuthorization = null;\n+            if (oauthAccessToken != null) {\n+                this.credentialProvider = ImmutableCredentialProvider.fromOauthToken(oauthAccessToken);\n+            } else {\n+                if (jwtToken != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromJwtToken(jwtToken);\n+                } else if (password != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromLoginAndPassword(login, password);\n+                } else {// anonymous access\n+                    this.credentialProvider = CredentialProvider.ANONYMOUS;\n+                }\n             }\n         }\n \n         this.rateLimitHandler = rateLimitHandler;\n         this.abuseLimitHandler = abuseLimitHandler;\n         this.rateLimitChecker = rateLimitChecker;\n \n-        if (login == null && encodedAuthorization != null && jwtToken == null) {\n-            GHMyself myself = fetch(GHMyself.class, \"/user\");\n-            login = myself.getLogin();\n-            if (myselfConsumer != null) {\n-                myselfConsumer.accept(myself);\n+        this.login = getCurrentUser(login, jwtToken, myselfConsumer);\n+    }\n+\n+    @Nullable\n+    private String getCurrentUser(String login, String jwtToken, Consumer<GHMyself> myselfConsumer) throws IOException {\n+        if (login == null && this.credentialProvider.getEncodedAuthorization() != null && jwtToken == null) {\n+            try {\n+                GHMyself myself = fetch(GHMyself.class, \"/user\");\n+                if (myselfConsumer != null) {\n+                    myselfConsumer.accept(myself);\n+                }\n+                return myself.getLogin();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NjQyMg==", "bodyText": "If we use a credentialProvider, we no longer know what kind of credentials we have here. Some credentials don't support checking who is making the call (api call to \"/user\"), and will fail, so the only way that I see to check if the credentials being used support \"user lookup\", is to actually make the call and handle the case where the call fails (e.g: installation tokens).", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r497456422", "createdAt": "2020-09-30T12:07:01Z", "author": {"login": "MarcosCela"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -111,33 +93,45 @@\n         this.apiUrl = apiUrl;\n         this.connector = connector;\n \n-        if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+        // Prefer credential configuration via provider\n+        if (credentialProvider != null) {\n+            this.credentialProvider = credentialProvider;\n         } else {\n-            if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n-            } else if (password != null) {\n-                String authorization = (login + ':' + password);\n-                String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n-                        + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n-            } else {// anonymous access\n-                encodedAuthorization = null;\n+            if (oauthAccessToken != null) {\n+                this.credentialProvider = ImmutableCredentialProvider.fromOauthToken(oauthAccessToken);\n+            } else {\n+                if (jwtToken != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromJwtToken(jwtToken);\n+                } else if (password != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromLoginAndPassword(login, password);\n+                } else {// anonymous access\n+                    this.credentialProvider = CredentialProvider.ANONYMOUS;\n+                }\n             }\n         }\n \n         this.rateLimitHandler = rateLimitHandler;\n         this.abuseLimitHandler = abuseLimitHandler;\n         this.rateLimitChecker = rateLimitChecker;\n \n-        if (login == null && encodedAuthorization != null && jwtToken == null) {\n-            GHMyself myself = fetch(GHMyself.class, \"/user\");\n-            login = myself.getLogin();\n-            if (myselfConsumer != null) {\n-                myselfConsumer.accept(myself);\n+        this.login = getCurrentUser(login, jwtToken, myselfConsumer);\n+    }\n+\n+    @Nullable\n+    private String getCurrentUser(String login, String jwtToken, Consumer<GHMyself> myselfConsumer) throws IOException {\n+        if (login == null && this.credentialProvider.getEncodedAuthorization() != null && jwtToken == null) {\n+            try {\n+                GHMyself myself = fetch(GHMyself.class, \"/user\");\n+                if (myselfConsumer != null) {\n+                    myselfConsumer.accept(myself);\n+                }\n+                return myself.getLogin();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMjcwNA=="}, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNzg5NA==", "bodyText": "If we use a credentialProvider, we no longer know what kind of credentials we have here.\n\nWhat about having a method on CredentialsProvider?  getLogin(Consumer<GHMyself> myselfConsumer) or something similar?  Then getCurrentUser() wouldn't check jwtToken or login or whatever, the credential itself would decide what to do.  getLogin() on JWTTokenProvider would always return null, while for fromOauthToken it would have code from lines 124-128.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545417894", "createdAt": "2020-12-17T21:34:23Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -111,33 +93,45 @@\n         this.apiUrl = apiUrl;\n         this.connector = connector;\n \n-        if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+        // Prefer credential configuration via provider\n+        if (credentialProvider != null) {\n+            this.credentialProvider = credentialProvider;\n         } else {\n-            if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n-            } else if (password != null) {\n-                String authorization = (login + ':' + password);\n-                String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n-                        + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n-            } else {// anonymous access\n-                encodedAuthorization = null;\n+            if (oauthAccessToken != null) {\n+                this.credentialProvider = ImmutableCredentialProvider.fromOauthToken(oauthAccessToken);\n+            } else {\n+                if (jwtToken != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromJwtToken(jwtToken);\n+                } else if (password != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromLoginAndPassword(login, password);\n+                } else {// anonymous access\n+                    this.credentialProvider = CredentialProvider.ANONYMOUS;\n+                }\n             }\n         }\n \n         this.rateLimitHandler = rateLimitHandler;\n         this.abuseLimitHandler = abuseLimitHandler;\n         this.rateLimitChecker = rateLimitChecker;\n \n-        if (login == null && encodedAuthorization != null && jwtToken == null) {\n-            GHMyself myself = fetch(GHMyself.class, \"/user\");\n-            login = myself.getLogin();\n-            if (myselfConsumer != null) {\n-                myselfConsumer.accept(myself);\n+        this.login = getCurrentUser(login, jwtToken, myselfConsumer);\n+    }\n+\n+    @Nullable\n+    private String getCurrentUser(String login, String jwtToken, Consumer<GHMyself> myselfConsumer) throws IOException {\n+        if (login == null && this.credentialProvider.getEncodedAuthorization() != null && jwtToken == null) {\n+            try {\n+                GHMyself myself = fetch(GHMyself.class, \"/user\");\n+                if (myselfConsumer != null) {\n+                    myselfConsumer.accept(myself);\n+                }\n+                return myself.getLogin();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMjcwNA=="}, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMDQ2OQ==", "bodyText": "Hmm, or maybe a CredentialsProvider would have boolean requiresMyself() to control whether this code is called and then getLogin(@CheckForNull GHMyself) that is always called, return credentialProvider.getLogin(myself);.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545430469", "createdAt": "2020-12-17T21:59:19Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -111,33 +93,45 @@\n         this.apiUrl = apiUrl;\n         this.connector = connector;\n \n-        if (oauthAccessToken != null) {\n-            encodedAuthorization = \"token \" + oauthAccessToken;\n+        // Prefer credential configuration via provider\n+        if (credentialProvider != null) {\n+            this.credentialProvider = credentialProvider;\n         } else {\n-            if (jwtToken != null) {\n-                encodedAuthorization = \"Bearer \" + jwtToken;\n-            } else if (password != null) {\n-                String authorization = (login + ':' + password);\n-                String charsetName = StandardCharsets.UTF_8.name();\n-                encodedAuthorization = \"Basic \"\n-                        + Base64.getEncoder().encodeToString(authorization.getBytes(charsetName));\n-            } else {// anonymous access\n-                encodedAuthorization = null;\n+            if (oauthAccessToken != null) {\n+                this.credentialProvider = ImmutableCredentialProvider.fromOauthToken(oauthAccessToken);\n+            } else {\n+                if (jwtToken != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromJwtToken(jwtToken);\n+                } else if (password != null) {\n+                    this.credentialProvider = ImmutableCredentialProvider.fromLoginAndPassword(login, password);\n+                } else {// anonymous access\n+                    this.credentialProvider = CredentialProvider.ANONYMOUS;\n+                }\n             }\n         }\n \n         this.rateLimitHandler = rateLimitHandler;\n         this.abuseLimitHandler = abuseLimitHandler;\n         this.rateLimitChecker = rateLimitChecker;\n \n-        if (login == null && encodedAuthorization != null && jwtToken == null) {\n-            GHMyself myself = fetch(GHMyself.class, \"/user\");\n-            login = myself.getLogin();\n-            if (myselfConsumer != null) {\n-                myselfConsumer.accept(myself);\n+        this.login = getCurrentUser(login, jwtToken, myselfConsumer);\n+    }\n+\n+    @Nullable\n+    private String getCurrentUser(String login, String jwtToken, Consumer<GHMyself> myselfConsumer) throws IOException {\n+        if (login == null && this.credentialProvider.getEncodedAuthorization() != null && jwtToken == null) {\n+            try {\n+                GHMyself myself = fetch(GHMyself.class, \"/user\");\n+                if (myselfConsumer != null) {\n+                    myselfConsumer.accept(myself);\n+                }\n+                return myself.getLogin();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMjcwNA=="}, "originalCommit": {"oid": "4f3099887352823d837a328e63575a92a63fea2a"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODA1MDc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/extras/auth/OrgInstallationCredentialProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowMzo0MlrOIIKkXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowMzo0MlrOIIKkXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMjY2OQ==", "bodyText": "Maybe? instead of duplicating the other class?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class OrgInstallationCredentialProvider implements CredentialProvider {\n          \n          \n            \n            public class OrgInstallationCredentialProvider extends org.kohsuke.github.OrgInstallationCredentialProvider implements CredentialProvider {", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545432669", "createdAt": "2020-12-17T22:03:42Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/extras/auth/OrgInstallationCredentialProvider.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import org.kohsuke.github.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Date;\n+\n+/**\n+ * This helper class provides an example on how to authenticate a GitHub instance with an installation token, that will\n+ * be automatically refreshed when required.\n+ */\n+public class OrgInstallationCredentialProvider implements CredentialProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610b02968e158e58b2c17183ef3e37a497fe6387"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODA4NTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/extras/auth/JWTTokenProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoxMzoxNFrOIIK3cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoxMzoxNFrOIIK3cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNzU1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getJWT() {\n          \n          \n            \n                private String getJWT() {", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545437552", "createdAt": "2020-12-17T22:13:14Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/extras/auth/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.CredentialProvider;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.util.Date;\n+\n+/**\n+ * A credential provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements CredentialProvider {\n+\n+    private static final long MINUTES_10 = Duration.ofMinutes(10).toMillis();\n+\n+    private final PrivateKey privateKey;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath)\n+            throws InvalidKeySpecException, NoSuchAlgorithmException, IOException {\n+        this.privateKey = loadPrivateKey(keyPath);\n+        this.applicationId = applicationId;\n+    }\n+\n+    /**\n+     * add dependencies for a jwt suite You can generate a key to load with this method with:\n+     *\n+     * <pre>\n+     * openssl pkcs8 -topk8 -inform PEM -outform DER -in ~/github-api-app.private-key.pem -out ~/github-api-app.private-key.der -nocrypt\n+     * </pre>\n+     */\n+    private PrivateKey loadPrivateKey(Path keyPath)\n+            throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {\n+\n+        byte[] keyBytes = Files.readAllBytes(keyPath);\n+        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);\n+        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n+        return kf.generatePrivate(spec);\n+    }\n+\n+    public String getJWT() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610b02968e158e58b2c17183ef3e37a497fe6387"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODEzMDQ5OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/OrgInstallationCredentialProviderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoyNjo1N1rOIILRPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjoyNjo1N1rOIILRPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0NDE1Nw==", "bodyText": "Are the credentials returned from fromJwtToken actually immutable?  I thought the token expired every 10 minutes.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545444157", "createdAt": "2020-12-17T22:26:57Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/OrgInstallationCredentialProviderTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package org.kohsuke.github;\n+\n+import net.sf.ezmorph.test.ArrayAssertions;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+public class OrgInstallationCredentialProviderTest extends AbstractGitHubWireMockTest {\n+\n+    @Test(expected = HttpException.class)\n+    public void invalidJWTTokenRaisesException() throws IOException {\n+\n+        gitHub.getClient().credentialProvider = ImmutableCredentialProvider.fromJwtToken(\"myToken\");\n+\n+        OrgInstallationCredentialProvider provider = new OrgInstallationCredentialProvider(\"testOrganization\", gitHub);\n+\n+        provider.getEncodedAuthorization();\n+    }\n+\n+    @Test\n+    public void validJWTTokenAllowsOauthTokenRequest() throws IOException {\n+        gitHub.getClient().credentialProvider = ImmutableCredentialProvider.fromJwtToken(\"valid-token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610b02968e158e58b2c17183ef3e37a497fe6387"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyODE1NTMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/extras/auth/OrgInstallationCredentialProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjozNDo1OFrOIILfxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOToxMDo0MVrOIIaOyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzg3OA==", "bodyText": "Having this take a GitHub at construction time makes it more difficult to work with.  A user building a GitHub using the builder will have difficulty working with this.  Perhaps having this take a JWTToken and include an internal setRefreshSource(GitHub)?  And maybe add an internal method to GitHubBuilder that takes an existing GitHub instance as the starting point?  Then setRefreshSource(GitHub) could build an identical instance with just the credential provider changed.  Does that make sense?\nI'm willing for the internals of this to be a bit messier if it makes the experience better for end users - we don't want them to have to configure a GitHub twice to get this to work.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545447878", "createdAt": "2020-12-17T22:34:58Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/extras/auth/OrgInstallationCredentialProvider.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import org.kohsuke.github.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Date;\n+\n+/**\n+ * This helper class provides an example on how to authenticate a GitHub instance with an installation token, that will\n+ * be automatically refreshed when required.\n+ */\n+public class OrgInstallationCredentialProvider implements CredentialProvider {\n+\n+    private final GitHub gitHub;\n+\n+    private final String organizationName;\n+\n+    private String latestToken;\n+\n+    private Date validUntil;\n+\n+    public OrgInstallationCredentialProvider(String organizationName, GitHub gitHub) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610b02968e158e58b2c17183ef3e37a497fe6387"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTY4OTI5MA==", "bodyText": "I will try to give it a go following your suggestions, thanks a lot!!!!", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r545689290", "createdAt": "2020-12-18T09:10:41Z", "author": {"login": "MarcosCela"}, "path": "src/main/java/org/kohsuke/github/extras/auth/OrgInstallationCredentialProvider.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import org.kohsuke.github.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Date;\n+\n+/**\n+ * This helper class provides an example on how to authenticate a GitHub instance with an installation token, that will\n+ * be automatically refreshed when required.\n+ */\n+public class OrgInstallationCredentialProvider implements CredentialProvider {\n+\n+    private final GitHub gitHub;\n+\n+    private final String organizationName;\n+\n+    private String latestToken;\n+\n+    private Date validUntil;\n+\n+    public OrgInstallationCredentialProvider(String organizationName, GitHub gitHub) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzg3OA=="}, "originalCommit": {"oid": "610b02968e158e58b2c17183ef3e37a497fe6387"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4Mzk1Njc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/extras/auth/JWTTokenProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxOToxMToxOVrOIP4qQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxOToxNjowNlrOIP4zgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyNzg3NA==", "bodyText": "@MarcosCela\nCould you add a test that verifies this?", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r553527874", "createdAt": "2021-01-07T19:11:19Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/extras/auth/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.AuthorizationProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Date;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A authorization provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements AuthorizationProvider {\n+\n+    private static final long MINUTES_10 = Duration.ofMinutes(10).toMillis();\n+\n+    private final PrivateKey privateKey;\n+\n+    @Nonnull\n+    private Instant validUntil = Instant.MIN;\n+\n+    private String token;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, File keyFile) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyFile.toPath()));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyPath));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, PrivateKey privateKey) {\n+        this.privateKey = privateKey;\n+        this.applicationId = applicationId;\n+    }\n+\n+    @Override\n+    public String getEncodedAuthorization() throws IOException {\n+        synchronized (this) {\n+            if (Instant.now().isAfter(validUntil)) {\n+                token = refreshJWT();\n+            }\n+            return String.format(\"Bearer %s\", token);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8a0bcb7db243cf52344fe05a7ac17fd7f91b395"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUzMDI0MA==", "bodyText": "Will do!", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r553530240", "createdAt": "2021-01-07T19:16:06Z", "author": {"login": "MarcosCela"}, "path": "src/main/java/org/kohsuke/github/extras/auth/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.AuthorizationProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Date;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A authorization provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements AuthorizationProvider {\n+\n+    private static final long MINUTES_10 = Duration.ofMinutes(10).toMillis();\n+\n+    private final PrivateKey privateKey;\n+\n+    @Nonnull\n+    private Instant validUntil = Instant.MIN;\n+\n+    private String token;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, File keyFile) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyFile.toPath()));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyPath));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, PrivateKey privateKey) {\n+        this.privateKey = privateKey;\n+        this.applicationId = applicationId;\n+    }\n+\n+    @Override\n+    public String getEncodedAuthorization() throws IOException {\n+        synchronized (this) {\n+            if (Instant.now().isAfter(validUntil)) {\n+                token = refreshJWT();\n+            }\n+            return String.format(\"Bearer %s\", token);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyNzg3NA=="}, "originalCommit": {"oid": "a8a0bcb7db243cf52344fe05a7ac17fd7f91b395"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4Mzk2NDg1OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/AbstractGHAppInstallationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxOToxNDowM1rOIP4vRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwOToxNjo0N1rOIQK9fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyOTE1Nw==", "bodyText": "@MarcosCela\nTo test JWT provider, maybe just add an assertion to the test that uses these.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r553529157", "createdAt": "2021-01-07T19:14:03Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/AbstractGHAppInstallationTest.java", "diffHunk": "@@ -63,15 +83,15 @@ private GHAppInstallation getAppInstallationWithToken(String jwtToken) throws IO\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp1() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_1, TEST_APP_ID_1));\n+        return getAppInstallationWithToken(JWT_PROVIDER_1.getEncodedAuthorization());\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp2() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_2, TEST_APP_ID_2));\n+        return getAppInstallationWithToken(JWT_PROVIDER_2.getEncodedAuthorization());\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp3() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_3, TEST_APP_ID_3));\n+        return getAppInstallationWithToken(JWT_PROVIDER_3.getEncodedAuthorization());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8a0bcb7db243cf52344fe05a7ac17fd7f91b395"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyNzcwOA==", "bodyText": "Tests added, what do you think?", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r553827708", "createdAt": "2021-01-08T09:16:47Z", "author": {"login": "MarcosCela"}, "path": "src/test/java/org/kohsuke/github/AbstractGHAppInstallationTest.java", "diffHunk": "@@ -63,15 +83,15 @@ private GHAppInstallation getAppInstallationWithToken(String jwtToken) throws IO\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp1() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_1, TEST_APP_ID_1));\n+        return getAppInstallationWithToken(JWT_PROVIDER_1.getEncodedAuthorization());\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp2() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_2, TEST_APP_ID_2));\n+        return getAppInstallationWithToken(JWT_PROVIDER_2.getEncodedAuthorization());\n     }\n \n     protected GHAppInstallation getAppInstallationWithTokenApp3() throws IOException {\n-        return getAppInstallationWithToken(createJwtToken(PRIVATE_KEY_FILE_APP_3, TEST_APP_ID_3));\n+        return getAppInstallationWithToken(JWT_PROVIDER_3.getEncodedAuthorization());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyOTE1Nw=="}, "originalCommit": {"oid": "a8a0bcb7db243cf52344fe05a7ac17fd7f91b395"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzIzMTM4OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/extras/auth/JWTTokenProviderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNTo1MjowN1rOIQXAHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNTo1MjowN1rOIQXAHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDAyNDk4OA==", "bodyText": "Very nice.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r554024988", "createdAt": "2021-01-08T15:52:07Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/extras/auth/JWTTokenProviderTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package org.kohsuke.github.extras.auth;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+\n+import org.junit.Test;\n+import org.kohsuke.github.AbstractGitHubWireMockTest;\n+import org.kohsuke.github.GitHub;\n+\n+public class JWTTokenProviderTest extends AbstractGitHubWireMockTest {\n+\n+    private static String TEST_APP_ID_2 = \"83009\";\n+    private static String PRIVATE_KEY_FILE_APP_2 = \"/ghapi-test-app-2.private-key.pem\";\n+\n+    /**\n+     * This test will request an application ensuring that the header for the \"Authorization\" matches a valid JWT token.\n+     * A JWT token in the Authorization header will always start with \"ey\" which is always the start of the base64\n+     * encoding of the JWT Header , so a valid header will look like this:\n+     *\n+     * <pre>\n+     * Authorization: Bearer ey{rest of the header}.{payload}.{signature}\n+     * </pre>\n+     *\n+     * Matched by the regular expression:\n+     *\n+     * <pre>\n+     * ^Bearer (?<JWTHeader>ey\\S*)\\.(?<JWTPayload>\\S*)\\.(?<JWTSignature>\\S*)$\n+     * </pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a96275c286ab82b1ccf8931bc0b985d318b8cf5b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMDk4MzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/extras/authorization/JWTTokenProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDowNzoxMlrOIT1Utw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMToyNzowNFrOIT33hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY2NzUxMQ==", "bodyText": "any reason this is private? seems like I just have to re-implement this / copy it if I'm working with strings", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r557667511", "createdAt": "2021-01-14T20:07:12Z", "author": {"login": "timja"}, "path": "src/main/java/org/kohsuke/github/extras/authorization/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.kohsuke.github.extras.authorization;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.authorization.AuthorizationProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Date;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A authorization provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements AuthorizationProvider {\n+\n+    private final PrivateKey privateKey;\n+\n+    @Nonnull\n+    private Instant validUntil = Instant.MIN;\n+\n+    private String token;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, File keyFile) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyFile.toPath()));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyPath));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, PrivateKey privateKey) {\n+        this.privateKey = privateKey;\n+        this.applicationId = applicationId;\n+    }\n+\n+    @Override\n+    public String getEncodedAuthorization() throws IOException {\n+        synchronized (this) {\n+            if (Instant.now().isAfter(validUntil)) {\n+                token = refreshJWT();\n+            }\n+            return String.format(\"Bearer %s\", token);\n+        }\n+    }\n+\n+    /**\n+     * add dependencies for a jwt suite You can generate a key to load in this method with:\n+     *\n+     * <pre>\n+     * openssl pkcs8 -topk8 -inform PEM -outform DER -in ~/github-api-app.private-key.pem -out ~/github-api-app.private-key.der -nocrypt\n+     * </pre>\n+     */\n+    private static PrivateKey loadPrivateKey(Path keyPath) throws GeneralSecurityException, IOException {\n+        String keyString = new String(Files.readAllBytes(keyPath), StandardCharsets.UTF_8);\n+        return getPrivateKeyFromString(keyString);\n+    }\n+\n+    /**\n+     * Convert a PKCS#8 formatted private key in string format into a java PrivateKey\n+     *\n+     * @param key\n+     *            PCKS#8 string\n+     * @return private key\n+     * @throws GeneralSecurityException\n+     *             if we couldn't parse the string\n+     */\n+    private static PrivateKey getPrivateKeyFromString(final String key) throws GeneralSecurityException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b84efdbfa510ed3775b78d7f491921b154ecb40"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwNzg1Nw==", "bodyText": "Probably better to create a constructor that takes a String.", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r557707857", "createdAt": "2021-01-14T21:24:24Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/extras/authorization/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.kohsuke.github.extras.authorization;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.authorization.AuthorizationProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Date;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A authorization provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements AuthorizationProvider {\n+\n+    private final PrivateKey privateKey;\n+\n+    @Nonnull\n+    private Instant validUntil = Instant.MIN;\n+\n+    private String token;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, File keyFile) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyFile.toPath()));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyPath));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, PrivateKey privateKey) {\n+        this.privateKey = privateKey;\n+        this.applicationId = applicationId;\n+    }\n+\n+    @Override\n+    public String getEncodedAuthorization() throws IOException {\n+        synchronized (this) {\n+            if (Instant.now().isAfter(validUntil)) {\n+                token = refreshJWT();\n+            }\n+            return String.format(\"Bearer %s\", token);\n+        }\n+    }\n+\n+    /**\n+     * add dependencies for a jwt suite You can generate a key to load in this method with:\n+     *\n+     * <pre>\n+     * openssl pkcs8 -topk8 -inform PEM -outform DER -in ~/github-api-app.private-key.pem -out ~/github-api-app.private-key.der -nocrypt\n+     * </pre>\n+     */\n+    private static PrivateKey loadPrivateKey(Path keyPath) throws GeneralSecurityException, IOException {\n+        String keyString = new String(Files.readAllBytes(keyPath), StandardCharsets.UTF_8);\n+        return getPrivateKeyFromString(keyString);\n+    }\n+\n+    /**\n+     * Convert a PKCS#8 formatted private key in string format into a java PrivateKey\n+     *\n+     * @param key\n+     *            PCKS#8 string\n+     * @return private key\n+     * @throws GeneralSecurityException\n+     *             if we couldn't parse the string\n+     */\n+    private static PrivateKey getPrivateKeyFromString(final String key) throws GeneralSecurityException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY2NzUxMQ=="}, "originalCommit": {"oid": "1b84efdbfa510ed3775b78d7f491921b154ecb40"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwOTE5MQ==", "bodyText": "yes or that...", "url": "https://github.com/hub4j/github-api/pull/945#discussion_r557709191", "createdAt": "2021-01-14T21:27:04Z", "author": {"login": "timja"}, "path": "src/main/java/org/kohsuke/github/extras/authorization/JWTTokenProvider.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.kohsuke.github.extras.authorization;\n+\n+import io.jsonwebtoken.JwtBuilder;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import org.kohsuke.github.authorization.AuthorizationProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.Date;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A authorization provider that gives valid JWT tokens. These tokens are then used to create a time-based token to\n+ * authenticate as an application. This token provider does not provide any kind of caching, and will always request a\n+ * new token to the API.\n+ */\n+public class JWTTokenProvider implements AuthorizationProvider {\n+\n+    private final PrivateKey privateKey;\n+\n+    @Nonnull\n+    private Instant validUntil = Instant.MIN;\n+\n+    private String token;\n+\n+    /**\n+     * The identifier for the application\n+     */\n+    private final String applicationId;\n+\n+    public JWTTokenProvider(String applicationId, File keyFile) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyFile.toPath()));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, Path keyPath) throws GeneralSecurityException, IOException {\n+        this(applicationId, loadPrivateKey(keyPath));\n+    }\n+\n+    public JWTTokenProvider(String applicationId, PrivateKey privateKey) {\n+        this.privateKey = privateKey;\n+        this.applicationId = applicationId;\n+    }\n+\n+    @Override\n+    public String getEncodedAuthorization() throws IOException {\n+        synchronized (this) {\n+            if (Instant.now().isAfter(validUntil)) {\n+                token = refreshJWT();\n+            }\n+            return String.format(\"Bearer %s\", token);\n+        }\n+    }\n+\n+    /**\n+     * add dependencies for a jwt suite You can generate a key to load in this method with:\n+     *\n+     * <pre>\n+     * openssl pkcs8 -topk8 -inform PEM -outform DER -in ~/github-api-app.private-key.pem -out ~/github-api-app.private-key.der -nocrypt\n+     * </pre>\n+     */\n+    private static PrivateKey loadPrivateKey(Path keyPath) throws GeneralSecurityException, IOException {\n+        String keyString = new String(Files.readAllBytes(keyPath), StandardCharsets.UTF_8);\n+        return getPrivateKeyFromString(keyString);\n+    }\n+\n+    /**\n+     * Convert a PKCS#8 formatted private key in string format into a java PrivateKey\n+     *\n+     * @param key\n+     *            PCKS#8 string\n+     * @return private key\n+     * @throws GeneralSecurityException\n+     *             if we couldn't parse the string\n+     */\n+    private static PrivateKey getPrivateKeyFromString(final String key) throws GeneralSecurityException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY2NzUxMQ=="}, "originalCommit": {"oid": "1b84efdbfa510ed3775b78d7f491921b154ecb40"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1831, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}