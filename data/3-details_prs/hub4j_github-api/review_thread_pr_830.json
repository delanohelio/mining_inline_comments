{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MTQyMjEw", "number": 830, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMTowM1rOEAS35w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToyMToyMFrOEOZdUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ0Njc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMTowM1rOGbfMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMTowM1rOGbfMQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTc3OQ==", "bodyText": "This is a notable change.", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431475779", "createdAt": "2020-05-27T22:21:03Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ0ODY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMTo0OVrOGbfNbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMzowOFrOGbfPmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjA3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * called TODO\n          \n          \n            \n                     * called the rate limit will refresh.", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476079", "createdAt": "2020-05-27T22:21:49Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.\n+         *\n+         * {@link GitHubClient#rateLimit(String)} will not query for a new rate limit until the current Record expires.\n+         * When {@link GitHubClient} is initialized it includes a default {@link GHRateLimit#Default()} which has\n+         * expired rate limit records. This guarantees that the first time {@link GitHubClient#rateLimit(String)} is\n+         * called TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjYzNA==", "bodyText": "TODO javadoc", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476634", "createdAt": "2020-05-27T22:23:08Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.\n+         *\n+         * {@link GitHubClient#rateLimit(String)} will not query for a new rate limit until the current Record expires.\n+         * When {@link GitHubClient} is initialized it includes a default {@link GHRateLimit#Default()} which has\n+         * expired rate limit records. This guarantees that the first time {@link GitHubClient#rateLimit(String)} is\n+         * called TODO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjA3OQ=="}, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ1MTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMjo0N1rOGbfO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMjo0N1rOGbfO9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQ3MQ==", "bodyText": "TODO javadoc", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476471", "createdAt": "2020-05-27T22:22:47Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -220,45 +247,107 @@ public int hashCode() {\n         return Objects.hash(getCore(), getSearch(), getGraphQL(), getIntegrationManifest());\n     }\n \n+    /**\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated information. If null, the current instance is returned.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s. If the merged instance is equivalent to\n+     *         either of the two existing limits, the matching instance is returned.\n+     */\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n     /**\n      * Gets the appropriate {@link Record} for a particular url path.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n+     * @param endpoint\n+     *            the rate limit endpoint specifier\n      * @return the {@link Record} for a url path.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecordForUrlPath(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        if (endpoint == GitHubRateLimitSpecifier.CORE) {\n+            return getCore();\n+        } else if (endpoint == GitHubRateLimitSpecifier.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (endpoint == GitHubRateLimitSpecifier.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (endpoint == GitHubRateLimitSpecifier.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit specifier: \" + endpoint.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        /**\n+         * This is set to a somewhat small duration, rather than a long one.\n+         *\n+         * {@link GitHubClient#rateLimit(String)} will not query for a new rate limit until the current Record expires.\n+         * When {@link GitHubClient} is initialized it includes a default {@link GHRateLimit#Default()} which has\n+         * expired rate limit records. This guarantees that the first time {@link GitHubClient#rateLimit(String)} is\n+         * called TODO\n+         *\n+         * The\n+         */\n+        static long unknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() * 1000;\n \n         static final int unknownLimit = 1000000;\n         static final int unknownRemaining = 999999;\n \n-        private UnknownLimitRecord() {\n-            super(unknownLimit, unknownRemaining, System.currentTimeMillis() / 1000L + unknownLimitResetSeconds);\n+        // The default UnknownLimitRecord is an expired record.\n+        private static final UnknownLimitRecord DEFAULT = new UnknownLimitRecord(Long.MIN_VALUE);\n+\n+        // The starting current UnknownLimitRecord is an expired record.\n+        private static UnknownLimitRecord current = DEFAULT;\n+\n+        /**\n+         * Internal For testing only.\n+         */\n+        UnknownLimitRecord() {\n+            this(System.currentTimeMillis() / 1000L + unknownLimitResetSeconds);\n+        }\n+\n+        /**\n+         * Not for use outside this class\n+         *\n+         * @param resetEpochSeconds\n+         *            the epoch second time when this record will expire.\n+         */\n+        private UnknownLimitRecord(long resetEpochSeconds) {\n+            super(unknownLimit, unknownRemaining, resetEpochSeconds);\n+        }\n+\n+        static synchronized Record current() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ1Mjg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMzoxOVrOGbfP6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMzoxOVrOGbfP6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjcxMw==", "bodyText": "TODO javadoc", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476713", "createdAt": "2020-05-27T22:23:19Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -66,16 +66,43 @@\n     private final Record integrationManifest;\n \n     @Nonnull\n-    static GHRateLimit Unknown() {\n-        return new GHRateLimit(new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord());\n+    static GHRateLimit Default() {\n+        return new GHRateLimit(UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT,\n+                UnknownLimitRecord.DEFAULT);\n+    }\n+\n+    @Nonnull\n+    static GHRateLimit Unknown(@Nonnull GitHubRateLimitSpecifier endpoint) {\n+        return fromHeaderRecord(UnknownLimitRecord.current(), endpoint);\n     }\n \n     @Nonnull\n-    static GHRateLimit fromHeaderRecord(Record header) {\n-        return new GHRateLimit(header, new UnknownLimitRecord(), new UnknownLimitRecord(), new UnknownLimitRecord());\n+    static GHRateLimit fromHeaderRecord(@Nonnull Record header, @Nonnull GitHubRateLimitSpecifier rateLimitSpecifier) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ1MzA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMzoyMlrOGbfQBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMzoyMlrOGbfQBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Njc0MQ==", "bodyText": "TODO javadoc", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431476741", "createdAt": "2020-05-27T22:23:22Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -66,16 +66,43 @@\n     private final Record integrationManifest;\n \n     @Nonnull\n-    static GHRateLimit Unknown() {\n-        return new GHRateLimit(new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord(),\n-                new UnknownLimitRecord());\n+    static GHRateLimit Default() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ1NjU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHub.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNDo1N1rOGbfSNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyNDo1N1rOGbfSNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzMwMA==", "bodyText": "TODO javadoc\nMention header information", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431477300", "createdAt": "2020-05-27T22:24:57Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHub.java", "diffHunk": "@@ -373,12 +373,19 @@ public String getApiUrl() {\n     }\n \n     /**\n-     * Gets the current rate limit.\n+     * Gets the current rate limit from the server.\n+     *\n+     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In that\n+     * case, if the most recent {@link GHRateLimit} will be returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzQ2NDQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyODoxOVrOGbfXUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyODoxOVrOGbfXUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODYxMQ==", "bodyText": "TODO, consider making fetch() take a builder instead of a urlPath?", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r431478611", "createdAt": "2020-05-27T22:28:19Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -210,69 +211,106 @@ public boolean isAnonymous() {\n     /**\n      * Gets the current rate limit from the server.\n      *\n-     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In\n-     * that, if {@link #lastRateLimit()} is not {@code null} and is not expired, it will be returned. Otherwise, a\n-     * placeholder {@link GHRateLimit} instance with {@link GHRateLimit.UnknownLimitRecord}s will be returned.\n+     * For some versions of GitHub Enterprise, the {@code /rate_limit} endpoint returns a {@code 404 Not Found}. In that\n+     * case, if the most recent {@link GHRateLimit} will be returned.\n+     *\n+     * For most use cases it would be better to implement a {@link RateLimitChecker} and add it via\n+     * {@link GitHubBuilder#withRateLimitChecker(RateLimitChecker)}.\n      *\n      * @return the rate limit\n      * @throws IOException\n      *             the io exception\n      */\n     @Nonnull\n     public GHRateLimit getRateLimit() throws IOException {\n+        return getRateLimit(GitHubRateLimitSpecifier.NONE);\n+    }\n+\n+    @Nonnull\n+    GHRateLimit getRateLimit(@Nonnull GitHubRateLimitSpecifier rateLimitSpecifier) throws IOException {\n         GHRateLimit result;\n         try {\n-            result = fetch(JsonRateLimit.class, \"/rate_limit\").resources;\n+            GitHubRequest request = GitHubRequest.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "363385ee96b89a09c0c68f6d078bb2f8aa3e491d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNDYyMjg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMDoxNTo1MVrOGuhcTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMDo0NDo1NFrOGu929A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQzNTU5Nw==", "bodyText": "this seems a bit strange?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() / 1000;\n          \n          \n            \n                    private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).getSeconds();", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r451435597", "createdAt": "2020-07-08T10:15:51Z", "author": {"login": "timja"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -221,44 +264,112 @@ public int hashCode() {\n     }\n \n     /**\n-     * Gets the appropriate {@link Record} for a particular url path.\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated {@link Record}s.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s from these two instances. If the merged\n+     *         instance is equal to the current instance, the current instance is returned. If the merged instance is\n+     *         equal to the current instance, the current instance is returned.\n+     */\n+    @Nonnull\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n+    /**\n+     * Gets the specified {@link Record}.\n+     *\n+     * {@link RateLimitTarget#NONE} will return {@link UnknownLimitRecord#DEFAULT} to prevent any clients from\n+     * accidentally waiting on that record to reset before continuing.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n-     * @return the {@link Record} for a url path.\n+     * @param rateLimitTarget\n+     *            the target rate limit record\n+     * @return the target {@link Record} from this instance.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecord(@Nonnull RateLimitTarget rateLimitTarget) {\n+        if (rateLimitTarget == RateLimitTarget.CORE) {\n+            return getCore();\n+        } else if (rateLimitTarget == RateLimitTarget.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (rateLimitTarget == RateLimitTarget.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit target: \" + rateLimitTarget.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() / 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97218ffd5d2f4706c69b8520869f6489e959b4c"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMTE3Mg==", "bodyText": "@timja\nThere is a Duration.toSeconds(); but only in Java 11+.\ngetSeconds() is not quite the same as toSeconds(), but you are correct for this case it can be considered the same.", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r451901172", "createdAt": "2020-07-09T00:44:54Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRateLimit.java", "diffHunk": "@@ -221,44 +264,112 @@ public int hashCode() {\n     }\n \n     /**\n-     * Gets the appropriate {@link Record} for a particular url path.\n+     * Merge a {@link GHRateLimit} with another one to create a new {@link GHRateLimit} keeping the latest\n+     * {@link Record}s from each.\n+     * \n+     * @param newLimit\n+     *            {@link GHRateLimit} with potentially updated {@link Record}s.\n+     * @return a merged {@link GHRateLimit} with the latest {@link Record}s from these two instances. If the merged\n+     *         instance is equal to the current instance, the current instance is returned. If the merged instance is\n+     *         equal to the current instance, the current instance is returned.\n+     */\n+    @Nonnull\n+    GHRateLimit getMergedRateLimit(@Nonnull GHRateLimit newLimit) {\n+\n+        GHRateLimit merged = new GHRateLimit(getCore().currentOrUpdated(newLimit.getCore()),\n+                getSearch().currentOrUpdated(newLimit.getSearch()),\n+                getGraphQL().currentOrUpdated(newLimit.getGraphQL()),\n+                getIntegrationManifest().currentOrUpdated(newLimit.getIntegrationManifest()));\n+\n+        if (merged.equals(this)) {\n+            merged = this;\n+        }\n+\n+        return merged;\n+    }\n+\n+    /**\n+     * Gets the specified {@link Record}.\n+     *\n+     * {@link RateLimitTarget#NONE} will return {@link UnknownLimitRecord#DEFAULT} to prevent any clients from\n+     * accidentally waiting on that record to reset before continuing.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n-     * @return the {@link Record} for a url path.\n+     * @param rateLimitTarget\n+     *            the target rate limit record\n+     * @return the target {@link Record} from this instance.\n      */\n     @Nonnull\n-    Record getRecordForUrlPath(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n-            return new UnknownLimitRecord();\n-        } else if (urlPath.startsWith(\"/search\")) {\n+    Record getRecord(@Nonnull RateLimitTarget rateLimitTarget) {\n+        if (rateLimitTarget == RateLimitTarget.CORE) {\n+            return getCore();\n+        } else if (rateLimitTarget == RateLimitTarget.SEARCH) {\n             return getSearch();\n-        } else if (urlPath.startsWith(\"/graphql\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.GRAPHQL) {\n             return getGraphQL();\n-        } else if (urlPath.startsWith(\"/app-manifests\")) {\n+        } else if (rateLimitTarget == RateLimitTarget.INTEGRATION_MANIFEST) {\n             return getIntegrationManifest();\n+        } else if (rateLimitTarget == RateLimitTarget.NONE) {\n+            return UnknownLimitRecord.DEFAULT;\n         } else {\n-            return getCore();\n+            throw new IllegalArgumentException(\"Unknown rate limit target: \" + rateLimitTarget.toString());\n         }\n     }\n \n     /**\n      * A limit record used as a placeholder when the the actual limit is not known.\n-     * <p>\n-     * Has a large limit and long duration so that it will doesn't expire too often.\n      *\n      * @since 1.100\n      */\n     public static class UnknownLimitRecord extends Record {\n \n-        // One hour\n-        private static final long unknownLimitResetSeconds = 60L * 60L;\n+        private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).toMillis() / 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQzNTU5Nw=="}, "originalCommit": {"oid": "d97218ffd5d2f4706c69b8520869f6489e959b4c"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDExMDU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GitHubRateLimitChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo1NzozOFrOGv8v2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo1NzozOFrOGv8v2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzMTU0Nw==", "bodyText": "Instead of trying to guess corresponding rate limit checker from the url path, depend on the requester to provide that information.  Much simpler.", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r452931547", "createdAt": "2020-07-10T15:57:38Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubRateLimitChecker.java", "diffHunk": "@@ -122,24 +136,26 @@ void checkRateLimit(GitHubClient client, GitHubRequest request) throws IOExcepti\n \n     /**\n      * Gets the appropriate {@link RateLimitChecker} for a particular url path. Similar to\n-     * {@link GHRateLimit#getRecordForUrlPath(String)}.\n+     * {@link GHRateLimit#getRecord(RateLimitTarget)}.\n      *\n-     * @param urlPath\n-     *            the url path of the request\n-     * @return the {@link RateLimitChecker} for a url path.\n+     * @param rateLimitTarget\n+     *            the rate limit to check\n+     * @return the {@link RateLimitChecker} for a particular target\n      */\n     @Nonnull\n-    private RateLimitChecker selectChecker(@Nonnull String urlPath) {\n-        if (urlPath.equals(\"/rate_limit\")) {\n+    private RateLimitChecker selectChecker(@Nonnull RateLimitTarget rateLimitTarget) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa4a8341f000b4df87b6fa7dd5fe0e9f05002ce3"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTMyNjI2OnYy", "diffSide": "LEFT", "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToyMToyMFrOGxh4Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToyMToyMFrOGxh4Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4ODQ0Mg==", "bodyText": "Merge and equality logic moved into GHRateLimit.", "url": "https://github.com/hub4j/github-api/pull/830#discussion_r454588442", "createdAt": "2020-07-14T19:21:20Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GitHubClient.java", "diffHunk": "@@ -654,37 +641,6 @@ private boolean isPrivateModeEnabled() {\n         }\n     }\n \n-    /**\n-     * Determine if one {@link GHRateLimit.Record} should replace another. Header date is only accurate to the second,\n-     * so we look at the information in the record itself.\n-     *\n-     * {@link GHRateLimit.UnknownLimitRecord}s are always replaced by regular {@link GHRateLimit.Record}s. Regular\n-     * {@link GHRateLimit.Record}s are never replaced by {@link GHRateLimit.UnknownLimitRecord}s. Candidates with\n-     * resetEpochSeconds later than current record are more recent. Candidates with the same reset and a lower remaining\n-     * count are more recent. Candidates with an earlier reset are older.\n-     *\n-     * @param candidate\n-     *            {@link GHRateLimit.Record} constructed from the response header information\n-     * @param current\n-     *            the current {@link GHRateLimit.Record} record\n-     */\n-    static boolean shouldReplace(@Nonnull GHRateLimit.Record candidate, @Nonnull GHRateLimit.Record current) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b3f81ee348e256a4d23af4cab15903619098d04"}, "originalPosition": 301}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1795, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}