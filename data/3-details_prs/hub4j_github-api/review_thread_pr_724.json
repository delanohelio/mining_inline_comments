{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMjgxODI2", "number": 724, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxNzo1MFrODkNksg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoxNjoyMVrODk7D1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mjk3NzE0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/AppTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxNzo1MFrOFwaLVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxNzo1MFrOFwaLVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMwNDg1NQ==", "bodyText": "Single Update", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r386304855", "createdAt": "2020-03-02T10:17:50Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/AppTest.java", "diffHunk": "@@ -784,44 +784,47 @@ public void testRepoLabel() throws IOException {\n         }\n         assertTrue(lst.size() > 5);\n         GHLabel e = r.getLabel(\"enhancement\");\n-        assertEquals(\"enhancement\", e.getName());\n-        assertNotNull(e.getUrl());\n-        assertTrue(Pattern.matches(\"[0-9a-fA-F]{6}\", e.getColor()));\n+        assertEquals(\"enhancement\", e.name());\n+        assertNotNull(e.url());\n+        assertTrue(Pattern.matches(\"[0-9a-fA-F]{6}\", e.color()));\n \n         GHLabel t = null;\n         GHLabel t2 = null;\n         try {// CRUD\n             t = r.createLabel(\"test\", \"123456\");\n             t2 = r.getLabel(\"test\");\n-            assertEquals(t.getName(), t2.getName());\n-            assertEquals(t.getColor(), \"123456\");\n-            assertEquals(t.getColor(), t2.getColor());\n-            assertEquals(t.getDescription(), \"\");\n-            assertEquals(t.getDescription(), t2.getDescription());\n-            assertEquals(t.getUrl(), t2.getUrl());\n-\n-            t.setColor(\"000000\");\n-\n-            // This is annoying behavior, but it is by design at this time.\n-            // Verifying so we can know when it is fixed.\n-            assertEquals(t.getColor(), \"123456\");\n+            assertEquals(t.name(), t2.name());\n+            assertEquals(t.color(), \"123456\");\n+            assertEquals(t.color(), t2.color());\n+            assertEquals(t.description(), \"\");\n+            assertEquals(t.description(), t2.description());\n+            assertEquals(t.url(), t2.url());\n+\n+            // update works on multiple changes in one call\n+            // t.setColor(\"\");\n+            t2 = t.update().color(\"000000\").description(\"It is dark!\").done();\n+\n+            // instances are immutable, but update returns a new updated instance.\n+            assertEquals(t.color(), \"123456\");\n+            assertEquals(t.description(), \"\");\n+            assertEquals(t2.color(), \"000000\");\n+            assertEquals(t2.description(), \"It is dark!\");\n \n             t = r.getLabel(\"test\");\n-            t.setDescription(\"this is also a test\");\n+            GHLabel t3 = t.set().description(\"this is also a test\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d59794b25f2db0889c3da09fe98a13d42e42181d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mjk3NzUzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/AppTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxNzo1OFrOFwaLnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxNzo1OFrOFwaLnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMwNDkyNA==", "bodyText": "Batch update", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r386304924", "createdAt": "2020-03-02T10:17:58Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/AppTest.java", "diffHunk": "@@ -784,44 +784,47 @@ public void testRepoLabel() throws IOException {\n         }\n         assertTrue(lst.size() > 5);\n         GHLabel e = r.getLabel(\"enhancement\");\n-        assertEquals(\"enhancement\", e.getName());\n-        assertNotNull(e.getUrl());\n-        assertTrue(Pattern.matches(\"[0-9a-fA-F]{6}\", e.getColor()));\n+        assertEquals(\"enhancement\", e.name());\n+        assertNotNull(e.url());\n+        assertTrue(Pattern.matches(\"[0-9a-fA-F]{6}\", e.color()));\n \n         GHLabel t = null;\n         GHLabel t2 = null;\n         try {// CRUD\n             t = r.createLabel(\"test\", \"123456\");\n             t2 = r.getLabel(\"test\");\n-            assertEquals(t.getName(), t2.getName());\n-            assertEquals(t.getColor(), \"123456\");\n-            assertEquals(t.getColor(), t2.getColor());\n-            assertEquals(t.getDescription(), \"\");\n-            assertEquals(t.getDescription(), t2.getDescription());\n-            assertEquals(t.getUrl(), t2.getUrl());\n-\n-            t.setColor(\"000000\");\n-\n-            // This is annoying behavior, but it is by design at this time.\n-            // Verifying so we can know when it is fixed.\n-            assertEquals(t.getColor(), \"123456\");\n+            assertEquals(t.name(), t2.name());\n+            assertEquals(t.color(), \"123456\");\n+            assertEquals(t.color(), t2.color());\n+            assertEquals(t.description(), \"\");\n+            assertEquals(t.description(), t2.description());\n+            assertEquals(t.url(), t2.url());\n+\n+            // update works on multiple changes in one call\n+            // t.setColor(\"\");\n+            t2 = t.update().color(\"000000\").description(\"It is dark!\").done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d59794b25f2db0889c3da09fe98a13d42e42181d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mjk4MDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/GHRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxODo1N1rOFwaNZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMDoxODo1N1rOFwaNZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMwNTM4Mw==", "bodyText": "Moved all the calls that create instances of GHLabel into that class.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r386305383", "createdAt": "2020-03-02T10:18:57Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHRepository.java", "diffHunk": "@@ -1842,9 +1842,7 @@ public GHCommitStatus createCommitStatus(String sha1, GHCommitState state, Strin\n      *             the io exception\n      */\n     public PagedIterable<GHLabel> listLabels() throws IOException {\n-        return root.createRequest()\n-                .withUrlPath(getApiTailUrl(\"labels\"))\n-                .toIterable(GHLabel[].class, item -> item.wrapUp(this));\n+        return GHLabel.readAll(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d59794b25f2db0889c3da09fe98a13d42e42181d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NTQzMTgzOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/kohsuke/github/AppTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoyNDoxN1rOFwxjWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMjoyNDoxN1rOFwxjWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4NzgzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // instances are immutable, but update returns a new updated instance.\n          \n          \n            \n                        // instances behave as immutable by default. Update returns a new updated instance.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r386687835", "createdAt": "2020-03-02T22:24:17Z", "author": {"login": "bitwiseman"}, "path": "src/test/java/org/kohsuke/github/AppTest.java", "diffHunk": "@@ -800,16 +800,19 @@ public void testRepoLabel() throws IOException {\n             assertEquals(t.getDescription(), t2.getDescription());\n             assertEquals(t.getUrl(), t2.getUrl());\n \n-            t.setColor(\"000000\");\n+            // update works on multiple changes in one call\n+            // t.setColor(\"\");\n+            t2 = t.update().color(\"000000\").description(\"It is dark!\").done();\n \n-            // This is annoying behavior, but it is by design at this time.\n-            // Verifying so we can know when it is fixed.\n+            // instances are immutable, but update returns a new updated instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f087c401ec891c4d3118c5afc75116af3d24a6"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzEwOTk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMTowNjo0OVrOFxBc4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwODo1MTowNFrOF37Qjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk0ODMyMQ==", "bodyText": "This threw me off the first time I read this code to realize that this is what ensures setters still make the REST API call instead of batching", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r386948321", "createdAt": "2020-03-03T11:06:49Z", "author": {"login": "res0nance"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+    private final Class<R> returnType;\n+    private final Class<S> intermediateReturnType;\n+    protected final Requester requester;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}.\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {\n+        R result;\n+        if (updateInPlace && baseInstance != null) {\n+            result = requester.fetchInto(baseInstance);\n+        } else {\n+            result = requester.fetch(returnType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Applies a value to a name for this builder.\n+     *\n+     * The internals of this method look terrifying, but they they're actually basically safe due to previous comparison\n+     * of U and T determined by comparing class instances passed in during construction.\n+     *\n+     * If U is the same as T, this cause the builder to commit changes after the first value change and return a T from\n+     * done().\n+     *\n+     * If U is not the same as T, the builder will batch together multiple changes and let the user call done() when\n+     * they are ready.\n+     *\n+     * This little bit of roughness in this base class means all inheriting builders get to create Updater and Setter\n+     * classes from almost identical code. Creator can be implemented with significant code reuse as well.\n+     *\n+     * There is probably a cleaner way to implement this, but I'm not sure what it is right now.\n+     *\n+     * @param name\n+     *            the name of the field\n+     * @param value\n+     *            the value of the field\n+     * @return either a continuing builder or an updated data record\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Nonnull\n+    protected S with(@Nonnull String name, Object value) throws IOException {\n+        requester.with(name, value);\n+        if (returnType.equals(intermediateReturnType)) {\n+            return intermediateReturnType.cast(done());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cec3e67cfc4ee0b4d0d0c1a28c325113b5e5a229"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEwNzcyMQ==", "bodyText": "I should make it a method or boolean field with comments to make it clearer.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387107721", "createdAt": "2020-03-03T15:43:08Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+    private final Class<R> returnType;\n+    private final Class<S> intermediateReturnType;\n+    protected final Requester requester;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}.\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {\n+        R result;\n+        if (updateInPlace && baseInstance != null) {\n+            result = requester.fetchInto(baseInstance);\n+        } else {\n+            result = requester.fetch(returnType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Applies a value to a name for this builder.\n+     *\n+     * The internals of this method look terrifying, but they they're actually basically safe due to previous comparison\n+     * of U and T determined by comparing class instances passed in during construction.\n+     *\n+     * If U is the same as T, this cause the builder to commit changes after the first value change and return a T from\n+     * done().\n+     *\n+     * If U is not the same as T, the builder will batch together multiple changes and let the user call done() when\n+     * they are ready.\n+     *\n+     * This little bit of roughness in this base class means all inheriting builders get to create Updater and Setter\n+     * classes from almost identical code. Creator can be implemented with significant code reuse as well.\n+     *\n+     * There is probably a cleaner way to implement this, but I'm not sure what it is right now.\n+     *\n+     * @param name\n+     *            the name of the field\n+     * @param value\n+     *            the value of the field\n+     * @return either a continuing builder or an updated data record\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Nonnull\n+    protected S with(@Nonnull String name, Object value) throws IOException {\n+        requester.with(name, value);\n+        if (returnType.equals(intermediateReturnType)) {\n+            return intermediateReturnType.cast(done());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk0ODMyMQ=="}, "originalCommit": {"oid": "cec3e67cfc4ee0b4d0d0c1a28c325113b5e5a229"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NjA2Ng==", "bodyText": "@res0nance How about now? Better?", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387466066", "createdAt": "2020-03-04T06:12:28Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+    private final Class<R> returnType;\n+    private final Class<S> intermediateReturnType;\n+    protected final Requester requester;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}.\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {\n+        R result;\n+        if (updateInPlace && baseInstance != null) {\n+            result = requester.fetchInto(baseInstance);\n+        } else {\n+            result = requester.fetch(returnType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Applies a value to a name for this builder.\n+     *\n+     * The internals of this method look terrifying, but they they're actually basically safe due to previous comparison\n+     * of U and T determined by comparing class instances passed in during construction.\n+     *\n+     * If U is the same as T, this cause the builder to commit changes after the first value change and return a T from\n+     * done().\n+     *\n+     * If U is not the same as T, the builder will batch together multiple changes and let the user call done() when\n+     * they are ready.\n+     *\n+     * This little bit of roughness in this base class means all inheriting builders get to create Updater and Setter\n+     * classes from almost identical code. Creator can be implemented with significant code reuse as well.\n+     *\n+     * There is probably a cleaner way to implement this, but I'm not sure what it is right now.\n+     *\n+     * @param name\n+     *            the name of the field\n+     * @param value\n+     *            the value of the field\n+     * @return either a continuing builder or an updated data record\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Nonnull\n+    protected S with(@Nonnull String name, Object value) throws IOException {\n+        requester.with(name, value);\n+        if (returnType.equals(intermediateReturnType)) {\n+            return intermediateReturnType.cast(done());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk0ODMyMQ=="}, "originalCommit": {"oid": "cec3e67cfc4ee0b4d0d0c1a28c325113b5e5a229"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE4Njg5NA==", "bodyText": "Much better", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r394186894", "createdAt": "2020-03-18T08:51:04Z", "author": {"login": "res0nance"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+    private final Class<R> returnType;\n+    private final Class<S> intermediateReturnType;\n+    protected final Requester requester;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}.\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {\n+        R result;\n+        if (updateInPlace && baseInstance != null) {\n+            result = requester.fetchInto(baseInstance);\n+        } else {\n+            result = requester.fetch(returnType);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Applies a value to a name for this builder.\n+     *\n+     * The internals of this method look terrifying, but they they're actually basically safe due to previous comparison\n+     * of U and T determined by comparing class instances passed in during construction.\n+     *\n+     * If U is the same as T, this cause the builder to commit changes after the first value change and return a T from\n+     * done().\n+     *\n+     * If U is not the same as T, the builder will batch together multiple changes and let the user call done() when\n+     * they are ready.\n+     *\n+     * This little bit of roughness in this base class means all inheriting builders get to create Updater and Setter\n+     * classes from almost identical code. Creator can be implemented with significant code reuse as well.\n+     *\n+     * There is probably a cleaner way to implement this, but I'm not sure what it is right now.\n+     *\n+     * @param name\n+     *            the name of the field\n+     * @param value\n+     *            the value of the field\n+     * @return either a continuing builder or an updated data record\n+     * @throws IOException\n+     *             if an I/O error occurs\n+     */\n+    @Nonnull\n+    protected S with(@Nonnull String name, Object value) throws IOException {\n+        requester.with(name, value);\n+        if (returnType.equals(intermediateReturnType)) {\n+            return intermediateReturnType.cast(done());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk0ODMyMQ=="}, "originalCommit": {"oid": "cec3e67cfc4ee0b4d0d0c1a28c325113b5e5a229"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDQyNDI4OnYy", "diffSide": "LEFT", "path": "src/main/java/org/kohsuke/github/GHLabel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoxMzowNVrOFxhD6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoxMzowNVrOFxhD6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NjIxNg==", "bodyText": "Replaced wrapUp() with lateBind().\nUpdate: removed need for late bind.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387466216", "createdAt": "2020-03-04T06:13:05Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/GHLabel.java", "diffHunk": "@@ -48,41 +69,23 @@ public String getColor() {\n      *\n      * @return the description\n      */\n+    @Nonnull\n     public String getDescription() {\n         return description;\n     }\n \n-    GHLabel wrapUp(GHRepository repo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDQyOTY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoxNjoyMlrOFxhHRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODozMDo1NlrOF47VZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NzA3OQ==", "bodyText": "Any suggestions for a better method name than done()?   send()?  submit()?\nWe can't use commit() because it will almost surely collide with a git \"commit\" at least conceptually if not literally.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387467079", "createdAt": "2020-03-04T06:16:22Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An abstract data object builder/updater.\n+ *\n+ * This class can be use to make a Builder that supports both batch and single property changes.\n+ * <p>\n+ * Batching looks like this:\n+ * \n+ * <pre>\n+ * update().someName(value).otherName(value).done()\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * Single changee look like this:\n+ * \n+ * <pre>\n+ * set().someName(value);\n+ * set().otherName(value);\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * If S is the same as R, {@link #with(String, Object)} will commit changes after the first value change and return a R\n+ * from {@link #done()}.\n+ * </p>\n+ * <p>\n+ * If S is not the same as R, {@link #with(String, Object)} will batch together multiple changes and let the user call\n+ * {@link #done()} when they are ready.\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    @Nonnull\n+    private final Class<R> returnType;\n+\n+    @Nonnull\n+    private final Class<S> intermediateReturnType;\n+\n+    private final boolean commitChangesImmediately;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    @Nonnull\n+    protected final Requester requester;\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}. Must either be equal\n+     *            to {@code builtReturnType} or this instance must be castable to this class. If not, the constructor\n+     *            {@link IllegalArgumentException}\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.commitChangesImmediately = returnType.equals(intermediateReturnType);\n+        if (!commitChangesImmediately && intermediateReturnType.isInstance(this)) {\n+            throw new IllegalArgumentException(\n+                    \"Argument \\\"intermediateReturnType\\\": This instance must be castable to intermediateReturnType or intermediateReturnType must be equal to builtReturnType.\");\n+        }\n+\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ3MTE4Mw==", "bodyText": "BulkChange in core uses commit and abort. abort is not needed. Maybe send is a good choice. or call?", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387471183", "createdAt": "2020-03-04T06:31:38Z", "author": {"login": "res0nance"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An abstract data object builder/updater.\n+ *\n+ * This class can be use to make a Builder that supports both batch and single property changes.\n+ * <p>\n+ * Batching looks like this:\n+ * \n+ * <pre>\n+ * update().someName(value).otherName(value).done()\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * Single changee look like this:\n+ * \n+ * <pre>\n+ * set().someName(value);\n+ * set().otherName(value);\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * If S is the same as R, {@link #with(String, Object)} will commit changes after the first value change and return a R\n+ * from {@link #done()}.\n+ * </p>\n+ * <p>\n+ * If S is not the same as R, {@link #with(String, Object)} will batch together multiple changes and let the user call\n+ * {@link #done()} when they are ready.\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    @Nonnull\n+    private final Class<R> returnType;\n+\n+    @Nonnull\n+    private final Class<S> intermediateReturnType;\n+\n+    private final boolean commitChangesImmediately;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    @Nonnull\n+    protected final Requester requester;\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}. Must either be equal\n+     *            to {@code builtReturnType} or this instance must be castable to this class. If not, the constructor\n+     *            {@link IllegalArgumentException}\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.commitChangesImmediately = returnType.equals(intermediateReturnType);\n+        if (!commitChangesImmediately && intermediateReturnType.isInstance(this)) {\n+            throw new IllegalArgumentException(\n+                    \"Argument \\\"intermediateReturnType\\\": This instance must be castable to intermediateReturnType or intermediateReturnType must be equal to builtReturnType.\");\n+        }\n+\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NzA3OQ=="}, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ3NTUwNg==", "bodyText": "The two places this will get used look something like this:\nGHLabel label = GHLabel.create().name(name).color(color).description(description).xxxx();\nlabel.update().color(color2).description(description2).xxxx();\nsend() could work.  call not as much. I'd just like to make sure we've considered alternatives before releasing this.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r387475506", "createdAt": "2020-03-04T06:47:18Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An abstract data object builder/updater.\n+ *\n+ * This class can be use to make a Builder that supports both batch and single property changes.\n+ * <p>\n+ * Batching looks like this:\n+ * \n+ * <pre>\n+ * update().someName(value).otherName(value).done()\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * Single changee look like this:\n+ * \n+ * <pre>\n+ * set().someName(value);\n+ * set().otherName(value);\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * If S is the same as R, {@link #with(String, Object)} will commit changes after the first value change and return a R\n+ * from {@link #done()}.\n+ * </p>\n+ * <p>\n+ * If S is not the same as R, {@link #with(String, Object)} will batch together multiple changes and let the user call\n+ * {@link #done()} when they are ready.\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    @Nonnull\n+    private final Class<R> returnType;\n+\n+    @Nonnull\n+    private final Class<S> intermediateReturnType;\n+\n+    private final boolean commitChangesImmediately;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    @Nonnull\n+    protected final Requester requester;\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}. Must either be equal\n+     *            to {@code builtReturnType} or this instance must be castable to this class. If not, the constructor\n+     *            {@link IllegalArgumentException}\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.commitChangesImmediately = returnType.equals(intermediateReturnType);\n+        if (!commitChangesImmediately && intermediateReturnType.isInstance(this)) {\n+            throw new IllegalArgumentException(\n+                    \"Argument \\\"intermediateReturnType\\\": This instance must be castable to intermediateReturnType or intermediateReturnType must be equal to builtReturnType.\");\n+        }\n+\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NzA3OQ=="}, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzMzE0OQ==", "bodyText": "Okay, well, this api is internal, so changing it later is not a breaking API change.  I'll go with the current verbs for now and we can change them later if needed.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r393933149", "createdAt": "2020-03-17T19:56:13Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An abstract data object builder/updater.\n+ *\n+ * This class can be use to make a Builder that supports both batch and single property changes.\n+ * <p>\n+ * Batching looks like this:\n+ * \n+ * <pre>\n+ * update().someName(value).otherName(value).done()\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * Single changee look like this:\n+ * \n+ * <pre>\n+ * set().someName(value);\n+ * set().otherName(value);\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * If S is the same as R, {@link #with(String, Object)} will commit changes after the first value change and return a R\n+ * from {@link #done()}.\n+ * </p>\n+ * <p>\n+ * If S is not the same as R, {@link #with(String, Object)} will batch together multiple changes and let the user call\n+ * {@link #done()} when they are ready.\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    @Nonnull\n+    private final Class<R> returnType;\n+\n+    @Nonnull\n+    private final Class<S> intermediateReturnType;\n+\n+    private final boolean commitChangesImmediately;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    @Nonnull\n+    protected final Requester requester;\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}. Must either be equal\n+     *            to {@code builtReturnType} or this instance must be castable to this class. If not, the constructor\n+     *            {@link IllegalArgumentException}\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.commitChangesImmediately = returnType.equals(intermediateReturnType);\n+        if (!commitChangesImmediately && intermediateReturnType.isInstance(this)) {\n+            throw new IllegalArgumentException(\n+                    \"Argument \\\"intermediateReturnType\\\": This instance must be castable to intermediateReturnType or intermediateReturnType must be equal to builtReturnType.\");\n+        }\n+\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NzA3OQ=="}, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIzNjcwOA==", "bodyText": "Hm, doh, no, what was I thinking this is public.  Ah, but I can use the same structure we already have for API Previews and ship this now.  \ud83d\ude04There we go.", "url": "https://github.com/hub4j/github-api/pull/724#discussion_r395236708", "createdAt": "2020-03-19T18:30:56Z", "author": {"login": "bitwiseman"}, "path": "src/main/java/org/kohsuke/github/AbstractBuilder.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.kohsuke.github;\n+\n+import java.io.IOException;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * An abstract data object builder/updater.\n+ *\n+ * This class can be use to make a Builder that supports both batch and single property changes.\n+ * <p>\n+ * Batching looks like this:\n+ * \n+ * <pre>\n+ * update().someName(value).otherName(value).done()\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * Single changee look like this:\n+ * \n+ * <pre>\n+ * set().someName(value);\n+ * set().otherName(value);\n+ * </pre>\n+ * </p>\n+ * <p>\n+ * If S is the same as R, {@link #with(String, Object)} will commit changes after the first value change and return a R\n+ * from {@link #done()}.\n+ * </p>\n+ * <p>\n+ * If S is not the same as R, {@link #with(String, Object)} will batch together multiple changes and let the user call\n+ * {@link #done()} when they are ready.\n+ *\n+ * @param <R>\n+ *            Final return type for built by this builder returned when {@link #done()}} is called.\n+ * @param <S>\n+ *            Intermediate return type for this builder returned by calls to {@link #with(String, Object)}. If {@link S}\n+ *            the same as {@link R}, this builder will commit changes after each call to {@link #with(String, Object)}.\n+ */\n+abstract class AbstractBuilder<R, S> {\n+\n+    @Nonnull\n+    private final Class<R> returnType;\n+\n+    @Nonnull\n+    private final Class<S> intermediateReturnType;\n+\n+    private final boolean commitChangesImmediately;\n+\n+    @CheckForNull\n+    private final R baseInstance;\n+\n+    @Nonnull\n+    protected final Requester requester;\n+\n+    // TODO: Not sure how update-in-place behavior should be controlled, but\n+    // it certainly can be controlled dynamically down to the instance level or inherited for all children of some\n+    // connection.\n+    protected boolean updateInPlace;\n+\n+    /**\n+     * Creates a builder.\n+     *\n+     * @param root\n+     *            the GitHub instance to connect to.\n+     * @param intermediateReturnType\n+     *            the intermediate return type returned by calls to {@link #with(String, Object)}. Must either be equal\n+     *            to {@code builtReturnType} or this instance must be castable to this class. If not, the constructor\n+     *            {@link IllegalArgumentException}\n+     * @param builtReturnType\n+     *            the final return type for built by this builder returned when {@link #done()}} is called.\n+     * @param baseInstance\n+     *            optional instance on which to base this builder.\n+     */\n+    protected AbstractBuilder(@Nonnull GitHub root,\n+            @Nonnull Class<S> intermediateReturnType,\n+            @Nonnull Class<R> builtReturnType,\n+            @CheckForNull R baseInstance) {\n+        this.requester = root.createRequest();\n+        this.returnType = builtReturnType;\n+        this.intermediateReturnType = intermediateReturnType;\n+        this.commitChangesImmediately = returnType.equals(intermediateReturnType);\n+        if (!commitChangesImmediately && intermediateReturnType.isInstance(this)) {\n+            throw new IllegalArgumentException(\n+                    \"Argument \\\"intermediateReturnType\\\": This instance must be castable to intermediateReturnType or intermediateReturnType must be equal to builtReturnType.\");\n+        }\n+\n+        this.baseInstance = baseInstance;\n+        this.updateInPlace = false;\n+\n+    }\n+\n+    /**\n+     * Finishes an update, committing changes.\n+     *\n+     * This method may update-in-place or not. Either way it returns the resulting instance.\n+     *\n+     * @return an instance with updated current data\n+     * @throws IOException\n+     *             if there is an I/O Exception\n+     */\n+    @Nonnull\n+    public R done() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NzA3OQ=="}, "originalCommit": {"oid": "d1205ff97144bd929364f834a380214da3a430d9"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1878, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}