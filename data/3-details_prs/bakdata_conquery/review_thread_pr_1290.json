{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MDM5ODk0", "number": 1290, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0ODowMFrOERB65g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1ODoxNVrOEXMrJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjkyNzEwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0ODowMFrOG1g0RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0ODowMFrOG1g0RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTM4MA==", "bodyText": "kannst du das boolean flag invertieren auf displayLogout finde so invertierte Namen/Semantiken ungeschickt", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458765380", "createdAt": "2020-07-22T12:48:00Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "diffHunk": "@@ -33,6 +33,7 @@\n \tpublic FEMeInformation getUserInformation(@NonNull User user){\n \t\treturn FEMeInformation.builder()\n \t\t\t.userName(user.getLabel())\n+\t\t\t.hideUserLogout(user.isHideUserLogout())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjkzMDQwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0OTowMFrOG1g2Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTo1Njo0MFrOG2RFhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA==", "bodyText": "Warum ist das pro User?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458765910", "createdAt": "2020-07-22T12:49:00Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "diffHunk": "@@ -36,6 +37,9 @@\n \tprivate String name;\n \t@Getter @Setter @NonNull @NotNull\n \tprivate String label;\n+\t\n+\t@Getter @Setter @JsonIgnore\n+\tprivate transient boolean hideUserLogout = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg4NjUyNg==", "bodyText": "Weil User auf unterschiedlichen wegen authentifiziert werden k\u00f6nnen. Abh\u00e4ngig davon wie sie authentifiziert wurden, soll der Logout sichtbar sein.", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458886526", "createdAt": "2020-07-22T15:37:17Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "diffHunk": "@@ -36,6 +37,9 @@\n \tprivate String name;\n \t@Getter @Setter @NonNull @NotNull\n \tprivate String label;\n+\t\n+\t@Getter @Setter @JsonIgnore\n+\tprivate transient boolean hideUserLogout = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}, "originalCommit": {"oid": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkwMTExOQ==", "bodyText": "Wenn ich mich mit RealmA einlogge (der nicht ausloggen kann), und dann mit RealmB einlogge der ausloggen kann, was steht dann im User?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458901119", "createdAt": "2020-07-22T15:57:51Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "diffHunk": "@@ -36,6 +37,9 @@\n \tprivate String name;\n \t@Getter @Setter @NonNull @NotNull\n \tprivate String label;\n+\t\n+\t@Getter @Setter @JsonIgnore\n+\tprivate transient boolean hideUserLogout = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}, "originalCommit": {"oid": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1NjIyOQ==", "bodyText": "In der Reihenfolge steht dort, dass dir der logout button angezeigt werden soll", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r459556229", "createdAt": "2020-07-23T15:56:40Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "diffHunk": "@@ -36,6 +37,9 @@\n \tprivate String name;\n \t@Getter @Setter @NonNull @NotNull\n \tprivate String label;\n+\t\n+\t@Getter @Setter @JsonIgnore\n+\tprivate transient boolean hideUserLogout = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}, "originalCommit": {"oid": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDAwMzYzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo1NzozMFrOG5cXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDoxMTowOFrOG5czzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4NjcyNg==", "bodyText": "hast du den Namen der Variable vergessen anzupassen?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462886726", "createdAt": "2020-07-30T09:57:30Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "diffHunk": "@@ -65,6 +66,7 @@ public static FEGroup from(@NonNull Group group) {\n \t@Builder\n \tpublic static class FEMeInformation {\n \t\tString userName;\n+\t\tboolean hideUserLogout;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NDAzMQ==", "bodyText": "Das Frontend nimmt das zur Zeit so", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462894031", "createdAt": "2020-07-30T10:11:08Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "diffHunk": "@@ -65,6 +66,7 @@ public static FEGroup from(@NonNull Group group) {\n \t@Builder\n \tpublic static class FEMeInformation {\n \t\tString userName;\n+\t\tboolean hideUserLogout;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4NjcyNg=="}, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDAxMDAwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo1OToyMFrOG5cbRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo1OToyMFrOG5cbRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzc0OQ==", "bodyText": "eine zeile", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462887749", "createdAt": "2020-07-30T09:59:20Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDAxMTM5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo1OTo0NFrOG5ccKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMDowMVrOG5ccyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzk3Ng==", "bodyText": "inline", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462887976", "createdAt": "2020-07-30T09:59:44Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODEzNg==", "bodyText": "return true/return false", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462888136", "createdAt": "2020-07-30T10:00:01Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzk3Ng=="}, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDAxNjE2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMTowN1rOG5cfBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwODo1ODoxNlrOG6BPvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODcxMA==", "bodyText": "K\u00f6nntest du das ErrorObject nicht als Cause in die Exception stecken?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462888710", "createdAt": "2020-07-30T10:01:07Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5MTAwNg==", "bodyText": "Das ist leider kein Throwable", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r463491006", "createdAt": "2020-07-31T08:58:16Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODcxMA=="}, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDAyNTIxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMzo1MlrOG5ckpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMzo1MlrOG5ckpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDE1MA==", "bodyText": "javax.ws.rs.core.UriBuilder\ngerade entdeckt, vlt ist das sinnvoller heir?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462890150", "createdAt": "2020-07-30T10:03:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());\n+\t\t\tthrow new AuthenticationException(\"Unable to retrieve access token from auth server.\");\n+\t\t}\n+\t\telse if (!(response instanceof TokenIntrospectionSuccessResponse)) {\n+\t\t\tlog.error(\"Unknown token response {}.\", response.getClass().getName());\n+\t\t\tthrow new AuthenticationException(\"Unknown token response. See log.\");\n+\t\t}\n+\n+\t\tTokenIntrospectionSuccessResponse successResponse = response.toSuccessResponse();\n+\t\tif(!successResponse.isActive()) {\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\t\treturn successResponse;\n+\t}\n+\n+\t@Override\n+\tpublic AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\treturn TokenHandler.extractToken(request);\n+\t}\n+\t\n+\t@Override\n+\tpublic void registerAdminUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t\tjerseyConfig.register(LoginResource.class);\n+\t}\n+\n+\t@Override\n+\tpublic void registerApiUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t}\n+\n+\t@Override\n+\t@SneakyThrows\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\tSecret passwordSecret = new Secret(new String(password));\n+\n+\t\tAuthorizationGrant  grant = new ResourceOwnerPasswordCredentialsGrant(username, passwordSecret);\n+\t\t\t\t\n+\t\tURI tokenEndpoint =  new URL(new URL(config.getAuthServerUrl()), serverConf.getTokenEndpoint()).toURI();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU4OTcyOnYy", "diffSide": "RIGHT", "path": "backend/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1NDozNVrOG-2b4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1NDozNVrOG-2b4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1Njc2OQ==", "bodyText": "einr\u00fcckung ist kaputt", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r468556769", "createdAt": "2020-08-11T12:54:35Z", "author": {"login": "awildturtok"}, "path": "backend/pom.xml", "diffHunk": "@@ -232,6 +232,15 @@\n             <groupId>io.dropwizard</groupId>\n             <artifactId>dropwizard-metrics-graphite</artifactId>\n         </dependency>\n-\n+\t\t<dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75e9a342d8268857a7a4629486616d4ef9a1df7b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzU5ODEyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1Njo0NlrOG-2hCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNDozMjo1NVrOG_kGeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODA4OQ==", "bodyText": "die booleans sind falschrum?", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r468558089", "createdAt": "2020-08-11T12:56:46Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.UriBuilder;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\"Created new user: {}\", user);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tif(expTime.isBefore(now)) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75e9a342d8268857a7a4629486616d4ef9a1df7b"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMwNDk1Mg==", "bodyText": "Haben wir gekl\u00e4rt ;)", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r469304952", "createdAt": "2020-08-12T14:32:55Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.UriBuilder;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\"Created new user: {}\", user);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tif(expTime.isBefore(now)) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODA4OQ=="}, "originalCommit": {"oid": "75e9a342d8268857a7a4629486616d4ef9a1df7b"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzYwMzU3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1ODoxNVrOG-2kUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1ODoxNVrOG-2kUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODkzMA==", "bodyText": "Die newlines sind ganz nach meinem Geschmack! :D", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r468558930", "createdAt": "2020-08-11T12:58:15Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.UriBuilder;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\"Created new user: {}\", user);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tif(expTime.isBefore(now)) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());\n+\t\t\tthrow new AuthenticationException(\"Unable to retrieve access token from auth server.\");\n+\t\t}\n+\t\telse if (!(response instanceof TokenIntrospectionSuccessResponse)) {\n+\t\t\tlog.error(\"Unknown token response {}.\", response.getClass().getName());\n+\t\t\tthrow new AuthenticationException(\"Unknown token response. See log.\");\n+\t\t}\n+\n+\t\tTokenIntrospectionSuccessResponse successResponse = response.toSuccessResponse();\n+\t\tif(!successResponse.isActive()) {\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\t\treturn successResponse;\n+\t}\n+\n+\t@Override\n+\tpublic AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\treturn TokenHandler.extractToken(request);\n+\t}\n+\t\n+\t@Override\n+\tpublic void registerAdminUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t\tjerseyConfig.register(LoginResource.class);\n+\t}\n+\n+\t@Override\n+\tpublic void registerApiUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t}\n+\n+\t@Override\n+\t@SneakyThrows\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\tSecret passwordSecret = new Secret(new String(password));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75e9a342d8268857a7a4629486616d4ef9a1df7b"}, "originalPosition": 181}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1313, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}