{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NTc1Mzgw", "number": 1216, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0NDowMlrOECHgOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyOToxM1rOEKiOWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU1NTQ3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/MasterCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0NDowMlrOGeYFMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0NDowMlrOGeYFMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwNTAxMA==", "bodyText": "Hier sollte es einen lognachricht geben, wenn ein store nicht geladen werden konnte", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r434505010", "createdAt": "2020-06-03T11:44:02Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/MasterCommand.java", "diffHunk": "@@ -92,16 +95,26 @@ public void run(ConqueryConfig config, Environment environment) {\n \t\tenvironment.lifecycle().manage(this);\n \n \t\tlog.info(\"Started meta storage\");\n-\t\tfor (File directory : config.getStorage().getDirectory().listFiles()) {\n-\t\t\tif (directory.getName().startsWith(\"dataset_\")) {\n+\n+\t\tExecutorService loaders = Executors.newFixedThreadPool(config.getPreprocessor().getThreads());\n+\n+\n+\t\tfor (File directory : config.getStorage().getDirectory().listFiles((file, name) -> name.startsWith(\"dataset_\"))) {\n+\t\t\tloaders.submit(() -> {\n \t\t\t\tNamespaceStorage datasetStorage = NamespaceStorage.tryLoad(validator, config.getStorage(), directory);\n-\t\t\t\tif (datasetStorage != null) {\n-\t\t\t\t\tNamespace ns = new Namespace(datasetStorage);\n-\t\t\t\t\tns.initMaintenance(maintenanceService);\n-\t\t\t\t\tnamespaces.add(ns);\n+\n+\t\t\t\tif (datasetStorage == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e422adc66e4d6ff291e5eef4f2e1b43ceaa0637"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU2ODc2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/MasterCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0ODoyMFrOGeYNuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo0ODoyMFrOGeYNuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwNzE5NQ==", "bodyText": "Im SlaveCommand nimmst du config.getStorage().getThreads(). Das ist denke ich besser", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r434507195", "createdAt": "2020-06-03T11:48:20Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/MasterCommand.java", "diffHunk": "@@ -92,16 +95,26 @@ public void run(ConqueryConfig config, Environment environment) {\n \t\tenvironment.lifecycle().manage(this);\n \n \t\tlog.info(\"Started meta storage\");\n-\t\tfor (File directory : config.getStorage().getDirectory().listFiles()) {\n-\t\t\tif (directory.getName().startsWith(\"dataset_\")) {\n+\n+\t\tExecutorService loaders = Executors.newFixedThreadPool(config.getPreprocessor().getThreads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e422adc66e4d6ff291e5eef4f2e1b43ceaa0637"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjU3NzE3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MDo1NlrOGeYS0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MDo1NlrOGeYS0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwODQ5Nw==", "bodyText": "kann hier nicht alles bis auf diese Zeile aus dem try-block raus", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r434508497", "createdAt": "2020-06-03T11:50:56Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "diffHunk": "@@ -228,9 +242,18 @@ public void stop() throws Exception {\n \t}\n \tprivate void reportJobManagerStatus() {\n \t\ttry {\n-\t\t\tif(context!= null && context.isConnected()) {\n-\t\t\t\tcontext.trySend(new UpdateJobManagerStatus(jobManager.reportStatus()));\n+\t\t\tif (context == null || !context.isConnected()) {\n+\t\t\t\treturn;\n \t\t\t}\n+\n+\t\t\t// Collect the Slaves and all its workers jobs into a single queue\n+\t\t\tfinal JobManagerStatus jobManagerStatus = jobManager.reportStatus();\n+\n+\t\t\tfor (Worker worker : workers.getWorkers().values()) {\n+\t\t\t\tjobManagerStatus.getJobs().addAll(worker.getJobManager().reportStatus().getJobs());\n+\t\t\t}\n+\n+\t\t\tcontext.trySend(new UpdateJobManagerStatus(jobManagerStatus));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e422adc66e4d6ff291e5eef4f2e1b43ceaa0637"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYyNjUxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ConqueryStorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNjozMlrOGeYy7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNjozMlrOGeYy7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjcxOA==", "bodyText": "wie wir es besprochen haben, gibt es hier abh\u00e4ngigkeiten. Um die abh\u00e4ngigkeiten leicht zu managen, k\u00f6nntest du den executerservice an den store geben und der k\u00fcmmert sich selber darum auf welches store-loading er warten muss, bzw. welche er gleichzeitig starten kann.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r434516718", "createdAt": "2020-06-03T12:06:32Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ConqueryStorageImpl.java", "diffHunk": "@@ -47,12 +52,21 @@ public void loadData() {\n \t\tlog.info(\"Loading storage {} from {}\", this.getClass().getSimpleName(), directory);\n \n \t\ttry (final Timer.Context timer = JobMetrics.getStoreLoadingTimer()) {\n+\t\t\tfinal ExecutorService loaders = Executors.newFixedThreadPool(nThreads);\n+\n \t\t\tStopwatch all = Stopwatch.createStarted();\n \t\t\tfor (KeyIncludingStore<?, ?> store : stores) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e422adc66e4d6ff291e5eef4f2e1b43ceaa0637"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjc4NzQ1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjo1MjowNFrOGeaXyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjo1MjowNFrOGeaXyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0MjUzNg==", "bodyText": "Ich finde es nicht so toll wo die start und stop methoden f\u00fcr den manager aufgerufen werden", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r434542536", "createdAt": "2020-06-03T12:52:04Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "diffHunk": "@@ -1,40 +1,54 @@\n package com.bakdata.conquery.models.worker;\n \n+import java.io.Closeable;\n+import java.io.IOException;\n+\n import com.bakdata.conquery.io.mina.MessageSender;\n import com.bakdata.conquery.io.mina.NetworkSession;\n import com.bakdata.conquery.io.xodus.WorkerStorage;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.events.BucketManager;\n import com.bakdata.conquery.models.jobs.JobManager;\n+import com.bakdata.conquery.models.jobs.SimpleJob;\n import com.bakdata.conquery.models.messages.namespaces.NamespaceMessage;\n import com.bakdata.conquery.models.messages.network.MasterMessage;\n import com.bakdata.conquery.models.messages.network.NetworkMessage;\n import com.bakdata.conquery.models.messages.network.specific.ForwardToNamespace;\n import com.bakdata.conquery.models.query.QueryExecutor;\n+import lombok.AccessLevel;\n import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n \n-import java.io.Closeable;\n-import java.io.IOException;\n-\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n public class Worker implements MessageSender.Transforming<NamespaceMessage, NetworkMessage<?>>, Closeable {\n+\n+\t@Getter\n+\tprivate final WorkerInformation info;\n+\n \t@Getter\n \tprivate final JobManager jobManager;\n+\n \t@Getter\n \tprivate final WorkerStorage storage;\n+\n \t@Getter\n \tprivate final QueryExecutor queryExecutor;\n-\t@Getter\n-\tprivate final WorkerInformation info;\n+\n \t@Setter\n \tprivate NetworkSession session;\n-\t\n-\tpublic Worker(WorkerInformation info, JobManager jobManager, WorkerStorage storage, QueryExecutor queryExecutor) {\n-\t\tthis.info = info;\n-\t\tthis.jobManager = jobManager;\n-\t\tthis.storage = storage;\n-\t\tBucketManager bucketManager = new BucketManager(jobManager, storage, this);\n+\n+\n+\tpublic static Worker createWorker(WorkerInformation info, WorkerStorage storage, ConqueryConfig config) {\n+\t\tfinal JobManager jobManager = new JobManager(info.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e422adc66e4d6ff291e5eef4f2e1b43ceaa0637"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Njg2OTczOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ConqueryStorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoyMjo0OFrOGkd1Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoyMjo0OFrOGkd1Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg5MDY0Nw==", "bodyText": "R\u00fcckgabewert checken, um Timeout zu \u00fcberpr\u00fcfen", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r440890647", "createdAt": "2020-06-16T14:22:48Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ConqueryStorageImpl.java", "diffHunk": "@@ -40,34 +44,35 @@ public ConqueryStorageImpl(Validator validator, StorageConfig config, File direc\n \t\tthis.nThreads = config.getThreads();\n \t}\n \n-\tprotected void createStores(Collector<KeyIncludingStore<?,?>> collector) {\n-\t}\n+\tprotected abstract List<ListenableFuture<KeyIncludingStore<?,?>>> createStores(ListeningExecutorService pool)\n+\t\t\tthrows ExecutionException, InterruptedException;\n \n \t/**\n \t * Load all stores from disk.\n+\t *\n+\t * Create a ThreadPool that can be used to submit as many tasks in parallel as possible.\n \t */\n \t@Override\n-\tpublic void loadData() {\n-\t\tcreateStores(stores::add);\n+\tpublic final void loadData() {\n \t\tlog.info(\"Loading storage {} from {}\", this.getClass().getSimpleName(), directory);\n \n \t\ttry (final Timer.Context timer = JobMetrics.getStoreLoadingTimer()) {\n-\t\t\tfinal ExecutorService loaders = Executors.newFixedThreadPool(nThreads);\n+\t\t\tListeningExecutorService pool = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(getNThreads()));\n \n \t\t\tStopwatch all = Stopwatch.createStarted();\n-\t\t\tfor (KeyIncludingStore<?, ?> store : stores) {\n-\t\t\t\tloaders.submit(store::loadData);\n-\t\t\t}\n \n-\t\t\tloaders.shutdown();\n-\t\t\tloaders.awaitTermination(1, TimeUnit.DAYS);\n+\t\t\tfinal List<ListenableFuture<KeyIncludingStore<?,?>>> loaded = createStores(pool);\n+\n+\t\t\tstores.addAll(Futures.allAsList(loaded).get());\n+\n+\t\t\tpool.shutdown();\n+\t\t\tpool.awaitTermination(1, TimeUnit.DAYS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4bc76f89568523e2d3d01389ee58a8ec248c071"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Njg5ODc2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespacedStorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoyOTowMVrOGkeHkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoyOTowMVrOGkeHkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg5NTM3OA==", "bodyText": "Doku", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r440895378", "createdAt": "2020-06-16T14:29:01Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespacedStorageImpl.java", "diffHunk": "@@ -120,13 +126,26 @@ protected void createStores(Collector<KeyIncludingStore<?, ?>> collector) {\n \t\t\t});\n \n \n-\t\tcollector\n-\t\t\t.collect(dataset)\n-\t\t\t.collect(dictionaries)\n-\t\t\t.collect(concepts)\n-\t\t\t.collect(imports);\n+\t\tpool.submit(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4bc76f89568523e2d3d01389ee58a8ec248c071"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzMyNTk2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/WorkerStorageImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTo1OTowOVrOGkiXQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTo1OTowOVrOGkiXQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk2NDkzMQ==", "bodyText": "Der ImmutableList.builder von Guave ist hier vllt besser", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r440964931", "createdAt": "2020-06-16T15:59:09Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/WorkerStorageImpl.java", "diffHunk": "@@ -41,18 +47,36 @@ public void setBucketManager(BucketManager bucketManager) {\n \t}\n \n \t@Override\n-\tprotected void createStores(Collector<KeyIncludingStore<?, ?>> collector) {\n-\t\tsuper.createStores(collector);\n+\tprotected List<ListenableFuture<KeyIncludingStore<?, ?>>> createStores(ListeningExecutorService pool) throws ExecutionException, InterruptedException {\n+\n+\t\t// Load all base data first, then load worker specific data.\n+\t\tfinal List<ListenableFuture<KeyIncludingStore<?, ?>>> stores = super.createStores(pool);\n+\t\tFutures.allAsList(stores).get();\n+\n+\n \t\tworker = StoreInfo.WORKER.singleton(getEnvironment(), getValidator());\n \t\tblocks = StoreInfo.BUCKETS.identifiable(getEnvironment(), getValidator(), getCentralRegistry());\n \t\tcBlocks = StoreInfo.C_BLOCKS.identifiable(getEnvironment(), getValidator(), getCentralRegistry());\n-\t\t\n-\t\tcollector\n-\t\t\t.collect(worker)\n-\t\t\t.collect(blocks)\n-\t\t\t.collect(cBlocks);\n+\n+\t\treturn ListUtils.union(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4bc76f89568523e2d3d01389ee58a8ec248c071"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc1NzIxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/QueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyNTo0NlrOGpdYhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyNTo0NlrOGpdYhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNjIxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tdefault Stream<QueryJob> executeOn(QueryExecutionContext context, Collection<Entity> entities, ShardResult result) {\n          \n          \n            \n            \tdefault Stream<QueryJob> executeOn(QueryExecutionContext context, Collection<Entity> entities) {", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446126213", "createdAt": "2020-06-26T11:25:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/QueryPlan.java", "diffHunk": "@@ -8,12 +8,13 @@\n import com.bakdata.conquery.models.query.entity.Entity;\n import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n \n public interface QueryPlan {\n \n \tQueryPlan clone(CloneContext ctx);\n \n-\tdefault Stream<QueryJob> executeOn(QueryExecutionContext context, Collection<Entity> entities) {\n+\tdefault Stream<QueryJob> executeOn(QueryExecutionContext context, Collection<Entity> entities, ShardResult result) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc2MTM5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/QueryExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyNzoyMlrOGpdbRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyNzoyMlrOGpdbRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNjkxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.executeOn(context, entries, result)\n          \n          \n            \n            \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.executeOn(context, entries)", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446126919", "createdAt": "2020-06-26T11:27:22Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/QueryExecutor.java", "diffHunk": "@@ -5,51 +5,48 @@\n import java.util.Collection;\n import java.util.List;\n import java.util.Map.Entry;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n+import java.util.Queue;\n import java.util.stream.Collectors;\n \n-import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n import com.bakdata.conquery.models.query.entity.Entity;\n import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n import com.bakdata.conquery.models.query.results.EntityResult;\n import com.bakdata.conquery.models.query.results.ShardResult;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n-import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.ListenableFutureTask;\n import com.google.common.util.concurrent.MoreExecutors;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n import lombok.extern.slf4j.Slf4j;\n \n-@Slf4j\n+@Slf4j @RequiredArgsConstructor\n public class QueryExecutor implements Closeable {\n \n-\tprivate final ThreadPoolExecutor executor;\n-\tprivate final ListeningExecutorService pool;\n-\t\n-\tpublic QueryExecutor(ConqueryConfig config) {\n-\t\tthis.executor = config.getQueries().getExecutionPool().createService(\"Query Executor %d\");\n-\t\tthis.pool = MoreExecutors.listeningDecorator(executor);\n-\t}\n+\t@Getter\n+\tprivate final Queue<Runnable> jobs;\n \n \tpublic ShardResult execute(ShardResult result, QueryExecutionContext context, Entry<ManagedExecutionId, QueryPlan> entry) {\n \n-\t\treturn execute(result, context, entry, pool);\n+\t\treturn execute(result, context, entry, jobs);\n \t}\n \n-\tpublic static ShardResult execute(ShardResult result, QueryExecutionContext context, Entry<ManagedExecutionId, QueryPlan> entry, ListeningExecutorService executor) {\n+\tpublic static ShardResult execute(ShardResult result, QueryExecutionContext context, Entry<ManagedExecutionId, QueryPlan> entry, Queue<Runnable> jobs) {\n \t\tManagedExecutionId executionId = entry.getKey();\n \t\tCollection<Entity> entries = context.getStorage().getBucketManager().getEntities().values();\n \n \t\tif(entries.isEmpty()) {\n-\t\t\tlog.warn(\"entries for query {} are empty\", executionId);\n+\t\t\tlog.warn(\"entries for Query[{}] are empty\", executionId);\n \t\t}\n-\t\t\n-\t\tList<ListenableFuture<EntityResult>> futures = entry.getValue()\n-\t\t\t.executeOn(context, entries)\n-\t\t\t.map(executor::submit)\n-\t\t\t.collect(Collectors.toList());\n-\t\t\n+\n+\t\tList<ListenableFutureTask<EntityResult>> futures = entry.getValue()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.executeOn(context, entries, result)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc2NTI0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Workers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyODo1N1rOGpddrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyOTo1NFrOGpdfUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzUzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic Workers(RoundRobinQueue<Runnable> queue, int threadPoolSize) {\n          \n          \n            \n            \t\tsuper();\n          \n          \n            \n            \t\tObjects.requireNonNull(queue, \"Queues may not be empty.\");\n          \n          \n            \n            \t\tqueryExecutorQueues = queue;\n          \n          \n            \n            \tpublic Workers(@NonNull RoundRobinQueue<Runnable> queue, int threadPoolSize) {\n          \n          \n            \n            \t\tsuper();\n          \n          \n            \n            \t\tqueryExecutorQueues = queue;", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446127533", "createdAt": "2020-06-26T11:28:57Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Workers.java", "diffHunk": "@@ -1,22 +1,48 @@\n package com.bakdata.conquery.models.worker;\n \n+import java.io.Closeable;\n+import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import com.bakdata.conquery.models.identifiable.CentralRegistry;\n import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n import com.bakdata.conquery.models.identifiable.ids.specific.WorkerId;\n+import com.bakdata.conquery.util.RoundRobinQueue;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import lombok.Getter;\n import lombok.Setter;\n+import lombok.SneakyThrows;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n-public class Workers extends NamespaceCollection {\n+public class Workers extends NamespaceCollection implements Closeable {\n+\n+\tprivate final ThreadPoolExecutor queryThreadPool;\n+\n+\t@Getter\n+\tprivate final RoundRobinQueue<Runnable> queryExecutorQueues;\n+\n+\tpublic Workers(RoundRobinQueue<Runnable> queue, int threadPoolSize) {\n+\t\tsuper();\n+\t\tObjects.requireNonNull(queue, \"Queues may not be empty.\");\n+\t\tqueryExecutorQueues = queue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzk1Mg==", "bodyText": "Hier ist es mal Queue und mal Queues", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446127952", "createdAt": "2020-06-26T11:29:54Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Workers.java", "diffHunk": "@@ -1,22 +1,48 @@\n package com.bakdata.conquery.models.worker;\n \n+import java.io.Closeable;\n+import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import com.bakdata.conquery.models.identifiable.CentralRegistry;\n import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n import com.bakdata.conquery.models.identifiable.ids.specific.WorkerId;\n+import com.bakdata.conquery.util.RoundRobinQueue;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import lombok.Getter;\n import lombok.Setter;\n+import lombok.SneakyThrows;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n-public class Workers extends NamespaceCollection {\n+public class Workers extends NamespaceCollection implements Closeable {\n+\n+\tprivate final ThreadPoolExecutor queryThreadPool;\n+\n+\t@Getter\n+\tprivate final RoundRobinQueue<Runnable> queryExecutorQueues;\n+\n+\tpublic Workers(RoundRobinQueue<Runnable> queue, int threadPoolSize) {\n+\t\tsuper();\n+\t\tObjects.requireNonNull(queue, \"Queues may not be empty.\");\n+\t\tqueryExecutorQueues = queue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzUzMw=="}, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc4OTYzOnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/util/RoundRobinQueueTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODoyMlrOGpdssw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODoyMlrOGpdssw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMTM3OQ==", "bodyText": "Hier ist die Formatierung futsch", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446131379", "createdAt": "2020-06-26T11:38:22Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/util/RoundRobinQueueTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.bakdata.conquery.util;\n+\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.api.Test;\n+\n+@Slf4j\n+class RoundRobinQueueTest {\n+\n+    private static List<Throwable> EXCEPTIONS = new ArrayList<>();\n+\n+    private static ThreadFactory threadFactory =\n+            new ThreadFactoryBuilder()\n+                    .setUncaughtExceptionHandler((t, e) -> {\n+                        log.error(\"Exception Thread.\", e);\n+                        EXCEPTIONS.add(e);\n+                    }).build();\n+\n+    @BeforeEach\n+    public void reset() {\n+        EXCEPTIONS.clear();\n+    }\n+\n+    @AfterEach\n+    public void testEmpty(){\n+        assertThat(EXCEPTIONS).isEmpty();\n+    }\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tassertThat(queue.contains(1)).isTrue();\n+\t\tassertThat(queue.contains(2)).isTrue();\n+\t\tassertThat(queue.contains(3)).isFalse();\n+\n+\t\tfinal Iterator<Integer> iterator = queue.iterator();\n+\n+\t\tassertThat(iterator.next()).isEqualTo(1);\n+\t\tassertThat(first).isEmpty();\n+\t\tassertThat(iterator.next()).isEqualTo(2);\n+\t\tassertThat(second).isEmpty();\n+\t\tassertThat(iterator.next()).isEqualTo(null);\n+\t\tassertThat(queue).isEmpty();\n+\t}\n+\n+\t@Test\n+\tpublic void testIterator() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tfinal List<Integer> out = new ArrayList<>();\n+\n+\t\tfor (Integer integer : queue) {\n+\t\t\tout.add(integer);\n+\t\t}\n+\n+\t\tassertThat(out).containsExactlyInAnyOrder(1, 2);\n+\t}\n+\n+\t@Test\n+\tpublic void testNewQueue() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\n+\t\tfinal Iterator<Integer> iterator = queue.iterator();\n+\n+\n+\t\tassertThat(iterator.next()).isEqualTo(1);\n+\t\tassertThat(iterator.next()).isEqualTo(2);\n+\t\tassertThat(iterator.next()).isEqualTo(null);\n+\n+\t\tfinal Queue<Integer> third = queue.createQueue();\n+\t\tthird.add(3);\n+\n+\n+\t\tassertThat(iterator.next()).isEqualTo(3);\n+\t}\n+\n+\n+\t@Test\n+\tpublic void parPutSynTake() throws InterruptedException {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tfinal Random waitMillis = new Random();\n+\n+        threadFactory.newThread(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc5MDk4OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/util/RoundRobinQueueTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODo1N1rOGpdteQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODo1N1rOGpdteQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMTU3Nw==", "bodyText": "Bitte kein Random im Test", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446131577", "createdAt": "2020-06-26T11:38:57Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/util/RoundRobinQueueTest.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.bakdata.conquery.util;\n+\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.api.Test;\n+\n+@Slf4j\n+class RoundRobinQueueTest {\n+\n+    private static List<Throwable> EXCEPTIONS = new ArrayList<>();\n+\n+    private static ThreadFactory threadFactory =\n+            new ThreadFactoryBuilder()\n+                    .setUncaughtExceptionHandler((t, e) -> {\n+                        log.error(\"Exception Thread.\", e);\n+                        EXCEPTIONS.add(e);\n+                    }).build();\n+\n+    @BeforeEach\n+    public void reset() {\n+        EXCEPTIONS.clear();\n+    }\n+\n+    @AfterEach\n+    public void testEmpty(){\n+        assertThat(EXCEPTIONS).isEmpty();\n+    }\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tassertThat(queue.contains(1)).isTrue();\n+\t\tassertThat(queue.contains(2)).isTrue();\n+\t\tassertThat(queue.contains(3)).isFalse();\n+\n+\t\tfinal Iterator<Integer> iterator = queue.iterator();\n+\n+\t\tassertThat(iterator.next()).isEqualTo(1);\n+\t\tassertThat(first).isEmpty();\n+\t\tassertThat(iterator.next()).isEqualTo(2);\n+\t\tassertThat(second).isEmpty();\n+\t\tassertThat(iterator.next()).isEqualTo(null);\n+\t\tassertThat(queue).isEmpty();\n+\t}\n+\n+\t@Test\n+\tpublic void testIterator() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tfinal List<Integer> out = new ArrayList<>();\n+\n+\t\tfor (Integer integer : queue) {\n+\t\t\tout.add(integer);\n+\t\t}\n+\n+\t\tassertThat(out).containsExactlyInAnyOrder(1, 2);\n+\t}\n+\n+\t@Test\n+\tpublic void testNewQueue() {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\n+\t\tfinal Iterator<Integer> iterator = queue.iterator();\n+\n+\n+\t\tassertThat(iterator.next()).isEqualTo(1);\n+\t\tassertThat(iterator.next()).isEqualTo(2);\n+\t\tassertThat(iterator.next()).isEqualTo(null);\n+\n+\t\tfinal Queue<Integer> third = queue.createQueue();\n+\t\tthird.add(3);\n+\n+\n+\t\tassertThat(iterator.next()).isEqualTo(3);\n+\t}\n+\n+\n+\t@Test\n+\tpublic void parPutSynTake() throws InterruptedException {\n+\t\tfinal RoundRobinQueue<Integer> queue = new RoundRobinQueue<>(100);\n+\n+\t\tfinal Queue<Integer> first = queue.createQueue();\n+\t\tfinal Queue<Integer> second = queue.createQueue();\n+\n+\t\tfirst.add(1);\n+\t\tsecond.add(2);\n+\n+\t\tfinal Random waitMillis = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgwNTA5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0NDoyN1rOGpd2Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0NDoyN1rOGpd2Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMzgzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public RoundRobinQueue(int capacity) {\n          \n          \n            \n                public RoundRobinQueue(@Min(1) int capacity) {", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446133834", "createdAt": "2020-06-26T11:44:27Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+    private final Queue<E>[] queues;\n+    private final Object signal = new Object();\n+\n+    /**\n+     * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+     */\n+    private final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+    public RoundRobinQueue(int capacity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgxMTA4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0Njo0OFrOGpd55Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjoyNjozNlrOGpe-OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNDc1Nw==", "bodyText": "M\u00fcsste die Kapazit\u00e4t nicht der Datasets entsprechen?", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446134757", "createdAt": "2020-06-26T11:46:48Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "diffHunk": "@@ -80,27 +86,42 @@ protected void run(Environment environment, Namespace namespace, ConqueryConfig\n \t\t\n \t\tscheduler.scheduleAtFixedRate(this::reportJobManagerStatus, 30, 1, TimeUnit.SECONDS);\n \n-\n \t\tthis.config = config;\n \n \t\tif(config.getStorage().getDirectory().mkdirs()){\n \t\t\tlog.warn(\"Had to create Storage Dir at `{}`\", config.getStorage().getDirectory());\n \t\t}\n \n-\t\tfor(File directory : config.getStorage().getDirectory().listFiles()) {\n-\t\t\tif(directory.getName().startsWith(\"worker_\")) {\n+\t\tworkers = new Workers(new RoundRobinQueue<>(config.getQueries().getRoundRobinQueueCapacity()), config.getQueries().getNThreads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1MjI0OQ==", "bodyText": "aber die wei\u00dft du nicht beim starten und du willst ja auch neue datasets hinzuf\u00fcgen k\u00f6nnnen. Aber f\u00fcr unseren Fall w\u00fcrde ich das so setzen, bzw +1 oder so", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446152249", "createdAt": "2020-06-26T12:26:36Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "diffHunk": "@@ -80,27 +86,42 @@ protected void run(Environment environment, Namespace namespace, ConqueryConfig\n \t\t\n \t\tscheduler.scheduleAtFixedRate(this::reportJobManagerStatus, 30, 1, TimeUnit.SECONDS);\n \n-\n \t\tthis.config = config;\n \n \t\tif(config.getStorage().getDirectory().mkdirs()){\n \t\t\tlog.warn(\"Had to create Storage Dir at `{}`\", config.getStorage().getDirectory());\n \t\t}\n \n-\t\tfor(File directory : config.getStorage().getDirectory().listFiles()) {\n-\t\t\tif(directory.getName().startsWith(\"worker_\")) {\n+\t\tworkers = new Workers(new RoundRobinQueue<>(config.getQueries().getRoundRobinQueueCapacity()), config.getQueries().getNThreads());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNDc1Nw=="}, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTg2MzM3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjowNTo1OVrOGpeaOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjowNTo1OVrOGpeaOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0MzAzMw==", "bodyText": "Format", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446143033", "createdAt": "2020-06-26T12:05:59Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+    private final Queue<E>[] queues;\n+    private final Object signal = new Object();\n+\n+    /**\n+     * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+     */\n+    private final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+    public RoundRobinQueue(int capacity) {\n+        super();\n+        queues = new Queue[capacity];\n+    }\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+     * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+     */\n+    @RequiredArgsConstructor\n+    private static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+        private final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+        private final Object signal;\n+\n+        @Override\n+        protected Queue<T> delegate() {\n+            return base;\n+        }\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+        public boolean offer(T element) {\n+            final boolean offer = super.offer(element);\n+\n+            if (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return offer;\n+        }\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+        @Override\n+        public boolean add(T element) {\n+            final boolean add = super.add(element);\n+\n+            if (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return add;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTg2OTUzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjowODoyOVrOGpeeCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjoyODozMFrOGpfBlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0NDAxMA==", "bodyText": "Du kannst in dieser Methode das Array auch neu anlegen und vergr\u00f6\u00dfern. Analog in der remove Methode verkleinern. Dann musst du dich nicht mit der festen Kapa rumschlagen.\nOder eine ArrayList. Solange get(i)=> O(1) hat sollte es doch kein Problem sein.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446144010", "createdAt": "2020-06-26T12:08:29Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+    private final Queue<E>[] queues;\n+    private final Object signal = new Object();\n+\n+    /**\n+     * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+     */\n+    private final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+    public RoundRobinQueue(int capacity) {\n+        super();\n+        queues = new Queue[capacity];\n+    }\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+     * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+     */\n+    @RequiredArgsConstructor\n+    private static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+        private final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+        private final Object signal;\n+\n+        @Override\n+        protected Queue<T> delegate() {\n+            return base;\n+        }\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+        public boolean offer(T element) {\n+            final boolean offer = super.offer(element);\n+\n+            if (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return offer;\n+        }\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+        @Override\n+        public boolean add(T element) {\n+            final boolean add = super.add(element);\n+\n+            if (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return add;\n+        }\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif(addAll){\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsignal.notifyAll();\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t * @throws IllegalStateException when no more slots are available.\n+\t * @return\n+\t */\n+    public Queue<E> createQueue() {\n+        // TODO: 25.06.2020 FK: add supplier as creation parameter\n+        final Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+        synchronized (queues) {\n+            free = ArrayUtils.indexOf(queues, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE1MzExMA==", "bodyText": "Wenn ich das array \u00e4ndere ist das aber eine racecondition in poll und dann ist das nicht mehr lock-free im consumer", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r446153110", "createdAt": "2020-06-26T12:28:30Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,443 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+    private final Queue<E>[] queues;\n+    private final Object signal = new Object();\n+\n+    /**\n+     * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+     */\n+    private final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+    public RoundRobinQueue(int capacity) {\n+        super();\n+        queues = new Queue[capacity];\n+    }\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+     * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+     */\n+    @RequiredArgsConstructor\n+    private static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+        private final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+        private final Object signal;\n+\n+        @Override\n+        protected Queue<T> delegate() {\n+            return base;\n+        }\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+        public boolean offer(T element) {\n+            final boolean offer = super.offer(element);\n+\n+            if (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return offer;\n+        }\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+        @Override\n+        public boolean add(T element) {\n+            final boolean add = super.add(element);\n+\n+            if (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+            return add;\n+        }\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif(addAll){\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsignal.notifyAll();\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t * @throws IllegalStateException when no more slots are available.\n+\t * @return\n+\t */\n+    public Queue<E> createQueue() {\n+        // TODO: 25.06.2020 FK: add supplier as creation parameter\n+        final Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+        synchronized (queues) {\n+            free = ArrayUtils.indexOf(queues, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0NDAxMA=="}, "originalCommit": {"oid": "adc87aaadfd3bd8f262426f6566954d923a0276a"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjM0OTc5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjowMzoxMFrOGqXxmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjowMzoxMFrOGqXxmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4MjkwNA==", "bodyText": "Du k\u00f6nntest diese zweite Loop einsparen und dem der Task der oben submitted wird sein Ergebnis gleich in eine ConcurrentMap wirft.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447082904", "createdAt": "2020-06-29T16:03:10Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();\n+\n+\t\tlog.info(\"All threads are done.\");\n+\n+\t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n+\n+\t\tfor (Future<Map<ConceptElementId<?>, MatchingStats.Entry>> conceptMatch : conceptMatches) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQwMDI1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNTowNFrOGqYQGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxNTo0NlrOGrjYlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MDcxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {\n          \n          \n            \n                      if(isCancelled()) {\n          \n          \n            \n                       \t\t\treturn null;\n          \n          \n            \n                       }\n          \n          \n            \n            \t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447090714", "createdAt": "2020-06-29T16:15:04Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();\n+\n+\t\tlog.info(\"All threads are done.\");\n+\n+\t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n+\n+\t\tfor (Future<Map<ConceptElementId<?>, MatchingStats.Entry>> conceptMatch : conceptMatches) {\n+\t\t\tmessages.putAll(conceptMatch.get());\n+\t\t}\n+\n+\n+\t\tif (!messages.isEmpty()) {\n+\t\t\tworker.send(new UpdateElementMatchingStats(worker.getInfo().getId(), messages));\n+\t\t}\n+\n+\t\tprogressReporter.done();\n+\t}\n+\n+\tpublic Map<ConceptElementId<?>, MatchingStats.Entry> calculateConceptMatches(Concept<?> concept) {\n \n \t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n \n \t\tfor (CBlock cBlock : new ArrayList<>(worker.getStorage().getAllCBlocks())) {\n \n-\t\t\tif(isCancelled()) {\n-\t\t\t\tprogressReporter.done();\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t\tif(isCancelled())\n+\t\t\t\treturn null;\n+\n+\t\t\tif(!cBlock.getConnector().getConcept().equals(concept.getId()))\n+\t\t\t\tcontinue;\n \n-\t\t\tConcept<?> concept = worker.getStorage().getConcept(cBlock.getConnector().getConcept());\n \t\t\ttry {\n \t\t\t\tBucket bucket = worker.getStorage().getBucket(cBlock.getBucket());\n \t\t\t\tTable table = worker.getStorage().getDataset().getTables().get(bucket.getImp().getTable());\n-\t\t\t\t\n+\n \t\t\t\tfor (int event = 0; event < bucket.getNumberOfEvents(); event++) {\n-\t\t\t\t\tif (concept instanceof TreeConcept && cBlock.getMostSpecificChildren() != null) {\n-\t\t\t\t\t\tint[] localIds = cBlock.getMostSpecificChildren().get(event);\n-\t\t\t\t\t\tif (localIds != null) {\n-\t\t\t\t\t\t\tConceptTreeNode<?> e = ((TreeConcept) concept).getElementByLocalId(localIds);\n-\t\n-\t\t\t\t\t\t\twhile (e != null) {\n-\t\t\t\t\t\t\t\tmessages.computeIfAbsent(e.getId(), (x) -> new MatchingStats.Entry())\n-\t\t\t\t\t\t\t\t\t.addEvent(table, bucket, cBlock, event);\n-\t\t\t\t\t\t\t\te = e.getParent();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tmessages\n-\t\t\t\t\t\t\t\t.computeIfAbsent(concept.getId(), (x) -> new MatchingStats.Entry())\n+\t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MTk4MA==", "bodyText": "Ich wei\u00df nicht ob wir laufende Tasks canceln wollen. Eigentlich will man doch auch festgehangene Tasks canceln", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447091980", "createdAt": "2020-06-29T16:16:58Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();\n+\n+\t\tlog.info(\"All threads are done.\");\n+\n+\t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n+\n+\t\tfor (Future<Map<ConceptElementId<?>, MatchingStats.Entry>> conceptMatch : conceptMatches) {\n+\t\t\tmessages.putAll(conceptMatch.get());\n+\t\t}\n+\n+\n+\t\tif (!messages.isEmpty()) {\n+\t\t\tworker.send(new UpdateElementMatchingStats(worker.getInfo().getId(), messages));\n+\t\t}\n+\n+\t\tprogressReporter.done();\n+\t}\n+\n+\tpublic Map<ConceptElementId<?>, MatchingStats.Entry> calculateConceptMatches(Concept<?> concept) {\n \n \t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n \n \t\tfor (CBlock cBlock : new ArrayList<>(worker.getStorage().getAllCBlocks())) {\n \n-\t\t\tif(isCancelled()) {\n-\t\t\t\tprogressReporter.done();\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t\tif(isCancelled())\n+\t\t\t\treturn null;\n+\n+\t\t\tif(!cBlock.getConnector().getConcept().equals(concept.getId()))\n+\t\t\t\tcontinue;\n \n-\t\t\tConcept<?> concept = worker.getStorage().getConcept(cBlock.getConnector().getConcept());\n \t\t\ttry {\n \t\t\t\tBucket bucket = worker.getStorage().getBucket(cBlock.getBucket());\n \t\t\t\tTable table = worker.getStorage().getDataset().getTables().get(bucket.getImp().getTable());\n-\t\t\t\t\n+\n \t\t\t\tfor (int event = 0; event < bucket.getNumberOfEvents(); event++) {\n-\t\t\t\t\tif (concept instanceof TreeConcept && cBlock.getMostSpecificChildren() != null) {\n-\t\t\t\t\t\tint[] localIds = cBlock.getMostSpecificChildren().get(event);\n-\t\t\t\t\t\tif (localIds != null) {\n-\t\t\t\t\t\t\tConceptTreeNode<?> e = ((TreeConcept) concept).getElementByLocalId(localIds);\n-\t\n-\t\t\t\t\t\t\twhile (e != null) {\n-\t\t\t\t\t\t\t\tmessages.computeIfAbsent(e.getId(), (x) -> new MatchingStats.Entry())\n-\t\t\t\t\t\t\t\t\t.addEvent(table, bucket, cBlock, event);\n-\t\t\t\t\t\t\t\te = e.getParent();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tmessages\n-\t\t\t\t\t\t\t\t.computeIfAbsent(concept.getId(), (x) -> new MatchingStats.Entry())\n+\t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MDcxNA=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MjUyMg==", "bodyText": "das gab es meines wissens nicht, dass man aufgehangene tasks abschie\u00dfen konnte.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447462522", "createdAt": "2020-06-30T07:17:31Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();\n+\n+\t\tlog.info(\"All threads are done.\");\n+\n+\t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n+\n+\t\tfor (Future<Map<ConceptElementId<?>, MatchingStats.Entry>> conceptMatch : conceptMatches) {\n+\t\t\tmessages.putAll(conceptMatch.get());\n+\t\t}\n+\n+\n+\t\tif (!messages.isEmpty()) {\n+\t\t\tworker.send(new UpdateElementMatchingStats(worker.getInfo().getId(), messages));\n+\t\t}\n+\n+\t\tprogressReporter.done();\n+\t}\n+\n+\tpublic Map<ConceptElementId<?>, MatchingStats.Entry> calculateConceptMatches(Concept<?> concept) {\n \n \t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n \n \t\tfor (CBlock cBlock : new ArrayList<>(worker.getStorage().getAllCBlocks())) {\n \n-\t\t\tif(isCancelled()) {\n-\t\t\t\tprogressReporter.done();\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t\tif(isCancelled())\n+\t\t\t\treturn null;\n+\n+\t\t\tif(!cBlock.getConnector().getConcept().equals(concept.getId()))\n+\t\t\t\tcontinue;\n \n-\t\t\tConcept<?> concept = worker.getStorage().getConcept(cBlock.getConnector().getConcept());\n \t\t\ttry {\n \t\t\t\tBucket bucket = worker.getStorage().getBucket(cBlock.getBucket());\n \t\t\t\tTable table = worker.getStorage().getDataset().getTables().get(bucket.getImp().getTable());\n-\t\t\t\t\n+\n \t\t\t\tfor (int event = 0; event < bucket.getNumberOfEvents(); event++) {\n-\t\t\t\t\tif (concept instanceof TreeConcept && cBlock.getMostSpecificChildren() != null) {\n-\t\t\t\t\t\tint[] localIds = cBlock.getMostSpecificChildren().get(event);\n-\t\t\t\t\t\tif (localIds != null) {\n-\t\t\t\t\t\t\tConceptTreeNode<?> e = ((TreeConcept) concept).getElementByLocalId(localIds);\n-\t\n-\t\t\t\t\t\t\twhile (e != null) {\n-\t\t\t\t\t\t\t\tmessages.computeIfAbsent(e.getId(), (x) -> new MatchingStats.Entry())\n-\t\t\t\t\t\t\t\t\t.addEvent(table, bucket, cBlock, event);\n-\t\t\t\t\t\t\t\te = e.getParent();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tmessages\n-\t\t\t\t\t\t\t\t.computeIfAbsent(concept.getId(), (x) -> new MatchingStats.Entry())\n+\t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MDcxNA=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTY4Nw==", "bodyText": "Ja das ist denke ich auch ein kompliziertes Thema, da jenach Job Rollbacks n\u00f6tig sein k\u00f6nnten.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r448321687", "createdAt": "2020-07-01T12:15:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();\n+\n+\t\tlog.info(\"All threads are done.\");\n+\n+\t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n+\n+\t\tfor (Future<Map<ConceptElementId<?>, MatchingStats.Entry>> conceptMatch : conceptMatches) {\n+\t\t\tmessages.putAll(conceptMatch.get());\n+\t\t}\n+\n+\n+\t\tif (!messages.isEmpty()) {\n+\t\t\tworker.send(new UpdateElementMatchingStats(worker.getInfo().getId(), messages));\n+\t\t}\n+\n+\t\tprogressReporter.done();\n+\t}\n+\n+\tpublic Map<ConceptElementId<?>, MatchingStats.Entry> calculateConceptMatches(Concept<?> concept) {\n \n \t\tMap<ConceptElementId<?>, MatchingStats.Entry> messages = new HashMap<>();\n \n \t\tfor (CBlock cBlock : new ArrayList<>(worker.getStorage().getAllCBlocks())) {\n \n-\t\t\tif(isCancelled()) {\n-\t\t\t\tprogressReporter.done();\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t\tif(isCancelled())\n+\t\t\t\treturn null;\n+\n+\t\t\tif(!cBlock.getConnector().getConcept().equals(concept.getId()))\n+\t\t\t\tcontinue;\n \n-\t\t\tConcept<?> concept = worker.getStorage().getConcept(cBlock.getConnector().getConcept());\n \t\t\ttry {\n \t\t\t\tBucket bucket = worker.getStorage().getBucket(cBlock.getBucket());\n \t\t\t\tTable table = worker.getStorage().getDataset().getTables().get(bucket.getImp().getTable());\n-\t\t\t\t\n+\n \t\t\t\tfor (int event = 0; event < bucket.getNumberOfEvents(); event++) {\n-\t\t\t\t\tif (concept instanceof TreeConcept && cBlock.getMostSpecificChildren() != null) {\n-\t\t\t\t\t\tint[] localIds = cBlock.getMostSpecificChildren().get(event);\n-\t\t\t\t\t\tif (localIds != null) {\n-\t\t\t\t\t\t\tConceptTreeNode<?> e = ((TreeConcept) concept).getElementByLocalId(localIds);\n-\t\n-\t\t\t\t\t\t\twhile (e != null) {\n-\t\t\t\t\t\t\t\tmessages.computeIfAbsent(e.getId(), (x) -> new MatchingStats.Entry())\n-\t\t\t\t\t\t\t\t\t.addEvent(table, bucket, cBlock, event);\n-\t\t\t\t\t\t\t\te = e.getParent();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tmessages\n-\t\t\t\t\t\t\t\t.computeIfAbsent(concept.getId(), (x) -> new MatchingStats.Entry())\n+\t\t\t\t\tif (!(concept instanceof TreeConcept) || cBlock.getMostSpecificChildren() == null || cBlock.getMostSpecificChildren().get(event) == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MDcxNA=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQxNDE1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/messages/namespaces/specific/ExecuteQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxODoyMVrOGqYYgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzoxODowMVrOGqu9gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5Mjg2NA==", "bodyText": "Das printed leider nicht den Stacktrace", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447092864", "createdAt": "2020-06-29T16:18:21Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/messages/namespaces/specific/ExecuteQuery.java", "diffHunk": "@@ -56,7 +56,7 @@ public void react(Worker context) throws Exception {\n \t\t\t\tcontext.getQueryExecutor().execute(result, new QueryExecutionContext(context.getStorage()), entry);\n \t\t\t\tresult.getFuture().addListener(()->result.send(context), MoreExecutors.directExecutor());\n \t\t\t} catch(Exception e) {\n-\t\t\t\tlog.error(String.format(\"Error while executing {} (with subquery: {})\", execution.getId(), entry.getKey()), e );\n+\t\t\t\tlog.error(\"Error while executing {} (with subquery: {})\", execution.getId(), entry.getKey(), e );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2Mjc4Ng==", "bodyText": "Doch, der letzte Parameter wenn es ein Throwable ist wird geprinted", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447462786", "createdAt": "2020-06-30T07:18:01Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/messages/namespaces/specific/ExecuteQuery.java", "diffHunk": "@@ -56,7 +56,7 @@ public void react(Worker context) throws Exception {\n \t\t\t\tcontext.getQueryExecutor().execute(result, new QueryExecutionContext(context.getStorage()), entry);\n \t\t\t\tresult.getFuture().addListener(()->result.send(context), MoreExecutors.directExecutor());\n \t\t\t} catch(Exception e) {\n-\t\t\t\tlog.error(String.format(\"Error while executing {} (with subquery: {})\", execution.getId(), entry.getKey()), e );\n+\t\t\t\tlog.error(\"Error while executing {} (with subquery: {})\", execution.getId(), entry.getKey(), e );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5Mjg2NA=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQ3NzkwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/messages/network/specific/AddWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjozMzozMVrOGqY-pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjozMzozMVrOGqY-pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwMjYzMQ==", "bodyText": "Ich habe nochmal geschaut. Diese start-Methode wird nie direkt vom Lifecycle gestartet. Ich w\u00fcrde daher das Starten des slow- und fastExecutors in den Konstruktor packen. sonst ist das aufrufen der Startmethode immer etwas l\u00e4stiges, an das man sich erinnern muss, wenn man die Klasse benutzen will.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447102631", "createdAt": "2020-06-29T16:33:31Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/messages/network/specific/AddWorker.java", "diffHunk": "@@ -39,12 +37,17 @@ public void react(Slave context) throws Exception {\n \t\tWorkerStorage workerStorage = new WorkerStorageImpl(context.getValidator(), config.getStorage(), dir);\n \t\tworkerStorage.loadData();\n \t\tworkerStorage.updateDataset(dataset);\n-\t\tWorker worker = new Worker(\n+\n+\n+\t\tWorker worker = Worker.createWorker(\n \t\t\tinfo,\n-\t\t\tcontext.getJobManager(),\n \t\t\tworkerStorage,\n-\t\t\tnew QueryExecutor(config)\n+\t\t\tconfig,\n+\t\t\tcontext.getWorkers().createQuerySubQueue()\n \t\t);\n+\n+\t\tworker.getJobManager().start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQ4NjQzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjozNTo1N1rOGqZD_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjozMTo1OVrOGq6GVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwMzk5Ng==", "bodyText": "Hat dieser Pool noch etwas mit den Queries zu tun? Daf\u00fcr ist doch jetzt die Queue da, oder?", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447103996", "createdAt": "2020-06-29T16:35:57Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "diffHunk": "@@ -2,39 +2,69 @@\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.util.Queue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n \n import com.bakdata.conquery.io.mina.MessageSender;\n import com.bakdata.conquery.io.mina.NetworkSession;\n import com.bakdata.conquery.io.xodus.WorkerStorage;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.events.BucketManager;\n import com.bakdata.conquery.models.jobs.JobManager;\n+import com.bakdata.conquery.models.jobs.SimpleJob;\n import com.bakdata.conquery.models.messages.namespaces.NamespaceMessage;\n import com.bakdata.conquery.models.messages.network.MasterMessage;\n import com.bakdata.conquery.models.messages.network.NetworkMessage;\n import com.bakdata.conquery.models.messages.network.specific.ForwardToNamespace;\n import com.bakdata.conquery.models.query.QueryExecutor;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import lombok.AccessLevel;\n import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n \n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n public class Worker implements MessageSender.Transforming<NamespaceMessage, NetworkMessage<?>>, Closeable {\n+\n+\t@Getter\n+\tprivate final WorkerInformation info;\n+\n \t@Getter\n \tprivate final JobManager jobManager;\n+\n \t@Getter\n \tprivate final WorkerStorage storage;\n+\n \t@Getter\n \tprivate final QueryExecutor queryExecutor;\n+\n+\t/**\n+\t * Pool that can be used in Jobs to execute a job in parallel.\n+\t */\n \t@Getter\n-\tprivate final WorkerInformation info;\n+\tprivate final ThreadPoolExecutor pool;\n+\n \t@Setter\n \tprivate NetworkSession session;\n-\t\n-\tpublic Worker(WorkerInformation info, JobManager jobManager, WorkerStorage storage, QueryExecutor queryExecutor) {\n-\t\tthis.info = info;\n-\t\tthis.jobManager = jobManager;\n-\t\tthis.storage = storage;\n-\t\tBucketManager bucketManager = new BucketManager(jobManager, storage, this);\n+\n+\n+\tpublic static Worker createWorker(WorkerInformation info, WorkerStorage storage, ConqueryConfig config, Queue<Runnable> queryQueue) {\n+\t\tfinal JobManager jobManager = new JobManager(info.getName());\n+\t\tfinal BucketManager bucketManager = new BucketManager(jobManager, storage, info);\n+\n \t\tstorage.setBucketManager(bucketManager);\n-\t\tthis.queryExecutor = queryExecutor;\n+\t\tjobManager.addSlowJob(new SimpleJob(\"Update Block Manager\", bucketManager::fullUpdate));\n+\n+\n+\t\tfinal QueryExecutor queryExecutor = new QueryExecutor(queryQueue);\n+\n+\t\t// Second format-str is used by ThreadPool.\n+\t\tfinal ThreadPoolExecutor pool = config.getQueries().getExecutionPool().createService(String.format(\"Dataset[%s] Worker-Thread %%d\", info.getDataset()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwOTQ0Nw==", "bodyText": "Vielleicht sollte der Pool nicht auf Worker ebene sein sondern dar\u00fcber, damit wir nicht so viele Threads haben.\nim Slavecommand machst du ja einen ThreadPool kurzfristig auf, den k\u00f6nntest du hier wieder verwenden.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447109447", "createdAt": "2020-06-29T16:44:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "diffHunk": "@@ -2,39 +2,69 @@\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.util.Queue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n \n import com.bakdata.conquery.io.mina.MessageSender;\n import com.bakdata.conquery.io.mina.NetworkSession;\n import com.bakdata.conquery.io.xodus.WorkerStorage;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.events.BucketManager;\n import com.bakdata.conquery.models.jobs.JobManager;\n+import com.bakdata.conquery.models.jobs.SimpleJob;\n import com.bakdata.conquery.models.messages.namespaces.NamespaceMessage;\n import com.bakdata.conquery.models.messages.network.MasterMessage;\n import com.bakdata.conquery.models.messages.network.NetworkMessage;\n import com.bakdata.conquery.models.messages.network.specific.ForwardToNamespace;\n import com.bakdata.conquery.models.query.QueryExecutor;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import lombok.AccessLevel;\n import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n \n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n public class Worker implements MessageSender.Transforming<NamespaceMessage, NetworkMessage<?>>, Closeable {\n+\n+\t@Getter\n+\tprivate final WorkerInformation info;\n+\n \t@Getter\n \tprivate final JobManager jobManager;\n+\n \t@Getter\n \tprivate final WorkerStorage storage;\n+\n \t@Getter\n \tprivate final QueryExecutor queryExecutor;\n+\n+\t/**\n+\t * Pool that can be used in Jobs to execute a job in parallel.\n+\t */\n \t@Getter\n-\tprivate final WorkerInformation info;\n+\tprivate final ThreadPoolExecutor pool;\n+\n \t@Setter\n \tprivate NetworkSession session;\n-\t\n-\tpublic Worker(WorkerInformation info, JobManager jobManager, WorkerStorage storage, QueryExecutor queryExecutor) {\n-\t\tthis.info = info;\n-\t\tthis.jobManager = jobManager;\n-\t\tthis.storage = storage;\n-\t\tBucketManager bucketManager = new BucketManager(jobManager, storage, this);\n+\n+\n+\tpublic static Worker createWorker(WorkerInformation info, WorkerStorage storage, ConqueryConfig config, Queue<Runnable> queryQueue) {\n+\t\tfinal JobManager jobManager = new JobManager(info.getName());\n+\t\tfinal BucketManager bucketManager = new BucketManager(jobManager, storage, info);\n+\n \t\tstorage.setBucketManager(bucketManager);\n-\t\tthis.queryExecutor = queryExecutor;\n+\t\tjobManager.addSlowJob(new SimpleJob(\"Update Block Manager\", bucketManager::fullUpdate));\n+\n+\n+\t\tfinal QueryExecutor queryExecutor = new QueryExecutor(queryQueue);\n+\n+\t\t// Second format-str is used by ThreadPool.\n+\t\tfinal ThreadPoolExecutor pool = config.getQueries().getExecutionPool().createService(String.format(\"Dataset[%s] Worker-Thread %%d\", info.getDataset()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwMzk5Ng=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY0NTI2OQ==", "bodyText": "Ist jetzt in Workers, war eine gute Idee", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447645269", "createdAt": "2020-06-30T12:31:59Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "diffHunk": "@@ -2,39 +2,69 @@\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.util.Queue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n \n import com.bakdata.conquery.io.mina.MessageSender;\n import com.bakdata.conquery.io.mina.NetworkSession;\n import com.bakdata.conquery.io.xodus.WorkerStorage;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.events.BucketManager;\n import com.bakdata.conquery.models.jobs.JobManager;\n+import com.bakdata.conquery.models.jobs.SimpleJob;\n import com.bakdata.conquery.models.messages.namespaces.NamespaceMessage;\n import com.bakdata.conquery.models.messages.network.MasterMessage;\n import com.bakdata.conquery.models.messages.network.NetworkMessage;\n import com.bakdata.conquery.models.messages.network.specific.ForwardToNamespace;\n import com.bakdata.conquery.models.query.QueryExecutor;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import lombok.AccessLevel;\n import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n \n+@Slf4j\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n public class Worker implements MessageSender.Transforming<NamespaceMessage, NetworkMessage<?>>, Closeable {\n+\n+\t@Getter\n+\tprivate final WorkerInformation info;\n+\n \t@Getter\n \tprivate final JobManager jobManager;\n+\n \t@Getter\n \tprivate final WorkerStorage storage;\n+\n \t@Getter\n \tprivate final QueryExecutor queryExecutor;\n+\n+\t/**\n+\t * Pool that can be used in Jobs to execute a job in parallel.\n+\t */\n \t@Getter\n-\tprivate final WorkerInformation info;\n+\tprivate final ThreadPoolExecutor pool;\n+\n \t@Setter\n \tprivate NetworkSession session;\n-\t\n-\tpublic Worker(WorkerInformation info, JobManager jobManager, WorkerStorage storage, QueryExecutor queryExecutor) {\n-\t\tthis.info = info;\n-\t\tthis.jobManager = jobManager;\n-\t\tthis.storage = storage;\n-\t\tBucketManager bucketManager = new BucketManager(jobManager, storage, this);\n+\n+\n+\tpublic static Worker createWorker(WorkerInformation info, WorkerStorage storage, ConqueryConfig config, Queue<Runnable> queryQueue) {\n+\t\tfinal JobManager jobManager = new JobManager(info.getName());\n+\t\tfinal BucketManager bucketManager = new BucketManager(jobManager, storage, info);\n+\n \t\tstorage.setBucketManager(bucketManager);\n-\t\tthis.queryExecutor = queryExecutor;\n+\t\tjobManager.addSlowJob(new SimpleJob(\"Update Block Manager\", bucketManager::fullUpdate));\n+\n+\n+\t\tfinal QueryExecutor queryExecutor = new QueryExecutor(queryQueue);\n+\n+\t\t// Second format-str is used by ThreadPool.\n+\t\tfinal ThreadPoolExecutor pool = config.getQueries().getExecutionPool().createService(String.format(\"Dataset[%s] Worker-Thread %%d\", info.getDataset()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwMzk5Ng=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njg5NDUyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODoyNzo0M1rOGqdAIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODoyNzo0M1rOGqdAIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2ODU0NQ==", "bodyText": "Ich denke es ist hier besser direkt auf die Futures zu synchronisieren, anstatt der indirektion \u00fcber den worker.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447168545", "createdAt": "2020-06-29T18:27:43Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/UpdateMatchingStats.java", "diffHunk": "@@ -34,60 +36,77 @@ public void execute() throws Exception {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.debug(\"Starting to update Matching stats with {}\", worker);\n+\t\tprogressReporter.setMax(worker.getStorage().getAllConcepts().size());\n \n-\t\tprogressReporter.setMax(worker.getStorage().getAllCBlocks().size());\n+\t\tlog.info(\"Starting to update Matching stats for {} Concepts\", worker.getStorage().getAllConcepts().size());\n+\n+\n+\t\tList<Future<Map<ConceptElementId<?>, MatchingStats.Entry>>> conceptMatches = new ArrayList<>();\n+\n+\t\tfor (Concept<?> concept :worker.getStorage().getAllConcepts()) {\n+\t\t\tconceptMatches.add(worker.getPool().submit(() -> calculateConceptMatches(concept)));\n+\t\t}\n+\n+\t\tworker.awaitSubJobTermination();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njk3NDgyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODo0OTozMlrOGqdw6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjozMjoyN1rOGq6HRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4MTAzNQ==", "bodyText": "Mir wird angezeigt, dass die (double) casts nicht notwendig sind", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447181035", "createdAt": "2020-06-29T18:49:32Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY0NTUwOQ==", "bodyText": "Ich vertraue Typsystemen nicht gut genug f\u00fcr sowas, finde das so sauberer", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447645509", "createdAt": "2020-06-30T12:32:27Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4MTAzNQ=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njk5NzgwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODo1NTo0NFrOGqd-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOToxNTo0OFrOGqzeeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4NDU3Mw==", "bodyText": "Der Iterator leert diese Queue, dass sollte doch nicht so sein, oder?", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447184573", "createdAt": "2020-06-29T18:55:44Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4Njk0MA==", "bodyText": "Ich w\u00fcrde ihn weglassen, wenn er nicht gebraucht wird.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447186940", "createdAt": "2020-06-29T18:59:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4NDU3Mw=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNjc2MQ==", "bodyText": "So implementieren andere Queues es auch", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447536761", "createdAt": "2020-06-30T09:15:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4NDU3Mw=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODU4ODA3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTo0OTo1NFrOGqsp0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTo0MToyN1rOGq0c8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNDk3OQ==", "bodyText": "Ich w\u00fcrde das increment in eine extra Funktion auslagern, da du die Magic \u00f6fter machst.\nIch bin mir gerade auch nicht \u00fcber das  % (queues.length - 1) sicher. Wenn queues.length=1 ist, dann solltest du hier eine  ArithmeticException: / by zero bekommen.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447424979", "createdAt": "2020-06-30T05:49:54Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNjA5MA==", "bodyText": "Eigentlich solltest du % queues.length wenn ich \u00fcberlege. Sonst l\u00e4sst du doch die letzte Queue aus", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447426090", "createdAt": "2020-06-30T05:53:12Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNDk3OQ=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1Mjc1NA==", "bodyText": "stimmt! Wobei auslagern hier doof ist", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447552754", "createdAt": "2020-06-30T09:41:27Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNDk3OQ=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODU5ODczOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTo1NDo0MVrOGqswGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTo1NDo0MVrOGqswGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNjU4NQ==", "bodyText": "Warum beginnst du hier bei 1?", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447426585", "createdAt": "2020-06-30T05:54:41Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);\n+\t\t\tQueue<E> curr = queues[index];\n+\n+\t\t\tif (curr == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// Poll once, if successful update the index of the last polled queue and return the polled element.\n+\t\t\tE out = curr.poll();\n+\n+\t\t\tif (out != null) {\n+\t\t\t\tlog.trace(\"Thread[{}] found Work in Queue[{}].\", Thread.currentThread().getName(), index);\n+\t\t\t\tcycleIndex.set(index + 1);\n+\t\t\t\treturn out;\n+\t\t\t}\n+\t\t}\n+\n+\t\tlog.trace(\"All Queues were empty.\");\n+\n+\n+\t\t// If no queue had elements, return null.\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t * Peek all queues for the next available element.\n+\t *\n+\t * @apiNote this method is NOT guaranteed to be stable: peeking multiple times will peek different queues.\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Override\n+\tpublic E peek() {\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 1; offset < queues.length; offset++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODYwMTY2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTo1NTo0NlrOGqsxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTo0MToxMFrOGq0cOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNzAxNA==", "bodyText": "Ich denke, dass gerade der cycleIndex gewrapt werden sollte", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447427014", "createdAt": "2020-06-30T05:55:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);\n+\t\t\tQueue<E> curr = queues[index];\n+\n+\t\t\tif (curr == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// Poll once, if successful update the index of the last polled queue and return the polled element.\n+\t\t\tE out = curr.poll();\n+\n+\t\t\tif (out != null) {\n+\t\t\t\tlog.trace(\"Thread[{}] found Work in Queue[{}].\", Thread.currentThread().getName(), index);\n+\t\t\t\tcycleIndex.set(index + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1MjU3MQ==", "bodyText": "ne weil der modulot wird beim zugriff auf die queues", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447552571", "createdAt": "2020-06-30T09:41:10Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);\n+\t\t\tQueue<E> curr = queues[index];\n+\n+\t\t\tif (curr == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// Poll once, if successful update the index of the last polled queue and return the polled element.\n+\t\t\tE out = curr.poll();\n+\n+\t\t\tif (out != null) {\n+\t\t\t\tlog.trace(\"Thread[{}] found Work in Queue[{}].\", Thread.currentThread().getName(), index);\n+\t\t\t\tcycleIndex.set(index + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQyNzAxNA=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODY3MDk1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjoyMjo0OFrOGqtZZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjoyMjo0OFrOGqtZZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQzNzE1OQ==", "bodyText": "Alle erste mal auf UnsupportedOperationException", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447437159", "createdAt": "2020-06-30T06:22:48Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/util/RoundRobinQueue.java", "diffHunk": "@@ -0,0 +1,457 @@\n+package com.bakdata.conquery.util;\n+\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.validation.constraints.Min;\n+\n+import com.google.common.collect.ForwardingQueue;\n+import com.google.common.collect.Queues;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Class implementing a queue that is backed by multiple queues at once that are evenly processed, avoiding starvation of jobs when a single producer creates a lot of jobs.\n+ *\n+ * @param <E>\n+ */\n+@Slf4j\n+// TODO: 26.06.2020 fk: migrate logging to trace\n+public class RoundRobinQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {\n+\n+\t/**\n+\t * If {@code queues} is full, it is grown by {@code GROWTH_FACTOR}.\n+\t */\n+\tprivate static final double GROWTH_FACTOR = 1.5d;\n+\n+\t/**\n+\t * The backing queues.\n+\t *\n+\t * @implNote null denotes no queue, and this queue must not be contiguously filled: Deletions just unset the queue so it is no longer processed.\n+\t */\n+\tprivate Queue<E>[] queues;\n+\tprivate final Object signal = new Object();\n+\n+\t/**\n+\t * The index to start polling. This is remembered so we don't have a bias towards lower indices.\n+\t */\n+\tprivate final ThreadLocal<Integer> cycleIndex = ThreadLocal.withInitial(() -> 0);\n+\n+\tpublic RoundRobinQueue(@Min(1) int capacity) {\n+\t\tsuper();\n+\t\tqueues = new Queue[capacity];\n+\t}\n+\n+\t/**\n+\t * @return Maximum number of queues allowed in this queue.\n+\t */\n+\tpublic int getCapacity() {\n+\t\treturn queues.length;\n+\t}\n+\n+\t/**\n+\t * @return Number of sub-queues.\n+\t */\n+\tpublic int getNQueues() {\n+\t\treturn (int) Arrays.stream(queues).filter(Objects::nonNull).count();\n+\t}\n+\n+\n+\t/**\n+\t * Helper class that notifies on {@code signal} when a new object is added to it queue, awakening waiting threads. This effectively implements a semaphore aroud {@code signal} as notify only awakens a single waiting thread.\n+\t */\n+\t@RequiredArgsConstructor\n+\tprivate static class SignallingForwardingQueue<T> extends ForwardingQueue<T> {\n+\n+\t\t/**\n+\t\t * The original queue.\n+\t\t */\n+\t\t@NonNull\n+\t\tprivate final Queue<T> base;\n+\n+\t\t/**\n+\t\t * The signal object to be notified on.\n+\t\t */\n+\t\tprivate final Object signal;\n+\n+\t\t@Override\n+\t\tprotected Queue<T> delegate() {\n+\t\t\treturn base;\n+\t\t}\n+\n+\t\tprotected void doNotify() {\n+\t\t\tlog.trace(\"Awakening a thread for new Work.\");\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.notify();\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean offer(T element) {\n+\t\t\tfinal boolean offer = super.offer(element);\n+\n+\t\t\tif (offer) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn offer;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to add a new element to the queue, if successful notify on signal, awakening a waiting thread.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean add(T element) {\n+\t\t\tfinal boolean add = super.add(element);\n+\n+\t\t\tif (add) {\n+\t\t\t\tdoNotify();\n+\t\t\t}\n+\n+\t\t\treturn add;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Try to offer multiple elements to the queue, if successful notify all threads waiting on signal.\n+\t\t *\n+\t\t * @implNote this can actually cause some threads to receive nothing, as the collections size might be smaller than the number of waiting threads.\n+\t\t */\n+\t\t@Override\n+\t\tpublic boolean addAll(Collection<? extends T> collection) {\n+\t\t\tfinal boolean addAll = super.addAll(collection);\n+\n+\t\t\tif (addAll) {\n+\t\t\t\t//TODO does this cause problems?\n+\t\t\t\tsynchronized (signal) {\n+\t\t\t\t\tsignal.notifyAll();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn addAll;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a new queue adding it as sub-queue if there is a slot available.\n+\t *\n+\t * @return\n+\t * @throws IllegalStateException when no more slots are available.\n+\t */\n+\tpublic Queue<E> createQueue() {\n+\t\t// TODO: 25.06.2020 FK: add supplier as creation parameter\n+\t\tfinal Queue<E> out = new SignallingForwardingQueue<E>(Queues.newConcurrentLinkedQueue(), signal);\n+\t\tfinal int free;\n+\n+\t\tsynchronized (signal) {\n+\t\t\tfree = ArrayUtils.indexOf(queues, null);\n+\n+\t\t\tif (free == -1) {\n+\t\t\t\tlog.warn(\"Growing RoundRobinQueue to new size {}\", (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t\tqueues = Arrays.copyOf(queues, (int) ((double) getCapacity() * GROWTH_FACTOR));\n+\t\t\t}\n+\n+\t\t\tqueues[free] = out;\n+\t\t}\n+\n+\t\tlog.debug(\"Create a new Queue at {}. Now have {}\", free, getNQueues());\n+\n+\t\treturn out;\n+\t}\n+\n+\t/**\n+\t * Tries to remove the queue if it is inside.\n+\t *\n+\t * @param del the Queue to delete.\n+\t * @return true if the queue was deleted, false if not.\n+\t */\n+\tpublic boolean removeQueue(Queue<E> del) {\n+\t\tfinal int index;\n+\t\tsynchronized (signal) {\n+\t\t\tindex = ArrayUtils.indexOf(queues, del);\n+\n+\t\t\tif (index == -1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tqueues[index] = null;\n+\t\t}\n+\n+\t\tlog.debug(\"Removing Queue at {}. Now have {}\", index, getNQueues());\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * The number of elements over all queues.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tint sum = 0;\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null) {\n+\t\t\t\tsum += queue.size();\n+\t\t\t}\n+\t\t}\n+\t\treturn sum;\n+\t}\n+\n+\t/**\n+\t * @return true, if all queues are empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && !queue.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * @param o the Object to check.\n+\t * @return True, if any queue contains the element.\n+\t */\n+\t@Override\n+\tpublic boolean contains(Object o) {\n+\t\tfor (Queue<E> queue : queues) {\n+\t\t\tif (queue != null && queue.contains(o)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param c the objects to check.\n+\t * @return True, if all objects are contained in any of the queues.\n+\t */\n+\t@Override\n+\tpublic boolean containsAll(@NotNull Collection<?> c) {\n+\t\tfor (Object o : c) {\n+\t\t\tif (!contains(o)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Create an iterator looping until the queues are empty.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new Iterator<E>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn !isEmpty();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic E next() {\n+\t\t\t\treturn poll();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\t/**\n+\t * Take one element from the queue, blocking until there is a new object available.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@NotNull\n+\t@Override\n+\tpublic E take() throws InterruptedException {\n+\t\twhile (true) {\n+\t\t\tE out = poll();\n+\t\t\tif (out != null) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\t\tsynchronized (signal) {\n+\t\t\t\tsignal.wait();\n+\t\t\t}\n+\n+\t\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Try taking one element from the queue, blocking until there is a new object available, or the timeout expires.\n+\t *\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Nullable\n+\t@Override\n+\tpublic E poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {\n+\t\tE out = poll();\n+\n+\t\tif (out != null) {\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}], no element in Queue, waiting on Signal.\", Thread.currentThread().getName());\n+\n+\t\tsynchronized (signal) {\n+\t\t\tunit.timedWait(signal, timeout);\n+\t\t}\n+\n+\t\tlog.trace(\"Thread[{}] Awakened for new Work.\", Thread.currentThread().getName());\n+\n+\t\treturn poll();\n+\t}\n+\n+\n+\t/**\n+\t * Find an element in any queue. Start searching in a different queue each time.\n+\t */\n+\t@Override\n+\tpublic E poll() {\n+\t\t// The next queue we look poll\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 0; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);\n+\t\t\tQueue<E> curr = queues[index];\n+\n+\t\t\tif (curr == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// Poll once, if successful update the index of the last polled queue and return the polled element.\n+\t\t\tE out = curr.poll();\n+\n+\t\t\tif (out != null) {\n+\t\t\t\tlog.trace(\"Thread[{}] found Work in Queue[{}].\", Thread.currentThread().getName(), index);\n+\t\t\t\tcycleIndex.set(index + 1);\n+\t\t\t\treturn out;\n+\t\t\t}\n+\t\t}\n+\n+\t\tlog.trace(\"All Queues were empty.\");\n+\n+\n+\t\t// If no queue had elements, return null.\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t * Peek all queues for the next available element.\n+\t *\n+\t * @apiNote this method is NOT guaranteed to be stable: peeking multiple times will peek different queues.\n+\t * @implNote see {@link RoundRobinQueue::poll()} for implementation details.\n+\t */\n+\t@Override\n+\tpublic E peek() {\n+\t\tfinal int begin = cycleIndex.get();\n+\n+\t\tfor (int offset = 1; offset < queues.length; offset++) {\n+\t\t\tfinal int index = (begin + offset) % (queues.length - 1);\n+\t\t\tQueue<E> curr = queues[index];\n+\n+\t\t\tif (curr == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tE out = curr.peek();\n+\n+\t\t\tif (out != null) {\n+\t\t\t\tcycleIndex.set(index);\n+\t\t\t\treturn out;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\n+\t//=====================================\n+\t//=       Unsupported Methods         =\n+\t//=====================================\n+\n+\t@Override\n+\tpublic int drainTo(@NotNull Collection<? super E> c) {\n+\t\t// TODO: 25.06.2020 implement this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODY3MjQzOnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/integration/tests/MetadataCollectionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjoyMzoyOFrOGqtaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTo0MzoyMFrOGq0hmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQzNzM3OQ==", "bodyText": "Ist das sleep notwendig?", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447437379", "createdAt": "2020-06-30T06:23:28Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/integration/tests/MetadataCollectionTest.java", "diffHunk": "@@ -33,12 +32,9 @@ public void execute(StandaloneSupport conquery) throws Exception {\n \t\ttest.importRequiredData(conquery);\n \t\t\n \t\t//ensure the metadata is collected\n-\t\tfor(SlaveCommand slave : conquery.getSlaves()) {\n-\t\t\tslave.getWorkers().getWorkers().forEach((id, worker) -> {\n-\t\t\t\tworker.getJobManager().addSlowJob(new UpdateMatchingStats(worker));\n-\t\t\t});\n-\t\t}\n-\t\t\n+\t\tconquery.getNamespace().sendToAll(new UpdateMatchingStatsMessage());\n+\n+\t\tThread.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1Mzk0NQ==", "bodyText": "ups, nein war nur um zu testen wegen isBusy", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447553945", "createdAt": "2020-06-30T09:43:20Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/integration/tests/MetadataCollectionTest.java", "diffHunk": "@@ -33,12 +32,9 @@ public void execute(StandaloneSupport conquery) throws Exception {\n \t\ttest.importRequiredData(conquery);\n \t\t\n \t\t//ensure the metadata is collected\n-\t\tfor(SlaveCommand slave : conquery.getSlaves()) {\n-\t\t\tslave.getWorkers().getWorkers().forEach((id, worker) -> {\n-\t\t\t\tworker.getJobManager().addSlowJob(new UpdateMatchingStats(worker));\n-\t\t\t});\n-\t\t}\n-\t\t\n+\t\tconquery.getNamespace().sendToAll(new UpdateMatchingStatsMessage());\n+\n+\t\tThread.sleep(5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQzNzM3OQ=="}, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODcwMTMzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjozMzozOVrOGqtq-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjozMzozOVrOGqtq-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0MTY1OA==", "bodyText": "Die Funktion sollte denke ich weg und dadurch ersetzt werden dass Updatematching stats auf seine kreierten Jobs synchronisiert.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r447441658", "createdAt": "2020-06-30T06:33:39Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/worker/Worker.java", "diffHunk": "@@ -49,15 +79,23 @@ public MasterMessage transform(NamespaceMessage message) {\n \t\n \t@Override\n \tpublic void close() throws IOException {\n-\t\tqueryExecutor.close();\n+\t\tpool.shutdownNow();\n \t\tstorage.close();\n \t}\n \t\n \t@Override\n \tpublic String toString() {\n \t\treturn \"Worker[\" + info.getId() + \", \" + session.getLocalAddress() + \"]\";\n \t}\n+\n+\tpublic void awaitSubJobTermination() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "311bb1045b5e524150ec2c4df3d81d4903db7ade"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDQ0ODY0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjo1NjowN1rOGrktlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjo1NjowN1rOGrktlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM0MzQ0NQ==", "bodyText": ".getNThreads() oder .getThreads()", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r448343445", "createdAt": "2020-07-01T12:56:07Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "diffHunk": "@@ -92,10 +90,7 @@ protected void run(Environment environment, Namespace namespace, ConqueryConfig\n \t\t\tlog.warn(\"Had to create Storage Dir at `{}`\", config.getStorage().getDirectory());\n \t\t}\n \n-\t\tworkers = new Workers(new RoundRobinQueue<>(config.getQueries().getRoundRobinQueueCapacity()), config.getQueries().getNThreads());\n-\n-\n-\t\tExecutorService loaders = Executors.newFixedThreadPool(config.getStorage().getThreads());\n+\t\tworkers = new Workers(new RoundRobinQueue<>(config.getQueries().getRoundRobinQueueCapacity()), config.getQueries().getNThreads(), config.getStorage().getThreads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be8f1bae8a09df95ab955a16d06339fac1fbdf5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDUwNDI1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzoxMTo0OVrOGrlQiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzoxMTo0OVrOGrlQiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1MjM5NQ==", "bodyText": "Wenn das immer gemacht wird, dann kann man die Job-Liste zu einem SortedSet machen, so dass schon gleich beim Inset nach dem Progress sortiert wird.", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r448352395", "createdAt": "2020-07-01T13:11:49Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/commands/SlaveCommand.java", "diffHunk": "@@ -229,17 +245,29 @@ public void stop() throws Exception {\n \t\tlog.info(\"Connection was closed by master\");\n \t\tconnector.dispose();\n \t}\n+\n \tprivate void reportJobManagerStatus() {\n+\t\tif (context == null || !context.isConnected()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Collect the Slaves and all its workers jobs into a single queue\n+\t\tfinal JobManagerStatus jobManagerStatus = jobManager.reportStatus();\n+\n+\t\tfor (Worker worker : workers.getWorkers().values()) {\n+\t\t\tjobManagerStatus.getJobs().addAll(worker.getJobManager().reportStatus().getJobs());\n+\t\t}\n+\n+\t\tjobManagerStatus.getJobs().sort(Comparator.comparingDouble(js -> js.getProgressReporter().getProgress()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0be8f1bae8a09df95ab955a16d06339fac1fbdf5"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDgxNTc4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/config/ClusterConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyODoyOFrOGroV0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyODoyOFrOGroV0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwMjg5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r448402898", "createdAt": "2020-07-01T14:28:28Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/config/ClusterConfig.java", "diffHunk": "@@ -21,5 +21,6 @@\n \tprivate MinaConfig mina = new MinaConfig();\n \t@Min(1)\n \tprivate int entityBucketSize = 1000;\n-\t\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc5de14a92cf04665c948f1763b4af2cf02642"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDgxOTQ0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyOToxM1rOGroYGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyOToxM1rOGroYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwMzQ4Mw==", "bodyText": ":D das war 0", "url": "https://github.com/bakdata/conquery/pull/1216#discussion_r448403483", "createdAt": "2020-07-01T14:29:13Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java", "diffHunk": "@@ -25,6 +24,6 @@\n \t@NotNull\n \tprivate Duration weakCacheDuration = Duration.hours(48);\n \n-\t@Min(0)\n-\tprivate int threads = Runtime.getRuntime().availableProcessors();\n+\t@Min(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc5de14a92cf04665c948f1763b4af2cf02642"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1407, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}