{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNDAyNzk0", "number": 1505, "title": "correct datacontext generation", "bodyText": "It's now possible to align the desired result date resolution to finer grain calendar borders, e.g:\nA Daterange of 02.08.2017-30.10.2019  might be subdivided into years which are aligned by calendar quarters:\nJ_0: 02.08.2017-30.09.2018\nJ_1: 01.10.2018-30.09.2019\nJ_2: 01.10.2019-30.10.2019\nor (how it was until now) on calendar years:\nJ_0: 02.08.2017-31.12.2018\nJ_1: 01.01.2018-31.12.2019\nJ_0: 01.01.2019-30.10.2019\nThese are absolute examples, the result is more important on relative Queries, which than allow to have equally size subdivisions for all entities.", "createdAt": "2020-12-15T16:51:22Z", "url": "https://github.com/bakdata/conquery/pull/1505", "merged": true, "mergeCommit": {"oid": "d5592a94f6fadff6c140d8e46f022211ec1ebaa1"}, "closed": true, "closedAt": "2020-12-16T16:32:53Z", "author": {"login": "thoniTUB"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmqRi2AH2gAyNTQwNDAyNzk0Ojk4ZmU4YjI0ZWY0Mjc3YzM3MDk0YzFlZmExNzBmOWYzN2U5N2YwOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmwSyHgFqTU1Mzc3NDEyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "98fe8b24ef4277c37094c1efa170f9f37e97f08c", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/98fe8b24ef4277c37094c1efa170f9f37e97f08c", "committedDate": "2020-12-16T08:01:32Z", "message": "wip: date context relative to context mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40235a99da8de863c16ec2e3ed5c9e2f5dd10133", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/40235a99da8de863c16ec2e3ed5c9e2f5dd10133", "committedDate": "2020-12-16T08:01:33Z", "message": "algorithm draft"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2bd1f2a01ddf90bea2667699a307aca267458da", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/f2bd1f2a01ddf90bea2667699a307aca267458da", "committedDate": "2020-12-16T08:01:33Z", "message": "fix date context tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c70b44e1e82235b3849e2f93611401bc3a2e951", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/8c70b44e1e82235b3849e2f93611401bc3a2e951", "committedDate": "2020-12-16T08:01:34Z", "message": "makes integration tests pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cdfbb5b9b8b2efa7536cc4a856e4adc2ed72d91", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/2cdfbb5b9b8b2efa7536cc4a856e4adc2ed72d91", "committedDate": "2020-12-16T08:01:35Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924dfe735085f75a63273e1b49f48222c880f976", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/924dfe735085f75a63273e1b49f48222c880f976", "committedDate": "2020-12-16T08:01:36Z", "message": "fixes query tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66da8f642ce1c1cddd6f0d12655906af5d050ec1", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/66da8f642ce1c1cddd6f0d12655906af5d050ec1", "committedDate": "2020-12-16T08:01:36Z", "message": "using extra enum to descripte calendar units"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/9861f332a05035e9b60b59a2b61bbf0136730332", "committedDate": "2020-12-16T08:01:37Z", "message": "automatic update to docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee5361458b6a5f64f81fe5690aec23f79fbd15d9", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/ee5361458b6a5f64f81fe5690aec23f79fbd15d9", "committedDate": "2020-12-15T17:10:40Z", "message": "automatic update to docs"}, "afterCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/9861f332a05035e9b60b59a2b61bbf0136730332", "committedDate": "2020-12-16T08:01:37Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ad65b600010a1cbec5de3739b76cb28451340bb", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/1ad65b600010a1cbec5de3739b76cb28451340bb", "committedDate": "2020-12-16T09:53:48Z", "message": "adds more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/53aac6b9881ef0b82d2fc8d3e85110977ad50259", "committedDate": "2020-12-16T09:54:05Z", "message": "wip more doku"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/a3ae6f610e1d932579b8731c7d1986df5656cf85", "committedDate": "2020-12-16T10:08:05Z", "message": "Merge branch 'develop' into feature/correct-datacontext-generation\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDUwOTY4", "url": "https://github.com/bakdata/conquery/pull/1505#pullrequestreview-553450968", "createdAt": "2020-12-16T08:24:56Z", "commit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNDo1NlrOIG5TGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0NjoxMFrOIG_Emg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTE0Ng==", "bodyText": "falsche Anno", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101146", "createdAt": "2020-12-16T08:24:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTcyOQ==", "bodyText": "den else branch finde ich nicht sauber, mach lieber eine Liste draus oder besser eine Methode", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101729", "createdAt": "2020-12-16T08:25:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull\n+\tpublic static List<ExportForm.ResolutionAndAlignment> getResolutionAlignmentMap(List<DateContext.Resolution> resolutions, DateContext.Alignment alignmentHint) {\n+\n+\t\treturn resolutions.stream()\n+\t\t\t\t.map(r -> ResolutionAndAlignment.of(r, r.getSupportedAlignments().contains(alignmentHint)? alignmentHint : r.getSupportedAlignments().iterator().next()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA==", "bodyText": "Warum handlest du die unterschiedlich? Kann es denn vorkommen, dass du das enum direkt bekommst und nicht den String oder andersrum?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544103614", "createdAt": "2020-12-16T08:28:50Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "diffHunk": "@@ -42,13 +42,13 @@ public String print(PrintSettings cfg, Object f) {\n \n \t\t@Override\n \t\tpublic String print(PrintSettings cfg, Object f) {\n-\t\t\tif (f instanceof DateContextMode) {\n-\t\t\t\treturn ((DateContextMode) f).toString(cfg.getLocale());\n+\t\t\tif (f instanceof DateContext.Resolution) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDQ4Mg==", "bodyText": "del", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104482", "createdAt": "2020-12-16T08:30:13Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -25,6 +25,7 @@\n import com.fasterxml.jackson.annotation.JsonCreator;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.tuple.Pair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgxNA==", "bodyText": "JsonIgnore? Oder kann das FE uns das schicken?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104814", "createdAt": "2020-12-16T08:30:50Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -38,7 +39,7 @@\n \t@NotNull @Valid\n \tprivate final ArrayConceptQuery features;\n \t@NotNull\n-\tprivate final List<DateContextMode> resolutions;\n+\tprivate final List<ExportForm.ResolutionAndAlignment> resolutionsAndAlignmentMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExOTU2MQ==", "bodyText": "was bedeutet es, dass es an stelle 0 und 1 ist?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544119561", "createdAt": "2020-12-16T08:54:06Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -189,13 +189,13 @@ private boolean hasCompleteDateContexts(List<DateContext> contexts) {\n \t\tif (featurePlan.getAggregatorSize() > 0 && outcomePlan.getAggregatorSize() > 0) {\n \t\t\t// We have features and outcomes check if both have complete date ranges (they should be at the beginning of the list)\n \t\t\treturn contexts.size()>=2\n-\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n-\t\t\t\t&& contexts.get(1).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n+\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContext.Resolution.COMPLETE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMDI1Nw==", "bodyText": "Da fehlt auf jeden Fall Doku", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544120257", "createdAt": "2020-12-16T08:55:06Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyNDc2MA==", "bodyText": "das                        interessant\n  Formatting ist", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544124760", "createdAt": "2020-12-16T09:01:43Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDExOA==", "bodyText": "das OOB'd wenn aligendSubdivisions empt ist", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194118", "createdAt": "2020-12-16T10:43:32Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDM2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n          \n          \n            \n            \t * Generates a list of date contexts around an index date which belong either to a feature date range (before the index)", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194366", "createdAt": "2020-12-16T10:43:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));\n+\t\t\t}\n+\n+\t\t\treturn alignRef.getAlignedIterationDirection(result);\n+\t\t};\n+\t}\n+\n \t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NTczOA==", "bodyText": "CDateSet ?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544195738", "createdAt": "2020-12-16T10:46:10Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateRangeSubDivider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public interface DateRangeSubDivider {\n+\n+    List<CDateRange> subdivideRange(CDateRange range);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e9eb91780bccdaec7646cbab6186ebee51ced76", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/2e9eb91780bccdaec7646cbab6186ebee51ced76", "committedDate": "2020-12-16T10:58:03Z", "message": "Update backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be68a54f61652ece9762c314a8394cf008299f79", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/be68a54f61652ece9762c314a8394cf008299f79", "committedDate": "2020-12-16T12:56:08Z", "message": "adds more doku"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "853c6ab3ae9ca4dba8ed104da9d45749713afcef", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/853c6ab3ae9ca4dba8ed104da9d45749713afcef", "committedDate": "2020-12-16T12:58:53Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92edc71b3b5c70b8a4551a9d566c524795ae0f2c", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/92edc71b3b5c70b8a4551a9d566c524795ae0f2c", "committedDate": "2020-12-16T14:08:38Z", "message": "Merge branch 'develop' into feature/correct-datacontext-generation\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzc0MTIw", "url": "https://github.com/bakdata/conquery/pull/1505#pullrequestreview-553774120", "createdAt": "2020-12-16T15:02:19Z", "commit": {"oid": "92edc71b3b5c70b8a4551a9d566c524795ae0f2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4792, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}