{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzAxMjgz", "number": 1058, "title": "Feature/move export form", "bodyText": "Ports the backend formular engine to conquery", "createdAt": "2020-02-26T14:20:32Z", "url": "https://github.com/bakdata/conquery/pull/1058", "merged": true, "mergeCommit": {"oid": "99d2bfba8b773e731ac459407cde8ebf850cb85f"}, "closed": true, "closedAt": "2020-03-16T11:28:39Z", "author": {"login": "thoniTUB"}, "timelineItems": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFzexCAH2gAyMzgwMzAxMjgzOjFjMmZiNjM2MTY1ODI2NjdlMmM0ZWFkMzg4ODU2ZTg3NjYyYWQwNTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOMXEmgH2gAyMzgwMzAxMjgzOjIwMWIzZWIxNjRjOWY4MmJjOWVlNjhmNGJmNzY4YjFhNjMwYTViNTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1c2fb63616582667e2c4ead388856e87662ad050", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/1c2fb63616582667e2c4ead388856e87662ad050", "committedDate": "2020-02-19T09:54:28Z", "message": "WIP move export form"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eaa37adfcd63476416d8e48faa0d9c5587dda33", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/3eaa37adfcd63476416d8e48faa0d9c5587dda33", "committedDate": "2020-02-20T10:00:30Z", "message": "WIP unify executions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a5ca191450a20d0b58530a3b4dbf61465ea115c", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/4a5ca191450a20d0b58530a3b4dbf61465ea115c", "committedDate": "2020-02-20T10:03:34Z", "message": "WIP unify executions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8441f1fcfeee76bd59a3e4bc289b2cb84307e45", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/e8441f1fcfeee76bd59a3e4bc289b2cb84307e45", "committedDate": "2020-02-21T08:12:55Z", "message": "Makes forms execute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dfdd10cae1f7b2e39f9865c23f066efcb96c11e", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/8dfdd10cae1f7b2e39f9865c23f066efcb96c11e", "committedDate": "2020-02-24T09:47:03Z", "message": "adds tests and data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecc791d0c26fbc285a80162b3ff48d1a329d5cb7", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/ecc791d0c26fbc285a80162b3ff48d1a329d5cb7", "committedDate": "2020-02-24T09:51:02Z", "message": "removes comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "047e4b55895b8cf84ca4e4b43aba5d8505d0379c", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/047e4b55895b8cf84ca4e4b43aba5d8505d0379c", "committedDate": "2020-02-24T17:39:34Z", "message": "makes forms csv renderable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "173b9b7f6dc2f6f860c84e703afd688b0ce396c7", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/173b9b7f6dc2f6f860c84e703afd688b0ce396c7", "committedDate": "2020-02-25T08:24:43Z", "message": "revert to query id"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16cbb0fa267b42573e1894319335ae8ea7490ded", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/16cbb0fa267b42573e1894319335ae8ea7490ded", "committedDate": "2020-02-25T08:52:18Z", "message": "makes forms work on query endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de98b1c94358164bb62060abbe3c6d7ce5e82c77", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/de98b1c94358164bb62060abbe3c6d7ce5e82c77", "committedDate": "2020-02-25T14:46:36Z", "message": "fixes id mapping warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5369340ffe265d480798891036dc006f41e9b79", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/e5369340ffe265d480798891036dc006f41e9b79", "committedDate": "2020-02-25T21:46:51Z", "message": "refines the generation interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9afcc842fa164e7f3a40392e68d9dbc80b646add", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/9afcc842fa164e7f3a40392e68d9dbc80b646add", "committedDate": "2020-02-26T10:10:53Z", "message": "move form endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2db5f43f723e3eb9cc030c6db23124b3a41ef81a", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/2db5f43f723e3eb9cc030c6db23124b3a41ef81a", "committedDate": "2020-02-26T14:18:31Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcb4b06fd1090a1974591a399254b249cf0d4d7f", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/dcb4b06fd1090a1974591a399254b249cf0d4d7f", "committedDate": "2020-02-26T14:50:43Z", "message": "enables permission checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/c6d11a5f27695a4b352bd2ef56045805444f9e90", "committedDate": "2020-02-26T14:51:14Z", "message": "enables permission checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a49c7a446d39d97039e6a0e290074c914665d16", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/5a49c7a446d39d97039e6a0e290074c914665d16", "committedDate": "2020-02-27T08:29:18Z", "message": "fix auto doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "717b710aef17b984a7fd64bada44433ad944387a", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/717b710aef17b984a7fd64bada44433ad944387a", "committedDate": "2020-02-27T08:29:29Z", "message": "Merge 5a49c7a446d39d97039e6a0e290074c914665d16 into 5069bf6e15c95229661b99828bbab56c7be45647"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/8707638d140d8c4d45ec2c37794d8a02095b6a7c", "committedDate": "2020-02-27T08:31:29Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02215ee621f6a4b360fc384cb702cfa43c15a186", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/02215ee621f6a4b360fc384cb702cfa43c15a186", "committedDate": "2020-02-27T10:18:10Z", "message": "review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6882f3855cc1d9262c9b4bc352bd863a282f1ddb", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/6882f3855cc1d9262c9b4bc352bd863a282f1ddb", "committedDate": "2020-02-27T10:18:32Z", "message": "Merge branch 'feature/move-export-form' of https://github.com/bakdata/conquery into feature/move-export-form"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e177dd649ffe8ea9c8132658d63b400812a18399", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/e177dd649ffe8ea9c8132658d63b400812a18399", "committedDate": "2020-02-27T10:42:08Z", "message": "review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14a486bd5890b4c3397de14c2116301876b46546", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/14a486bd5890b4c3397de14c2116301876b46546", "committedDate": "2020-02-27T10:43:57Z", "message": "Merge branch 'develop' into feature/move-export-form\n\n# Conflicts:\n#\tbackend/src/test/java/com/bakdata/conquery/integration/IntegrationTests.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDg2Mzg4", "url": "https://github.com/bakdata/conquery/pull/1058#pullrequestreview-365086388", "createdAt": "2020-02-26T17:13:35Z", "commit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMzozNVrOFu0hLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjowMTo0OVrOFvPosg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzOTI3OA==", "bodyText": "Kannst du evtl 5min \u00fcberlegen, ob man das Dataset auch komplett aus der Query kriegt und dann in der Ausf\u00fchrung erst aufl\u00f6st?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384639278", "createdAt": "2020-02-26T17:13:35Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/QueryProcessor.java", "diffHunk": "@@ -65,43 +66,53 @@ public ExecutionStatus postQuery(Dataset dataset, IQuery query, URLBuilder urlb,\n \t\t\t}\n \t\t}\n \t\t\n-\t\tManagedQuery mq = namespace.getQueryManager().runQuery(query, user);\n \n+\t\tManagedExecution<?> mq = ExecutionManager.runQuery(storage, namespaces, query, user.getId(), dataset.getId());\n \t\t// Set abilities for submitted query\n \t\tuser.addPermission(storage, QueryPermission.onInstance(AbilitySets.QUERY_CREATOR, mq.getId()));\n \n+\t\tif(query instanceof IQuery) {\n+\t\t\ttranslateToOtherDatasets(dataset, query, user, mq);\n+\t\t}\n+\n+\t\t// return status\n+\t\treturn getStatus(dataset, mq, urlb, user);\n+\t}\n+\n+\tprivate void translateToOtherDatasets(Dataset dataset, SubmittedQuery query, User user, ManagedExecution<?> mq) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDMyOQ==", "bodyText": "semicolon", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384640329", "createdAt": "2020-02-26T17:15:15Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/Form.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.bakdata.conquery.apiv1.forms;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.permissions.Ability;\n+import com.bakdata.conquery.models.auth.permissions.FormPermission;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+\n+/**\n+ * API representation of a form query.\n+ */\n+@Getter\n+@Setter\n+public abstract class Form implements SubmittedQuery {\n+\n+\tpublic abstract Map<String, List<ManagedQuery>> createSubQueries(Namespaces namespaces, UserId userId, DatasetId submittedDataset);\n+\n+\t/**\n+\t * Executed upon Execution initialization.\n+\t * E.g. Manipulate or add concepts to the form.\n+\t * @param namespaces\n+\t */\n+\tpublic void init(Namespaces namespaces) {\n+\t\t// Do nothing if not necessary\n+\t};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MjEyMw==", "bodyText": "Warum gibt es diese Klasse einfach als kopie der anderen? Wegen den Namen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384642123", "createdAt": "2020-02-26T17:18:15Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/TimeSelector.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.bakdata.conquery.apiv1.forms;\n+\n+import java.util.OptionalInt;\n+\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.query.concept.specific.temporal.TemporalSampler;\n+\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public enum TimeSelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MzQyMQ==", "bodyText": "brauchst das noch?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384643421", "createdAt": "2020-02-26T17:20:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/filters/Filter.java", "diffHunk": "@@ -43,7 +43,7 @@ public final boolean requiresColumn(Column c) {\n \t\treturn ArrayUtils.contains(getRequiredColumns(), c);\n \t}\n \n-\tpublic abstract FilterNode createAggregator(FE_TYPE filterValue);\n+\tpublic abstract FilterNode createAggregator(FE_TYPE filterValue);//, QueryPlanContext ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4MzM4MA==", "bodyText": "these classes?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384983380", "createdAt": "2020-02-27T08:47:34Z", "author": {"login": "awildturtok"}, "path": "autodoc/src/main/java/com/bakdata/conquery/handler/GroupHandler.java", "diffHunk": "@@ -371,6 +372,11 @@ private String printType(Ctx ctx, TypeSignature type) {\n \t\t\t\t\t+ \" to \"\n \t\t\t\t\t+ printType(ctx.withGeneric(true), classRef.getTypeArguments().get(1));\n \t\t\t}\n+\t\t\tif(ClassToInstanceMap.class.isAssignableFrom(cl)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NDE5NQ==", "bodyText": "Kannst du nicht noch einen Konstruktor f\u00fcr childQueries machen? Das w\u00fcrde den Code ordentlicher machen", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384984195", "createdAt": "2020-02-27T08:49:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/AbsExportGenerator.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.bakdata.conquery.models.forms.export;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.export_form.AbsoluteMode;\n+import com.bakdata.conquery.models.forms.managed.AbsoluteFormQuery;\n+import com.bakdata.conquery.models.forms.util.ConceptManipulator;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.CQElement;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class AbsExportGenerator {\n+\t\n+\tpublic static AbsoluteFormQuery generate(Namespaces namespaces, AbsoluteMode mode, DateContextMode resolution, UserId userId, DatasetId submittedDataset) {\n+\t\tManagedQuery prerequisite = (ManagedQuery)namespaces.getMetaStorage().getExecution(mode.getForm().getQueryGroup());\n+\t\n+\t\t// Apply defaults to user concept\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getFeatures(), namespaces);\n+\t\t\n+\t\tAbsoluteFormQuery query = new AbsoluteFormQuery(\n+\t\t\t(ConceptQuery) prerequisite.getQuery(),\n+\t\t\tmode.getDateRange(),\n+\t\t\tcreateSubQuery(mode.getFeatures()),\n+\t\t\tresolution\n+\t\t);\n+\t\t\n+\t\treturn query;\n+\t}\n+\t\n+\tpublic static ArrayConceptQuery createSubQuery(List<CQElement> features) {\n+\t\tList<ConceptQuery> cqWraps = features.stream().map(ConceptQuery::new).collect(Collectors.toList());\n+\t\treturn createSubPlanFromQueries(cqWraps);\n+\t}\n+\t\n+\tpublic static ArrayConceptQuery createSubPlanFromQueries(List<ConceptQuery> featureQueries) {\n+\t\tArrayConceptQuery subQuery = new ArrayConceptQuery();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NDgyNg==", "bodyText": "Die Funktion ist komisch, aber einziehen in das AbsExport w\u00e4re wohl auch nicht gut?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384984826", "createdAt": "2020-02-27T08:50:47Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/RelExportGenerator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.bakdata.conquery.models.forms.export;\n+\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.export_form.RelativeMode;\n+import com.bakdata.conquery.models.forms.managed.RelativeFormQuery;\n+import com.bakdata.conquery.models.forms.util.ConceptManipulator;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.concept.specific.ResultInfoDecorator;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.google.common.collect.ImmutableClassToInstanceMap;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class RelExportGenerator {\n+\t\n+\tpublic static RelativeFormQuery generate(Namespaces namespaces, RelativeMode mode, UserId userId, DatasetId submittedDataset) {\n+\t\tManagedQuery prerequisite = (ManagedQuery)namespaces.getMetaStorage().getExecution(mode.getForm().getQueryGroup());\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getFeatures(), namespaces);\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getOutcomes(), namespaces);\n+\t\t\n+\t\tRelativeFormQuery query = new RelativeFormQuery(\n+\t\t\t(ConceptQuery) prerequisite.getQuery(),\n+\t\t\tsetInfos(\n+\t\t\t\tAbsExportGenerator.createSubQuery(mode.getFeatures()),\n+\t\t\t\tFeatureGroup.FEATURE\n+\t\t\t),\n+\t\t\tsetInfos(\n+\t\t\t\tAbsExportGenerator.createSubQuery(mode.getOutcomes()),\n+\t\t\t\tFeatureGroup.OUTCOME\n+\t\t\t),\n+\t\t\tmode.getIndexSelector(),\n+\t\t\tmode.getIndexPlacement(),\n+\t\t\tmode.getTimeCountBefore(),\n+\t\t\tmode.getTimeCountAfter(),\n+\t\t\tmode.getTimeUnit()\n+\t\t);\n+\t\treturn query;\n+\t}\n+\t\n+\tprivate static ArrayConceptQuery setInfos(ArrayConceptQuery arrayQuery, FeatureGroup group) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Njc3MQ==", "bodyText": "Was macht das?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384986771", "createdAt": "2020-02-27T08:54:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/FormQueryPlan.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.forms.util.DateContext;\n+import com.bakdata.conquery.models.forms.util.ResultModifier;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public class FormQueryPlan implements QueryPlan {\n+\n+\tprivate final List<DateContext> dateContexts;\n+\tprivate final ArrayConceptQueryPlan features;\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tList<Object[]> resultValues = new ArrayList<>(dateContexts.size());\n+\t\t\n+\t\tfor(DateContext dateContext : dateContexts) {\n+\t\t\t\n+\t\t\tCloneContext clCtx = new CloneContext(ctx.getStorage());\n+\t\t\t\t\t\t\n+\t\t\tArrayConceptQueryPlan subPlan = features.clone(clCtx);\n+\t\n+\t\t\tCDateSet dateRestriction = CDateSet.create(ctx.getDateRestriction());\n+\t\t\tdateRestriction.retainAll(dateContext.getDateRange());\n+\t\t\tEntityResult subResult = subPlan.execute(ctx.withDateRestriction(dateRestriction), entity);\n+\t\t\t\n+\t\t\tresultValues.addAll(\n+\t\t\t\tResultModifier.modify(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NzU2NQ==", "bodyText": "weg", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384987565", "createdAt": "2020-02-27T08:56:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Nzg1NA==", "bodyText": "Haben die keine Id o\u00e4 \u00fcber die du sie identifizieren kannst?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384987854", "createdAt": "2020-02-27T08:57:03Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4ODczNQ==", "bodyText": "Kannst du das nicht vereinfachen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384988735", "createdAt": "2020-02-27T08:58:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;\n+\n+\t@InternalOnly\n+\tprivate Map<ManagedExecutionId,ManagedQuery> flatSubQueries;\n+\t\n+\t@JsonIgnore\n+\tprivate transient AtomicInteger openSubQueries;\n+\t\n+\tpublic ManagedForm(MasterMetaStorage storage, Form submittedForm, UserId owner, DatasetId submittedDataset) {\n+\t\tsuper(storage,  owner, submittedDataset);\n+\t\tthis.submittedForm = submittedForm;\n+\t}\n+\t\n+\n+\n+\t@Override\n+\tpublic void initExecutable(@NonNull Namespaces namespaces) {\n+\t\tsubmittedForm.init(namespaces);\n+\t\t// init all subqueries\n+\t\tsubQueries = submittedForm.createSubQueries(namespaces, super.getOwner(), super.getDataset());\n+\t\tflatSubQueries = subQueries.values().stream().flatMap(List::stream).collect(Collectors.toMap(ManagedQuery::getId, Function.identity()));\n+\t\tflatSubQueries.values().forEach(mq -> mq.initExecutable(namespaces));\n+\t\topenSubQueries = new AtomicInteger(flatSubQueries.values().size());\n+\t}\n+\t\n+\t@Override\n+\tpublic void start() {\n+\t\tflatSubQueries.values().forEach(ManagedQuery::start);\n+\t\tsuper.start();\n+\t}\n+\t\n+\t@Override\n+\tpublic ExecutionStatus buildStatus(URLBuilder url, User user) {\n+\t\tExecutionStatus status = super.buildStatus(url, user);\n+\t\t// Send null here, because no usable value can be reported to the user for a form\n+\t\tstatus.setNumberOfResults(null);\n+\t\treturn status;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ManagedQuery> toResultQuery() {\n+\t\tif(subQueries.size() == 1) {\n+\t\t\t// Get the query, only if there is only one in the whole execution\n+\t\t\treturn subQueries.values().iterator().next();\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Can't return the result query of a multi query form\");\n+\t}\n+\n+\t@Override\n+\tpublic Set<NamespacedId> getUsedNamespacedIds() {\n+\t\tNamespacedIdCollector collector = new NamespacedIdCollector();\n+\n+\t\tfor( Map.Entry<String, List<ManagedQuery>> entry : subQueries.entrySet()) {\n+\t\t\tfor(ManagedQuery subquery : entry.getValue()) {\n+\t\t\t\tsubquery.getQuery().visit(collector);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn collector.getIds();\n+\t}\n+\n+\t// Executed on Worker\n+\t@Override\n+\tpublic Map<ManagedExecutionId,QueryPlan> createQueryPlans(QueryPlanContext context) {\n+\t\tMap<ManagedExecutionId,QueryPlan> plans = new HashMap<>();\n+\t\tfor( ManagedQuery subQuery : flatSubQueries.values()) {\n+\t\t\tplans.putAll(subQuery.createQueryPlans(context));\n+\t\t}\n+\t\treturn plans;\n+\t}\n+\n+\t/**\n+\t * Distribute the result to a sub query.\n+\t */\n+\t@Override\n+\tpublic void addResult(FormSharedResult result) {\n+\t\tManagedQuery subQuery = flatSubQueries.get(result.getSubqueryId());\n+\t\tsubQuery.addResult(result);\n+\t\tswitch(subQuery.getState()) {\n+\t\t\tcase CANCELED:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4OTIyOA==", "bodyText": "doku", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384989228", "createdAt": "2020-02-27T08:59:54Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQuery.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.ConqueryConstants;\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeSelector;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@CPSType(id=\"RELATIVE_FORM_QUERY\", base=SubmittedQuery.class)\n+@Getter\n+@RequiredArgsConstructor(onConstructor_=@JsonCreator)\n+public class RelativeFormQuery extends IQuery {\n+\t@NotNull @Valid\n+\tprivate final ConceptQuery query;\n+\t@NotNull @Valid\n+\tprivate final ArrayConceptQuery features;\n+\t@NotNull @Valid\n+\tprivate final ArrayConceptQuery outcomes;\n+\t@NotNull\n+\tprivate final TimeSelector indexSelector;\n+\t@NotNull\n+\tprivate final IndexPlacement indexPlacement;\n+\t@Min(0)\n+\tprivate final int timeCountBefore;\n+\t@Min(0)\n+\tprivate final int timeCountAfter;\n+\t@NotNull\n+\tprivate final TimeUnit timeUnit;\n+\t\n+\t@Override\n+\tpublic RelativeFormQuery resolve(QueryResolveContext context) {\n+\t\treturn new RelativeFormQuery(\n+\t\t\tquery.resolve(context),\n+\t\t\tfeatures.resolve(context),\n+\t\t\toutcomes.resolve(context),\n+\t\t\tindexSelector,\n+\t\t\tindexPlacement,\n+\t\t\ttimeCountBefore,\n+\t\t\ttimeCountAfter,\n+\t\t\ttimeUnit\n+\t\t);\n+\t}\n+\t\n+\t@Override\n+\tpublic RelativeFormQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\treturn new RelativeFormQueryPlan(\n+\t\t\tquery.createQueryPlan(context.withGenerateSpecialDateUnion(true)),\n+\t\t\tfeatures.createQueryPlan(context.withGenerateSpecialDateUnion(false)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMzk3MQ==", "bodyText": "Das - 2 solltest du begr\u00fcnden", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385003971", "createdAt": "2020-02-27T09:27:58Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeSelector;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.forms.util.DateContext;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.ConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.query.results.MultilineContainedEntityResult;\n+import com.bakdata.conquery.models.query.results.SinglelineContainedEntityResult;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+@Getter @RequiredArgsConstructor\n+public class RelativeFormQueryPlan implements QueryPlan {\n+\n+\tprivate final ConceptQueryPlan query;\n+\tprivate final ArrayConceptQueryPlan featurePlan;\n+\tprivate final ArrayConceptQueryPlan outcomePlan;\n+\tprivate final TimeSelector indexSelector;\n+\tprivate final IndexPlacement indexPlacement;\n+\tprivate final int timeCountBefore;\n+\tprivate final int timeCountAfter;\n+\tprivate final TimeUnit timeUnit;\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tEntityResult preResult = query.execute(ctx, entity);\n+\t\tif (preResult.isFailed() || !preResult.isContained()) {\n+\t\t\treturn preResult;\n+\t\t}\n+\n+\t\tSinglelineContainedEntityResult contained = (SinglelineContainedEntityResult) preResult;\n+\t\tCDateSet dateSet = CDateSet.parse(Objects.toString(contained.getValues()[0]));\n+\t\tfinal OptionalInt sampled = indexSelector.sample(dateSet);\n+\n+\t\t// dateset is empty or sampling failed.\n+\t\tif (!sampled.isPresent()) {\n+\t\t\tlog.warn(\"Sampled empty result for Entity[{}]: `{}({})`\", contained.getEntityId(), indexSelector, dateSet);\n+\t\t\treturn preResult;\n+\t\t}\n+\n+\t\tint sample = sampled.getAsInt();\n+\t\tList<DateContext> contexts = DateContext\n+\t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, true, timeUnit);\n+\n+\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tList<Object[]> values = new ArrayList<>();\n+\t\tint featureLength = featureResult.getValues().get(0).length;\n+\t\tint outcomeLength = outcomeResult.getValues().get(0).length;\n+\t\tint size = featureLength + outcomeLength - 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDY1Nw==", "bodyText": "Klammern", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385004657", "createdAt": "2020-02-27T09:29:07Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ConceptManipulator.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.forms.util.DefaultSelectConceptManipulator.FillMethod;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.CQElement;\n+import com.bakdata.conquery.models.query.concept.specific.CQConcept;\n+import com.bakdata.conquery.models.query.visitor.QueryVisitor;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+\n+public interface ConceptManipulator {\n+\t// Often used manipulators, that can be statically instantiated\n+\tpublic final static ConceptManipulator DEFAULT_SELECTS_WHEN_EMPTY = new DefaultSelectConceptManipulator(FillMethod.ADD_TO_COMPLETE_EMPTY);\n+\t\n+\tvoid consume(CQConcept concept, Namespaces namespaces);\n+\t\n+\tdefault void consume(List<? extends CQElement> userFeatures, Namespaces namespaces) {\n+\t\tfor(CQElement feature : userFeatures) {\n+\t\t\tfeature.visit(new QueryVisitor() {\n+\t\t\t\t\n+\t\t\t\t@Override\n+\t\t\t\tpublic void accept(Visitable element) {\n+\t\t\t\t\tif (element instanceof CQConcept)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDkyMg==", "bodyText": "die ganzen returns k\u00f6nnen hier weg", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385004922", "createdAt": "2020-02-27T09:29:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNTA4NA==", "bodyText": "OptionalInt?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385005084", "createdAt": "2020-02-27T09:29:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzY1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));\n          \n          \n            \n            \t\t\t\t\t\t.getFirstDayOfQuarter(CDate.toLocalDate(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385007657", "createdAt": "2020-02-27T09:34:30Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredDays();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredDays();\n+\t\t\t} else if (timeUnit.equals(TimeUnit.QUARTERS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredQuarters();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredQuarters();\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Resolution \" + timeUnit + \" not supported.\");\n+\t\t\t}\n+\n+\t\t\tint numRanges = featureRanges.size();\n+\t\t\tint idx = indexPlacement.equals(IndexPlacement.BEFORE) ? numRanges - 1 : numRanges;\n+\t\t\tfor (CDateRange range : featureRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.FEATURE, -idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx--;\n+\t\t\t}\n+\n+\t\t\tnumRanges = outcomeRanges.size();\n+\t\t\tidx = indexPlacement.equals(IndexPlacement.AFTER) ? 0 : 1;\n+\t\t\tfor (CDateRange range : outcomeRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.OUTCOME, idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcl;\n+\t}\n+\n+\t/**\n+\t * Calculates the feature range.\n+\t * \n+\t * @param event       The event date to which the range is relative.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the event index\n+\t *                    belongs.\n+\t * @param featureTime the time units to be included.\n+\t * @param timeUnit  The time unit.\n+\t * @return The feature range.\n+\t */\n+\tprivate static CDateRange generateFeatureRange(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\tTimeUnit timeUnit) {\n+\t\tif (indexPlacement.equals(IndexPlacement.BEFORE)) {\n+\t\t\tswitch (timeUnit) {\n+\t\t\t\tcase DAYS:\n+\t\t\t\t\treturn CDateRange.of(event - featureTime + 1, event);\n+\t\t\t\tcase QUARTERS:\n+\t\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzkyNw==", "bodyText": "so", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385007927", "createdAt": "2020-02-27T09:34:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredDays();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredDays();\n+\t\t\t} else if (timeUnit.equals(TimeUnit.QUARTERS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredQuarters();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredQuarters();\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Resolution \" + timeUnit + \" not supported.\");\n+\t\t\t}\n+\n+\t\t\tint numRanges = featureRanges.size();\n+\t\t\tint idx = indexPlacement.equals(IndexPlacement.BEFORE) ? numRanges - 1 : numRanges;\n+\t\t\tfor (CDateRange range : featureRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.FEATURE, -idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx--;\n+\t\t\t}\n+\n+\t\t\tnumRanges = outcomeRanges.size();\n+\t\t\tidx = indexPlacement.equals(IndexPlacement.AFTER) ? 0 : 1;\n+\t\t\tfor (CDateRange range : outcomeRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.OUTCOME, idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcl;\n+\t}\n+\n+\t/**\n+\t * Calculates the feature range.\n+\t * \n+\t * @param event       The event date to which the range is relative.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the event index\n+\t *                    belongs.\n+\t * @param featureTime the time units to be included.\n+\t * @param timeUnit  The time unit.\n+\t * @return The feature range.\n+\t */\n+\tprivate static CDateRange generateFeatureRange(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\tTimeUnit timeUnit) {\n+\t\tif (indexPlacement.equals(IndexPlacement.BEFORE)) {\n+\t\t\tswitch (timeUnit) {\n+\t\t\t\tcase DAYS:\n+\t\t\t\t\treturn CDateRange.of(event - featureTime + 1, event);\n+\t\t\t\tcase QUARTERS:\n+\t\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));\n+\t\t\t\t\tLocalDate eventRangeEnd = QuarterUtils.getLastDayOfQuarter(event);\n+\t\t\t\t\treturn CDateRange.of(eventRangeStart, eventRangeEnd);\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Resolution: \" + timeUnit);\n+\t\t\t}\n+\t\t}\n+\t\t// eventIndex == NEUTRAL or AFTER\n+\t\tswitch (timeUnit) {\n+\t\t\tcase DAYS:\n+\t\t\t\treturn CDateRange.of(event - featureTime, event - 1);\n+\t\t\tcase QUARTERS:\n+\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime, IsoFields.QUARTER_YEARS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODQ5OQ==", "bodyText": "switch case?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385008499", "createdAt": "2020-02-27T09:35:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMTUzMg==", "bodyText": "else kanst du dir hier sparen macht das auch \u00fcbersichtlicher", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385011532", "createdAt": "2020-02-27T09:41:01Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ResultModifier.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.UnaryOperator;\n+\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.ConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.aggregators.Aggregator;\n+import com.bakdata.conquery.models.query.queryplan.aggregators.specific.ExistsAggregator;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.query.results.MultilineContainedEntityResult;\n+import com.bakdata.conquery.models.query.results.SinglelineContainedEntityResult;\n+\n+public class ResultModifier {\n+\n+\t/**\n+\t * Modifies the given result lines with the given function.\n+\t * \n+\t * If the result is not contained this method creates a default result row anyways.\n+\t */\n+\tpublic static List<Object[]> modify(EntityResult inResult, ConceptQueryPlan subPlan, UnaryOperator<Object[]> modification) {\n+\t\tif(inResult.isFailed()) {\n+\t\t\tthrow new RuntimeException(\"failed result can't be modified: \"+inResult);\n+\t\t}\n+\t\tif(!inResult.isContained()) {\n+\t\t\tObject[] result = new Object[subPlan.getAggregatorSize()];\n+\t\t\tint aggIdx = 0;\n+\t\t\tfor(Aggregator<?> agg : subPlan.getAggregators()) {\n+\t\t\t\t// Fill with null, except for EXIST aggregators\n+\t\t\t\tif(agg instanceof ExistsAggregator) {\n+\t\t\t\t\tresult[aggIdx] = false;\n+\t\t\t\t}\n+\t\t\t\taggIdx++;\n+\t\t\t}\n+\t\t\treturn Collections.singletonList(modification.apply(result));\n+\t\t}\n+\t\tif(inResult instanceof SinglelineContainedEntityResult) {\n+\t\t\treturn Collections.singletonList(\n+\t\t\t\tmodification.apply(\n+\t\t\t\t\t((SinglelineContainedEntityResult) inResult).getValues()\n+\t\t\t\t)\n+\t\t\t);\n+\t\t}\n+\t\telse if(inResult instanceof MultilineContainedEntityResult) {\n+\t\t\tvar values = ((MultilineContainedEntityResult) inResult).getValues();\n+\t\t\tList<Object[]> result = new ArrayList<>(values);\n+\t\t\tresult.replaceAll(modification);\n+\t\t\treturn result;\n+\t\t}\n+\t\telse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMjUzMA==", "bodyText": "Erkl\u00e4ren was und warum du das machst", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385012530", "createdAt": "2020-02-27T09:42:38Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/TableManipulator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.concepts.select.Select;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ConnectorSelectId;\n+import com.bakdata.conquery.models.query.concept.filter.CQTable;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+/**\n+ * Manipulates a given Table based on the provided blacklisting or whitelisting\n+ * for {@link ConnectorSelectId}s. After this filtering, the defined default\n+ * values are added if the corresponding list is empty.\n+ */\n+@Getter\n+@Setter\n+@Builder(builderClassName = \"TableManipulatorInternalBuilder\", builderMethodName = \"internalBuilder\")\n+public class TableManipulator {\n+\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectBlacklist = Collections.emptyList();\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectWhitelist = Collections.emptyList();\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectDefault = Collections.emptyList();\n+\n+\tprivate void init() {\n+\n+\t\tif (!selectBlacklist.isEmpty() && !selectWhitelist.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"Either blacklist or whitelist needs to be empty.\");\n+\t\t}\n+\n+\t\tSet<ConnectorSelectId> blackDefaultIntersection = selectBlacklist\n+\t\t\t.stream()\n+\t\t\t.distinct()\n+\t\t\t.filter(selectDefault::contains)\n+\t\t\t.collect(Collectors.toSet());\n+\t\tif (!blackDefaultIntersection.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString\n+\t\t\t\t\t.format(\n+\t\t\t\t\t\t\"The list of default selects intersects with the blacklist. Intersecting Elements:\\t\",\n+\t\t\t\t\t\tblackDefaultIntersection.toString()));\n+\t\t}\n+\n+\t}\n+\n+\tpublic void consume(CQTable table, Namespaces namespaces) {\n+\n+\t\tList<Select> selects = table.getSelects();\n+\t\tif (!selectBlacklist.isEmpty()) {\n+\t\t\tselects.removeIf(s -> selectBlacklist.contains(s.getId()));\n+\t\t}\n+\t\telse if (!selectWhitelist.isEmpty()) {\n+\t\t\tselects.removeIf(s -> !selectWhitelist.contains(s.getId()));\n+\t\t}\n+\n+\t\t// Add default selects if none is present anymore\n+\t\tif (selects.isEmpty()) {\n+\t\t\ttable.setSelects(selectDefault.stream().map(namespaces::resolve).collect(Collectors.toList()));\n+\t\t}\n+\t}\n+\n+\tpublic static TableManipulatorBuilder builder() {\n+\t\treturn new TableManipulatorBuilder();\n+\t}\n+\n+\tpublic static class TableManipulatorBuilder extends TableManipulatorInternalBuilder {\n+\n+\t\tpublic TableManipulatorBuilder() {\n+\t\t\tsuper();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic TableManipulator build() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzQxOQ==", "bodyText": "*Query weg machen", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385037419", "createdAt": "2020-02-27T10:26:26Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ExecutionManager.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.bakdata.conquery.models.query;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.messages.namespaces.specific.ExecuteQuery;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.models.worker.WorkerInformation;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public class ExecutionManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0ODE5OQ==", "bodyText": "public", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385048199", "createdAt": "2020-02-27T10:45:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/IQuery.java", "diffHunk": "@@ -1,35 +1,68 @@\n package com.bakdata.conquery.models.query;\n \n import java.util.HashSet;\n+import java.util.Optional;\n import java.util.Set;\n \n-import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.google.common.collect.MoreCollectors;\n \n-@JsonTypeInfo(use=JsonTypeInfo.Id.CUSTOM, property=\"type\")\n-@CPSBase\n-public interface IQuery extends Visitable {\n+public abstract class IQuery implements SubmittedQuery {\n \n-\tIQuery resolve(QueryResolveContext context);\n-\tQueryPlan createQueryPlan(QueryPlanContext context);\n+\tpublic abstract IQuery resolve(QueryResolveContext context);\n+\tpublic abstract QueryPlan createQueryPlan(QueryPlanContext context);\n \t\n-\tvoid collectRequiredQueries(Set<ManagedExecutionId> requiredQueries);\n+\tpublic abstract void collectRequiredQueries(Set<ManagedExecutionId> requiredQueries);\n \t\n-\tdefault Set<ManagedExecutionId> collectRequiredQueries() {\n+\tpublic Set<ManagedExecutionId> collectRequiredQueries() {\n \t\tHashSet<ManagedExecutionId> set = new HashSet<>();\n \t\tthis.collectRequiredQueries(set);\n \t\treturn set;\n \t}\n \n-\tdefault ResultInfoCollector collectResultInfos(PrintSettings config) {\n+\tpublic ResultInfoCollector collectResultInfos(PrintSettings config) {\n \t\tResultInfoCollector collector = new ResultInfoCollector(config);\n \t\tcollectResultInfos(collector);\n \t\treturn collector;\n \t}\n \t\n-\tvoid collectResultInfos(ResultInfoCollector collector);\n+\tpublic abstract void collectResultInfos(ResultInfoCollector collector);\n+\t\n+\t@Override\n+\tpublic ManagedQuery toManagedExecution(MasterMetaStorage storage, Namespaces namespaces, UserId userId, DatasetId submittedDataset) {\n+\t\tDatasetId dataset = IQuery.getDataset(this, submittedDataset);\n+\t\tIQuery query = this.resolve(new QueryResolveContext(\n+\t\t\tstorage,\n+\t\t\tnamespaces.get(dataset)\n+\t\t\t));\n+\t\tManagedQuery managed = new ManagedQuery(storage, query,userId, dataset);\n+\t\treturn managed;\n+\t}\n+\n+\t/**\n+\t * Tries to extract the {@link DatasetId} from the submitted query.\n+\t * If none could be extracted the alternative dataset is chosen.\n+\t * When more than one {@link DatasetId} is found an {@link IllegalArgumentException} is thrown.\n+\t */\n+\tstatic DatasetId getDataset(IQuery query, DatasetId alternativeDataset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0OTgzNw==", "bodyText": "Das sieht komisch aus, was macht das?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385049837", "createdAt": "2020-02-27T10:48:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "diffHunk": "@@ -130,4 +139,30 @@ public ManagedQuery toResultQuery() {\n \t\tquery.visit(collector);\n \t\treturn collector.getIds();\n \t}\n+\n+\t@Override\n+\tpublic Map<ManagedExecutionId,QueryPlan> createQueryPlans(QueryPlanContext context) {\n+\t\tif(context.getDataset().equals(getDataset())) {\t\t\t\n+\t\t\treturn Map.of(this.getId(), query.createQueryPlan(context));\n+\t\t}\n+\t\tlog.trace(\"Did not create a QueryPlan for the query {} because the plan corresponds to dataset {} but the execution worker belongs to {}.\", getId(), getDataset(), context.getDataset());\n+\t\treturn Collections.emptyMap();\n+\t}\n+\n+\t@Override\n+\tpublic ShardResult getInitializedShardResult(Entry<ManagedExecutionId, QueryPlan> entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDE3MQ==", "bodyText": "Sind die meisten jetzt nicht eh teil der ManagedQuery und du kannst sie reinziehen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385050171", "createdAt": "2020-02-27T10:49:31Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "diffHunk": "@@ -112,16 +121,16 @@ public ResultInfoCollector collectResultInfos(PrintSettings config) {\n \t@Override\n \tpublic ExecutionStatus buildStatus(URLBuilder url, User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzU3MA==", "bodyText": "warum iterierst du das nicht normal?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385083570", "createdAt": "2020-02-27T12:01:49Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/resources/api/FormProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package com.bakdata.conquery.resources.api;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.regex.Pattern;\n+\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.cps.CPSTypeIdResolver;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.permissions.Ability;\n+import com.bakdata.conquery.models.auth.permissions.FormPermission;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.github.classgraph.Resource;\n+import io.github.classgraph.ResourceList;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@RequiredArgsConstructor\n+@Getter @Slf4j\n+public class FormProcessor {\n+\n+\tprivate final Namespaces namespaces;\n+\tprivate final MasterMetaStorage storage;\n+\tprivate static final Map<Class<? extends Form>, JsonNode> FRONTEND_FORM_CONFIGS = generateFEFormConfigMap();\n+\n+\tprivate static Map<Class<? extends Form>, JsonNode> generateFEFormConfigMap() {\n+\t\tMap<String, Class<? extends Form>> forms = new HashMap<>();\n+\t\tfor( Class<?> subclass : CPSTypeIdResolver.SCAN_RESULT.getSubclasses(Form.class.getName()).loadClasses()) {\n+\t\t\tif(Modifier.isAbstract(subclass.getModifiers())){\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tCPSType anno = subclass.getAnnotation(CPSType.class);\n+\t\t\tif(anno == null) {\n+\t\t\t\tlog.warn(\"Implemented Form {} has no CPSType annotation\", subclass);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tforms.put(anno.id(), (Class<? extends Form>) subclass);\n+\t\t}\n+\t\t\n+\t\tMap<Class<? extends Form>, JsonNode> result = new HashMap<>();\n+\t\tResourceList frontendConfigs = CPSTypeIdResolver.SCAN_RESULT\n+\t\t\t.getResourcesMatchingPattern(Pattern.compile(\".*\\\\.frontend_conf\\\\.json\"));\n+\t\tObjectReader reader = io.dropwizard.jackson.Jackson.newObjectMapper().reader();\n+\t\tfinal String infoFormat = \"\\t%-20s %-50s %-20s\\n\";\n+\t\tStringBuilder info = new StringBuilder(String.format(infoFormat, \"Form Type\", \"Frontend Config\", \"Backend Class\"));\n+\t\tfor (Resource config : frontendConfigs) {\n+\t\t\tJsonNode configTree;\n+\t\t\ttry {\n+\t\t\t\tconfigTree = reader.readTree(config.open());\n+\t\t\t}\n+\t\t\tcatch (IOException e) {\n+\t\t\t\tthrow new IllegalArgumentException(String.format(\"Could not parse the frontend config: %s\", config.getPath()), e);\n+\t\t\t}\n+\t\t\tString formType = configTree.get(\"type\").asText();\n+\t\t\tClass<? extends Form> formClass = forms.get(formType);\n+\t\t\tif(formClass == null) {\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Found frontend config for form %s but could not find an corresponding backend implementation.\", formType));\n+\t\t\t}\n+\t\t\tJsonNode prev = result.put(formClass, configTree);\n+\t\t\tif(prev != null ) {\t\t\t\t\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Could not map %s to form %s because there was already a mapping:\\n%s\", config.getPathRelativeToClasspathElement(), formType, prev));\n+\t\t\t}\n+\t\t\tinfo.append(String.format(infoFormat, formType, config.getPathRelativeToClasspathElement(), formClass));\n+\t\t}\n+\t\tlog.info(\"Found form config mapping for form:\\n{}\", info.toString());\n+\t\t\n+\t\treturn result;\n+\t}\n+\n+\tpublic Collection<JsonNode> getFormsForUser(User user) {\n+\t\tList<JsonNode> allowedForms = new ArrayList<>();\n+\t\tIterator<Entry<Class<? extends Form>, JsonNode>> it = FRONTEND_FORM_CONFIGS.entrySet().iterator();\n+\t\twhile(it.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a486bd5890b4c3397de14c2116301876b46546"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6517957af8e8fc0f4230089ca41cdee4530b56a", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/e6517957af8e8fc0f4230089ca41cdee4530b56a", "committedDate": "2020-02-27T12:59:09Z", "message": "removes time selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1aeb54ea277f59dace01afac0e23a62a0598751", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/d1aeb54ea277f59dace01afac0e23a62a0598751", "committedDate": "2020-02-27T12:59:19Z", "message": "Merge e6517957af8e8fc0f4230089ca41cdee4530b56a into 242513d2a0a3f57200b7c97de7ea35866b6ae12f"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06b2442ed90ae36b84c4c7c47b5663b3cc0643dd", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/06b2442ed90ae36b84c4c7c47b5663b3cc0643dd", "committedDate": "2020-02-27T13:01:33Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd49c3417522279f3877a7322baa633cb2601a65", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/fd49c3417522279f3877a7322baa633cb2601a65", "committedDate": "2020-02-27T13:14:37Z", "message": "review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "add8dfb90f676f8c5bea2d331557725f7ab24e1e", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/add8dfb90f676f8c5bea2d331557725f7ab24e1e", "committedDate": "2020-02-27T13:14:48Z", "message": "Merge branch 'feature/move-export-form' of https://github.com/bakdata/conquery into feature/move-export-form"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "068b1fcf57586eec5fc8ab1a5e8e862cfdd75a1f", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/068b1fcf57586eec5fc8ab1a5e8e862cfdd75a1f", "committedDate": "2020-02-27T13:15:07Z", "message": "Merge add8dfb90f676f8c5bea2d331557725f7ab24e1e into 242513d2a0a3f57200b7c97de7ea35866b6ae12f"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6259f480d00a2e7dfebb9933d1c1c9103223c7e1", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/6259f480d00a2e7dfebb9933d1c1c9103223c7e1", "committedDate": "2020-02-27T13:17:26Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "555a6aece53b88a47b57a9134300398d893c4c34", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/555a6aece53b88a47b57a9134300398d893c4c34", "committedDate": "2020-02-27T14:30:28Z", "message": "fix default Constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f4ec9992431a685758373e48d146f9ff694fff8", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/5f4ec9992431a685758373e48d146f9ff694fff8", "committedDate": "2020-02-27T14:34:49Z", "message": "fix rel export form test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "091bef6ba6f914dee48f63cfa6b0aa63136f8747", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/091bef6ba6f914dee48f63cfa6b0aa63136f8747", "committedDate": "2020-02-27T15:39:37Z", "message": "review chnages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76b116e1f42d596ebcca50c860feef5f538cd788", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/76b116e1f42d596ebcca50c860feef5f538cd788", "committedDate": "2020-02-27T16:09:47Z", "message": "adds comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13ff84fa2f3986ae801170614ec1f94331509efb", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/13ff84fa2f3986ae801170614ec1f94331509efb", "committedDate": "2020-02-27T16:09:57Z", "message": "Merge 76b116e1f42d596ebcca50c860feef5f538cd788 into 242513d2a0a3f57200b7c97de7ea35866b6ae12f"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b72f60588f41df3bb23a572e12f3111cf6c2d82", "author": {"user": {"login": "bakdata-bot", "name": null}}, "url": "https://github.com/bakdata/conquery/commit/6b72f60588f41df3bb23a572e12f3111cf6c2d82", "committedDate": "2020-02-27T16:12:23Z", "message": "automatic update to docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83fa3053971ec8f51fc4555ca426124918a783c7", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/83fa3053971ec8f51fc4555ca426124918a783c7", "committedDate": "2020-02-27T17:22:39Z", "message": "review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df35514e1b705647ea0162d835f8c4af9fc3291a", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/df35514e1b705647ea0162d835f8c4af9fc3291a", "committedDate": "2020-02-28T16:51:06Z", "message": "fix default value in export frontend config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69bd8df0eece5f73c2ea40a0d6c80e4ccdec24cd", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/69bd8df0eece5f73c2ea40a0d6c80e4ccdec24cd", "committedDate": "2020-02-28T23:02:45Z", "message": "Merge branch 'feature/proceed-with-next-auth-token' into feature/move-export-form"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fca76cddc548a1578e910c0c230dfa3dbbec3543", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/fca76cddc548a1578e910c0c230dfa3dbbec3543", "committedDate": "2020-03-03T10:01:36Z", "message": "better log message for from mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b92931bc9e5fe5ef0b19ffae35b347ee671142ec", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/b92931bc9e5fe5ef0b19ffae35b347ee671142ec", "committedDate": "2020-03-03T15:12:11Z", "message": "fixes null pointer exception on building query status"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "819319a169d2ab5c002120db35a02efcd691cb9b", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/819319a169d2ab5c002120db35a02efcd691cb9b", "committedDate": "2020-03-03T15:15:59Z", "message": "Merge branch 'develop' into feature/move-export-form"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c947e4e938c2b79484de660a4e96107a50394f0f", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/c947e4e938c2b79484de660a4e96107a50394f0f", "committedDate": "2020-03-04T13:14:29Z", "message": "adds date context test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "134767b3d68a6e068ceb63d212179e92ded2aca9", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/134767b3d68a6e068ceb63d212179e92ded2aca9", "committedDate": "2020-03-04T13:19:42Z", "message": "doku and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "100631ee3d54883b4c67dc43feb6432ec2351666", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/100631ee3d54883b4c67dc43feb6432ec2351666", "committedDate": "2020-03-04T13:28:24Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f18c0877ceb7aca23e3c23d79f932fde1b91437b", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/f18c0877ceb7aca23e3c23d79f932fde1b91437b", "committedDate": "2020-03-16T08:55:11Z", "message": "Merge branch 'develop' into feature/move-export-form\n\n# Conflicts:\n#\tautodoc/src/main/java/com/bakdata/conquery/Constants.java\n#\tautodoc/src/main/java/com/bakdata/conquery/handler/GroupHandler.java\n#\tdocs/REST API JSONs.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "201b3eb164c9f82bc9ee68f4bf768b1a630a5b54", "author": {"user": {"login": "thoniTUB", "name": "MT"}}, "url": "https://github.com/bakdata/conquery/commit/201b3eb164c9f82bc9ee68f4bf768b1a630a5b54", "committedDate": "2020-03-16T11:25:05Z", "message": "renames SubmittedQuery -> QueryDescription"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4629, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}