{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1OTE3Njk2", "number": 1182, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzo0NzoyOFrOD7H3Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NzoyNlrOD8GcDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzIxNDM4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/Form.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzo0NzoyOFrOGTQjDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzo0NzoyOFrOGTQjDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzI0NQ==", "bodyText": "das ist eine coole funktion, sowas habe ich schon l\u00e4nger mir gew\u00fcnscht", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r422847245", "createdAt": "2020-05-11T07:47:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/Form.java", "diffHunk": "@@ -25,6 +27,11 @@\n  * API representation of a form query.\n  */\n public interface Form extends QueryDescription {\n+\t\n+\t@JsonIgnore\n+\tdefault String getFormType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5c907966e729c9d54da63ebf60b74f2936a57f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzIzMzUyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzo1Mjo0MlrOGTQuWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzo1Mjo0MlrOGTQuWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MDEzNw==", "bodyText": "Ich wei\u00df leider nicht genug von Secure Random aber sollte man die nicht wiederverwenden? Ich k\u00f6nnte mir vorstellen, dass es schnell den entropie pool verschwendet", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r422850137", "createdAt": "2020-05-11T07:52:42Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -116,6 +118,16 @@ private static String extractTokenFromQuery(ContainerRequestContext request) {\n \t\t}\n \t\treturn null;\n \t}\n+\t\n+\t/**\n+\t * Generate a random secret.\n+\t */\n+\tpublic static String generateTokenSecret() {\n+\t\tRandom rand = new SecureRandom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5c907966e729c9d54da63ebf60b74f2936a57f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzQ5NzM1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMDo0OFrOGTTNOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMDo0OFrOGTTNOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5MDgxMQ==", "bodyText": "Wof\u00fcr ist der Setter wenn du oben keine setzt?", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r422890811", "createdAt": "2020-05-11T09:00:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.bakdata.conquery.models.auth.conquerytoken;\n+\n+import javax.validation.constraints.Min;\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.AccessLevel;\n+import lombok.Data;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+\n+@Slf4j\n+public class ConqueryTokenRealm extends ConqueryAuthenticationRealm {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\n+\tprivate MasterMetaStorage storage;\n+\t\n+\t@Setter(value = AccessLevel.PRIVATE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee99bb6e637006986239a7ec87c0195f3d1825a4"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzUwMDMwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMTozNFrOGTTPEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMTozNFrOGTTPEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5MTI4MA==", "bodyText": "der construtor k\u00f6nnte doch schon mit defaults ind er klasse besetzt werden?", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r422891280", "createdAt": "2020-05-11T09:01:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.bakdata.conquery.models.auth.conquerytoken;\n+\n+import javax.validation.constraints.Min;\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.AccessLevel;\n+import lombok.Data;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+\n+@Slf4j\n+public class ConqueryTokenRealm extends ConqueryAuthenticationRealm {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\n+\tprivate MasterMetaStorage storage;\n+\t\n+\t@Setter(value = AccessLevel.PRIVATE)\n+\tprivate JWTConfig jwtConfig;\n+\t\n+\t@JsonIgnore\n+\tprivate JWTVerifier oauthTokenVerifier;\n+\t\n+\t\n+\tpublic ConqueryTokenRealm(MasterMetaStorage storage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee99bb6e637006986239a7ec87c0195f3d1825a4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMzUwNzE4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMzoyOVrOGTTTgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOTowMzoyOVrOGTTTgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5MjQxNw==", "bodyText": "Dropwizard hat ne Duration Klasse die sich nice schreiben/lesen l\u00e4sst", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r422892417", "createdAt": "2020-05-11T09:03:29Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.bakdata.conquery.models.auth.conquerytoken;\n+\n+import javax.validation.constraints.Min;\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.AccessLevel;\n+import lombok.Data;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+\n+@Slf4j\n+public class ConqueryTokenRealm extends ConqueryAuthenticationRealm {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\n+\tprivate MasterMetaStorage storage;\n+\t\n+\t@Setter(value = AccessLevel.PRIVATE)\n+\tprivate JWTConfig jwtConfig;\n+\t\n+\t@JsonIgnore\n+\tprivate JWTVerifier oauthTokenVerifier;\n+\t\n+\t\n+\tpublic ConqueryTokenRealm(MasterMetaStorage storage) {\n+\t\tthis.storage = storage;\n+\t\tsetAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tsetCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tupdateJWTConfig(new JWTConfig());\n+\t}\n+\t\n+\tpublic void updateJWTConfig(JWTConfig jwtConfig){\n+\t\tthis.jwtConfig = jwtConfig;\n+\t\toauthTokenVerifier = JWT.require(jwtConfig.getTokenSignAlgorithm()).withIssuer(getName()).build();\n+\t}\n+\n+\t@Override\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\tif (!(TOKEN_CLASS.isAssignableFrom(token.getClass()))) {\n+\t\t\t// Incompatible token\n+\t\t\treturn null;\n+\t\t}\n+\t\tDecodedJWT decodedToken = null;\n+\t\ttry {\n+\t\t\tdecodedToken = oauthTokenVerifier.verify((String) token.getCredentials());\n+\t\t}\n+\t\tcatch (TokenExpiredException e) {\n+\t\t\tlog.trace(\"The provided token is expired.\");\n+\t\t\tthrow new ExpiredCredentialsException(e);\n+\t\t}\n+\t\tcatch (SignatureVerificationException | InvalidClaimException e) {\n+\t\t\tlog.trace(\"The provided token was not successfully verified against its signature or claims.\");\n+\t\t\tthrow new IncorrectCredentialsException(e);\n+\t\t}\n+\t\tcatch (JWTVerificationException e) {\n+\t\t\tlog.trace(\"The provided token could not be verified.\");\n+\t\t\tthrow new AuthenticationException(e);\n+\t\t}\n+\n+\t\tString username = decodedToken.getSubject();\n+\n+\t\tUserId userId = UserId.Parser.INSTANCE.parse(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tlog.warn(\n+\t\t\t\t\"Provided credentials were valid, but a corresponding user was not found in the System. You need to add a user to the system with the id: {}\",\n+\t\t\t\tuserId);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(userId, token, this);\n+\t}\n+\t\n+\n+\t\n+\tpublic String createTokenForUser(UserId userId) {\n+\t\tif(storage.getUser(userId) == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Cannot create a JWT for unknown user with id: \" + userId);\n+\t\t}\n+\t\treturn TokenHandler.createToken(userId.toString(), jwtConfig.getJwtDuration(), getName(), jwtConfig.getTokenSignAlgorithm());\n+\t}\n+\t\n+\t@Data\n+\tpublic static class JWTConfig{\n+\t\t@Min(1)\n+\t\tprivate int jwtDuration = 8; // Hours", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee99bb6e637006986239a7ec87c0195f3d1825a4"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzMwMzgwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoxMjo1NVrOGUznnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoxMjo1NVrOGUznnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ3MDQyOA==", "bodyText": "wenn der mehrfach initialisiert wird, leakt doch ein singleton oder?", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r424470428", "createdAt": "2020-05-13T14:12:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationController.java", "diffHunk": "@@ -53,7 +57,21 @@\n \tprivate List<Realm> realms = new ArrayList<>();\n \t\n \tpublic void init() {\n-\t\tinitializeRealms(storage, authenticationConfigs, authenticationRealms, realms);\n+\t\t// Init authentication realms provided by with the config.\n+\t\tfor (AuthenticationConfig authenticationConf : authenticationConfigs) {\n+\t\t\tConqueryAuthenticationRealm realm = authenticationConf.createRealm(storage);\n+\t\t\tauthenticationRealms.add(realm);\n+\t\t\trealms.add(realm);\n+\t\t}\n+\t\t\n+\t\t// Add the central authentication realm\n+\t\tCENTRAL_TOKEN_REALM = new ConqueryTokenRealm(storage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137596c1e0f7a89d7d3e54225d6b527bbb8d567"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzM2MTE4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoyNToyN1rOGU0M4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDoyNToyN1rOGU0M4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ3OTk2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tlog.trace(\"Token has expected format.\", TOKEN_CLASS, token.getClass());\n          \n          \n            \n            \t\tlog.trace(\"Token has expected format.{} - {}\", TOKEN_CLASS, token.getClass());", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r424479969", "createdAt": "2020-05-13T14:25:27Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.bakdata.conquery.models.auth.conquerytoken;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import io.dropwizard.util.Duration;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+\n+@Slf4j\n+public class ConqueryTokenRealm extends ConqueryAuthenticationRealm {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\n+\tprivate final MasterMetaStorage storage;\n+\t\n+\t@Setter\n+\tprivate JWTConfig jwtConfig = new JWTConfig();\n+\t\n+\t\n+\tpublic ConqueryTokenRealm(MasterMetaStorage storage) {\n+\t\tthis.storage = storage;\n+\t\tsetAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tsetCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t}\n+\n+\t@Override\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\tif (!(TOKEN_CLASS.isAssignableFrom(token.getClass()))) {\n+\t\t\tlog.trace(\"Incompatible token. Expected {}, got {}\", TOKEN_CLASS, token.getClass());\n+\t\t\treturn null;\n+\t\t}\n+\t\tlog.trace(\"Token has expected format.\", TOKEN_CLASS, token.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137596c1e0f7a89d7d3e54225d6b527bbb8d567"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzQ1ODcxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NTo1MlrOGU1Lfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NTo1MlrOGU1Lfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5NTk5OA==", "bodyText": "die Duration w\u00fcrde ich hier in eine Java Duration umwandeln, das ist nur ne coole klasse f\u00fcr parsing", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r424495998", "createdAt": "2020-05-13T14:45:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/auth/conquerytoken/ConqueryTokenRealm.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.bakdata.conquery.models.auth.conquerytoken;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import io.dropwizard.util.Duration;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+\n+@Slf4j\n+public class ConqueryTokenRealm extends ConqueryAuthenticationRealm {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\n+\tprivate final MasterMetaStorage storage;\n+\t\n+\t@Setter\n+\tprivate JWTConfig jwtConfig = new JWTConfig();\n+\t\n+\t\n+\tpublic ConqueryTokenRealm(MasterMetaStorage storage) {\n+\t\tthis.storage = storage;\n+\t\tsetAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tsetCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t}\n+\n+\t@Override\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\tif (!(TOKEN_CLASS.isAssignableFrom(token.getClass()))) {\n+\t\t\tlog.trace(\"Incompatible token. Expected {}, got {}\", TOKEN_CLASS, token.getClass());\n+\t\t\treturn null;\n+\t\t}\n+\t\tlog.trace(\"Token has expected format.\", TOKEN_CLASS, token.getClass());\n+\t\tDecodedJWT decodedToken = null;\n+\t\ttry {\n+\t\t\tdecodedToken = jwtConfig.getTokenVerifier(this).verify((String) token.getCredentials());\n+\t\t}\n+\t\tcatch (TokenExpiredException e) {\n+\t\t\tlog.trace(\"The provided token is expired.\");\n+\t\t\tthrow new ExpiredCredentialsException(e);\n+\t\t}\n+\t\tcatch (SignatureVerificationException | InvalidClaimException e) {\n+\t\t\tlog.trace(\"The provided token was not successfully verified against its signature or claims.\");\n+\t\t\tthrow new IncorrectCredentialsException(e);\n+\t\t}\n+\t\tcatch (JWTVerificationException e) {\n+\t\t\tlog.trace(\"The provided token could not be verified.\");\n+\t\t\tthrow new AuthenticationException(e);\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tlog.trace(\"Unable to decode token\", e);\n+\t\t\tthrow new AuthenticationException(e);\n+\t\t}\n+\t\tlog.trace(\"Received valid token.\");\n+\n+\t\tString username = decodedToken.getSubject();\n+\n+\t\tUserId userId = UserId.Parser.INSTANCE.parse(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tlog.warn(\n+\t\t\t\t\"Provided credentials were valid, but a corresponding user was not found in the System. You need to add a user to the system with the id: {}\",\n+\t\t\t\tuserId);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(userId, token, this);\n+\t}\n+\t\n+\n+\t\n+\tpublic String createTokenForUser(UserId userId) {\n+\t\tif(storage.getUser(userId) == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Cannot create a JWT for unknown user with id: \" + userId);\n+\t\t}\n+\t\treturn TokenHandler.createToken(userId.toString(), jwtConfig.getJwtDuration(), getName(), jwtConfig.getTokenSignAlgorithm());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137596c1e0f7a89d7d3e54225d6b527bbb8d567"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzQ2NjM5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/resultinfo/ResultInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NzoyNlrOGU1QcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNDo0NzoyNlrOGU1QcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5NzI2NA==", "bodyText": "wenn du eh auf die map synchronisierst musst du da drin keine Atomics benutzen", "url": "https://github.com/bakdata/conquery/pull/1182#discussion_r424497264", "createdAt": "2020-05-13T14:47:26Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/resultinfo/ResultInfo.java", "diffHunk": "@@ -43,8 +43,7 @@ public final String getUniqueName(PrintSettings settings) {\n \t\t}\n \t\tsynchronized (ocurrenceCounter) {\n \t\t\tif(postfix == UNSET_PREFIX) {\n-\t\t\t\tAtomicInteger occurence = ocurrenceCounter.computeIfAbsent(name, str -> new AtomicInteger(0));\n-\t\t\t\tpostfix = occurence.getAndIncrement();\n+\t\t\t\tpostfix = ocurrenceCounter.computeIfAbsent(name, str -> new AtomicInteger(0)).getAndIncrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137596c1e0f7a89d7d3e54225d6b527bbb8d567"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1391, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}