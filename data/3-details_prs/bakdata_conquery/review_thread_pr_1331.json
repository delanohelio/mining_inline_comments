{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2MzI5NjE4", "number": 1331, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowMjozNFrOEfbAsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzoyNFrOEfbGzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzgzODU5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowMjozNFrOHLr3wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowMjozNFrOHLr3wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNTE2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// Check if the result if of an processible type (multiline or not contained)\n          \n          \n            \n            \t\t// Check if the result is processible (type is multiline or not contained)", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482015169", "createdAt": "2020-09-02T12:02:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -63,63 +62,118 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tList<DateContext> contexts = DateContext\n \t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, timeUnit, resolutions);\n \n-\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n-\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\t\tFormQueryPlan featureSubquery = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tFormQueryPlan outcomeSubquery = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tEntityResult featureResult = featureSubquery.execute(ctx, entity);\n+\t\tEntityResult outcomeResult = outcomeSubquery.execute(ctx, entity);\n+\n+\t\t// on fail return failed result\n+\t\tif (featureResult.isFailed()) {\n+\t\t\treturn featureResult;\n+\t\t}\n+\t\tif (outcomeResult.isFailed()) {\n+\t\t\treturn outcomeResult;\n+\t\t}\n+\n+\t\t// Check if the result if of an processible type (multiline or not contained)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzg0MTExOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowMzoyNFrOHLr5Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowMzoyNFrOHLr5Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNTU4Mg==", "bodyText": "kannst du das in zwei checks aufsplitten?", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482015582", "createdAt": "2020-09-02T12:03:24Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -63,63 +62,118 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tList<DateContext> contexts = DateContext\n \t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, timeUnit, resolutions);\n \n-\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n-\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\t\tFormQueryPlan featureSubquery = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tFormQueryPlan outcomeSubquery = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tEntityResult featureResult = featureSubquery.execute(ctx, entity);\n+\t\tEntityResult outcomeResult = outcomeSubquery.execute(ctx, entity);\n+\n+\t\t// on fail return failed result\n+\t\tif (featureResult.isFailed()) {\n+\t\t\treturn featureResult;\n+\t\t}\n+\t\tif (outcomeResult.isFailed()) {\n+\t\t\treturn outcomeResult;\n+\t\t}\n+\n+\t\t// Check if the result if of an processible type (multiline or not contained)\n+\t\tcheckIfResultProcessible(featureResult);\n+\t\tcheckIfResultProcessible(outcomeResult);\n+\n+\t\tif (!featureResult.isContained() && !outcomeResult.isContained()) {\n+\t\t\t// if both, feature and outcome are not contained fast quit.\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t// determine result length and check against aggregators in query\n+\t\tint featureLength = determineResultWithAndCheck(featureSubquery, featureResult);\n+\t\tint outcomeLength = determineResultWithAndCheck(outcomeSubquery, outcomeResult);\n \n-\t\tList<Object[]> values = new ArrayList<>();\n-\t\t// We look at the first result line to determine the length of the subresult\n-\t\tint featureLength = featureResult.getValues().get(0).length;\n-\t\tint outcomeLength = outcomeResult.getValues().get(0).length;\n-\t\t\n \t\t/*\n-\t\t *  Whole result is the concatenation of the subresults. The final output format combines resolution info, index and eventdate of both sub queries.\n-\t\t *  The feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... \n-\t\t *  The wanted format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR], [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n+\t\t * Whole result is the concatenation of the subresults. The final output format\n+\t\t * combines resolution info, index and eventdate of both sub queries. The\n+\t\t * feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX],\n+\t\t * [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... The wanted\n+\t\t * format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR],\n+\t\t * [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n \t\t */\n-\t\tint size = featureLength + outcomeLength - 3/*= [RESOLUTION], [INDEX], [EVENTDATE]*/;\n+\t\tint size = featureLength + outcomeLength - 3/* ^= [RESOLUTION], [INDEX], [EVENTDATE] */;\n \n \t\tint resultStartIndex = 0;\n-\t\tif(hasCompleteDateContexts(contexts)) {\n-\t\t\t// merge a line for the complete daterange, when two dateContext were generated that don't target the same feature group,\n+\t\tList<Object[]> values = new ArrayList<>();\n+\t\tif (hasCompleteDateContexts(contexts)) {\n+\t\t\t// merge a line for the complete daterange, when two dateContext were generated\n+\t\t\t// that don't target the same feature group,\n \t\t\t// which would be a mistake by the generation\n-\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE is the coarsed resolution it must be at the first\n+\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE\n+\t\t\t// is the coarsed resolution it must be at the first\n \t\t\t// to indexes of the list.\n \t\t\tObject[] mergedFull = new Object[size];\n-\t\t\tsetFeatureValues(mergedFull, featureResult.getValues().get(resultStartIndex));\n-\t\t\tsetOutcomeValues(mergedFull, outcomeResult.getValues().get(resultStartIndex), featureLength);\n+\t\t\tif (featureResult.isContained()) {\n+\t\t\t\tsetFeatureValues(mergedFull, ((MultilineContainedEntityResult) featureResult).getValues().get(resultStartIndex));\n+\t\t\t}\n+\t\t\tif (outcomeResult.isContained()) {\n+\t\t\t\tsetOutcomeValues(\n+\t\t\t\t\tmergedFull,\n+\t\t\t\t\t((MultilineContainedEntityResult) outcomeResult).getValues().get(resultStartIndex),\n+\t\t\t\t\tfeatureLength);\n+\t\t\t}\n \t\t\tvalues.add(mergedFull);\n \t\t\tresultStartIndex++;\n \t\t}\n \n \t\t// append all other lines directly\n-\t\tfor (int i = resultStartIndex; i < featureResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetFeatureValues(result, featureResult.getValues().get(i));\n-\t\t\tvalues.add(result);\n+\t\tif (featureResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) featureResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetFeatureValues(result, multiresult.getValues().get(i));\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n-\t\tfor (int i = resultStartIndex; i < outcomeResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetOutcomeValues(result, outcomeResult.getValues().get(i), featureLength);\n-\t\t\tvalues.add(result);\n+\t\tif (outcomeResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) outcomeResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetOutcomeValues(result, multiresult.getValues().get(i), featureLength);\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n \t\treturn EntityResult.multilineOf(entity.getId(), values);\n \t}\n \n+\tprivate int determineResultWithAndCheck(FormQueryPlan subquery, EntityResult subResult) {\n+\t\tint featureLength = subquery.columnCount();\n+\t\tint featureResultColumnCount;\n+\t\tif (subResult.isContained() && (featureResultColumnCount = subResult.asContained().columnCount()) != featureLength) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzg0NDA3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNDoxOVrOHLr7Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNDoxOVrOHLr7Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNjAyMg==", "bodyText": "wenn das ne fehlermeldung wirft, w\u00fcrde ich das assertProcessible oder so nennen", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482016022", "createdAt": "2020-09-02T12:04:19Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -63,63 +62,118 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tList<DateContext> contexts = DateContext\n \t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, timeUnit, resolutions);\n \n-\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n-\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\t\tFormQueryPlan featureSubquery = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tFormQueryPlan outcomeSubquery = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tEntityResult featureResult = featureSubquery.execute(ctx, entity);\n+\t\tEntityResult outcomeResult = outcomeSubquery.execute(ctx, entity);\n+\n+\t\t// on fail return failed result\n+\t\tif (featureResult.isFailed()) {\n+\t\t\treturn featureResult;\n+\t\t}\n+\t\tif (outcomeResult.isFailed()) {\n+\t\t\treturn outcomeResult;\n+\t\t}\n+\n+\t\t// Check if the result if of an processible type (multiline or not contained)\n+\t\tcheckIfResultProcessible(featureResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzg0ODgwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNTo0M1rOHLr98Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo0NTozNVrOHLtX3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNjc1Mw==", "bodyText": "die methode macht zu viel auf einmal, kannst du das nicht splitten?", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482016753", "createdAt": "2020-09-02T12:05:43Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -63,63 +62,118 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tList<DateContext> contexts = DateContext\n \t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, timeUnit, resolutions);\n \n-\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n-\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\t\tFormQueryPlan featureSubquery = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tFormQueryPlan outcomeSubquery = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tEntityResult featureResult = featureSubquery.execute(ctx, entity);\n+\t\tEntityResult outcomeResult = outcomeSubquery.execute(ctx, entity);\n+\n+\t\t// on fail return failed result\n+\t\tif (featureResult.isFailed()) {\n+\t\t\treturn featureResult;\n+\t\t}\n+\t\tif (outcomeResult.isFailed()) {\n+\t\t\treturn outcomeResult;\n+\t\t}\n+\n+\t\t// Check if the result if of an processible type (multiline or not contained)\n+\t\tcheckIfResultProcessible(featureResult);\n+\t\tcheckIfResultProcessible(outcomeResult);\n+\n+\t\tif (!featureResult.isContained() && !outcomeResult.isContained()) {\n+\t\t\t// if both, feature and outcome are not contained fast quit.\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t// determine result length and check against aggregators in query\n+\t\tint featureLength = determineResultWithAndCheck(featureSubquery, featureResult);\n+\t\tint outcomeLength = determineResultWithAndCheck(outcomeSubquery, outcomeResult);\n \n-\t\tList<Object[]> values = new ArrayList<>();\n-\t\t// We look at the first result line to determine the length of the subresult\n-\t\tint featureLength = featureResult.getValues().get(0).length;\n-\t\tint outcomeLength = outcomeResult.getValues().get(0).length;\n-\t\t\n \t\t/*\n-\t\t *  Whole result is the concatenation of the subresults. The final output format combines resolution info, index and eventdate of both sub queries.\n-\t\t *  The feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... \n-\t\t *  The wanted format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR], [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n+\t\t * Whole result is the concatenation of the subresults. The final output format\n+\t\t * combines resolution info, index and eventdate of both sub queries. The\n+\t\t * feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX],\n+\t\t * [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... The wanted\n+\t\t * format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR],\n+\t\t * [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n \t\t */\n-\t\tint size = featureLength + outcomeLength - 3/*= [RESOLUTION], [INDEX], [EVENTDATE]*/;\n+\t\tint size = featureLength + outcomeLength - 3/* ^= [RESOLUTION], [INDEX], [EVENTDATE] */;\n \n \t\tint resultStartIndex = 0;\n-\t\tif(hasCompleteDateContexts(contexts)) {\n-\t\t\t// merge a line for the complete daterange, when two dateContext were generated that don't target the same feature group,\n+\t\tList<Object[]> values = new ArrayList<>();\n+\t\tif (hasCompleteDateContexts(contexts)) {\n+\t\t\t// merge a line for the complete daterange, when two dateContext were generated\n+\t\t\t// that don't target the same feature group,\n \t\t\t// which would be a mistake by the generation\n-\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE is the coarsed resolution it must be at the first\n+\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE\n+\t\t\t// is the coarsed resolution it must be at the first\n \t\t\t// to indexes of the list.\n \t\t\tObject[] mergedFull = new Object[size];\n-\t\t\tsetFeatureValues(mergedFull, featureResult.getValues().get(resultStartIndex));\n-\t\t\tsetOutcomeValues(mergedFull, outcomeResult.getValues().get(resultStartIndex), featureLength);\n+\t\t\tif (featureResult.isContained()) {\n+\t\t\t\tsetFeatureValues(mergedFull, ((MultilineContainedEntityResult) featureResult).getValues().get(resultStartIndex));\n+\t\t\t}\n+\t\t\tif (outcomeResult.isContained()) {\n+\t\t\t\tsetOutcomeValues(\n+\t\t\t\t\tmergedFull,\n+\t\t\t\t\t((MultilineContainedEntityResult) outcomeResult).getValues().get(resultStartIndex),\n+\t\t\t\t\tfeatureLength);\n+\t\t\t}\n \t\t\tvalues.add(mergedFull);\n \t\t\tresultStartIndex++;\n \t\t}\n \n \t\t// append all other lines directly\n-\t\tfor (int i = resultStartIndex; i < featureResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetFeatureValues(result, featureResult.getValues().get(i));\n-\t\t\tvalues.add(result);\n+\t\tif (featureResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) featureResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetFeatureValues(result, multiresult.getValues().get(i));\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n-\t\tfor (int i = resultStartIndex; i < outcomeResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetOutcomeValues(result, outcomeResult.getValues().get(i), featureLength);\n-\t\t\tvalues.add(result);\n+\t\tif (outcomeResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) outcomeResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetOutcomeValues(result, multiresult.getValues().get(i), featureLength);\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n \t\treturn EntityResult.multilineOf(entity.getId(), values);\n \t}\n \n+\tprivate int determineResultWithAndCheck(FormQueryPlan subquery, EntityResult subResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzOTc3NQ==", "bodyText": "Ich habe sie jetzt mehr dokumentiert. Ich w\u00fcrde es nicht trennen, da es sehr nah bei ein ander ist.", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482039775", "createdAt": "2020-09-02T12:45:35Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -63,63 +62,118 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tList<DateContext> contexts = DateContext\n \t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, timeUnit, resolutions);\n \n-\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n-\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\t\tFormQueryPlan featureSubquery = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tFormQueryPlan outcomeSubquery = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tEntityResult featureResult = featureSubquery.execute(ctx, entity);\n+\t\tEntityResult outcomeResult = outcomeSubquery.execute(ctx, entity);\n+\n+\t\t// on fail return failed result\n+\t\tif (featureResult.isFailed()) {\n+\t\t\treturn featureResult;\n+\t\t}\n+\t\tif (outcomeResult.isFailed()) {\n+\t\t\treturn outcomeResult;\n+\t\t}\n+\n+\t\t// Check if the result if of an processible type (multiline or not contained)\n+\t\tcheckIfResultProcessible(featureResult);\n+\t\tcheckIfResultProcessible(outcomeResult);\n+\n+\t\tif (!featureResult.isContained() && !outcomeResult.isContained()) {\n+\t\t\t// if both, feature and outcome are not contained fast quit.\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t// determine result length and check against aggregators in query\n+\t\tint featureLength = determineResultWithAndCheck(featureSubquery, featureResult);\n+\t\tint outcomeLength = determineResultWithAndCheck(outcomeSubquery, outcomeResult);\n \n-\t\tList<Object[]> values = new ArrayList<>();\n-\t\t// We look at the first result line to determine the length of the subresult\n-\t\tint featureLength = featureResult.getValues().get(0).length;\n-\t\tint outcomeLength = outcomeResult.getValues().get(0).length;\n-\t\t\n \t\t/*\n-\t\t *  Whole result is the concatenation of the subresults. The final output format combines resolution info, index and eventdate of both sub queries.\n-\t\t *  The feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... \n-\t\t *  The wanted format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR], [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n+\t\t * Whole result is the concatenation of the subresults. The final output format\n+\t\t * combines resolution info, index and eventdate of both sub queries. The\n+\t\t * feature/outcome sub queries are of in form of: [RESOLUTION], [INDEX],\n+\t\t * [EVENTDATE], [FEATURE/OUTCOME_DR], [FEATURE/OUTCOME_SELECTS]... The wanted\n+\t\t * format is: [RESOLUTION], [INDEX], [EVENTDATE], [FEATURE_DR], [OUTCOME_DR],\n+\t\t * [FEATURE_SELECTS]... , [OUTCOME_SELECTS]\n \t\t */\n-\t\tint size = featureLength + outcomeLength - 3/*= [RESOLUTION], [INDEX], [EVENTDATE]*/;\n+\t\tint size = featureLength + outcomeLength - 3/* ^= [RESOLUTION], [INDEX], [EVENTDATE] */;\n \n \t\tint resultStartIndex = 0;\n-\t\tif(hasCompleteDateContexts(contexts)) {\n-\t\t\t// merge a line for the complete daterange, when two dateContext were generated that don't target the same feature group,\n+\t\tList<Object[]> values = new ArrayList<>();\n+\t\tif (hasCompleteDateContexts(contexts)) {\n+\t\t\t// merge a line for the complete daterange, when two dateContext were generated\n+\t\t\t// that don't target the same feature group,\n \t\t\t// which would be a mistake by the generation\n-\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE is the coarsed resolution it must be at the first\n+\t\t\t// Since the DateContexts are primarily ordered by their coarseness and COMPLETE\n+\t\t\t// is the coarsed resolution it must be at the first\n \t\t\t// to indexes of the list.\n \t\t\tObject[] mergedFull = new Object[size];\n-\t\t\tsetFeatureValues(mergedFull, featureResult.getValues().get(resultStartIndex));\n-\t\t\tsetOutcomeValues(mergedFull, outcomeResult.getValues().get(resultStartIndex), featureLength);\n+\t\t\tif (featureResult.isContained()) {\n+\t\t\t\tsetFeatureValues(mergedFull, ((MultilineContainedEntityResult) featureResult).getValues().get(resultStartIndex));\n+\t\t\t}\n+\t\t\tif (outcomeResult.isContained()) {\n+\t\t\t\tsetOutcomeValues(\n+\t\t\t\t\tmergedFull,\n+\t\t\t\t\t((MultilineContainedEntityResult) outcomeResult).getValues().get(resultStartIndex),\n+\t\t\t\t\tfeatureLength);\n+\t\t\t}\n \t\t\tvalues.add(mergedFull);\n \t\t\tresultStartIndex++;\n \t\t}\n \n \t\t// append all other lines directly\n-\t\tfor (int i = resultStartIndex; i < featureResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetFeatureValues(result, featureResult.getValues().get(i));\n-\t\t\tvalues.add(result);\n+\t\tif (featureResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) featureResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetFeatureValues(result, multiresult.getValues().get(i));\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n-\t\tfor (int i = resultStartIndex; i < outcomeResult.getValues().size(); i++) {\n-\t\t\tObject[] result = new Object[size];\n-\t\t\tsetOutcomeValues(result, outcomeResult.getValues().get(i), featureLength);\n-\t\t\tvalues.add(result);\n+\t\tif (outcomeResult.isContained()) {\n+\t\t\tMultilineContainedEntityResult multiresult = ((MultilineContainedEntityResult) outcomeResult);\n+\t\t\tfor (int i = resultStartIndex; i < multiresult.getValues().size(); i++) {\n+\t\t\t\tObject[] result = new Object[size];\n+\t\t\t\tsetOutcomeValues(result, multiresult.getValues().get(i), featureLength);\n+\t\t\t\tvalues.add(result);\n+\t\t\t}\n \t\t}\n \t\treturn EntityResult.multilineOf(entity.getId(), values);\n \t}\n \n+\tprivate int determineResultWithAndCheck(FormQueryPlan subquery, EntityResult subResult) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNjc1Mw=="}, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzg1NDIyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzoyNFrOHLsBZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjowNzoyNFrOHLsBZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxNzYzOA==", "bodyText": "danke!", "url": "https://github.com/bakdata/conquery/pull/1331#discussion_r482017638", "createdAt": "2020-09-02T12:07:24Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -160,16 +214,6 @@ public RelativeFormQueryPlan clone(CloneContext ctx) {\n \n \t@Override\n \tpublic boolean isOfInterest(Entity entity) {\n-\t\treturn query.isOfInterest(entity);\n+\t\treturn query.isOfInterest(entity) || featurePlan.isOfInterest(entity) || outcomePlan.isOfInterest(entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a556db45fc7486853ab6741ceb72d0b5cbc9771"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1365, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}