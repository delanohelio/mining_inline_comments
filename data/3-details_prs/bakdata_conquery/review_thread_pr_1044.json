{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NzE3MjMy", "number": 1044, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNDo0MlrODhcw3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozOTo1NVrODitGOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDAwODYxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNDo0MlrOFsL2wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNDo0MlrOFsL2wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NTkwNg==", "bodyText": "Etwas generelle Doku w\u00e4re gut. Ich finde es nicht ersichtlich, was hier berechnet wird", "url": "https://github.com/bakdata/conquery/pull/1044#discussion_r381875906", "createdAt": "2020-02-20T09:24:42Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "diffHunk": "@@ -136,33 +136,37 @@ private void calculateCBlock(CBlock cBlock, ConceptTreeConnector connector, Calc\n \n \t\tcBlock.setMostSpecificChildren(new ArrayList<>(bucket.getNumberOfEvents()));\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccec6b0b7bd5345e9faa63772229c0a1b0b84673"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDAxNzQ3OnYy", "diffSide": "RIGHT", "path": "backend/src/test/resources/tests/query/SIMPLE_TREECONCEPT_CONNECTOR_CONDITION_QUERY/SIMPLE_TREECONCEPT_Query.test.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyNzowM1rOFsL8Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyODozM1rOFsL_Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzI2Nw==", "bodyText": "H\u00e4tte der Test nicht das selbe Ergebnis ohne diese condition?", "url": "https://github.com/bakdata/conquery/pull/1044#discussion_r381877267", "createdAt": "2020-02-20T09:27:03Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/resources/tests/query/SIMPLE_TREECONCEPT_CONNECTOR_CONDITION_QUERY/SIMPLE_TREECONCEPT_Query.test.json", "diffHunk": "@@ -0,0 +1,72 @@\n+{\n+    \"type\": \"QUERY_TEST\",\n+    \"label\": \"SIMPLE_TREECONCEPT_QUERY Test\",\n+    \"expectedCsv\": \"tests/query/SIMPLE_TREECONCEPT_QUERY/expected.csv\",\n+    \"query\": {\n+        \"type\": \"CONCEPT_QUERY\",\n+        \"root\": {\n+            \"type\": \"CONCEPT\",\n+            \"ids\": [\n+              \"${dataset}.test_tree.test_child1\"\n+            ],\n+            \"tables\": [\n+                {\n+                  \"id\": \"${dataset}.test_tree.test_column\",\n+                    \"filters\": []\n+                }\n+            ]\n+        }\n+    },\n+    \"concepts\": [\n+        {\n+            \"label\": \"test_tree\",\n+            \"type\":\"TREE\",\n+            \"connectors\": {\n+              \"condition\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccec6b0b7bd5345e9faa63772229c0a1b0b84673"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3ODExMA==", "bodyText": "Eine COLUMN_EQUAL condition w\u00fcrde hier denke ich klarer sein", "url": "https://github.com/bakdata/conquery/pull/1044#discussion_r381878110", "createdAt": "2020-02-20T09:28:33Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/resources/tests/query/SIMPLE_TREECONCEPT_CONNECTOR_CONDITION_QUERY/SIMPLE_TREECONCEPT_Query.test.json", "diffHunk": "@@ -0,0 +1,72 @@\n+{\n+    \"type\": \"QUERY_TEST\",\n+    \"label\": \"SIMPLE_TREECONCEPT_QUERY Test\",\n+    \"expectedCsv\": \"tests/query/SIMPLE_TREECONCEPT_QUERY/expected.csv\",\n+    \"query\": {\n+        \"type\": \"CONCEPT_QUERY\",\n+        \"root\": {\n+            \"type\": \"CONCEPT\",\n+            \"ids\": [\n+              \"${dataset}.test_tree.test_child1\"\n+            ],\n+            \"tables\": [\n+                {\n+                  \"id\": \"${dataset}.test_tree.test_column\",\n+                    \"filters\": []\n+                }\n+            ]\n+        }\n+    },\n+    \"concepts\": [\n+        {\n+            \"label\": \"test_tree\",\n+            \"type\":\"TREE\",\n+            \"connectors\": {\n+              \"condition\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzI2Nw=="}, "originalCommit": {"oid": "ccec6b0b7bd5345e9faa63772229c0a1b0b84673"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzE1NzkzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/tree/TreeChildPrefixIndex.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozNjoyN1rOFuGQqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozNjoyN1rOFuGQqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MTM4NQ==", "bodyText": "Ich sehe nur die statische Wildcard Typisierung, wird hier \u00fcberhaupt Generizit\u00e4t benutzt?", "url": "https://github.com/bakdata/conquery/pull/1044#discussion_r383881385", "createdAt": "2020-02-25T13:36:27Z", "author": {"login": "Priehn"}, "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/tree/TreeChildPrefixIndex.java", "diffHunk": "@@ -47,7 +48,7 @@ private static boolean isPrefixMaintainigCondition(CTCondition cond) {\n \t\t\t\t;\n \t}\n \n-\tpublic static void putIndexInto(ConceptTreeNode root) {\n+\tpublic static void putIndexInto(ConceptTreeNode<?> root) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e9f00596d1c9c2b57c35b7a86b26e6cbce7df1"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzE3MDQ4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/tree/TreeChildPrefixIndex.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozOTo1NVrOFuGYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozOTo1NVrOFuGYCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MzI3Mg==", "bodyText": "Leider stecke ich nicht tief genug in der EVA um hier was beuteilen zu k\u00f6nnen aber ein Kommentar f\u00e4nde ich ganz hilfreich", "url": "https://github.com/bakdata/conquery/pull/1044#discussion_r383883272", "createdAt": "2020-02-25T13:39:55Z", "author": {"login": "Priehn"}, "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/tree/TreeChildPrefixIndex.java", "diffHunk": "@@ -62,30 +63,33 @@ public static void putIndexInto(ConceptTreeNode root) {\n \n \t\t\tTreeChildPrefixIndex index = new TreeChildPrefixIndex();\n \n-\t\t\tList<ConceptTreeChild> treeChildrenOrig = new ArrayList<>();\n-\t\t\ttreeChildrenOrig.addAll(root.getChildren());\n-\n \t\t\t// collect all prefix children that are itself children of prefix nodes\n \t\t\tMap<String, ConceptTreeChild> gatheredPrefixChildren = new HashMap<>();\n \n-\t\t\tfor (int i = 0; i < treeChildrenOrig.size(); i++) {\n-\t\t\t\tConceptTreeChild child = treeChildrenOrig.get(i);\n+\t\t\tQueue<ConceptTreeChild> treeChildrenOrig = new ArrayDeque<>(root.getChildren());\n+\t\t\tConceptTreeChild child;\n+\n+\t\t\t// Iterate over all children that can be reached deterministically with prefixes\n+\t\t\twhile ((child = treeChildrenOrig.poll()) != null) {\n \t\t\t\tCTCondition condition = child.getCondition();\n \n-\t\t\t\tif(isPrefixMaintainigCondition(condition)) {\n-\t\t\t\t\ttreeChildrenOrig.addAll(child.getChildren());\n-\n-\t\t\t\t\tif (condition instanceof PrefixCondition) {\n-\t\t\t\t\t\tfor (String prefix : ((PrefixCondition) condition).getPrefixes()) {\n-\t\t\t\t\t\t\t// We are interested in the most specific child, therefore the deepest.\n-\t\t\t\t\t\t\tgatheredPrefixChildren.merge(prefix, child,\n-\t\t\t\t\t\t\t\t(newChild, oldChild) -> oldChild.getDepth() > newChild.getDepth() ? oldChild : newChild\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n+\t\t\t\t// If the Condition is not deterministic wrt to prefixes, we will not build an index over it, but start a new one from there.\n+\t\t\t\tif (!isPrefixMaintainigCondition(condition)) {\n \t\t\t\t\tputIndexInto(child);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\ttreeChildrenOrig.addAll(child.getChildren());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e9f00596d1c9c2b57c35b7a86b26e6cbce7df1"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1513, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}