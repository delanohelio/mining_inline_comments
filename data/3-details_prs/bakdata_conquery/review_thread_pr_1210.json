{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMzA5NTU3", "number": 1210, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowMzo1MFrOEFbjYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0Mzo1NVrOEFdzPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTI5NzYwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/FormConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowMzo1MFrOGjnU1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowMzo1MFrOGjnU1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NzY1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}.\", getId(), target);\n          \n          \n            \n            \t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}.\", getId(), target, e);", "url": "https://github.com/bakdata/conquery/pull/1210#discussion_r439997654", "createdAt": "2020-06-15T08:03:50Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/FormConfig.java", "diffHunk": "@@ -93,36 +96,57 @@ public FormConfigOverviewRepresentation overview(MasterMetaStorage storage, User\n \t}\n \n \t/**\n-\t * Tries to convert the given raw form to the provided dataset. It does not\n+\t * Tries to convert this form to the provided dataset. It does not\n \t * check whether the {@link NamespacedId} that are converted in this processes\n \t * are actually resolvable. Also, it tries to map the values to a subclass of\n-\t * {@link Form}, for conversion. If that is not possible the untranslated values\n-\t * are output.\n+\t * {@link Form}, for conversion. If that is not possible the an empty optional is returned.\n \t */\n-\tpublic FormConfigFullRepresentation tryTranslateToDataset(MasterMetaStorage storage, DatasetId target, ObjectMapper mapper, User user) {\n+\tpublic Optional<FormConfig> tryTranslateToDataset(Namespaces namespaces, DatasetId target, ObjectMapper mapper) {\n \t\tJsonNode finalRep = values;\n \t\ttry {\n-\t\t\tForm intemediateRep = mapper.readerFor(Form.class).readValue(values.traverse());\n-\t\t\tForm translatedRep = QueryTranslator.replaceDataset(storage.getNamespaces(), intemediateRep, target);\n+\t\t\tForm intermediateRep = mapper.readerFor(Form.class).readValue(values);\n+\t\t\tif (! NamespacedIdHolding.class.isAssignableFrom(intermediateRep.getClass())) {\n+\t\t\t\tlog.trace(\"Not translating FormConfig ({}) with form type ({}) to dataset ({}), because it does not hold any namespaced ids for translation.\", this.getId(), this.getFormType(), target);\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tForm translatedRep = QueryTranslator.replaceDataset(namespaces, intermediateRep, target);\n \t\t\tfinalRep = mapper.valueToTree(translatedRep);\n \t\t}\n \t\tcatch (IOException e) {\n-\t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}. Sending untranslated version.\", getId(), target);\n+\t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}.\", getId(), target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4109a8f9ae4dfec7893c7a946e72db164103e01a"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTMwMDE0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/FormConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowNDo0M1rOGjnWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowNDo0M1rOGjnWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5ODA3Nw==", "bodyText": "system ist bisher nur PSM automatisch generierte aber das feature habe ich nicht mehr gemerged weil das automatische l\u00f6schen da mMn sinnvoller war.", "url": "https://github.com/bakdata/conquery/pull/1210#discussion_r439998077", "createdAt": "2020-06-15T08:04:43Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/FormConfig.java", "diffHunk": "@@ -93,36 +96,57 @@ public FormConfigOverviewRepresentation overview(MasterMetaStorage storage, User\n \t}\n \n \t/**\n-\t * Tries to convert the given raw form to the provided dataset. It does not\n+\t * Tries to convert this form to the provided dataset. It does not\n \t * check whether the {@link NamespacedId} that are converted in this processes\n \t * are actually resolvable. Also, it tries to map the values to a subclass of\n-\t * {@link Form}, for conversion. If that is not possible the untranslated values\n-\t * are output.\n+\t * {@link Form}, for conversion. If that is not possible the an empty optional is returned.\n \t */\n-\tpublic FormConfigFullRepresentation tryTranslateToDataset(MasterMetaStorage storage, DatasetId target, ObjectMapper mapper, User user) {\n+\tpublic Optional<FormConfig> tryTranslateToDataset(Namespaces namespaces, DatasetId target, ObjectMapper mapper) {\n \t\tJsonNode finalRep = values;\n \t\ttry {\n-\t\t\tForm intemediateRep = mapper.readerFor(Form.class).readValue(values.traverse());\n-\t\t\tForm translatedRep = QueryTranslator.replaceDataset(storage.getNamespaces(), intemediateRep, target);\n+\t\t\tForm intermediateRep = mapper.readerFor(Form.class).readValue(values);\n+\t\t\tif (! NamespacedIdHolding.class.isAssignableFrom(intermediateRep.getClass())) {\n+\t\t\t\tlog.trace(\"Not translating FormConfig ({}) with form type ({}) to dataset ({}), because it does not hold any namespaced ids for translation.\", this.getId(), this.getFormType(), target);\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t\tForm translatedRep = QueryTranslator.replaceDataset(namespaces, intermediateRep, target);\n \t\t\tfinalRep = mapper.valueToTree(translatedRep);\n \t\t}\n \t\tcatch (IOException e) {\n-\t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}. Sending untranslated version.\", getId(), target);\n+\t\t\tlog.warn(\"Unable to translate form configuration {} to dataset {}.\", getId(), target);\n+\t\t\treturn Optional.empty();\n \t\t}\n+\t\t\n+\t\tFormConfig translatedConf = new FormConfig(\n+\t\t\ttarget,\n+\t\t\tformType,\n+\t\t\tformId,\n+\t\t\tlabel,\n+\t\t\ttags,\n+\t\t\tshared,\n+\t\t\tfinalRep,\n+\t\t\towner,\n+\t\t\tcreationTime\n+\t\t\t);\n+\n+\t\treturn Optional.of(translatedConf);\n+\t}\n \n-\t\t@NonNull\n+\t/**\n+\t * Return the full representation of the configuration with the configured form fields and meta data.\n+\t */\n+\tpublic FormConfigFullRepresentation fullRepresentation(MasterMetaStorage storage, User requestingUser){\n \t\tString ownerName = Optional.ofNullable(storage.getUser(owner)).map(User::getLabel).orElse(null);\n-\n \t\treturn FormConfigFullRepresentation.builder()\n \t\t\t.id(getId()).formType(formType)\n \t\t\t.label(label)\n \t\t\t.tags(tags)\n \t\t\t.ownerName(ownerName)\n-\t\t\t.own(user.getId().equals(owner))\n+\t\t\t.own(requestingUser != null? requestingUser.getId().equals(owner) : false)\n \t\t\t.createdAt(getCreationTime().atZone(ZoneId.systemDefault()))\n \t\t\t.shared(shared)\n-\t\t\t// system?\n-\t\t\t.values(finalRep).build();\n+\t\t\t// system? TODO discuss how system is determined (may check if owning user is in a special system group or so)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4109a8f9ae4dfec7893c7a946e72db164103e01a"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTMwNTUxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/frontendconfiguration/FormConfigProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowNjoxMVrOGjnZvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowNjoxMVrOGjnZvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5ODkxMQ==", "bodyText": "deine indentation spinnt hier?", "url": "https://github.com/bakdata/conquery/pull/1210#discussion_r439998911", "createdAt": "2020-06-15T08:06:11Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/frontendconfiguration/FormConfigProcessor.java", "diffHunk": "@@ -65,17 +79,62 @@\n \t */\n \tpublic FormConfigFullRepresentation getConfig(DatasetId datasetId, User user, FormConfigId formId) {\n \t\tuser.checkPermission(FormConfigPermission.onInstance(Ability.READ, formId));\n-\t\tFormConfigFullRepresentation config = Objects.requireNonNull(storage.getFormConfig(formId), String.format(\"Could not find form config %s\", formId))\n-\t\t\t.tryTranslateToDataset(storage, datasetId, MAPPER, user);\n-\t\treturn config;\n+\t\treturn Objects.requireNonNull(storage.getFormConfig(formId), String.format(\"Could not find form config %s\", formId))\n+\t\t\t.fullRepresentation(storage, user);\n+\t}\n+\t\n+\t/**\n+\t * Adds the provided config to the desired dataset and the datasets that the user has access to (has the READ ability on the Dataset), if the config is translatable to those.\n+\t */\n+\tpublic FormConfigId addConfig(User user, DatasetId targetDataset, FormConfig config) {\n+\t\tuser.checkPermission(DatasetPermission.onInstance(Ability.READ.asSet(), targetDataset));\n+\t\t\n+\t\tList<DatasetId> translateToDatasets = storage.getNamespaces()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4109a8f9ae4dfec7893c7a946e72db164103e01a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTY2NTkxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/frontendconfiguration/FormConfigProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0Mzo1NVrOGjq4Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOTo0Mzo1NVrOGjq4Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NTgyNg==", "bodyText": "ifPresentOrElse auf newline?", "url": "https://github.com/bakdata/conquery/pull/1210#discussion_r440055826", "createdAt": "2020-06-15T09:43:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/frontendconfiguration/FormConfigProcessor.java", "diffHunk": "@@ -65,17 +79,62 @@\n \t */\n \tpublic FormConfigFullRepresentation getConfig(DatasetId datasetId, User user, FormConfigId formId) {\n \t\tuser.checkPermission(FormConfigPermission.onInstance(Ability.READ, formId));\n-\t\tFormConfigFullRepresentation config = Objects.requireNonNull(storage.getFormConfig(formId), String.format(\"Could not find form config %s\", formId))\n-\t\t\t.tryTranslateToDataset(storage, datasetId, MAPPER, user);\n-\t\treturn config;\n+\t\treturn Objects.requireNonNull(storage.getFormConfig(formId), String.format(\"Could not find form config %s\", formId))\n+\t\t\t.fullRepresentation(storage, user);\n+\t}\n+\t\n+\t/**\n+\t * Adds the provided config to the desired dataset and the datasets that the user has access to (has the READ ability on the Dataset), if the config is translatable to those.\n+\t */\n+\tpublic FormConfigId addConfig(User user, DatasetId targetDataset, FormConfig config) {\n+\t\tuser.checkPermission(DatasetPermission.onInstance(Ability.READ.asSet(), targetDataset));\n+\t\t\n+\t\tList<DatasetId> translateToDatasets = storage.getNamespaces()\n+\t\t.getAllDatasets()\n+\t\t.stream()\n+\t\t.map(Identifiable::getId)\n+\t\t.filter(dId -> user.isPermitted(DatasetPermission.onInstance(Ability.READ.asSet(), dId)))\n+\t\t.collect(Collectors.toList());\n+\t\t\n+\t\t\n+\t\ttranslateToDatasets.remove(targetDataset);\n+\t\t\n+\t\treturn addConfigAndTranslations(user, targetDataset, translateToDatasets, config);\n+\t}\n+\t\n+\t/**\n+\t * Adds the config to the dataset it was submitted under and also to all other datasets it can be translated to.\n+\t * This method does not check permissions.\n+\t */\n+\tpublic FormConfigId addConfigAndTranslations(User user, DatasetId targetDataset, Collection<DatasetId> translateTo, FormConfig config) {\n+\n+\t\t// Add the config immediately to the submitted dataset\n+\t\taddConfigToDataset(user, targetDataset, config);\n+\n+\t\t// Add the translated config to the other datasets (synchronous at the moment)\n+\t\tfor (DatasetId target : translateTo) {\n+\t\t\tif (target.equals(targetDataset)) {\n+\t\t\t\t// Skip the actual target dataset here because its already added\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tconfig.tryTranslateToDataset(storage.getNamespaces(), target, MAPPER).ifPresentOrElse(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4109a8f9ae4dfec7893c7a946e72db164103e01a"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1401, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}