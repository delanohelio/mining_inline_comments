{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MzM2NTg4", "number": 1163, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo0NDowNFrOD4DK0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzoyNDo0NFrOEpB1tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDk4NzY4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/Connector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo0NDowNFrOGOp7WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo0NDowNFrOGOp7WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyMDE4NQ==", "bodyText": "Ich wei\u00df nicht ob das frontend das macht aber es sollte immer ein default validity date geben.", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418020185", "createdAt": "2020-04-30T13:44:04Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/Connector.java", "diffHunk": "@@ -154,6 +154,9 @@ public boolean validateSelectableDates(ConstraintValidatorContext context) {\n \t}\n \n \tpublic Column getValidityDateColumn(String name) {\n+\t\tif(name == null ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDk5ODI1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo0NjoyMVrOGOqCEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo0NjoyMVrOGOqCEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyMTkwNQ==", "bodyText": "warum machst du das hier und nicht im resolve schritt?", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418021905", "createdAt": "2020-04-30T13:46:21Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.bakdata.conquery.models.query.concept;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.Range;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.concepts.Concept;\n+import com.bakdata.conquery.models.externalservice.ResultType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.filter.CQUnfilteredTable;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan.TableExportConnector;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.bakdata.conquery.models.query.resultinfo.SimpleResultInfo;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+\n+/**\n+ * A TABLE_EXPORT creates a full export of the given tables. It ignores selects completely.\n+ */\n+@Slf4j\n+@Getter @Setter\n+@CPSType(id = \"TABLE_EXPORT\", base = QueryDescription.class)\n+@RequiredArgsConstructor(onConstructor = @__({@JsonCreator}))\n+public class TableExportQuery extends IQuery {\n+\n+\t@Valid\n+\t@NotNull @NonNull\n+\tprotected IQuery query;\n+\t@NotNull\n+\tprivate Range<LocalDate> dateRange = Range.all();\n+\t@NotEmpty @Valid\n+\tprivate List<CQUnfilteredTable> tables;\n+\n+\t@Override\n+\tpublic TableExportQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\tfor(CQUnfilteredTable table : tables) {\n+\t\t\ttry {\n+\t\t\t\tConcept<?> concept=context.getCentralRegistry().resolve(table.getId().getConcept());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTAzNDI5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/TableRequiringAggregatorNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo1NDoyMlrOGOqZgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo1NDoyMlrOGOqZgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyNzkwNA==", "bodyText": "Da w\u00fcrde ich mir Doku w\u00fcnschen. Mir ist nicht klar wof\u00fcr genau das gut ist", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418027904", "createdAt": "2020-04-30T13:54:22Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/TableRequiringAggregatorNode.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.bakdata.conquery.models.query.queryplan.specific;\n+\n+import java.util.Set;\n+\n+import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n+import com.bakdata.conquery.models.query.queryplan.aggregators.Aggregator;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+\n+public class TableRequiringAggregatorNode<T> extends AggregatorNode<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTAzNzI2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/DateRangeTypePacked.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo1NTowNFrOGOqbcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTowMTo0MVrOGOtbRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyODQwMw==", "bodyText": "hier dann auch null?", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418028403", "createdAt": "2020-04-30T13:55:04Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/DateRangeTypePacked.java", "diffHunk": "@@ -20,16 +20,24 @@ public DateRangeTypePacked() {\n \t}\n \t\n \t@Override\n-\tpublic Object createPrintValue(Integer value) {\n-\t\tif (value == null) {\n-\t\t\treturn \"\";\n+\tpublic CDateRange createScriptValue(Integer value) {\n+\t\tif(value == null) {\n+\t\t\treturn null;\n \t\t}\n-\n \t\treturn CDateRange.of(\n \t\t\tPackedUnsigned1616.getLeft(value)+minValue,\n \t\t\tPackedUnsigned1616.getRight(value)+minValue\n \t\t);\n \t}\n+\t\n+\t@Override\n+\tpublic Object createPrintValue(Integer value) {\n+\t\tif (value == null) {\n+\t\t\treturn \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3NzUwOQ==", "bodyText": "createPrintValue sollte immer non-null zur\u00fcckgeben", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418077509", "createdAt": "2020-04-30T15:01:41Z", "author": {"login": "manuel-hegner"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/DateRangeTypePacked.java", "diffHunk": "@@ -20,16 +20,24 @@ public DateRangeTypePacked() {\n \t}\n \t\n \t@Override\n-\tpublic Object createPrintValue(Integer value) {\n-\t\tif (value == null) {\n-\t\t\treturn \"\";\n+\tpublic CDateRange createScriptValue(Integer value) {\n+\t\tif(value == null) {\n+\t\t\treturn null;\n \t\t}\n-\n \t\treturn CDateRange.of(\n \t\t\tPackedUnsigned1616.getLeft(value)+minValue,\n \t\t\tPackedUnsigned1616.getRight(value)+minValue\n \t\t);\n \t}\n+\t\n+\t@Override\n+\tpublic Object createPrintValue(Integer value) {\n+\t\tif (value == null) {\n+\t\t\treturn \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyODQwMw=="}, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTA0NTgxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/TableExportQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo1NzowM1rOGOqhHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzo1NzowM1rOGOqhHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyOTg1Mg==", "bodyText": "Kleiner  makel aber ich finde den Namen hier etwas tr\u00fcgerisch weil es ja kein echter Connector ist", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r418029852", "createdAt": "2020-04-30T13:57:03Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/TableExportQueryPlan.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.bakdata.conquery.models.query.queryplan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.datasets.Table;\n+import com.bakdata.conquery.models.events.Bucket;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.types.CType;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * The QueryPlan creates a full dump of the given table within a certain\n+ * date range.\n+ */\n+@RequiredArgsConstructor\n+public class TableExportQueryPlan implements QueryPlan {\n+\n+\tprivate final QueryPlan subPlan;\n+\tprivate final CDateRange dateRange;\n+\tprivate final List<TableExportConnector> tables;\n+\tprivate final int totalColumns;\n+\t\n+\t@Override\n+\tpublic QueryPlan clone(CloneContext ctx) {\n+\t\treturn new TableExportQueryPlan(subPlan.clone(ctx), dateRange, tables, totalColumns);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isOfInterest(Entity entity) {\n+\t\treturn subPlan.isOfInterest(entity);\n+\t}\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tEntityResult result = subPlan.execute(ctx, entity);\n+\t\t\n+\t\tif(!result.isContained()) {\n+\t\t\treturn result;\n+\t\t}\n+\t\t\n+\t\tif (tables.isEmpty()) {\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t\n+\t\tList<Object[]> results = new ArrayList<>();\n+\t\tfor(TableExportConnector tec : tables) {\n+\t\t\tfor(Bucket bucket : entity.getBucket(tec.getTable().getId())) {\n+\t\t\t\tint localEntity = bucket.toLocal(entity.getId());\n+\t\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n+\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n+\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n+\t\t\t\t\tfor(int event = start; event < end ; event++) {\n+\t\t\t\t\t\tif (bucket.eventIsContainedIn(event, tec.getValidityDateColumn(), dateRange)) {\n+\t\t\t\t\t\t\tObject[] entry = new Object[totalColumns];\n+\t\t\t\t\t\t\tfor(int col = 0; col < tec.getTable().getColumns().length; col++) {\n+\t\t\t\t\t\t\t\tCType type = tec.getTable().getColumns()[col].getTypeFor(bucket);\n+\t\n+\t\t\t\t\t\t\t\t// depending on context use pretty printing or script value\n+\t\t\t\t\t\t\t\tentry[col+tec.getColumnOffset()] = ctx.isPrettyPrint()\n+\t\t\t\t\t\t\t\t\t? type.createPrintValue(bucket.getRaw(event, col))\n+\t\t\t\t\t\t\t\t\t: type.createScriptValue(bucket.getRaw(event, col));\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tresults.add(entry);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t//pivot the last column\n+\t\treturn EntityResult.multilineOf(\n+\t\t\tresult.asContained().getEntityId(),\n+\t\t\tresults\n+\t\t);\n+\t}\n+\t\n+\t@RequiredArgsConstructor\n+\t@Getter\n+\tpublic static class TableExportConnector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d535653f627805bc6df94d5e2947a36d87396"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDUwODkwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzowOTo0OFrOHacvKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo1MzozOVrOHahl3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5NTg1MA==", "bodyText": "Ist der Umweg hier unbedingt gewollt, dass ein Connector \u00fcbergeben wird. W\u00fcrde es nicht auch schon eine TableId tun und man w\u00fcrde Concepte und Connectoren ganz raus lassen?", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497495850", "createdAt": "2020-09-30T13:09:48Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.bakdata.conquery.models.query.concept;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.Range;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.concepts.Concept;\n+import com.bakdata.conquery.models.concepts.Connector;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.externalservice.ResultType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ColumnId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.filter.CQUnfilteredTable;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan.TableExportDescription;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.bakdata.conquery.models.query.resultinfo.SimpleResultInfo;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+\n+/**\n+ * A TABLE_EXPORT creates a full export of the given tables. It ignores selects completely.\n+ */\n+@Slf4j\n+@Getter @Setter\n+@CPSType(id = \"TABLE_EXPORT\", base = QueryDescription.class)\n+@RequiredArgsConstructor(onConstructor = @__({@JsonCreator}))\n+public class TableExportQuery extends IQuery {\n+\n+\t@Valid\n+\t@NotNull @NonNull\n+\tprotected IQuery query;\n+\t@NotNull\n+\tprivate Range<LocalDate> dateRange = Range.all();\n+\t@NotEmpty @Valid\n+\tprivate List<CQUnfilteredTable> tables;\n+\tprivate List<ColumnId> resolvedHeader;  \n+\n+\t@Override\n+\tpublic TableExportQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\tint totalColumns = 0;\n+\t\tList<TableExportDescription> resolvedConnectors = new ArrayList<>();\n+\t\tfor(CQUnfilteredTable table : tables) {\n+\t\t\ttry {\n+\t\t\t\tConcept<?> concept = context.getCentralRegistry().resolve(table.getId().getConcept());\n+\t\t\t\tConnector connector = concept.getConnectorByName(table.getId().getConnector());\n+\t\t\t\tresolvedConnectors.add(\n+\t\t\t\t\tnew TableExportDescription(\n+\t\t\t\t\t\tconnector.getTable(),\n+\t\t\t\t\t\tconnector.getValidityDateColumn(table.selectedValidityDate()),\n+\t\t\t\t\t\ttotalColumns\n+\t\t\t\t\t)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MzkwMA==", "bodyText": "Das geht nicht, weil das Frontend keine Tables kennt", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497573900", "createdAt": "2020-09-30T14:51:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.bakdata.conquery.models.query.concept;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.Range;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.concepts.Concept;\n+import com.bakdata.conquery.models.concepts.Connector;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.externalservice.ResultType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ColumnId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.filter.CQUnfilteredTable;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan.TableExportDescription;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.bakdata.conquery.models.query.resultinfo.SimpleResultInfo;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+\n+/**\n+ * A TABLE_EXPORT creates a full export of the given tables. It ignores selects completely.\n+ */\n+@Slf4j\n+@Getter @Setter\n+@CPSType(id = \"TABLE_EXPORT\", base = QueryDescription.class)\n+@RequiredArgsConstructor(onConstructor = @__({@JsonCreator}))\n+public class TableExportQuery extends IQuery {\n+\n+\t@Valid\n+\t@NotNull @NonNull\n+\tprotected IQuery query;\n+\t@NotNull\n+\tprivate Range<LocalDate> dateRange = Range.all();\n+\t@NotEmpty @Valid\n+\tprivate List<CQUnfilteredTable> tables;\n+\tprivate List<ColumnId> resolvedHeader;  \n+\n+\t@Override\n+\tpublic TableExportQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\tint totalColumns = 0;\n+\t\tList<TableExportDescription> resolvedConnectors = new ArrayList<>();\n+\t\tfor(CQUnfilteredTable table : tables) {\n+\t\t\ttry {\n+\t\t\t\tConcept<?> concept = context.getCentralRegistry().resolve(table.getId().getConcept());\n+\t\t\t\tConnector connector = concept.getConnectorByName(table.getId().getConnector());\n+\t\t\t\tresolvedConnectors.add(\n+\t\t\t\t\tnew TableExportDescription(\n+\t\t\t\t\t\tconnector.getTable(),\n+\t\t\t\t\t\tconnector.getValidityDateColumn(table.selectedValidityDate()),\n+\t\t\t\t\t\ttotalColumns\n+\t\t\t\t\t)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5NTg1MA=="}, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3NTM4OA==", "bodyText": "Noch nicht ;)", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497575388", "createdAt": "2020-09-30T14:53:39Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/TableExportQuery.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.bakdata.conquery.models.query.concept;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.Range;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.concepts.Concept;\n+import com.bakdata.conquery.models.concepts.Connector;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.externalservice.ResultType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ColumnId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.filter.CQUnfilteredTable;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.TableExportQueryPlan.TableExportDescription;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.bakdata.conquery.models.query.resultinfo.SimpleResultInfo;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+\n+/**\n+ * A TABLE_EXPORT creates a full export of the given tables. It ignores selects completely.\n+ */\n+@Slf4j\n+@Getter @Setter\n+@CPSType(id = \"TABLE_EXPORT\", base = QueryDescription.class)\n+@RequiredArgsConstructor(onConstructor = @__({@JsonCreator}))\n+public class TableExportQuery extends IQuery {\n+\n+\t@Valid\n+\t@NotNull @NonNull\n+\tprotected IQuery query;\n+\t@NotNull\n+\tprivate Range<LocalDate> dateRange = Range.all();\n+\t@NotEmpty @Valid\n+\tprivate List<CQUnfilteredTable> tables;\n+\tprivate List<ColumnId> resolvedHeader;  \n+\n+\t@Override\n+\tpublic TableExportQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\tint totalColumns = 0;\n+\t\tList<TableExportDescription> resolvedConnectors = new ArrayList<>();\n+\t\tfor(CQUnfilteredTable table : tables) {\n+\t\t\ttry {\n+\t\t\t\tConcept<?> concept = context.getCentralRegistry().resolve(table.getId().getConcept());\n+\t\t\t\tConnector connector = concept.getConnectorByName(table.getId().getConnector());\n+\t\t\t\tresolvedConnectors.add(\n+\t\t\t\t\tnew TableExportDescription(\n+\t\t\t\t\t\tconnector.getTable(),\n+\t\t\t\t\t\tconnector.getValidityDateColumn(table.selectedValidityDate()),\n+\t\t\t\t\t\ttotalColumns\n+\t\t\t\t\t)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5NTg1MA=="}, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDU1NzA1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/filter/CQUnfilteredTable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzoyMToxNFrOHadNYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzoyMToxNFrOHadNYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwMzU4Ng==", "bodyText": "Das f\u00fchrt in 'Connector::getValidityDateColumn' zu einer NoSuchElementException. Soweit muss es ja nicht kommen.", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497503586", "createdAt": "2020-09-30T13:21:14Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/filter/CQUnfilteredTable.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.bakdata.conquery.models.query.concept.filter;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.models.concepts.Connector;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ConnectorId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ValidityDateId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+\n+@Getter @Setter\n+public class CQUnfilteredTable {\n+\t@Valid @NotNull\n+\tprivate ConnectorId id;\n+\t@Valid\n+\tprivate ValidityDateColumn dateColumn;\n+\n+\t@JsonIgnore\n+\tprivate Connector resolvedConnector;\n+\t\n+\t@Data @AllArgsConstructor @NoArgsConstructor\n+\tpublic static class ValidityDateColumn {\n+\t\tprivate ValidityDateId value;\n+\t\t\n+\t\tpublic ValidityDateColumn(String id) {\n+\t\t\tthis(ValidityDateId.Parser.INSTANCE.parse(id));\n+\t\t}\n+\t}\n+\n+\tpublic String selectedValidityDate() {\n+\t\tif(dateColumn == null || dateColumn.getValue() == null) {\n+\t\t\treturn null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDU3MjA3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/TableExportQueryPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzoyNDo0NFrOHadXHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0OTo0NFrOHahZtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwNjA3OQ==", "bodyText": "@awildturtok gab es nicht einen Weg die localEntities hier rauszuhalten?", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497506079", "createdAt": "2020-09-30T13:24:44Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/TableExportQueryPlan.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.bakdata.conquery.models.query.queryplan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.datasets.Table;\n+import com.bakdata.conquery.models.events.Bucket;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.types.CType;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * The QueryPlan creates a full dump of the given table within a certain\n+ * date range.\n+ */\n+@RequiredArgsConstructor\n+public class TableExportQueryPlan implements QueryPlan {\n+\n+\tprivate final QueryPlan subPlan;\n+\tprivate final CDateRange dateRange;\n+\tprivate final List<TableExportDescription> tables;\n+\tprivate final int totalColumns;\n+\t\n+\t@Override\n+\tpublic QueryPlan clone(CloneContext ctx) {\n+\t\treturn new TableExportQueryPlan(subPlan.clone(ctx), dateRange, tables, totalColumns);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isOfInterest(Entity entity) {\n+\t\treturn subPlan.isOfInterest(entity);\n+\t}\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tEntityResult result = subPlan.execute(ctx, entity);\n+\t\t\n+\t\tif(!result.isContained()) {\n+\t\t\treturn result;\n+\t\t}\n+\t\t\n+\t\tif (tables.isEmpty()) {\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t\n+\t\tList<Object[]> results = new ArrayList<>();\n+\t\tfor(TableExportDescription exportDescription : tables) {\n+\t\t\tfor(Bucket bucket : entity.getBucket(exportDescription.getTable().getId())) {\n+\n+\t\t\t\tint localEntity = bucket.toLocal(entity.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MjI3OA==", "bodyText": "noch nicht ne", "url": "https://github.com/bakdata/conquery/pull/1163#discussion_r497572278", "createdAt": "2020-09-30T14:49:44Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/TableExportQueryPlan.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.bakdata.conquery.models.query.queryplan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.datasets.Column;\n+import com.bakdata.conquery.models.datasets.Table;\n+import com.bakdata.conquery.models.events.Bucket;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.types.CType;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * The QueryPlan creates a full dump of the given table within a certain\n+ * date range.\n+ */\n+@RequiredArgsConstructor\n+public class TableExportQueryPlan implements QueryPlan {\n+\n+\tprivate final QueryPlan subPlan;\n+\tprivate final CDateRange dateRange;\n+\tprivate final List<TableExportDescription> tables;\n+\tprivate final int totalColumns;\n+\t\n+\t@Override\n+\tpublic QueryPlan clone(CloneContext ctx) {\n+\t\treturn new TableExportQueryPlan(subPlan.clone(ctx), dateRange, tables, totalColumns);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isOfInterest(Entity entity) {\n+\t\treturn subPlan.isOfInterest(entity);\n+\t}\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tEntityResult result = subPlan.execute(ctx, entity);\n+\t\t\n+\t\tif(!result.isContained()) {\n+\t\t\treturn result;\n+\t\t}\n+\t\t\n+\t\tif (tables.isEmpty()) {\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n+\t\t\n+\t\tList<Object[]> results = new ArrayList<>();\n+\t\tfor(TableExportDescription exportDescription : tables) {\n+\t\t\tfor(Bucket bucket : entity.getBucket(exportDescription.getTable().getId())) {\n+\n+\t\t\t\tint localEntity = bucket.toLocal(entity.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwNjA3OQ=="}, "originalCommit": {"oid": "5750252d13f131f35e13788a26972dd37a996910"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1384, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}