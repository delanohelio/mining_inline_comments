{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNjQ4Nzk0", "number": 1431, "reviewThreads": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NDoyN1rOE6fESA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDoxODoyM1rOFVNraw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzYxODY0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NDoyN1rOH1lp4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1NDoyN1rOH1lp4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1MzUwNw==", "bodyText": "NotImplementedException -> UnsupportedOperationException", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525953507", "createdAt": "2020-11-18T09:54:27Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "diffHunk": "@@ -36,14 +38,54 @@ public CentralRegistry getCentralRegistry() {\n \t\treturn delegate.getCentralRegistry();\n \t}\n \n+\t@Override\n+\tpublic void loadData() {\n+\t\tthrow new NotImplementedException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzYyODU2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1Njo0MFrOH1lwHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo0NTo1MlrOIUNC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTEwMw==", "bodyText": "Dadurch machst du potentiell aus Compiletime-Fehlern Runtime-Fehler. K\u00f6nnen wir das umgehen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525955103", "createdAt": "2020-11-18T09:56:40Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "diffHunk": "@@ -19,12 +20,13 @@\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportId;\n import com.bakdata.conquery.models.worker.WorkerInformation;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.NotImplementedException;\n \n /**\n- * Provides a view on the storage that does not allow modification of the storage (update, delete). \n+ * Provides a view on the storage that does not allow modification of the storage (update, delete).\n  */\n @RequiredArgsConstructor\n-public class ModificationShieldedWorkerStorage {\n+public class ModificationShieldedWorkerStorage implements WorkerStorage {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxNjc3OQ==", "bodyText": "Finde es ehrlich gesagt auch fragw\u00fcrdig, dass in einer Message der Worker sich nicht bearbeiten darf", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r527716779", "createdAt": "2020-11-20T14:13:40Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "diffHunk": "@@ -19,12 +20,13 @@\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportId;\n import com.bakdata.conquery.models.worker.WorkerInformation;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.NotImplementedException;\n \n /**\n- * Provides a view on the storage that does not allow modification of the storage (update, delete). \n+ * Provides a view on the storage that does not allow modification of the storage (update, delete).\n  */\n @RequiredArgsConstructor\n-public class ModificationShieldedWorkerStorage {\n+public class ModificationShieldedWorkerStorage implements WorkerStorage {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTEwMw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA1NjE0NQ==", "bodyText": "Na doch das darf er schon \u00fcber Methoden die der Worker selber nach drau\u00dfen, gibt, aber seinen Storage sollte er nicht nach drau\u00dfen geben und zur Modifikation freigeben", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558056145", "createdAt": "2021-01-15T08:45:52Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/ModificationShieldedWorkerStorage.java", "diffHunk": "@@ -19,12 +20,13 @@\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportId;\n import com.bakdata.conquery.models.worker.WorkerInformation;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.NotImplementedException;\n \n /**\n- * Provides a view on the storage that does not allow modification of the storage (update, delete). \n+ * Provides a view on the storage that does not allow modification of the storage (update, delete).\n  */\n @RequiredArgsConstructor\n-public class ModificationShieldedWorkerStorage {\n+public class ModificationShieldedWorkerStorage implements WorkerStorage {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTEwMw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzc0MzIzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DirectDictionary.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoyMzoyOVrOH1m2tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoyMzoyOVrOH1m2tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MzE3NQ==", "bodyText": "Hier sind noch ein paar leere Bodies. Vllt eine Exception werfen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525973175", "createdAt": "2020-11-18T10:23:29Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DirectDictionary.java", "diffHunk": "@@ -3,19 +3,32 @@\n import java.nio.charset.StandardCharsets;\n import java.util.Iterator;\n \n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import com.bakdata.conquery.models.types.specific.VarIntType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n import com.google.common.collect.Iterators;\n \n-public class DirectDictionary extends AStringType<Integer> {\n+public class DirectDictionary extends StringType {\n \n \tprivate final Dictionary dict;\n \t\n \tpublic DirectDictionary(Dictionary dict) {\n-\t\tsuper(int.class);\n+\t\tsuper();\n \t\tthis.dict = dict;\n \t}\n-\t\n+\n+\n+\t// TODO why is this a StringType at all?\n+\n+\t@Override\n+\tpublic StringType select(int[] starts, int[] length) {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzc0ODcyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DirectDictionary.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoyNDo0NFrOH1m6Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDoyNDo0NFrOH1m6Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3NDAzMA==", "bodyText": "Ja es sieht eher aus, als w\u00fcrde die Klasse als Bridge fungieren", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525974030", "createdAt": "2020-11-18T10:24:44Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DirectDictionary.java", "diffHunk": "@@ -3,19 +3,32 @@\n import java.nio.charset.StandardCharsets;\n import java.util.Iterator;\n \n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import com.bakdata.conquery.models.types.specific.VarIntType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n import com.google.common.collect.Iterators;\n \n-public class DirectDictionary extends AStringType<Integer> {\n+public class DirectDictionary extends StringType {\n \n \tprivate final Dictionary dict;\n \t\n \tpublic DirectDictionary(Dictionary dict) {\n-\t\tsuper(int.class);\n+\t\tsuper();\n \t\tthis.dict = dict;\n \t}\n-\t\n+\n+\n+\t// TODO why is this a StringType at all?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzc4ODQ5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/MapDictionary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDozMzo1N1rOH1nRyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDozNDoyN1rOH1nTDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MDEwNA==", "bodyText": "Ist das Wrapping in ByteArrayList notwendig? Es wird in getId2Value und getElement nur wieder entpackt. Soweit ich das verstehe \u00e4ndern sich die eintr\u00e4ge auch nicht mehr nach dem sie drinne sind", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525980104", "createdAt": "2020-11-18T10:33:57Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/MapDictionary.java", "diffHunk": "@@ -7,46 +7,39 @@\n import java.util.List;\n import java.util.ListIterator;\n \n+import javax.validation.constraints.NotNull;\n+\n import com.bakdata.conquery.io.cps.CPSType;\n import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.math.DoubleMath;\n import it.unimi.dsi.fastutil.Hash;\n import it.unimi.dsi.fastutil.bytes.ByteArrayList;\n import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n-import lombok.AllArgsConstructor;\n \n @CPSType(id = \"MAP_DICTIONARY\", base = Dictionary.class)\n-@AllArgsConstructor\n public class MapDictionary extends Dictionary {\n \n \tprivate Object2IntOpenHashMap<ByteArrayList> value2Id;\n \tprivate List<ByteArrayList> id2Value;\n \n-\tpublic MapDictionary() {\n+\tpublic MapDictionary(DatasetId dataset, @NotNull String name) {\n+\t\tsuper(dataset, name);\n \t\tvalue2Id = new Object2IntOpenHashMap<>();\n \t\tvalue2Id.defaultReturnValue(-1);\n \t\tid2Value = new ArrayList<>();\n \t}\n \n-\tpublic MapDictionary(DictionaryId dictionaryId) {\n-\t\tthis();\n-\t\tthis.setName(dictionaryId.getDictionary());\n-\t\tthis.setDataset(dictionaryId.getDataset());\n-\t}\n-\n \t@JsonCreator\n \tpublic MapDictionary(DatasetId datasetId, String name, byte[][] id2Value) {\n+\t\tsuper(datasetId, name);\n \t\tif (id2Value == null) {\n \t\t\tid2Value = new byte[0][];\n \t\t}\n \t\tthis.id2Value = new ArrayList<>(id2Value.length);\n \t\tvalue2Id = new Object2IntOpenHashMap<>(id2Value.length);\n \t\tvalue2Id.defaultReturnValue(-1);\n-\t\tthis.setName(name);\n-\t\tthis.setDataset(datasetId);\n \n \t\tfor (int i = 0; i < id2Value.length; i++) {\n \t\t\tByteArrayList v = new ByteArrayList(id2Value[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MDQzMA==", "bodyText": "Aber das ist etwas f\u00fcr einen extra PR", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525980430", "createdAt": "2020-11-18T10:34:27Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/MapDictionary.java", "diffHunk": "@@ -7,46 +7,39 @@\n import java.util.List;\n import java.util.ListIterator;\n \n+import javax.validation.constraints.NotNull;\n+\n import com.bakdata.conquery.io.cps.CPSType;\n import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.math.DoubleMath;\n import it.unimi.dsi.fastutil.Hash;\n import it.unimi.dsi.fastutil.bytes.ByteArrayList;\n import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n-import lombok.AllArgsConstructor;\n \n @CPSType(id = \"MAP_DICTIONARY\", base = Dictionary.class)\n-@AllArgsConstructor\n public class MapDictionary extends Dictionary {\n \n \tprivate Object2IntOpenHashMap<ByteArrayList> value2Id;\n \tprivate List<ByteArrayList> id2Value;\n \n-\tpublic MapDictionary() {\n+\tpublic MapDictionary(DatasetId dataset, @NotNull String name) {\n+\t\tsuper(dataset, name);\n \t\tvalue2Id = new Object2IntOpenHashMap<>();\n \t\tvalue2Id.defaultReturnValue(-1);\n \t\tid2Value = new ArrayList<>();\n \t}\n \n-\tpublic MapDictionary(DictionaryId dictionaryId) {\n-\t\tthis();\n-\t\tthis.setName(dictionaryId.getDictionary());\n-\t\tthis.setDataset(dictionaryId.getDataset());\n-\t}\n-\n \t@JsonCreator\n \tpublic MapDictionary(DatasetId datasetId, String name, byte[][] id2Value) {\n+\t\tsuper(datasetId, name);\n \t\tif (id2Value == null) {\n \t\t\tid2Value = new byte[0][];\n \t\t}\n \t\tthis.id2Value = new ArrayList<>(id2Value.length);\n \t\tvalue2Id = new Object2IntOpenHashMap<>(id2Value.length);\n \t\tvalue2Id.defaultReturnValue(-1);\n-\t\tthis.setName(name);\n-\t\tthis.setDataset(datasetId);\n \n \t\tfor (int i = 0; i < id2Value.length; i++) {\n \t\t\tByteArrayList v = new ByteArrayList(id2Value[i]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MDEwNA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzgxOTc5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDo0MToyNVrOH1nkjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNDo0MjoyMlrOIUfCmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDkxMA==", "bodyText": "W\u00e4re hier nicht eine ArrayList oder besser int[] angemessen wo: start[2] == -1 wenn die entity nicht vorhanden ist", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525984910", "createdAt": "2020-11-18T10:41:25Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5MjAwMg==", "bodyText": "Okay, ich sehe, dass du von localentity wegkommen m\u00f6chtest, aber das ist denke ich ein wichtiger Faktor um den Object overhead gering zu halten.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525992002", "createdAt": "2020-11-18T10:52:24Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDkxMA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc2ODAwOQ==", "bodyText": "Ich habe das durch einen copy-Konstruktor von Int2IntArrayMap im Constructor gel\u00f6st", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r527768009", "createdAt": "2020-11-20T15:28:42Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDkxMA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE0MzkzMQ==", "bodyText": "Aber Int2IntArrayMap bewart dich nicht vor boxing und unboxing, oder wird das sofort wegoptimiert?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558143931", "createdAt": "2021-01-15T09:44:21Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDkxMA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1MTAwMA==", "bodyText": "ich habs jetzt mit einem serializer gel\u00f6st", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558351000", "createdAt": "2021-01-15T14:42:22Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDkxMA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Nzg0OTU1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMDo0ODo0MVrOH1n21g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxMjozNDoxOFrOIdfLyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTU5MA==", "bodyText": "Map<Column, Object> als R\u00fcckgabe. Momentan wird in den Column Conditions noch der Spaltenname an statt der SpaltenId gef\u00fchrt, was letztens zu einem Problem ohne Fehlermeldung gef\u00fchrt hat", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r525989590", "createdAt": "2020-11-18T10:48:41Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;\n+\n+\t/**\n+\t * Number of events per Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> length;\n+\n+\tprivate final int bucketSize;\n \n-\tpublic abstract int getBucketSize();\n \n \t@Override\n-\tpublic PrimitiveIterator.OfInt iterator() {\n-\t\treturn IntStream.range(0, getBucketSize())\n-\t\t\t\t\t\t.filter(this::containsLocalEntity)\n-\t\t\t\t\t\t.map(this::toGlobal)\n-\t\t\t\t\t\t.iterator();\n+\tpublic BucketId createId() {\n+\t\treturn new BucketId(importId, bucket);\n \t}\n \n-\tpublic boolean containsLocalEntity(int localEntity) {\n-\t\treturn offsets[localEntity] != -1;\n+\t/**\n+\t * Iterate entities\n+\t */\n+\tpublic Collection<Integer> entities() {\n+\t\treturn start.keySet();\n \t}\n \n-\tpublic abstract void initFields(int numberOfEntities);\n-\n-\tpublic int toLocal(int entity) {\n-\t\treturn entity - getBucketSize() * bucket;\n+\tpublic boolean containsEntity(int localEntity) {\n+\t\treturn start.containsKey(localEntity);\n \t}\n \n-\tpublic int toGlobal(int entity) {\n-\t\treturn entity + getBucketSize() * bucket;\n+\tpublic Iterable<BucketEntry> entries() {\n+\t\treturn () -> start.keySet()\n+\t\t\t\t\t\t  .stream()\n+\t\t\t\t\t\t  .flatMap(entity -> IntStream.range(getEntityStart(entity), getEntityEnd(entity))\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  .mapToObj(e -> new BucketEntry(entity, e))\n+\t\t\t\t\t\t  )\n+\t\t\t\t\t\t  .iterator();\n \t}\n \n-\n-\tpublic int getFirstEventOfLocal(int localEntity) {\n-\t\treturn offsets[localEntity];\n+\tpublic int getEntityStart(int entityId) {\n+\t\treturn start.get(entityId);\n \t}\n \n-\tpublic int getLastEventOfLocal(int localEntity) {\n-\t\tfor (localEntity++; localEntity < offsets.length; localEntity++) {\n-\t\t\tif (offsets[localEntity] != -1) {\n-\t\t\t\treturn offsets[localEntity];\n-\t\t\t}\n-\t\t}\n-\t\treturn numberOfEvents;\n+\tpublic int getEntityEnd(int entityId) {\n+\t\treturn start.get(entityId) + length.get(entityId);\n \t}\n \n-\t@Override\n-\tpublic void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-\t\tjava.io.OutputStream outputStream = baos;\n-\t\ttry (Output output = new Output(outputStream)) {\n-\t\t\twriteContent(output);\n-\t\t}\n-\t\tbyte[] content = baos.toByteArray();\n-\t\tgen.writeStartObject();\n-\t\tgen.writeNumberField(Fields.bucket, bucket);\n-\t\tgen.writeStringField(Fields.imp, imp.getId().toString());\n-\t\tgen.writeNumberField(Fields.numberOfEvents, numberOfEvents);\n-\t\tgen.writeFieldName(Fields.offsets);\n-\t\tgen.writeArray(offsets, 0, offsets.length);\n-\t\tgen.writeBinaryField(\"content\", content);\n-\t\tgen.writeEndObject();\n+\tpublic final boolean has(int event, Column column) {\n+\t\treturn stores[column.getPosition()].has(event);\n \t}\n \n-\tpublic Iterable<BucketEntry> entries() {\n-\t\treturn () -> IntStream\n-\t\t\t\t\t\t\t .range(0, getBucketSize())\n-\t\t\t\t\t\t\t .filter(this::containsLocalEntity)\n-\t\t\t\t\t\t\t .boxed()\n-\t\t\t\t\t\t\t .flatMap(le -> IntStream\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.range(getFirstEventOfLocal(le), getLastEventOfLocal(le))\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.mapToObj(e -> new BucketEntry(le, e))\n-\t\t\t\t\t\t\t )\n-\t\t\t\t\t\t\t .iterator();\n+\tpublic int getString(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getString(event);\n \t}\n \n-\n-\tpublic boolean has(int event, Column column) {\n-\t\treturn has(event, column.getPosition());\n+\tpublic long getInteger(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getInteger(event);\n \t}\n \n-\tpublic abstract boolean has(int event, int columnPosition);\n-\n-\tpublic abstract int getString(int event, Column column);\n-\n-\tpublic abstract long getInteger(int event, Column column);\n-\n-\tpublic abstract boolean getBoolean(int event, Column column);\n-\n-\tpublic abstract double getReal(int event, Column column);\n+\tpublic boolean getBoolean(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getBoolean(event);\n+\t}\n \n-\tpublic abstract BigDecimal getDecimal(int event, Column column);\n+\tpublic double getReal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getReal(event);\n+\t}\n \n-\tpublic abstract long getMoney(int event, Column column);\n+\tpublic BigDecimal getDecimal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDecimal(event);\n+\t}\n \n-\tpublic abstract int getDate(int event, Column column);\n+\tpublic long getMoney(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getMoney(event);\n+\t}\n \n-\tpublic abstract CDateRange getDateRange(int event, Column column);\n+\tpublic int getDate(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDate(event);\n+\t}\n \n-\tpublic Object getRaw(int event, Column column) {\n-\t\treturn getRaw(event, column.getPosition());\n+\tpublic CDateRange getAsDateRange(int event, Column currentColumn) {\n+\t\treturn getDateRange(event, currentColumn);\n \t}\n \n-\tpublic abstract Object getRaw(int event, int columnPosition);\n+\tpublic CDateRange getDateRange(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDateRange(event);\n+\t}\n \n \tpublic Object getAsObject(int event, Column column) {\n-\t\treturn getAsObject(event, column.getPosition());\n+\t\treturn stores[column.getPosition()].getAsObject(event);\n \t}\n \n-\tpublic abstract Object getAsObject(int event, int columnPosition);\n-\n-\tpublic abstract boolean eventIsContainedIn(int event, Column column, CDateRange dateRange);\n-\n \tpublic boolean eventIsContainedIn(int event, Column column, BitMapCDateSet dateRanges) {\n-\t\treturn dateRanges.intersects(getAsDateRange(event, column));\n+\t\treturn dateRanges.intersects(stores[column.getPosition()].getDateRange(event));\n \t}\n \n-\tpublic abstract CDateRange getAsDateRange(int event, Column currentColumn);\n \n-\t@Override\n-\tpublic void serializeWithType(JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {\n-\t\tthis.serialize(gen, serializers);\n-\t}\n+\tpublic Map<String, Object> calculateMap(int event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc5NjM5OA==", "bodyText": "geht leider nicht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r527796398", "createdAt": "2020-11-20T16:10:58Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;\n+\n+\t/**\n+\t * Number of events per Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> length;\n+\n+\tprivate final int bucketSize;\n \n-\tpublic abstract int getBucketSize();\n \n \t@Override\n-\tpublic PrimitiveIterator.OfInt iterator() {\n-\t\treturn IntStream.range(0, getBucketSize())\n-\t\t\t\t\t\t.filter(this::containsLocalEntity)\n-\t\t\t\t\t\t.map(this::toGlobal)\n-\t\t\t\t\t\t.iterator();\n+\tpublic BucketId createId() {\n+\t\treturn new BucketId(importId, bucket);\n \t}\n \n-\tpublic boolean containsLocalEntity(int localEntity) {\n-\t\treturn offsets[localEntity] != -1;\n+\t/**\n+\t * Iterate entities\n+\t */\n+\tpublic Collection<Integer> entities() {\n+\t\treturn start.keySet();\n \t}\n \n-\tpublic abstract void initFields(int numberOfEntities);\n-\n-\tpublic int toLocal(int entity) {\n-\t\treturn entity - getBucketSize() * bucket;\n+\tpublic boolean containsEntity(int localEntity) {\n+\t\treturn start.containsKey(localEntity);\n \t}\n \n-\tpublic int toGlobal(int entity) {\n-\t\treturn entity + getBucketSize() * bucket;\n+\tpublic Iterable<BucketEntry> entries() {\n+\t\treturn () -> start.keySet()\n+\t\t\t\t\t\t  .stream()\n+\t\t\t\t\t\t  .flatMap(entity -> IntStream.range(getEntityStart(entity), getEntityEnd(entity))\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  .mapToObj(e -> new BucketEntry(entity, e))\n+\t\t\t\t\t\t  )\n+\t\t\t\t\t\t  .iterator();\n \t}\n \n-\n-\tpublic int getFirstEventOfLocal(int localEntity) {\n-\t\treturn offsets[localEntity];\n+\tpublic int getEntityStart(int entityId) {\n+\t\treturn start.get(entityId);\n \t}\n \n-\tpublic int getLastEventOfLocal(int localEntity) {\n-\t\tfor (localEntity++; localEntity < offsets.length; localEntity++) {\n-\t\t\tif (offsets[localEntity] != -1) {\n-\t\t\t\treturn offsets[localEntity];\n-\t\t\t}\n-\t\t}\n-\t\treturn numberOfEvents;\n+\tpublic int getEntityEnd(int entityId) {\n+\t\treturn start.get(entityId) + length.get(entityId);\n \t}\n \n-\t@Override\n-\tpublic void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-\t\tjava.io.OutputStream outputStream = baos;\n-\t\ttry (Output output = new Output(outputStream)) {\n-\t\t\twriteContent(output);\n-\t\t}\n-\t\tbyte[] content = baos.toByteArray();\n-\t\tgen.writeStartObject();\n-\t\tgen.writeNumberField(Fields.bucket, bucket);\n-\t\tgen.writeStringField(Fields.imp, imp.getId().toString());\n-\t\tgen.writeNumberField(Fields.numberOfEvents, numberOfEvents);\n-\t\tgen.writeFieldName(Fields.offsets);\n-\t\tgen.writeArray(offsets, 0, offsets.length);\n-\t\tgen.writeBinaryField(\"content\", content);\n-\t\tgen.writeEndObject();\n+\tpublic final boolean has(int event, Column column) {\n+\t\treturn stores[column.getPosition()].has(event);\n \t}\n \n-\tpublic Iterable<BucketEntry> entries() {\n-\t\treturn () -> IntStream\n-\t\t\t\t\t\t\t .range(0, getBucketSize())\n-\t\t\t\t\t\t\t .filter(this::containsLocalEntity)\n-\t\t\t\t\t\t\t .boxed()\n-\t\t\t\t\t\t\t .flatMap(le -> IntStream\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.range(getFirstEventOfLocal(le), getLastEventOfLocal(le))\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.mapToObj(e -> new BucketEntry(le, e))\n-\t\t\t\t\t\t\t )\n-\t\t\t\t\t\t\t .iterator();\n+\tpublic int getString(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getString(event);\n \t}\n \n-\n-\tpublic boolean has(int event, Column column) {\n-\t\treturn has(event, column.getPosition());\n+\tpublic long getInteger(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getInteger(event);\n \t}\n \n-\tpublic abstract boolean has(int event, int columnPosition);\n-\n-\tpublic abstract int getString(int event, Column column);\n-\n-\tpublic abstract long getInteger(int event, Column column);\n-\n-\tpublic abstract boolean getBoolean(int event, Column column);\n-\n-\tpublic abstract double getReal(int event, Column column);\n+\tpublic boolean getBoolean(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getBoolean(event);\n+\t}\n \n-\tpublic abstract BigDecimal getDecimal(int event, Column column);\n+\tpublic double getReal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getReal(event);\n+\t}\n \n-\tpublic abstract long getMoney(int event, Column column);\n+\tpublic BigDecimal getDecimal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDecimal(event);\n+\t}\n \n-\tpublic abstract int getDate(int event, Column column);\n+\tpublic long getMoney(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getMoney(event);\n+\t}\n \n-\tpublic abstract CDateRange getDateRange(int event, Column column);\n+\tpublic int getDate(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDate(event);\n+\t}\n \n-\tpublic Object getRaw(int event, Column column) {\n-\t\treturn getRaw(event, column.getPosition());\n+\tpublic CDateRange getAsDateRange(int event, Column currentColumn) {\n+\t\treturn getDateRange(event, currentColumn);\n \t}\n \n-\tpublic abstract Object getRaw(int event, int columnPosition);\n+\tpublic CDateRange getDateRange(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDateRange(event);\n+\t}\n \n \tpublic Object getAsObject(int event, Column column) {\n-\t\treturn getAsObject(event, column.getPosition());\n+\t\treturn stores[column.getPosition()].getAsObject(event);\n \t}\n \n-\tpublic abstract Object getAsObject(int event, int columnPosition);\n-\n-\tpublic abstract boolean eventIsContainedIn(int event, Column column, CDateRange dateRange);\n-\n \tpublic boolean eventIsContainedIn(int event, Column column, BitMapCDateSet dateRanges) {\n-\t\treturn dateRanges.intersects(getAsDateRange(event, column));\n+\t\treturn dateRanges.intersects(stores[column.getPosition()].getDateRange(event));\n \t}\n \n-\tpublic abstract CDateRange getAsDateRange(int event, Column currentColumn);\n \n-\t@Override\n-\tpublic void serializeWithType(JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {\n-\t\tthis.serialize(gen, serializers);\n-\t}\n+\tpublic Map<String, Object> calculateMap(int event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTU5MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE0NjMzNw==", "bodyText": "schade", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558146337", "createdAt": "2021-01-15T09:45:44Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;\n+\n+\t/**\n+\t * Number of events per Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> length;\n+\n+\tprivate final int bucketSize;\n \n-\tpublic abstract int getBucketSize();\n \n \t@Override\n-\tpublic PrimitiveIterator.OfInt iterator() {\n-\t\treturn IntStream.range(0, getBucketSize())\n-\t\t\t\t\t\t.filter(this::containsLocalEntity)\n-\t\t\t\t\t\t.map(this::toGlobal)\n-\t\t\t\t\t\t.iterator();\n+\tpublic BucketId createId() {\n+\t\treturn new BucketId(importId, bucket);\n \t}\n \n-\tpublic boolean containsLocalEntity(int localEntity) {\n-\t\treturn offsets[localEntity] != -1;\n+\t/**\n+\t * Iterate entities\n+\t */\n+\tpublic Collection<Integer> entities() {\n+\t\treturn start.keySet();\n \t}\n \n-\tpublic abstract void initFields(int numberOfEntities);\n-\n-\tpublic int toLocal(int entity) {\n-\t\treturn entity - getBucketSize() * bucket;\n+\tpublic boolean containsEntity(int localEntity) {\n+\t\treturn start.containsKey(localEntity);\n \t}\n \n-\tpublic int toGlobal(int entity) {\n-\t\treturn entity + getBucketSize() * bucket;\n+\tpublic Iterable<BucketEntry> entries() {\n+\t\treturn () -> start.keySet()\n+\t\t\t\t\t\t  .stream()\n+\t\t\t\t\t\t  .flatMap(entity -> IntStream.range(getEntityStart(entity), getEntityEnd(entity))\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  .mapToObj(e -> new BucketEntry(entity, e))\n+\t\t\t\t\t\t  )\n+\t\t\t\t\t\t  .iterator();\n \t}\n \n-\n-\tpublic int getFirstEventOfLocal(int localEntity) {\n-\t\treturn offsets[localEntity];\n+\tpublic int getEntityStart(int entityId) {\n+\t\treturn start.get(entityId);\n \t}\n \n-\tpublic int getLastEventOfLocal(int localEntity) {\n-\t\tfor (localEntity++; localEntity < offsets.length; localEntity++) {\n-\t\t\tif (offsets[localEntity] != -1) {\n-\t\t\t\treturn offsets[localEntity];\n-\t\t\t}\n-\t\t}\n-\t\treturn numberOfEvents;\n+\tpublic int getEntityEnd(int entityId) {\n+\t\treturn start.get(entityId) + length.get(entityId);\n \t}\n \n-\t@Override\n-\tpublic void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-\t\tjava.io.OutputStream outputStream = baos;\n-\t\ttry (Output output = new Output(outputStream)) {\n-\t\t\twriteContent(output);\n-\t\t}\n-\t\tbyte[] content = baos.toByteArray();\n-\t\tgen.writeStartObject();\n-\t\tgen.writeNumberField(Fields.bucket, bucket);\n-\t\tgen.writeStringField(Fields.imp, imp.getId().toString());\n-\t\tgen.writeNumberField(Fields.numberOfEvents, numberOfEvents);\n-\t\tgen.writeFieldName(Fields.offsets);\n-\t\tgen.writeArray(offsets, 0, offsets.length);\n-\t\tgen.writeBinaryField(\"content\", content);\n-\t\tgen.writeEndObject();\n+\tpublic final boolean has(int event, Column column) {\n+\t\treturn stores[column.getPosition()].has(event);\n \t}\n \n-\tpublic Iterable<BucketEntry> entries() {\n-\t\treturn () -> IntStream\n-\t\t\t\t\t\t\t .range(0, getBucketSize())\n-\t\t\t\t\t\t\t .filter(this::containsLocalEntity)\n-\t\t\t\t\t\t\t .boxed()\n-\t\t\t\t\t\t\t .flatMap(le -> IntStream\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.range(getFirstEventOfLocal(le), getLastEventOfLocal(le))\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.mapToObj(e -> new BucketEntry(le, e))\n-\t\t\t\t\t\t\t )\n-\t\t\t\t\t\t\t .iterator();\n+\tpublic int getString(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getString(event);\n \t}\n \n-\n-\tpublic boolean has(int event, Column column) {\n-\t\treturn has(event, column.getPosition());\n+\tpublic long getInteger(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getInteger(event);\n \t}\n \n-\tpublic abstract boolean has(int event, int columnPosition);\n-\n-\tpublic abstract int getString(int event, Column column);\n-\n-\tpublic abstract long getInteger(int event, Column column);\n-\n-\tpublic abstract boolean getBoolean(int event, Column column);\n-\n-\tpublic abstract double getReal(int event, Column column);\n+\tpublic boolean getBoolean(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getBoolean(event);\n+\t}\n \n-\tpublic abstract BigDecimal getDecimal(int event, Column column);\n+\tpublic double getReal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getReal(event);\n+\t}\n \n-\tpublic abstract long getMoney(int event, Column column);\n+\tpublic BigDecimal getDecimal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDecimal(event);\n+\t}\n \n-\tpublic abstract int getDate(int event, Column column);\n+\tpublic long getMoney(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getMoney(event);\n+\t}\n \n-\tpublic abstract CDateRange getDateRange(int event, Column column);\n+\tpublic int getDate(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDate(event);\n+\t}\n \n-\tpublic Object getRaw(int event, Column column) {\n-\t\treturn getRaw(event, column.getPosition());\n+\tpublic CDateRange getAsDateRange(int event, Column currentColumn) {\n+\t\treturn getDateRange(event, currentColumn);\n \t}\n \n-\tpublic abstract Object getRaw(int event, int columnPosition);\n+\tpublic CDateRange getDateRange(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDateRange(event);\n+\t}\n \n \tpublic Object getAsObject(int event, Column column) {\n-\t\treturn getAsObject(event, column.getPosition());\n+\t\treturn stores[column.getPosition()].getAsObject(event);\n \t}\n \n-\tpublic abstract Object getAsObject(int event, int columnPosition);\n-\n-\tpublic abstract boolean eventIsContainedIn(int event, Column column, CDateRange dateRange);\n-\n \tpublic boolean eventIsContainedIn(int event, Column column, BitMapCDateSet dateRanges) {\n-\t\treturn dateRanges.intersects(getAsDateRange(event, column));\n+\t\treturn dateRanges.intersects(stores[column.getPosition()].getDateRange(event));\n \t}\n \n-\tpublic abstract CDateRange getAsDateRange(int event, Column currentColumn);\n \n-\t@Override\n-\tpublic void serializeWithType(JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {\n-\t\tthis.serialize(gen, serializers);\n-\t}\n+\tpublic Map<String, Object> calculateMap(int event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTU5MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE1ODMzNg==", "bodyText": "Kannst du nicht imp.getColumns()[i].createId() aufrufen, oder besser noch von der ImportColumn auf die TableColumnId schlie\u00dfen?\nIch sehe jetzt leider nicht direkt wo das Problem ist", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558158336", "createdAt": "2021-01-15T09:53:01Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;\n+\n+\t/**\n+\t * Number of events per Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> length;\n+\n+\tprivate final int bucketSize;\n \n-\tpublic abstract int getBucketSize();\n \n \t@Override\n-\tpublic PrimitiveIterator.OfInt iterator() {\n-\t\treturn IntStream.range(0, getBucketSize())\n-\t\t\t\t\t\t.filter(this::containsLocalEntity)\n-\t\t\t\t\t\t.map(this::toGlobal)\n-\t\t\t\t\t\t.iterator();\n+\tpublic BucketId createId() {\n+\t\treturn new BucketId(importId, bucket);\n \t}\n \n-\tpublic boolean containsLocalEntity(int localEntity) {\n-\t\treturn offsets[localEntity] != -1;\n+\t/**\n+\t * Iterate entities\n+\t */\n+\tpublic Collection<Integer> entities() {\n+\t\treturn start.keySet();\n \t}\n \n-\tpublic abstract void initFields(int numberOfEntities);\n-\n-\tpublic int toLocal(int entity) {\n-\t\treturn entity - getBucketSize() * bucket;\n+\tpublic boolean containsEntity(int localEntity) {\n+\t\treturn start.containsKey(localEntity);\n \t}\n \n-\tpublic int toGlobal(int entity) {\n-\t\treturn entity + getBucketSize() * bucket;\n+\tpublic Iterable<BucketEntry> entries() {\n+\t\treturn () -> start.keySet()\n+\t\t\t\t\t\t  .stream()\n+\t\t\t\t\t\t  .flatMap(entity -> IntStream.range(getEntityStart(entity), getEntityEnd(entity))\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  .mapToObj(e -> new BucketEntry(entity, e))\n+\t\t\t\t\t\t  )\n+\t\t\t\t\t\t  .iterator();\n \t}\n \n-\n-\tpublic int getFirstEventOfLocal(int localEntity) {\n-\t\treturn offsets[localEntity];\n+\tpublic int getEntityStart(int entityId) {\n+\t\treturn start.get(entityId);\n \t}\n \n-\tpublic int getLastEventOfLocal(int localEntity) {\n-\t\tfor (localEntity++; localEntity < offsets.length; localEntity++) {\n-\t\t\tif (offsets[localEntity] != -1) {\n-\t\t\t\treturn offsets[localEntity];\n-\t\t\t}\n-\t\t}\n-\t\treturn numberOfEvents;\n+\tpublic int getEntityEnd(int entityId) {\n+\t\treturn start.get(entityId) + length.get(entityId);\n \t}\n \n-\t@Override\n-\tpublic void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-\t\tjava.io.OutputStream outputStream = baos;\n-\t\ttry (Output output = new Output(outputStream)) {\n-\t\t\twriteContent(output);\n-\t\t}\n-\t\tbyte[] content = baos.toByteArray();\n-\t\tgen.writeStartObject();\n-\t\tgen.writeNumberField(Fields.bucket, bucket);\n-\t\tgen.writeStringField(Fields.imp, imp.getId().toString());\n-\t\tgen.writeNumberField(Fields.numberOfEvents, numberOfEvents);\n-\t\tgen.writeFieldName(Fields.offsets);\n-\t\tgen.writeArray(offsets, 0, offsets.length);\n-\t\tgen.writeBinaryField(\"content\", content);\n-\t\tgen.writeEndObject();\n+\tpublic final boolean has(int event, Column column) {\n+\t\treturn stores[column.getPosition()].has(event);\n \t}\n \n-\tpublic Iterable<BucketEntry> entries() {\n-\t\treturn () -> IntStream\n-\t\t\t\t\t\t\t .range(0, getBucketSize())\n-\t\t\t\t\t\t\t .filter(this::containsLocalEntity)\n-\t\t\t\t\t\t\t .boxed()\n-\t\t\t\t\t\t\t .flatMap(le -> IntStream\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.range(getFirstEventOfLocal(le), getLastEventOfLocal(le))\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.mapToObj(e -> new BucketEntry(le, e))\n-\t\t\t\t\t\t\t )\n-\t\t\t\t\t\t\t .iterator();\n+\tpublic int getString(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getString(event);\n \t}\n \n-\n-\tpublic boolean has(int event, Column column) {\n-\t\treturn has(event, column.getPosition());\n+\tpublic long getInteger(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getInteger(event);\n \t}\n \n-\tpublic abstract boolean has(int event, int columnPosition);\n-\n-\tpublic abstract int getString(int event, Column column);\n-\n-\tpublic abstract long getInteger(int event, Column column);\n-\n-\tpublic abstract boolean getBoolean(int event, Column column);\n-\n-\tpublic abstract double getReal(int event, Column column);\n+\tpublic boolean getBoolean(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getBoolean(event);\n+\t}\n \n-\tpublic abstract BigDecimal getDecimal(int event, Column column);\n+\tpublic double getReal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getReal(event);\n+\t}\n \n-\tpublic abstract long getMoney(int event, Column column);\n+\tpublic BigDecimal getDecimal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDecimal(event);\n+\t}\n \n-\tpublic abstract int getDate(int event, Column column);\n+\tpublic long getMoney(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getMoney(event);\n+\t}\n \n-\tpublic abstract CDateRange getDateRange(int event, Column column);\n+\tpublic int getDate(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDate(event);\n+\t}\n \n-\tpublic Object getRaw(int event, Column column) {\n-\t\treturn getRaw(event, column.getPosition());\n+\tpublic CDateRange getAsDateRange(int event, Column currentColumn) {\n+\t\treturn getDateRange(event, currentColumn);\n \t}\n \n-\tpublic abstract Object getRaw(int event, int columnPosition);\n+\tpublic CDateRange getDateRange(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDateRange(event);\n+\t}\n \n \tpublic Object getAsObject(int event, Column column) {\n-\t\treturn getAsObject(event, column.getPosition());\n+\t\treturn stores[column.getPosition()].getAsObject(event);\n \t}\n \n-\tpublic abstract Object getAsObject(int event, int columnPosition);\n-\n-\tpublic abstract boolean eventIsContainedIn(int event, Column column, CDateRange dateRange);\n-\n \tpublic boolean eventIsContainedIn(int event, Column column, BitMapCDateSet dateRanges) {\n-\t\treturn dateRanges.intersects(getAsDateRange(event, column));\n+\t\treturn dateRanges.intersects(stores[column.getPosition()].getDateRange(event));\n \t}\n \n-\tpublic abstract CDateRange getAsDateRange(int event, Column currentColumn);\n \n-\t@Override\n-\tpublic void serializeWithType(JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {\n-\t\tthis.serialize(gen, serializers);\n-\t}\n+\tpublic Map<String, Object> calculateMap(int event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTU5MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzc5MDUzOA==", "bodyText": "Das Problem sind eher die B\u00e4ume/Conditions als hier. Das m\u00fcsste man da erstmal l\u00f6sen. Habe auch ein Ticket f\u00fcr erstellt.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567790538", "createdAt": "2021-02-01T12:34:18Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/Bucket.java", "diffHunk": "@@ -40,155 +33,131 @@\n @Getter\n @Setter\n @ToString\n-@JsonDeserialize(using = BucketDeserializer.class)\n-public abstract class Bucket extends IdentifiableImpl<BucketId> implements Iterable<Integer>, JsonSerializable {\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n+public class Bucket extends IdentifiableImpl<BucketId> {\n \n \t@Min(0)\n-\tprivate int bucket;\n-\t@NotNull\n+\tprivate final int bucket;\n+\n+\tprivate final ImportId importId;\n+\n+\t// todo try to reduce reliance on import and use internal components instead\n \t@NsIdRef\n \tprivate Import imp;\n+\n \t@Min(0)\n-\tprivate int numberOfEvents;\n-\t@ToString.Exclude\n-\tprivate int[] offsets;\n-\t@NotNull\n-\t@Setter\n-\t@ToString.Exclude\n-\tprotected BitStore nullBits;\n+\tprivate final int numberOfEvents;\n \n-\tpublic Bucket(int bucket, Import imp, int[] offsets) {\n-\t\tthis.bucket = bucket;\n-\t\tthis.imp = imp;\n-\t\tthis.offsets = offsets;\n-\t}\n+\tprivate final CType<?,?>[] stores;\n \n-\t@Override\n-\tpublic BucketId createId() {\n-\t\treturn new BucketId(imp.getId(), bucket);\n-\t}\n \n+\t/**\n+\t * start of each Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> start;\n+\n+\t/**\n+\t * Number of events per Entity in {@code stores}.\n+\t */\n+\tprivate final Map<Integer, Integer> length;\n+\n+\tprivate final int bucketSize;\n \n-\tpublic abstract int getBucketSize();\n \n \t@Override\n-\tpublic PrimitiveIterator.OfInt iterator() {\n-\t\treturn IntStream.range(0, getBucketSize())\n-\t\t\t\t\t\t.filter(this::containsLocalEntity)\n-\t\t\t\t\t\t.map(this::toGlobal)\n-\t\t\t\t\t\t.iterator();\n+\tpublic BucketId createId() {\n+\t\treturn new BucketId(importId, bucket);\n \t}\n \n-\tpublic boolean containsLocalEntity(int localEntity) {\n-\t\treturn offsets[localEntity] != -1;\n+\t/**\n+\t * Iterate entities\n+\t */\n+\tpublic Collection<Integer> entities() {\n+\t\treturn start.keySet();\n \t}\n \n-\tpublic abstract void initFields(int numberOfEntities);\n-\n-\tpublic int toLocal(int entity) {\n-\t\treturn entity - getBucketSize() * bucket;\n+\tpublic boolean containsEntity(int localEntity) {\n+\t\treturn start.containsKey(localEntity);\n \t}\n \n-\tpublic int toGlobal(int entity) {\n-\t\treturn entity + getBucketSize() * bucket;\n+\tpublic Iterable<BucketEntry> entries() {\n+\t\treturn () -> start.keySet()\n+\t\t\t\t\t\t  .stream()\n+\t\t\t\t\t\t  .flatMap(entity -> IntStream.range(getEntityStart(entity), getEntityEnd(entity))\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  .mapToObj(e -> new BucketEntry(entity, e))\n+\t\t\t\t\t\t  )\n+\t\t\t\t\t\t  .iterator();\n \t}\n \n-\n-\tpublic int getFirstEventOfLocal(int localEntity) {\n-\t\treturn offsets[localEntity];\n+\tpublic int getEntityStart(int entityId) {\n+\t\treturn start.get(entityId);\n \t}\n \n-\tpublic int getLastEventOfLocal(int localEntity) {\n-\t\tfor (localEntity++; localEntity < offsets.length; localEntity++) {\n-\t\t\tif (offsets[localEntity] != -1) {\n-\t\t\t\treturn offsets[localEntity];\n-\t\t\t}\n-\t\t}\n-\t\treturn numberOfEvents;\n+\tpublic int getEntityEnd(int entityId) {\n+\t\treturn start.get(entityId) + length.get(entityId);\n \t}\n \n-\t@Override\n-\tpublic void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-\t\tjava.io.OutputStream outputStream = baos;\n-\t\ttry (Output output = new Output(outputStream)) {\n-\t\t\twriteContent(output);\n-\t\t}\n-\t\tbyte[] content = baos.toByteArray();\n-\t\tgen.writeStartObject();\n-\t\tgen.writeNumberField(Fields.bucket, bucket);\n-\t\tgen.writeStringField(Fields.imp, imp.getId().toString());\n-\t\tgen.writeNumberField(Fields.numberOfEvents, numberOfEvents);\n-\t\tgen.writeFieldName(Fields.offsets);\n-\t\tgen.writeArray(offsets, 0, offsets.length);\n-\t\tgen.writeBinaryField(\"content\", content);\n-\t\tgen.writeEndObject();\n+\tpublic final boolean has(int event, Column column) {\n+\t\treturn stores[column.getPosition()].has(event);\n \t}\n \n-\tpublic Iterable<BucketEntry> entries() {\n-\t\treturn () -> IntStream\n-\t\t\t\t\t\t\t .range(0, getBucketSize())\n-\t\t\t\t\t\t\t .filter(this::containsLocalEntity)\n-\t\t\t\t\t\t\t .boxed()\n-\t\t\t\t\t\t\t .flatMap(le -> IntStream\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.range(getFirstEventOfLocal(le), getLastEventOfLocal(le))\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.mapToObj(e -> new BucketEntry(le, e))\n-\t\t\t\t\t\t\t )\n-\t\t\t\t\t\t\t .iterator();\n+\tpublic int getString(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getString(event);\n \t}\n \n-\n-\tpublic boolean has(int event, Column column) {\n-\t\treturn has(event, column.getPosition());\n+\tpublic long getInteger(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getInteger(event);\n \t}\n \n-\tpublic abstract boolean has(int event, int columnPosition);\n-\n-\tpublic abstract int getString(int event, Column column);\n-\n-\tpublic abstract long getInteger(int event, Column column);\n-\n-\tpublic abstract boolean getBoolean(int event, Column column);\n-\n-\tpublic abstract double getReal(int event, Column column);\n+\tpublic boolean getBoolean(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getBoolean(event);\n+\t}\n \n-\tpublic abstract BigDecimal getDecimal(int event, Column column);\n+\tpublic double getReal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getReal(event);\n+\t}\n \n-\tpublic abstract long getMoney(int event, Column column);\n+\tpublic BigDecimal getDecimal(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDecimal(event);\n+\t}\n \n-\tpublic abstract int getDate(int event, Column column);\n+\tpublic long getMoney(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getMoney(event);\n+\t}\n \n-\tpublic abstract CDateRange getDateRange(int event, Column column);\n+\tpublic int getDate(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDate(event);\n+\t}\n \n-\tpublic Object getRaw(int event, Column column) {\n-\t\treturn getRaw(event, column.getPosition());\n+\tpublic CDateRange getAsDateRange(int event, Column currentColumn) {\n+\t\treturn getDateRange(event, currentColumn);\n \t}\n \n-\tpublic abstract Object getRaw(int event, int columnPosition);\n+\tpublic CDateRange getDateRange(int event, Column column) {\n+\t\treturn stores[column.getPosition()].getDateRange(event);\n+\t}\n \n \tpublic Object getAsObject(int event, Column column) {\n-\t\treturn getAsObject(event, column.getPosition());\n+\t\treturn stores[column.getPosition()].getAsObject(event);\n \t}\n \n-\tpublic abstract Object getAsObject(int event, int columnPosition);\n-\n-\tpublic abstract boolean eventIsContainedIn(int event, Column column, CDateRange dateRange);\n-\n \tpublic boolean eventIsContainedIn(int event, Column column, BitMapCDateSet dateRanges) {\n-\t\treturn dateRanges.intersects(getAsDateRange(event, column));\n+\t\treturn dateRanges.intersects(stores[column.getPosition()].getDateRange(event));\n \t}\n \n-\tpublic abstract CDateRange getAsDateRange(int event, Column currentColumn);\n \n-\t@Override\n-\tpublic void serializeWithType(JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException {\n-\t\tthis.serialize(gen, serializers);\n-\t}\n+\tpublic Map<String, Object> calculateMap(int event) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTU5MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODAzMjg2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTozNDo1MlrOH1pllA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTo1NjozN1rOIUToOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzk0MA==", "bodyText": "Kann der CBlock nicht Teil eines Buckets sein?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526017940", "createdAt": "2020-11-18T11:34:52Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMDY4OA==", "bodyText": "Sodass man local ids beibehalten kann, aber diese in der Implementierung verkapselt sind und nicht nachdrau\u00dfen dringen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526200688", "createdAt": "2020-11-18T15:56:10Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzk0MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0ODgxNw==", "bodyText": "Finde ich eine lustige Idee, aber bitte in einem separaten PR", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r530448817", "createdAt": "2020-11-25T15:16:00Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzk0MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2NDAyNA==", "bodyText": "Okay, ich habe ein Ticket erstellt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558164024", "createdAt": "2021-01-15T09:56:37Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzk0MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODA1NDkwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/ByteStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTo0MDo1MVrOH1pyjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTo0MDo1MVrOH1pyjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAyMTI2Mw==", "bodyText": "Eine bessere ToString Methode bitte", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526021263", "createdAt": "2020-11-18T11:40:51Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/ByteStore.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+@CPSType(id = \"BYTES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODA4OTE0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/ByteStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMTo0OTo1MVrOH1qHKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyMzoxNFrOH8AD6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAyNjUzNw==", "bodyText": "Das ist leider eine nifty Fehlerquelle. Du solltest null events separat flaggen. So schr\u00e4nkst du den Wertebereicht ein und dein get und set reagieren nicht darauf.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526026537", "createdAt": "2020-11-18T11:49:51Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/ByteStore.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+@CPSType(id = \"BYTES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class ByteStore extends ColumnStoreAdapter<Long> {\n+\n+\tprivate final byte nullValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3NzYwOA==", "bodyText": "Habe doku daf\u00fcr angelegt, der soll n\u00e4mlich nicht eigenst\u00e4ndig erstellt werden", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r532677608", "createdAt": "2020-11-30T15:23:14Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/ByteStore.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+@CPSType(id = \"BYTES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class ByteStore extends ColumnStoreAdapter<Long> {\n+\n+\tprivate final byte nullValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAyNjUzNw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTE3Mzg2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Import.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1Mzo1NFrOH10mRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyMzozMlrOH8AExA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5ODM0Mw==", "bodyText": "Es war ja vorher schon fragw\u00fcrdig ob die Funktion einen realistischen wert zur\u00fcckgibt, aber ist es jetzt \u00fcberhaupt noch ein ding?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526198343", "createdAt": "2020-11-18T15:53:54Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Import.java", "diffHunk": "@@ -174,6 +61,17 @@ public static Import createForPreprocessing(String table, String tag, PPColumn[]\n \t\treturn imp;\n \t}\n \n+\t@Override\n+\tpublic ImportId createId() {\n+\t\treturn new ImportId(table, getName());\n+\t}\n+\n+\tpublic void loadExternalInfos(NamespacedStorage storage) {\n+\t\tfor (ImportColumn col : columns) {\n+\t\t\tcol.getType().loadDictionaries(storage);\n+\t\t}\n+\t}\n+\n \tpublic long estimateMemoryConsumption() {\n \t\tlong mem = 0;\n \t\tfor (ImportColumn col : columns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3NzgyOA==", "bodyText": "Sollte es schon, das w\u00e4re sonst schade.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r532677828", "createdAt": "2020-11-30T15:23:32Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Import.java", "diffHunk": "@@ -174,6 +61,17 @@ public static Import createForPreprocessing(String table, String tag, PPColumn[]\n \t\treturn imp;\n \t}\n \n+\t@Override\n+\tpublic ImportId createId() {\n+\t\treturn new ImportId(table, getName());\n+\t}\n+\n+\tpublic void loadExternalInfos(NamespacedStorage storage) {\n+\t\tfor (ImportColumn col : columns) {\n+\t\t\tcol.getType().loadDictionaries(storage);\n+\t\t}\n+\t}\n+\n \tpublic long estimateMemoryConsumption() {\n \t\tlong mem = 0;\n \t\tfor (ImportColumn col : columns) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5ODM0Mw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTE5NTIwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTo1NzozMlrOH10z_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNDoyOFrOH8AHzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg1NQ==", "bodyText": "Ich habe das gef\u00fchl @Valid macht nichts, oder gibt es einen Validator f\u00fcr primitive Arrays?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526201855", "createdAt": "2020-11-18T15:57:32Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();\n+\t\n \t/**\n \t * Statistic for fast lookup if entity is of interest.\n \t * Int array for memory performance.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate int[] minDate, maxDate;\n+\tprivate Int2IntMap minDate = new Int2IntArrayMap();\n+\tprivate Int2IntMap maxDate = new Int2IntArrayMap();\n \t\n \t/**\n \t * Represents the path in a {@link TreeConcept} to optimize lookup.\n \t * Nodes in the tree are simply enumerated.\n-\t *\n-\t * Per Event.\n \t */\n-\t@Nullable\n-\tprivate int[][] mostSpecificChildren = null;\n+\t@Valid\n+\tprivate int[][] mostSpecificChildren;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3ODYwNQ==", "bodyText": "ja gerade hier.. :D", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r532678605", "createdAt": "2020-11-30T15:24:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/CBlock.java", "diffHunk": "@@ -37,28 +36,22 @@\n \t\n \t/**\n \t * Bloom filter per entity for the first 64 {@link ConceptTreeChild}.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate long[] includedConcepts;\n-\n-\t// TODO: 02.09.2020 FK: Make chop this onto a per-column basis\n+\tprivate Int2LongArrayMap includedConcepts = new Int2LongArrayMap();\n+\t\n \t/**\n \t * Statistic for fast lookup if entity is of interest.\n \t * Int array for memory performance.\n-\t *\n-\t * Per Entity.\n \t */\n-\tprivate int[] minDate, maxDate;\n+\tprivate Int2IntMap minDate = new Int2IntArrayMap();\n+\tprivate Int2IntMap maxDate = new Int2IntArrayMap();\n \t\n \t/**\n \t * Represents the path in a {@link TreeConcept} to optimize lookup.\n \t * Nodes in the tree are simply enumerated.\n-\t *\n-\t * Per Event.\n \t */\n-\t@Nullable\n-\tprivate int[][] mostSpecificChildren = null;\n+\t@Valid\n+\tprivate int[][] mostSpecificChildren;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg1NQ=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTIxMTczOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DateStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowMDo1NlrOH10-og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNDo1N1rOH8AJKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwNDU3OA==", "bodyText": "Der Cast/Box/Unbox sieht komisch aus", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526204578", "createdAt": "2020-11-18T16:00:56Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DateStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DATES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DateStore extends ColumnStoreAdapter<Integer> {\n+\n+\tprivate final ColumnStore<Long> store;\n+\n+\t@JsonCreator\n+\tpublic DateStore(ColumnStore<Long> store) {\n+\t\tthis.store = store;\n+\t}\n+\n+\tpublic static DateStore create(int size) {\n+\t\treturn new DateStore(IntegerStore.create(size));\n+\t}\n+\n+\tpublic DateStore select(int[] starts, int[] ends) {\n+\t\treturn new DateStore(store.select(starts,ends));\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tif (value == null) {\n+\t\t\tstore.set(event, null);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tstore.set(event, (long) value);\n+\t}\n+\n+\t@Override\n+\tpublic boolean has(int event) {\n+\t\treturn store.has(event);\n+\t}\n+\n+\t@Override\n+\tpublic CDateRange getDateRange(int event) {\n+\t\treturn CDateRange.exactly(get(event));\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn (int) store.getInteger(event);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwNzY4Ng==", "bodyText": "must du hier nicht .intValue() aufrufen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526207686", "createdAt": "2020-11-18T16:04:14Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DateStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DATES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DateStore extends ColumnStoreAdapter<Integer> {\n+\n+\tprivate final ColumnStore<Long> store;\n+\n+\t@JsonCreator\n+\tpublic DateStore(ColumnStore<Long> store) {\n+\t\tthis.store = store;\n+\t}\n+\n+\tpublic static DateStore create(int size) {\n+\t\treturn new DateStore(IntegerStore.create(size));\n+\t}\n+\n+\tpublic DateStore select(int[] starts, int[] ends) {\n+\t\treturn new DateStore(store.select(starts,ends));\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tif (value == null) {\n+\t\t\tstore.set(event, null);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tstore.set(event, (long) value);\n+\t}\n+\n+\t@Override\n+\tpublic boolean has(int event) {\n+\t\treturn store.has(event);\n+\t}\n+\n+\t@Override\n+\tpublic CDateRange getDateRange(int event) {\n+\t\treturn CDateRange.exactly(get(event));\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn (int) store.getInteger(event);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwNDU3OA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3ODk1Mw==", "bodyText": "stimmt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r532678953", "createdAt": "2020-11-30T15:24:57Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DateStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DATES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DateStore extends ColumnStoreAdapter<Integer> {\n+\n+\tprivate final ColumnStore<Long> store;\n+\n+\t@JsonCreator\n+\tpublic DateStore(ColumnStore<Long> store) {\n+\t\tthis.store = store;\n+\t}\n+\n+\tpublic static DateStore create(int size) {\n+\t\treturn new DateStore(IntegerStore.create(size));\n+\t}\n+\n+\tpublic DateStore select(int[] starts, int[] ends) {\n+\t\treturn new DateStore(store.select(starts,ends));\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tif (value == null) {\n+\t\t\tstore.set(event, null);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tstore.set(event, (long) value);\n+\t}\n+\n+\t@Override\n+\tpublic boolean has(int event) {\n+\t\treturn store.has(event);\n+\t}\n+\n+\t@Override\n+\tpublic CDateRange getDateRange(int event) {\n+\t\treturn CDateRange.exactly(get(event));\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn (int) store.getInteger(event);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwNDU3OA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTI0NzEwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/date/PackedDateRangeStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowNzoyMVrOH11UyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNjo1NlrOH8APcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIxMDI0OQ==", "bodyText": "Ich verstehe noch nicht so ganz warum das manchmal dieser Store ist. Manchmal ColumnStore<> und manchmal ein Array", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526210249", "createdAt": "2020-11-18T16:07:21Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/date/PackedDateRangeStore.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.bakdata.conquery.models.events.stores.date;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.bakdata.conquery.models.events.stores.base.IntegerStore;\n+import com.bakdata.conquery.util.PackedUnsigned1616;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"PACKED_DATE_RANGES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class PackedDateRangeStore extends ColumnStoreAdapter<CDateRange> {\n+\n+\tprivate final IntegerStore store;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MDU2Mg==", "bodyText": "Inkonsistenz von meiner Seite: Es gibt ein paar Grundlegende Stores, auf die delegiert werden soll, aber f\u00fcr generizit\u00e4t soll immer der oberste Typ verwendet werden, also Byte/Int/Short -> Long etc. die haben dann auch das Array. Der castet die Werte hoch/runter", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r532680562", "createdAt": "2020-11-30T15:26:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/date/PackedDateRangeStore.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.bakdata.conquery.models.events.stores.date;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.ColumnStoreAdapter;\n+import com.bakdata.conquery.models.events.stores.base.IntegerStore;\n+import com.bakdata.conquery.util.PackedUnsigned1616;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"PACKED_DATE_RANGES\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class PackedDateRangeStore extends ColumnStoreAdapter<CDateRange> {\n+\n+\tprivate final IntegerStore store;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIxMDI0OQ=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTI1MjAzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowODoyNlrOH11X3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjowODoyNlrOH11X3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIxMTAzNg==", "bodyText": "Format", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526211036", "createdAt": "2020-11-18T16:08:26Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "diffHunk": "@@ -98,18 +102,22 @@ private void calculateEntityDateIndices(CBlock cBlock, Bucket bucket) {\n \n \t\t\t\tCDateRange range = bucket.getAsDateRange(entry.getEvent(), column);\n \n-\t\t\t\tcBlock.getMinDate()[entry.getLocalEntity()] = Math.min(cBlock.getMinDate()[entry.getLocalEntity()], range.getMinValue());\n-\n-\t\t\t\tcBlock.getMaxDate()[entry.getLocalEntity()] = Math.max(cBlock.getMaxDate()[entry.getLocalEntity()], range.getMaxValue());\n+\t\t\t\tcBlock.getMinDate()\n+\t\t\t\t\t  .put(\n+\t\t\t\t\t\t\t  entry.getEntity(),\n+\t\t\t\t\t\t\t  Math.min(cBlock.getMinDate().getOrDefault(entry.getEntity(), Integer.MAX_VALUE), range.getMinValue())\n+\t\t\t\t\t  );\n+\n+\t\t\t\tcBlock.getMaxDate()\n+\t\t\t\t\t  .put(\n+\t\t\t\t\t\t\t  entry.getEntity(),\n+\t\t\t\t\t\t\t  Math.max(cBlock.getMaxDate()\n+\t\t\t\t\t\t\t\t\t\t\t .getOrDefault(entry.getEntity(), Integer.MIN_VALUE), range.getMaxValue())\n+\t\t\t\t\t  );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTMzNjA3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/messages/namespaces/specific/ImportBucket.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjoyNjozMVrOH12NNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjoyNjozMVrOH12NNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIyNDY5Mg==", "bodyText": "Bei ADD_IMPORT und hier IMPORT_BIT m\u00fcssen die Dictionaries geladen werden. Ich verstehe nicht warum", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526224692", "createdAt": "2020-11-18T16:26:31Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/messages/namespaces/specific/ImportBucket.java", "diffHunk": "@@ -1,72 +1,39 @@\n package com.bakdata.conquery.models.messages.namespaces.specific;\n \n-import java.io.ByteArrayInputStream;\n-import java.util.Arrays;\n-\n-import javax.annotation.Nonnull;\n-import javax.validation.constraints.NotEmpty;\n-import javax.validation.constraints.NotNull;\n-\n import com.bakdata.conquery.io.cps.CPSType;\n-import com.bakdata.conquery.models.datasets.Import;\n import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.events.generation.BlockFactory;\n-import com.bakdata.conquery.models.identifiable.ids.specific.BucketId;\n import com.bakdata.conquery.models.messages.namespaces.NamespacedMessage;\n import com.bakdata.conquery.models.messages.namespaces.WorkerMessage;\n+import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.worker.Worker;\n import com.fasterxml.jackson.annotation.JsonCreator;\n-import com.jakewharton.byteunits.BinaryByteUnit;\n-import it.unimi.dsi.fastutil.ints.IntArrayList;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n import lombok.Setter;\n \n-@CPSType(id=\"IMPORT_BIT\", base=NamespacedMessage.class)\n-@RequiredArgsConstructor(onConstructor_ = @JsonCreator) @Getter @Setter\n+@CPSType(id = \"IMPORT_BIT\", base = NamespacedMessage.class)\n+@RequiredArgsConstructor(onConstructor_ = @JsonCreator)\n+@Getter\n+@Setter\n public class ImportBucket extends WorkerMessage.Slow {\n-\t\n-\t@Nonnull @NotNull\n-\tprivate final BucketId bucket;\n-\t@NotEmpty\n-\tprivate IntArrayList includedEntities = new IntArrayList();\n-\t@NotNull\n-\tprivate byte[][] bytes;\n-\t\n+\n+\tprivate final Bucket bucket;\n \n \t@Override\n \tpublic void react(Worker context) throws Exception {\n-\t\tgetProgressReporter().setMax(includedEntities.size());\n-\t\tImport imp = context.getStorage().getImport(bucket.getImp());\n-\t\t\n-\t\tBlockFactory factory = imp.getBlockFactory();\n-\t\tBucket[] buckets = new Bucket[includedEntities.size()];\n-\t\t\n-\t\tfor(int index=0;index<includedEntities.size();index++) {\n-\t\t\tint entity = includedEntities.getInt(index);\n-\t\t\t\n-\t\t\ttry(ByteArrayInputStream input = new ByteArrayInputStream(bytes[index])) {\n-\t\t\t\tbuckets[index] = factory.readSingleValue(bucket.getBucket(), imp, input);\n-\t\t\t\tif(input.available() > 0) {\n-\t\t\t\t\tthrow new IllegalStateException(\"After reading the block of \"+entity+\" there are still \"+input.available()+\" bytes remaining in its content\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tgetProgressReporter().report(1);\n+\t\t// todo get import via idRef instead.\n+\n+\t\t// todo encapsulate this better.\n+\t\tfor (CType<?, ?> store : bucket.getStores()) {\n+\t\t\tstore.loadDictionaries(context.getStorage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTM5MzkzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/DateRestrictingNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjozODoyNlrOH12xiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTozNDoyMlrOH2UO2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzMzk5Mw==", "bodyText": "Okay, es gibt sie noch die localId. Bin verwirrt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526233993", "createdAt": "2020-11-18T16:38:26Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/DateRestrictingNode.java", "diffHunk": "@@ -59,16 +59,16 @@ public boolean isOfInterest(Bucket bucket) {\n \t\t\treturn true;\n \t\t}\n \n-\t\tint localId = bucket.toLocal(entity.getId());\n+\t\tint localId = entity.getId();\n \n \t\t// This means the Entity is not contained.\n-\t\tif(cBlock.getMinDate()[localId] > cBlock.getMaxDate()[localId]) {\n+\t\tif(cBlock.getMinDate().get(localId) > cBlock.getMaxDate().get(localId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNjYzNA==", "bodyText": "das ist jetzt die entityId eigentlich, der Name ist nur noch nichgt richtig", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526716634", "createdAt": "2020-11-19T09:34:22Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/DateRestrictingNode.java", "diffHunk": "@@ -59,16 +59,16 @@ public boolean isOfInterest(Bucket bucket) {\n \t\t\treturn true;\n \t\t}\n \n-\t\tint localId = bucket.toLocal(entity.getId());\n+\t\tint localId = entity.getId();\n \n \t\t// This means the Entity is not contained.\n-\t\tif(cBlock.getMinDate()[localId] > cBlock.getMaxDate()[localId]) {\n+\t\tif(cBlock.getMinDate().get(localId) > cBlock.getMaxDate().get(localId)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzMzk5Mw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTQ0MjE4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/Decision.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0ODoxNFrOH13PzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTozNDo0NFrOH2UQGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MTc0MA==", "bodyText": "Ist dieser Container noch notwendig?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526241740", "createdAt": "2020-11-18T16:48:14Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/Decision.java", "diffHunk": "@@ -1,13 +1,13 @@\n package com.bakdata.conquery.models.types.parser;\n \n import com.bakdata.conquery.models.types.CType;\n-\n import lombok.Data;\n-import lombok.RequiredArgsConstructor;\n \n-@RequiredArgsConstructor\n @Data\n-public class Decision<MAJOR_JAVA_TYPE, JAVA_TYPE, CTYPE extends CType<MAJOR_JAVA_TYPE, JAVA_TYPE>> {\n-\tprivate final Transformer<MAJOR_JAVA_TYPE, JAVA_TYPE> transformer;\n+public class Decision<CTYPE extends CType<?, ?>> {\n \tprivate final CTYPE type;\n+\n+\tpublic Decision(CTYPE type) {\n+\t\tthis.type = type;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNjk1Mw==", "bodyText": "nein, hab mir noch nicht die Zeit genommen das zu entkapseln", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526716953", "createdAt": "2020-11-19T09:34:44Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/Decision.java", "diffHunk": "@@ -1,13 +1,13 @@\n package com.bakdata.conquery.models.types.parser;\n \n import com.bakdata.conquery.models.types.CType;\n-\n import lombok.Data;\n-import lombok.RequiredArgsConstructor;\n \n-@RequiredArgsConstructor\n @Data\n-public class Decision<MAJOR_JAVA_TYPE, JAVA_TYPE, CTYPE extends CType<MAJOR_JAVA_TYPE, JAVA_TYPE>> {\n-\tprivate final Transformer<MAJOR_JAVA_TYPE, JAVA_TYPE> transformer;\n+public class Decision<CTYPE extends CType<?, ?>> {\n \tprivate final CTYPE type;\n+\n+\tpublic Decision(CTYPE type) {\n+\t\tthis.type = type;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MTc0MA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTQ3MjI1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/specific/MoneyParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo1NDoyNlrOH13jAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo1NDoyNlrOH13jAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0NjY1OA==", "bodyText": "Hallo hier hinten", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526246658", "createdAt": "2020-11-18T16:54:26Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/specific/MoneyParser.java", "diffHunk": "@@ -4,30 +4,28 @@\n \n import com.bakdata.conquery.models.config.ConqueryConfig;\n import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.stores.base.LongStore;\n import com.bakdata.conquery.models.exceptions.ParsingException;\n import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.NoopTransformer;\n import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.Transformer;\n import com.bakdata.conquery.models.types.specific.MoneyTypeLong;\n import com.bakdata.conquery.models.types.specific.MoneyTypeVarInt;\n import com.bakdata.conquery.models.types.specific.VarIntType;\n import com.bakdata.conquery.util.NumberParsing;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import lombok.Getter;\n-import lombok.NonNull;\n import lombok.ToString;\n \n @ToString(callSuper = true)\n public class MoneyParser extends Parser<Long> {\n \n+\t@JsonIgnore\n+\t@Getter(lazy = true)\n+\tprivate final BigDecimal moneyFactor = BigDecimal.valueOf(10)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t .pow(ConqueryConfig.getInstance().getLocale().getCurrency().getDefaultFractionDigits());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTUxNTkyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/specific/string/StringParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzowMzoxNlrOH13-eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTozNTowOVrOH2URRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MzY4OA==", "bodyText": "Dieses Lambda hatte ich doch schonmal entfernt.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526253688", "createdAt": "2020-11-18T17:03:16Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/specific/string/StringParser.java", "diffHunk": "@@ -1,58 +1,55 @@\n package com.bakdata.conquery.models.types.parser.specific.string;\n \n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.EnumSet;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Objects;\n-import java.util.UUID;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.stores.base.BooleanStore;\n import com.bakdata.conquery.models.exceptions.ParsingException;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.preproc.ColumnDescription;\n import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.types.parser.Decision;\n import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.Transformer;\n-import com.bakdata.conquery.models.types.parser.specific.VarIntParser;\n import com.bakdata.conquery.models.types.parser.specific.string.TypeGuesser.Guess;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.StringTypePrefix;\n-import com.bakdata.conquery.models.types.specific.StringTypeSingleton;\n-import com.bakdata.conquery.models.types.specific.StringTypeSuffix;\n-import com.bakdata.conquery.models.types.specific.VarIntType;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeEncoded.Encoding;\n+import com.bakdata.conquery.models.types.specific.string.StringTypePrefix;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeSingleton;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeSuffix;\n import com.google.common.base.Strings;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n import com.jakewharton.byteunits.BinaryByteUnit;\n import lombok.Getter;\n-import lombok.NonNull;\n import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.lang3.StringUtils;\n \n-@Slf4j @Getter\n+@Slf4j\n+@Getter\n public class StringParser extends Parser<Integer> {\n \n-\tprivate DictionaryId dictionaryId = new DictionaryId(new DatasetId(\"null\"), UUID.randomUUID().toString());\n-\tprivate VarIntParser indexType = new VarIntParser(); \n-\tprivate Map<String, Integer> strings = new LinkedHashMap<>();\n+\tprivate final String name;\n+\n+\tprivate BiMap<String, Integer> strings = HashBiMap.create();\n+\n \tprivate List<byte[]> decoded;\n \tprivate Encoding encoding;\n \tprivate String prefix = null;\n \tprivate String suffix = null;\n \n-\tpublic StringParser(ParserConfig config) {\n-\n+\tpublic StringParser(ColumnDescription description, ParserConfig config) {\n+\t\tthis.name = description.getName();\n \t}\n \n \t@Override\n \tprotected Integer parseValue(String value) throws ParsingException {\n-\t\treturn strings.computeIfAbsent(value, v-> {\n+\t\treturn strings.computeIfAbsent(value, v -> {\n \t\t\t//new values\n \n \t\t\t//set longest common prefix and suffix", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxNzI1NA==", "bodyText": "muss mal wieder develop mergen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526717254", "createdAt": "2020-11-19T09:35:09Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/parser/specific/string/StringParser.java", "diffHunk": "@@ -1,58 +1,55 @@\n package com.bakdata.conquery.models.types.parser.specific.string;\n \n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.EnumSet;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Objects;\n-import java.util.UUID;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.stores.base.BooleanStore;\n import com.bakdata.conquery.models.exceptions.ParsingException;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.preproc.ColumnDescription;\n import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.types.parser.Decision;\n import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.Transformer;\n-import com.bakdata.conquery.models.types.parser.specific.VarIntParser;\n import com.bakdata.conquery.models.types.parser.specific.string.TypeGuesser.Guess;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.StringTypePrefix;\n-import com.bakdata.conquery.models.types.specific.StringTypeSingleton;\n-import com.bakdata.conquery.models.types.specific.StringTypeSuffix;\n-import com.bakdata.conquery.models.types.specific.VarIntType;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeEncoded.Encoding;\n+import com.bakdata.conquery.models.types.specific.string.StringTypePrefix;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeSingleton;\n+import com.bakdata.conquery.models.types.specific.string.StringTypeSuffix;\n import com.google.common.base.Strings;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n import com.jakewharton.byteunits.BinaryByteUnit;\n import lombok.Getter;\n-import lombok.NonNull;\n import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.lang3.StringUtils;\n \n-@Slf4j @Getter\n+@Slf4j\n+@Getter\n public class StringParser extends Parser<Integer> {\n \n-\tprivate DictionaryId dictionaryId = new DictionaryId(new DatasetId(\"null\"), UUID.randomUUID().toString());\n-\tprivate VarIntParser indexType = new VarIntParser(); \n-\tprivate Map<String, Integer> strings = new LinkedHashMap<>();\n+\tprivate final String name;\n+\n+\tprivate BiMap<String, Integer> strings = HashBiMap.create();\n+\n \tprivate List<byte[]> decoded;\n \tprivate Encoding encoding;\n \tprivate String prefix = null;\n \tprivate String suffix = null;\n \n-\tpublic StringParser(ParserConfig config) {\n-\n+\tpublic StringParser(ColumnDescription description, ParserConfig config) {\n+\t\tthis.name = description.getName();\n \t}\n \n \t@Override\n \tprotected Integer parseValue(String value) throws ParsingException {\n-\t\treturn strings.computeIfAbsent(value, v-> {\n+\t\treturn strings.computeIfAbsent(value, v -> {\n \t\t\t//new values\n \n \t\t\t//set longest common prefix and suffix", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MzY4OA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTU2ODk5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/ChainedStringType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoxNDo0N1rOH14f9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTozODo0MVrOH2UaOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2MjI2Mw==", "bodyText": "Doku", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526262263", "createdAt": "2020-11-18T17:14:47Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/ChainedStringType.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.bakdata.conquery.models.types.specific;\n+\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter @Setter\n+@ToString\n+public abstract class ChainedStringType extends StringType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxOTU0NA==", "bodyText": "Ach die Klasse kommt ja von mir, ich glaube man braucht die gar nicht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526719544", "createdAt": "2020-11-19T09:38:41Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/ChainedStringType.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.bakdata.conquery.models.types.specific;\n+\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.bakdata.conquery.models.types.specific.string.StringType;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter @Setter\n+@ToString\n+public abstract class ChainedStringType extends StringType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2MjI2Mw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTU4MzMwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/MoneyTypeLong.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoxNzo1N1rOH14o9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTozNzo0OFrOH2UX8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NDU2Nw==", "bodyText": "Warum implementiert CType ColumnStore?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526264567", "createdAt": "2020-11-18T17:17:57Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/MoneyTypeLong.java", "diffHunk": "@@ -4,30 +4,53 @@\n \n import com.bakdata.conquery.io.cps.CPSType;\n import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.base.LongStore;\n import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.types.MajorTypeId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n-\n import lombok.Getter;\n \n-@CPSType(base=CType.class, id=\"MONEY_LONG\")\n+@CPSType(base = ColumnStore.class, id = \"MONEY_LONG\")\n+@Getter\n public class MoneyTypeLong extends CType<Long, Long> {\n \n-\t@JsonIgnore @Getter(lazy = true)\n+\t@JsonIgnore\n+\t@Getter(lazy = true)\n \tprivate final BigDecimal moneyFactor = BigDecimal.valueOf(10)\n-\t\t.pow(ConqueryConfig.getInstance().getLocale().getCurrency().getDefaultFractionDigits());\n-\t\n-\tpublic MoneyTypeLong() {\n-\t\tsuper(MajorTypeId.MONEY, long.class);\n-\t}\n-\t\n-\t@Override\n-\tpublic boolean canStoreNull() {\n-\t\treturn true;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t .pow(ConqueryConfig.getInstance().getLocale().getCurrency().getDefaultFractionDigits());\n+\n+\tprivate final LongStore store;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxODk2MQ==", "bodyText": "Ich gehe davon aus, dass ich die Klassen entweder wieder strenger Trenne, oder zusammenfasse. Die Trennung war erstmal nur der einfachheit halber gemacht um mich nur um eine Stelle zu k\u00fcmmern anstatt immer beides zu pflegen. Denn an und f\u00fcr sich erf\u00fcllen sie den gleichen Zweck bzw sollten transparent f\u00fcr die QueryEngine sein", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526718961", "createdAt": "2020-11-19T09:37:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/types/specific/MoneyTypeLong.java", "diffHunk": "@@ -4,30 +4,53 @@\n \n import com.bakdata.conquery.io.cps.CPSType;\n import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.events.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.base.LongStore;\n import com.bakdata.conquery.models.types.CType;\n import com.bakdata.conquery.models.types.MajorTypeId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n-\n import lombok.Getter;\n \n-@CPSType(base=CType.class, id=\"MONEY_LONG\")\n+@CPSType(base = ColumnStore.class, id = \"MONEY_LONG\")\n+@Getter\n public class MoneyTypeLong extends CType<Long, Long> {\n \n-\t@JsonIgnore @Getter(lazy = true)\n+\t@JsonIgnore\n+\t@Getter(lazy = true)\n \tprivate final BigDecimal moneyFactor = BigDecimal.valueOf(10)\n-\t\t.pow(ConqueryConfig.getInstance().getLocale().getCurrency().getDefaultFractionDigits());\n-\t\n-\tpublic MoneyTypeLong() {\n-\t\tsuper(MajorTypeId.MONEY, long.class);\n-\t}\n-\t\n-\t@Override\n-\tpublic boolean canStoreNull() {\n-\t\treturn true;\n+\t\t\t\t\t\t\t\t\t\t\t\t\t .pow(ConqueryConfig.getInstance().getLocale().getCurrency().getDefaultFractionDigits());\n+\n+\tprivate final LongStore store;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NDU2Nw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTU5NzcxOnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedGroovyPerformanceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyMToxNlrOH14yFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMzo0OVrOH8n1Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NjkwMg==", "bodyText": "Achtung aus kommentiert", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526266902", "createdAt": "2020-11-18T17:21:16Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedGroovyPerformanceTest.java", "diffHunk": "@@ -1,86 +1,86 @@\n-package com.bakdata.conquery.models.concepts.tree.perf;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.models.concepts.tree.ConceptTreeCache;\n-import com.bakdata.conquery.models.concepts.tree.TreeChildPrefixIndex;\n-import com.bakdata.conquery.models.exceptions.ConceptConfigurationException;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.lang3.RandomUtils;\n-\n-@Slf4j\n-public class CachedGroovyPerformanceTest extends AbstractSearchPerformanceTest<Integer> {\n-\n-\tprivate SuccinctTrie dict;\n-\tprivate ConceptTreeCache cache;\n-\tprivate List<Integer> ids;\n-\tprivate StringTypeEncoded type;\n-\n-\t@Override\n-\tpublic String getName() {\n-\t\treturn getClass().getSimpleName();\n-\t}\n-\n-\t@Override\n-\tpublic int[] getIterations(){\n-\t\treturn new int[]{1000, 10000, 100000, 500000};\n-\t}\n-\n-\n-\t@Override\n-\tpublic String getConceptSourceName() {\n-\t\treturn \"prefixes.concept.json\";\n-\t}\n-\n-\tpublic List<byte[]> getTestStrings() {\n-\t\treturn Arrays.asList(\n-\t\t\t\"63F\", \"J14B\", \"N01C\", \"I10C\", \"L36Z\", \"960Z\", \"M10B\", \"X07A\", \"F06E\", \"P04C\", \"R63E\", \"O65B\", \"G77B\", \"F60B\", \"I65A\", \"F57Z\", \"R16Z\", \"R01D\", \"I23B\", \"A11E\", \"B44D\", \"F14A\", \"N62B\", \"Q61C\", \"I43B\", \"L43Z\", \"B36A\", \"F12F\", \"Z64B\", \"G07B\"\n-\t\t)\n-\t\t.stream()\n-\t\t.map(String::getBytes)\n-\t\t.collect(Collectors.toList());\n-\t}\n-\n-\t@Override\n-\tpublic List<Integer> getTestKeys() {\n-\t\treturn ids;\n-\t}\n-\n-\t@Override\n-\tpublic void postprocessConcepts() {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tids = getTestStrings().stream().map(dict::add).collect(Collectors.toList());\n-\t\tdict.compress();\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(newConcept);\n-\t\tTreeChildPrefixIndex.putIndexInto(referenceConcept);\n-\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tnewConcept.initializeIdCache(type, importId);\n-\n-\t\tcache = newConcept.getCache(importId);\n-\t}\n-\n-\t@Override\n-\tpublic void referenceSearch(Integer key) throws ConceptConfigurationException {\n-\t\treferenceConcept.findMostSpecificChild(type.getElement(key),  new CalculatedValue<>(() -> Collections.singletonMap(\"distinction\", RandomUtils.nextInt(8, 19 ))));\n-\t}\n-\n-\t@Override\n-\tpublic void newSearch(Integer key) throws ConceptConfigurationException {\n-\t\tcache.findMostSpecificChild(key, type.getElement(key), new CalculatedValue<>(() -> Collections.singletonMap(\"distinction\", RandomUtils.nextInt(8, 19 ))));\n-\t}\n-\n-}\n-\n+//package com.bakdata.conquery.models.concepts.tree.perf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyOTI1NA==", "bodyText": "gel\u00f6scht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533329254", "createdAt": "2020-12-01T11:13:49Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedGroovyPerformanceTest.java", "diffHunk": "@@ -1,86 +1,86 @@\n-package com.bakdata.conquery.models.concepts.tree.perf;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.models.concepts.tree.ConceptTreeCache;\n-import com.bakdata.conquery.models.concepts.tree.TreeChildPrefixIndex;\n-import com.bakdata.conquery.models.exceptions.ConceptConfigurationException;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.lang3.RandomUtils;\n-\n-@Slf4j\n-public class CachedGroovyPerformanceTest extends AbstractSearchPerformanceTest<Integer> {\n-\n-\tprivate SuccinctTrie dict;\n-\tprivate ConceptTreeCache cache;\n-\tprivate List<Integer> ids;\n-\tprivate StringTypeEncoded type;\n-\n-\t@Override\n-\tpublic String getName() {\n-\t\treturn getClass().getSimpleName();\n-\t}\n-\n-\t@Override\n-\tpublic int[] getIterations(){\n-\t\treturn new int[]{1000, 10000, 100000, 500000};\n-\t}\n-\n-\n-\t@Override\n-\tpublic String getConceptSourceName() {\n-\t\treturn \"prefixes.concept.json\";\n-\t}\n-\n-\tpublic List<byte[]> getTestStrings() {\n-\t\treturn Arrays.asList(\n-\t\t\t\"63F\", \"J14B\", \"N01C\", \"I10C\", \"L36Z\", \"960Z\", \"M10B\", \"X07A\", \"F06E\", \"P04C\", \"R63E\", \"O65B\", \"G77B\", \"F60B\", \"I65A\", \"F57Z\", \"R16Z\", \"R01D\", \"I23B\", \"A11E\", \"B44D\", \"F14A\", \"N62B\", \"Q61C\", \"I43B\", \"L43Z\", \"B36A\", \"F12F\", \"Z64B\", \"G07B\"\n-\t\t)\n-\t\t.stream()\n-\t\t.map(String::getBytes)\n-\t\t.collect(Collectors.toList());\n-\t}\n-\n-\t@Override\n-\tpublic List<Integer> getTestKeys() {\n-\t\treturn ids;\n-\t}\n-\n-\t@Override\n-\tpublic void postprocessConcepts() {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tids = getTestStrings().stream().map(dict::add).collect(Collectors.toList());\n-\t\tdict.compress();\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(newConcept);\n-\t\tTreeChildPrefixIndex.putIndexInto(referenceConcept);\n-\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tnewConcept.initializeIdCache(type, importId);\n-\n-\t\tcache = newConcept.getCache(importId);\n-\t}\n-\n-\t@Override\n-\tpublic void referenceSearch(Integer key) throws ConceptConfigurationException {\n-\t\treferenceConcept.findMostSpecificChild(type.getElement(key),  new CalculatedValue<>(() -> Collections.singletonMap(\"distinction\", RandomUtils.nextInt(8, 19 ))));\n-\t}\n-\n-\t@Override\n-\tpublic void newSearch(Integer key) throws ConceptConfigurationException {\n-\t\tcache.findMostSpecificChild(key, type.getElement(key), new CalculatedValue<>(() -> Collections.singletonMap(\"distinction\", RandomUtils.nextInt(8, 19 ))));\n-\t}\n-\n-}\n-\n+//package com.bakdata.conquery.models.concepts.tree.perf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NjkwMg=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTU5OTM2OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/PrefixIndexedTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyMTozOFrOH14zLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMzo1NFrOH8n1mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NzE4Mw==", "bodyText": "Achtung aus kommentiert", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526267183", "createdAt": "2020-11-18T17:21:38Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/PrefixIndexedTest.java", "diffHunk": "@@ -1,180 +1,180 @@\n-package com.bakdata.conquery.models.concepts.tree;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.Jackson;\n-import com.bakdata.conquery.models.concepts.Concept;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Dataset;\n-import com.bakdata.conquery.models.datasets.Table;\n-import com.bakdata.conquery.models.exceptions.ConfigurationException;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.ImportId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.models.worker.SingletonNamespaceCollection;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.github.powerlibraries.io.In;\n-import io.dropwizard.jersey.validation.Validators;\n-import lombok.extern.slf4j.Slf4j;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-@Slf4j\n-public class PrefixIndexedTest {\n-\n-\tprivate static final String CONCEPT_SOURCE = \"prefixes.concept.json\";\n-\n-\tprivate static SuccinctTrie dict;\n-\tprivate static TreeConcept indexedConcept;\n-\tprivate static TreeConcept oldConcept;\n-\tprivate static ImportId importId;\n-\tprivate static StringTypeEncoded type;\n-\t\n-\n-\tpublic static Stream<Arguments> getTestKeys() {\n-\t\tCalculatedValue<Map<String, Object>> rowMap = new CalculatedValue<>(Collections::emptyMap);\n-\n-\t\treturn Stream.of(\n-\t\t\t\t\"A047b\" , \"A0470\" , \"A0471\" , \"A0472\" , \"A0473\" , \"A0479\" , \"A3180\" , \"A3188\" , \"A4151\" , \"A4152\" , \"A4158\" , \"B2580\" , \"B2588\" , \"B3781\" , \"B3788\" , \"B9541\" , \"B9542\" , \"B9548\" , \"B9590\" , \"B9591\" , \"B9681\" , \"B9688\" , \"C4101\" , \"C4102\" , \"C4130\" , \"C4131\" , \"C4132\" , \"C7981\" , \"C7982\" , \"C7983\" , \"C7984\" , \"O029\" , \"Z935\" , \"M1202\" , \"E011\" , \"D370\" , \"P13\" , \"G259\" , \"J9921\" , \"I831\" , \"H950\" , \"E8331\" , \"H511\" , \"I11\" , \"S252\" , \"M0704\"\n-\t\t)\n-\t\t\t\t\t.map(key -> Arguments.of(key, rowMap));\n-\t}\n-\n-\n-\t@BeforeAll\n-\tpublic static void init() throws IOException, JSONException, ConfigurationException {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tgetTestKeys()\n-\t\t\t.map(args -> (String) args.get()[0])\n-\t\t\t.map(String::getBytes)\n-\t\t\t.forEach(dict::add);\n-\t\t\n-\t\tdict.compress();\n-\n-\t\tObjectNode node = Jackson.MAPPER.readerFor(ObjectNode.class).readValue(In.resource(PrefixIndexedTest.class, CONCEPT_SOURCE).asStream());\n-\n-\t\t// load concept tree from json\n-\t\tCentralRegistry registry = new CentralRegistry();\n-\n-\n-\t\tTable table = new Table();\n-\n-\t\ttable.setName(\"the_table\");\n-\t\tDataset dataset = new Dataset();\n-\n-\t\tdataset.setName(\"the_dataset\");\n-\n-\t\tregistry.register(dataset);\n-\n-\t\ttable.setDataset(dataset);\n-\n-\t\tColumn column = new Column();\n-\t\tcolumn.setName(\"the_column\");\n-\t\tcolumn.setType(MajorTypeId.STRING);\n-\n-\t\ttable.setColumns(new Column[]{column});\n-\t\tcolumn.setTable(table);\n-\n-\t\tregistry.register(table);\n-\t\tregistry.register(column);\n-\n-\t\timportId = new ImportId(table.getId(), \"import\");\n-\n-\t\t// load tree twice to to avoid references\n-\n-\t\tindexedConcept = new SingletonNamespaceCollection(registry).injectInto(dataset.injectInto(Jackson.MAPPER.readerFor(Concept.class))).readValue(node);\n-\n-\t\tindexedConcept.setDataset(dataset.getId());\n-\t\tindexedConcept.initElements(Validators.newValidator());\n-\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(indexedConcept);\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tindexedConcept.initializeIdCache(type, importId);\n-\n-\t\toldConcept = new SingletonNamespaceCollection(registry).injectInto(dataset.injectInto(Jackson.MAPPER.readerFor(Concept.class))).readValue(node);\n-\n-\t\toldConcept.setDataset(dataset.getId());\n-\t\toldConcept.initElements(Validators.newValidator());\n-\n-\t\tassertThat(indexedConcept.getChildIndex()).isNotNull();\n-\t\tassertThat(oldConcept.getChildIndex()).isNull();\n-\t}\n-\n-\t@ParameterizedTest(name = \"{index}: {0}\")\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void basic(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, rowMap);\n-\t\tConceptTreeChild oldResult = oldConcept.findMostSpecificChild(key, rowMap);\n-\n-\t\tif(oldResult == null) {\n-\t\t\tassertThat(idxResult).isNull();\n-\t\t}\n-\t\telse {\n-\t\t\tlog.trace(\"index_result: {}\", idxResult.getId());\n-\t\t\tlog.trace(\"normal_result: {}\", oldResult.getId());\n-\t\t\tassertThat(oldResult.getId())\n-\t\t\t\t\t.isEqualTo(idxResult.getId());\n-\t\t}\n-\t}\n-\n-\t@ParameterizedTest\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void withTail(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tString keyWithTail = key + \".someTextAfterTheActualText\";\n-\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild idxResultTail = indexedConcept.findMostSpecificChild(keyWithTail, rowMap);\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, rowMap);\n-\n-\t\tassertThat(idxResult.getId()).isEqualTo(idxResultTail.getId());\n-\t}\n-\n-\t@ParameterizedTest\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void cached(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild reference = indexedConcept.findMostSpecificChild(key, rowMap);\n-\t\tConceptTreeChild cached = indexedConcept.getCache(importId).findMostSpecificChild(type.getId(key), type.getElement(type.getId(key)), rowMap);\n-\t\tConceptTreeChild cached2 = indexedConcept.getCache(importId).findMostSpecificChild(type.getId(key), type.getElement(type.getId(key)), rowMap);\n-\n-\t\tassertThat(reference.getId())\n-\t\t\t\t.describedAs(\"%s hierarchical name\", key)\n-\t\t\t\t.isEqualTo(cached2.getId())\n-\t\t\t\t.isEqualTo(cached.getId())\n-\t\t;\n-\t}\n-\n-\n-\t@Test\n-\tpublic void missing() throws JSONException {\n-\t\tfinal String key = \"valueThatIsNotPresent\";\n-\n-\t\tlog.trace(\"Searching for Missing value {}\", key);\n-\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, new CalculatedValue<>(Collections::emptyMap));\n-\n-\t\tassertThat(idxResult).isNull();\n-\t}\n-}\n\\ No newline at end of file\n+//package com.bakdata.conquery.models.concepts.tree;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyOTMwNw==", "bodyText": "gel\u00f6scht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533329307", "createdAt": "2020-12-01T11:13:54Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/PrefixIndexedTest.java", "diffHunk": "@@ -1,180 +1,180 @@\n-package com.bakdata.conquery.models.concepts.tree;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.Jackson;\n-import com.bakdata.conquery.models.concepts.Concept;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Dataset;\n-import com.bakdata.conquery.models.datasets.Table;\n-import com.bakdata.conquery.models.exceptions.ConfigurationException;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.ImportId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.models.worker.SingletonNamespaceCollection;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.github.powerlibraries.io.In;\n-import io.dropwizard.jersey.validation.Validators;\n-import lombok.extern.slf4j.Slf4j;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-@Slf4j\n-public class PrefixIndexedTest {\n-\n-\tprivate static final String CONCEPT_SOURCE = \"prefixes.concept.json\";\n-\n-\tprivate static SuccinctTrie dict;\n-\tprivate static TreeConcept indexedConcept;\n-\tprivate static TreeConcept oldConcept;\n-\tprivate static ImportId importId;\n-\tprivate static StringTypeEncoded type;\n-\t\n-\n-\tpublic static Stream<Arguments> getTestKeys() {\n-\t\tCalculatedValue<Map<String, Object>> rowMap = new CalculatedValue<>(Collections::emptyMap);\n-\n-\t\treturn Stream.of(\n-\t\t\t\t\"A047b\" , \"A0470\" , \"A0471\" , \"A0472\" , \"A0473\" , \"A0479\" , \"A3180\" , \"A3188\" , \"A4151\" , \"A4152\" , \"A4158\" , \"B2580\" , \"B2588\" , \"B3781\" , \"B3788\" , \"B9541\" , \"B9542\" , \"B9548\" , \"B9590\" , \"B9591\" , \"B9681\" , \"B9688\" , \"C4101\" , \"C4102\" , \"C4130\" , \"C4131\" , \"C4132\" , \"C7981\" , \"C7982\" , \"C7983\" , \"C7984\" , \"O029\" , \"Z935\" , \"M1202\" , \"E011\" , \"D370\" , \"P13\" , \"G259\" , \"J9921\" , \"I831\" , \"H950\" , \"E8331\" , \"H511\" , \"I11\" , \"S252\" , \"M0704\"\n-\t\t)\n-\t\t\t\t\t.map(key -> Arguments.of(key, rowMap));\n-\t}\n-\n-\n-\t@BeforeAll\n-\tpublic static void init() throws IOException, JSONException, ConfigurationException {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tgetTestKeys()\n-\t\t\t.map(args -> (String) args.get()[0])\n-\t\t\t.map(String::getBytes)\n-\t\t\t.forEach(dict::add);\n-\t\t\n-\t\tdict.compress();\n-\n-\t\tObjectNode node = Jackson.MAPPER.readerFor(ObjectNode.class).readValue(In.resource(PrefixIndexedTest.class, CONCEPT_SOURCE).asStream());\n-\n-\t\t// load concept tree from json\n-\t\tCentralRegistry registry = new CentralRegistry();\n-\n-\n-\t\tTable table = new Table();\n-\n-\t\ttable.setName(\"the_table\");\n-\t\tDataset dataset = new Dataset();\n-\n-\t\tdataset.setName(\"the_dataset\");\n-\n-\t\tregistry.register(dataset);\n-\n-\t\ttable.setDataset(dataset);\n-\n-\t\tColumn column = new Column();\n-\t\tcolumn.setName(\"the_column\");\n-\t\tcolumn.setType(MajorTypeId.STRING);\n-\n-\t\ttable.setColumns(new Column[]{column});\n-\t\tcolumn.setTable(table);\n-\n-\t\tregistry.register(table);\n-\t\tregistry.register(column);\n-\n-\t\timportId = new ImportId(table.getId(), \"import\");\n-\n-\t\t// load tree twice to to avoid references\n-\n-\t\tindexedConcept = new SingletonNamespaceCollection(registry).injectInto(dataset.injectInto(Jackson.MAPPER.readerFor(Concept.class))).readValue(node);\n-\n-\t\tindexedConcept.setDataset(dataset.getId());\n-\t\tindexedConcept.initElements(Validators.newValidator());\n-\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(indexedConcept);\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tindexedConcept.initializeIdCache(type, importId);\n-\n-\t\toldConcept = new SingletonNamespaceCollection(registry).injectInto(dataset.injectInto(Jackson.MAPPER.readerFor(Concept.class))).readValue(node);\n-\n-\t\toldConcept.setDataset(dataset.getId());\n-\t\toldConcept.initElements(Validators.newValidator());\n-\n-\t\tassertThat(indexedConcept.getChildIndex()).isNotNull();\n-\t\tassertThat(oldConcept.getChildIndex()).isNull();\n-\t}\n-\n-\t@ParameterizedTest(name = \"{index}: {0}\")\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void basic(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, rowMap);\n-\t\tConceptTreeChild oldResult = oldConcept.findMostSpecificChild(key, rowMap);\n-\n-\t\tif(oldResult == null) {\n-\t\t\tassertThat(idxResult).isNull();\n-\t\t}\n-\t\telse {\n-\t\t\tlog.trace(\"index_result: {}\", idxResult.getId());\n-\t\t\tlog.trace(\"normal_result: {}\", oldResult.getId());\n-\t\t\tassertThat(oldResult.getId())\n-\t\t\t\t\t.isEqualTo(idxResult.getId());\n-\t\t}\n-\t}\n-\n-\t@ParameterizedTest\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void withTail(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tString keyWithTail = key + \".someTextAfterTheActualText\";\n-\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild idxResultTail = indexedConcept.findMostSpecificChild(keyWithTail, rowMap);\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, rowMap);\n-\n-\t\tassertThat(idxResult.getId()).isEqualTo(idxResultTail.getId());\n-\t}\n-\n-\t@ParameterizedTest\n-\t@MethodSource(\"getTestKeys\")\n-\tpublic void cached(String key, CalculatedValue<Map<String, Object>> rowMap) throws JSONException {\n-\t\tlog.trace(\"Searching for {}\", key);\n-\n-\t\tConceptTreeChild reference = indexedConcept.findMostSpecificChild(key, rowMap);\n-\t\tConceptTreeChild cached = indexedConcept.getCache(importId).findMostSpecificChild(type.getId(key), type.getElement(type.getId(key)), rowMap);\n-\t\tConceptTreeChild cached2 = indexedConcept.getCache(importId).findMostSpecificChild(type.getId(key), type.getElement(type.getId(key)), rowMap);\n-\n-\t\tassertThat(reference.getId())\n-\t\t\t\t.describedAs(\"%s hierarchical name\", key)\n-\t\t\t\t.isEqualTo(cached2.getId())\n-\t\t\t\t.isEqualTo(cached.getId())\n-\t\t;\n-\t}\n-\n-\n-\t@Test\n-\tpublic void missing() throws JSONException {\n-\t\tfinal String key = \"valueThatIsNotPresent\";\n-\n-\t\tlog.trace(\"Searching for Missing value {}\", key);\n-\n-\t\tConceptTreeChild idxResult = indexedConcept.findMostSpecificChild(key, new CalculatedValue<>(Collections::emptyMap));\n-\n-\t\tassertThat(idxResult).isNull();\n-\t}\n-}\n\\ No newline at end of file\n+//package com.bakdata.conquery.models.concepts.tree;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NzE4Mw=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTYwMTE4OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedPrefixPerformanceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyMTo1OVrOH140TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxMzo1OVrOH8n1yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NzQ2OA==", "bodyText": "Achtung aus kommentiert", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526267468", "createdAt": "2020-11-18T17:21:59Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedPrefixPerformanceTest.java", "diffHunk": "@@ -1,88 +1,88 @@\n-package com.bakdata.conquery.models.concepts.tree.perf;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.models.concepts.tree.ConceptTreeCache;\n-import com.bakdata.conquery.models.concepts.tree.TreeChildPrefixIndex;\n-import com.bakdata.conquery.models.exceptions.ConceptConfigurationException;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import lombok.extern.slf4j.Slf4j;\n-\n-\n-@Slf4j\n-public class CachedPrefixPerformanceTest extends AbstractSearchPerformanceTest<Integer> {\n-\n-\tprivate final CalculatedValue<Map<String, Object>> rowMap = new CalculatedValue<>(Collections::emptyMap);\n-\n-\tprivate SuccinctTrie dict;\n-\tprivate ConceptTreeCache cache;\n-\tprivate List<Integer> ids;\n-\tprivate StringTypeEncoded type;\n-\n-\t@Override\n-\tpublic int[] getIterations(){\n-\t\treturn new int[]{1000, 10000, 100000, 500000};\n-\t}\n-\n-\t@Override\n-\tpublic String getName() {\n-\t\treturn getClass().getSimpleName();\n-\t}\n-\n-\t@Override\n-\tpublic String getConceptSourceName() {\n-\t\treturn \"prefixes.concept.json\";\n-\t}\n-\n-\tpublic List<byte[]> getTestStrings() {\n-\t\treturn Arrays.asList(\n-\t\t\t\t\"A047b\", \"A0470\", \"A0471\", \"A0472\", \"A0473\", \"A0479\", \"A3180\", \"A3188\", \"A4151\", \"A4152\", \"A4158\", \"B2580\", \"B2588\", \"B3781\", \"B3788\", \"B9541\", \"B9542\", \"B9548\", \"B9590\", \"B9591\", \"B9681\", \"B9688\", \"C4101\", \"C4102\", \"C4130\", \"C4131\", \"C4132\", \"C7981\", \"C7982\", \"C7983\", \"C7984\", \"O029\", \"Z935\", \"M1202\", \"E011\", \"D370\", \"P13\", \"G259\", \"J9921\", \"I831\", \"H950\", \"E8331\", \"H511\", \"I11\", \"S252\", \"M0704\"\n-\t\t)\n-\t\t.stream()\n-\t\t.map(String::getBytes)\n-\t\t.collect(Collectors.toList());\n-\t}\n-\n-\t@Override\n-\tpublic List<Integer> getTestKeys() {\n-\t\treturn ids;\n-\t}\n-\n-\n-\t@Override\n-\tpublic void postprocessConcepts() {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tids = getTestStrings().stream().map(dict::add).collect(Collectors.toList());\n-\t\tdict.compress();\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(newConcept);\n-\t\tTreeChildPrefixIndex.putIndexInto(referenceConcept);\n-\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tnewConcept.initializeIdCache(type, importId);\n-\t\t\n-\t\tcache = newConcept.getCache(importId);\n-\t}\n-\n-\t@Override\n-\tpublic void referenceSearch(Integer key) throws ConceptConfigurationException {\n-\t\treferenceConcept.findMostSpecificChild(type.getElement(key), rowMap);\n-\t}\n-\n-\t@Override\n-\tpublic void newSearch(Integer key) throws ConceptConfigurationException {\n-\t\tcache.findMostSpecificChild(key, type.getElement(key), rowMap);\n-\t}\n-}\n-\n+//package com.bakdata.conquery.models.concepts.tree.perf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyOTM1Mg==", "bodyText": "gel\u00f6scht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533329352", "createdAt": "2020-12-01T11:13:59Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/concepts/tree/perf/CachedPrefixPerformanceTest.java", "diffHunk": "@@ -1,88 +1,88 @@\n-package com.bakdata.conquery.models.concepts.tree.perf;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.models.concepts.tree.ConceptTreeCache;\n-import com.bakdata.conquery.models.concepts.tree.TreeChildPrefixIndex;\n-import com.bakdata.conquery.models.exceptions.ConceptConfigurationException;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.util.CalculatedValue;\n-import com.bakdata.conquery.util.dict.SuccinctTrie;\n-import lombok.extern.slf4j.Slf4j;\n-\n-\n-@Slf4j\n-public class CachedPrefixPerformanceTest extends AbstractSearchPerformanceTest<Integer> {\n-\n-\tprivate final CalculatedValue<Map<String, Object>> rowMap = new CalculatedValue<>(Collections::emptyMap);\n-\n-\tprivate SuccinctTrie dict;\n-\tprivate ConceptTreeCache cache;\n-\tprivate List<Integer> ids;\n-\tprivate StringTypeEncoded type;\n-\n-\t@Override\n-\tpublic int[] getIterations(){\n-\t\treturn new int[]{1000, 10000, 100000, 500000};\n-\t}\n-\n-\t@Override\n-\tpublic String getName() {\n-\t\treturn getClass().getSimpleName();\n-\t}\n-\n-\t@Override\n-\tpublic String getConceptSourceName() {\n-\t\treturn \"prefixes.concept.json\";\n-\t}\n-\n-\tpublic List<byte[]> getTestStrings() {\n-\t\treturn Arrays.asList(\n-\t\t\t\t\"A047b\", \"A0470\", \"A0471\", \"A0472\", \"A0473\", \"A0479\", \"A3180\", \"A3188\", \"A4151\", \"A4152\", \"A4158\", \"B2580\", \"B2588\", \"B3781\", \"B3788\", \"B9541\", \"B9542\", \"B9548\", \"B9590\", \"B9591\", \"B9681\", \"B9688\", \"C4101\", \"C4102\", \"C4130\", \"C4131\", \"C4132\", \"C7981\", \"C7982\", \"C7983\", \"C7984\", \"O029\", \"Z935\", \"M1202\", \"E011\", \"D370\", \"P13\", \"G259\", \"J9921\", \"I831\", \"H950\", \"E8331\", \"H511\", \"I11\", \"S252\", \"M0704\"\n-\t\t)\n-\t\t.stream()\n-\t\t.map(String::getBytes)\n-\t\t.collect(Collectors.toList());\n-\t}\n-\n-\t@Override\n-\tpublic List<Integer> getTestKeys() {\n-\t\treturn ids;\n-\t}\n-\n-\n-\t@Override\n-\tpublic void postprocessConcepts() {\n-\t\tdict = new SuccinctTrie();\n-\n-\t\tids = getTestStrings().stream().map(dict::add).collect(Collectors.toList());\n-\t\tdict.compress();\n-\n-\t\tTreeChildPrefixIndex.putIndexInto(newConcept);\n-\t\tTreeChildPrefixIndex.putIndexInto(referenceConcept);\n-\n-\t\ttype = new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)), Encoding.UTF8);\n-\t\ttype.getSubType().setDictionary(dict);\n-\t\tnewConcept.initializeIdCache(type, importId);\n-\t\t\n-\t\tcache = newConcept.getCache(importId);\n-\t}\n-\n-\t@Override\n-\tpublic void referenceSearch(Integer key) throws ConceptConfigurationException {\n-\t\treferenceConcept.findMostSpecificChild(type.getElement(key), rowMap);\n-\t}\n-\n-\t@Override\n-\tpublic void newSearch(Integer key) throws ConceptConfigurationException {\n-\t\tcache.findMostSpecificChild(key, type.getElement(key), rowMap);\n-\t}\n-}\n-\n+//package com.bakdata.conquery.models.concepts.tree.perf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NzQ2OA=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTYwMzA3OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyMjoyMFrOH141Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMToxNDoxN1rOH8n2bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2Nzc0Ng==", "bodyText": "Achtung aus kommentiert", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526267746", "createdAt": "2020-11-18T17:22:20Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +1,290 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {\n-\n-\tprivate static final double requiredPrecision = Math.ulp(100f);\n-\n-\tpublic static Stream<Arguments> createRandomContent() {\n-\t\treturn IntStream\n-\t\t\t\t\t   .of(100)\n-\t\t\t\t\t   .mapToObj(numberOfValues -> {\n-\t\t\t\t\t\t\t\t\t Random r = new Random(7);\n-\t\t\t\t\t\t\t\t\t ArrayList<Object[]> arrays = new ArrayList<>();\n-\t\t\t\t\t\t\t\t\t for (int i = 0; i < numberOfValues; i++) {\n-\t\t\t\t\t\t\t\t\t\t Object[] event = new Object[20];\n-\t\t\t\t\t\t\t\t\t\t arrays.add(event);\n-\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[0] = (CDate.ofLocalDate(LocalDate.now()));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[1] = Long.toHexString(r.nextLong());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[2] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[3] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[4] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[5] = Integer.valueOf((byte) r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[6] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[7] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[8] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[9] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[10] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(10) - 5);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[11] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t event[12] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t event[13] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t //event[14] = null;\n-\t\t\t\t\t\t\t\t\t\t event[15] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[16] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(120) - 60);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[17] = Integer.toString(r.nextInt(800));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Inside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[18] = r.nextDouble() * 99d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Outside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[19] = r.nextDouble() * 1000d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\n-\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t arrays.trimToSize();\n-\n-\t\t\t\t\t\t\t\t\t return Arguments.of(numberOfValues, arrays);\n-\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t   );\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testParallelSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException, InterruptedException {\n-\t\tExecutorService pool = Executors.newFixedThreadPool(100);\n-\t\tList<Future<?>> futures = new ArrayList<>();\n-\t\tfor (int i = 0; i < 30; i++) {\n-\t\t\tList<Object[]> l = arrays.stream().map(v -> Arrays.copyOf(v, v.length)).collect(Collectors.toList());\n-\t\t\tfutures.add(pool.submit(() -> generateBucket(l)));\n-\t\t}\n-\t\tpool.shutdown();\n-\t\tfor (Future<?> f : futures) {\n-\t\t\tassertThatCode(() -> f.get()).doesNotThrowAnyException();\n-\t\t}\n-\t\tpool.awaitTermination(1, TimeUnit.HOURS);\n-\t}\n-\n-\tpublic Bucket generateBucket(List<Object[]> arrays) throws IOException {\n-\t\tfinal ParserConfig parserConfig = new ParserConfig();\n-\t\tparserConfig.setMinPrecision(requiredPrecision);\n-\n-\t\tParser[] parser = new Parser[]{\n-\t\t\t\tMajorTypeId.DATE.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig)\n-\t\t};\n-\n-\t\tassertThat(parser.length)\n-\t\t\t\t.describedAs(\"Length of Parsers and Rows.\")\n-\t\t\t\t.isEqualTo(arrays.get(0).length);\n-\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\t\ttry {\n-\t\t\t\t\t//only parse strings, this test otherwise already creates parsed values\n-\t\t\t\t\tif (parser[i] instanceof StringParser && event[i] != null) {\n-\t\t\t\t\t\tevent[i] = parser[i].parse((String) event[i]);\n-\t\t\t\t\t}\n-\t\t\t\t\tparser[i].addLine(event[i]);\n-\t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Column \" + i, e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal int entityBucketSize = ConqueryConfig.getInstance().getCluster().getEntityBucketSize();\n-\n-\t\tImport imp = new Import(entityBucketSize);\n-\t\timp.setTable(new TableId(new DatasetId(\"test_dataset\"), \"table\"));\n-\t\timp.setName(\"import\");\n-\t\timp.setColumns(IntStream.range(0, parser.length)\n-\t\t\t\t\t\t\t\t.mapToObj(i -> column(imp, i))\n-\t\t\t\t\t\t\t\t.toArray(ImportColumn[]::new)\n-\t\t);\n-\n-\t\tDecision[] decisions = Arrays.stream(parser).map(Parser::findBestType).toArray(Decision[]::new);\n-\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\timp.getColumns()[i].setType(decisions[i].getType());\n-\t\t\tlog.info(\"{}: {} mapped to {}\", imp.getColumns()[i], parser[i], imp.getColumns()[i].getType());\n-\t\t}\n-\n-\t\tList<Object[]> result = new ArrayList<>(arrays.size());\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tObject[] line = Arrays.copyOf(event, event.length);\n-\t\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\t\tif (event[i] != null) {\n-\t\t\t\t\tline[i] = decisions[i].getTransformer().transform(event[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tresult.add(line);\n-\t\t}\n-\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\timp.getColumns()[i].getType().writeHeader(new NullOutputStream());\n-\t\t}\n-\n-\t\treturn imp.getBlockFactory().create(imp, result);\n-\t}\n-\n-\tprivate ImportColumn column(Import imp, int pos) {\n-\t\tImportColumn col = new ImportColumn();\n-\t\tcol.setName(String.format(\"@column%02d\", pos));\n-\t\tcol.setParent(imp);\n-\t\tcol.setPosition(pos);\n-\t\treturn col;\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException {\n-\t\tList<Object[]> originalArrays = new ArrayList<>(arrays);\n-\t\toriginalArrays.replaceAll(v -> Arrays.copyOf(v, v.length));\n-\n-\t\tBucket bucket = generateBucket(arrays);\n-\t\tfor (int i = 0; i < arrays.size(); i++) {\n-\t\t\tfor (int c = 0; c < arrays.get(i).length; c++) {\n-\t\t\t\tColumn fake = new Column();\n-\t\t\t\tfake.setPosition(c);\n-\n-\t\t\t\tObject orig = originalArrays.get(i)[c];\n-\t\t\t\tString message = \"checking \" + c + \" \" + bucket.getImp().getColumns()[c].getType() + \":\" + i + \" = \" + orig;\n-\n-\t\t\t\tif (orig == null) {\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t.isFalse();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tImportColumn impCol = bucket.getImp().getColumns()[c];\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message + \" is not null\")\n-\t\t\t\t\t\t\t.isTrue();\n-\n-\t\t\t\t\tif (orig instanceof BigDecimal) {\n-\t\t\t\t\t\tassertThat((BigDecimal) bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.usingComparator(BigDecimal::compareTo)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.STRING) {\n-\t\t\t\t\t\tassertThat(((AStringType<?>) impCol.getType()).getElement(bucket.getString(i, fake)))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.REAL) {\n-\t\t\t\t\t\tassertThat(bucket.getReal(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isCloseTo((Double) orig, Offset.offset(requiredPrecision));\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tassertThat(bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t\tbucket.calculateMap(i, bucket.getImp());\n-\t\t}\n-\t\tCentralRegistry registry = new CentralRegistry();\n-\t\tregistry.register(bucket.getImp());\n-\n-\t\tSerializationTestUtil\n-\t\t\t\t.forType(Bucket.class)\n-\t\t\t\t.registry(registry)\n-\t\t\t\t.test(bucket);\n-\t}\n-}\n+//package com.bakdata.conquery.models.events.generation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyOTM5NA==", "bodyText": "gel\u00f6scht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533329394", "createdAt": "2020-12-01T11:14:04Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +1,290 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {\n-\n-\tprivate static final double requiredPrecision = Math.ulp(100f);\n-\n-\tpublic static Stream<Arguments> createRandomContent() {\n-\t\treturn IntStream\n-\t\t\t\t\t   .of(100)\n-\t\t\t\t\t   .mapToObj(numberOfValues -> {\n-\t\t\t\t\t\t\t\t\t Random r = new Random(7);\n-\t\t\t\t\t\t\t\t\t ArrayList<Object[]> arrays = new ArrayList<>();\n-\t\t\t\t\t\t\t\t\t for (int i = 0; i < numberOfValues; i++) {\n-\t\t\t\t\t\t\t\t\t\t Object[] event = new Object[20];\n-\t\t\t\t\t\t\t\t\t\t arrays.add(event);\n-\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[0] = (CDate.ofLocalDate(LocalDate.now()));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[1] = Long.toHexString(r.nextLong());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[2] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[3] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[4] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[5] = Integer.valueOf((byte) r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[6] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[7] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[8] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[9] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[10] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(10) - 5);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[11] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t event[12] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t event[13] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t //event[14] = null;\n-\t\t\t\t\t\t\t\t\t\t event[15] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[16] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(120) - 60);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[17] = Integer.toString(r.nextInt(800));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Inside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[18] = r.nextDouble() * 99d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Outside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[19] = r.nextDouble() * 1000d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\n-\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t arrays.trimToSize();\n-\n-\t\t\t\t\t\t\t\t\t return Arguments.of(numberOfValues, arrays);\n-\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t   );\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testParallelSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException, InterruptedException {\n-\t\tExecutorService pool = Executors.newFixedThreadPool(100);\n-\t\tList<Future<?>> futures = new ArrayList<>();\n-\t\tfor (int i = 0; i < 30; i++) {\n-\t\t\tList<Object[]> l = arrays.stream().map(v -> Arrays.copyOf(v, v.length)).collect(Collectors.toList());\n-\t\t\tfutures.add(pool.submit(() -> generateBucket(l)));\n-\t\t}\n-\t\tpool.shutdown();\n-\t\tfor (Future<?> f : futures) {\n-\t\t\tassertThatCode(() -> f.get()).doesNotThrowAnyException();\n-\t\t}\n-\t\tpool.awaitTermination(1, TimeUnit.HOURS);\n-\t}\n-\n-\tpublic Bucket generateBucket(List<Object[]> arrays) throws IOException {\n-\t\tfinal ParserConfig parserConfig = new ParserConfig();\n-\t\tparserConfig.setMinPrecision(requiredPrecision);\n-\n-\t\tParser[] parser = new Parser[]{\n-\t\t\t\tMajorTypeId.DATE.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig)\n-\t\t};\n-\n-\t\tassertThat(parser.length)\n-\t\t\t\t.describedAs(\"Length of Parsers and Rows.\")\n-\t\t\t\t.isEqualTo(arrays.get(0).length);\n-\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\t\ttry {\n-\t\t\t\t\t//only parse strings, this test otherwise already creates parsed values\n-\t\t\t\t\tif (parser[i] instanceof StringParser && event[i] != null) {\n-\t\t\t\t\t\tevent[i] = parser[i].parse((String) event[i]);\n-\t\t\t\t\t}\n-\t\t\t\t\tparser[i].addLine(event[i]);\n-\t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Column \" + i, e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal int entityBucketSize = ConqueryConfig.getInstance().getCluster().getEntityBucketSize();\n-\n-\t\tImport imp = new Import(entityBucketSize);\n-\t\timp.setTable(new TableId(new DatasetId(\"test_dataset\"), \"table\"));\n-\t\timp.setName(\"import\");\n-\t\timp.setColumns(IntStream.range(0, parser.length)\n-\t\t\t\t\t\t\t\t.mapToObj(i -> column(imp, i))\n-\t\t\t\t\t\t\t\t.toArray(ImportColumn[]::new)\n-\t\t);\n-\n-\t\tDecision[] decisions = Arrays.stream(parser).map(Parser::findBestType).toArray(Decision[]::new);\n-\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\timp.getColumns()[i].setType(decisions[i].getType());\n-\t\t\tlog.info(\"{}: {} mapped to {}\", imp.getColumns()[i], parser[i], imp.getColumns()[i].getType());\n-\t\t}\n-\n-\t\tList<Object[]> result = new ArrayList<>(arrays.size());\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tObject[] line = Arrays.copyOf(event, event.length);\n-\t\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\t\tif (event[i] != null) {\n-\t\t\t\t\tline[i] = decisions[i].getTransformer().transform(event[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tresult.add(line);\n-\t\t}\n-\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\timp.getColumns()[i].getType().writeHeader(new NullOutputStream());\n-\t\t}\n-\n-\t\treturn imp.getBlockFactory().create(imp, result);\n-\t}\n-\n-\tprivate ImportColumn column(Import imp, int pos) {\n-\t\tImportColumn col = new ImportColumn();\n-\t\tcol.setName(String.format(\"@column%02d\", pos));\n-\t\tcol.setParent(imp);\n-\t\tcol.setPosition(pos);\n-\t\treturn col;\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException {\n-\t\tList<Object[]> originalArrays = new ArrayList<>(arrays);\n-\t\toriginalArrays.replaceAll(v -> Arrays.copyOf(v, v.length));\n-\n-\t\tBucket bucket = generateBucket(arrays);\n-\t\tfor (int i = 0; i < arrays.size(); i++) {\n-\t\t\tfor (int c = 0; c < arrays.get(i).length; c++) {\n-\t\t\t\tColumn fake = new Column();\n-\t\t\t\tfake.setPosition(c);\n-\n-\t\t\t\tObject orig = originalArrays.get(i)[c];\n-\t\t\t\tString message = \"checking \" + c + \" \" + bucket.getImp().getColumns()[c].getType() + \":\" + i + \" = \" + orig;\n-\n-\t\t\t\tif (orig == null) {\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t.isFalse();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tImportColumn impCol = bucket.getImp().getColumns()[c];\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message + \" is not null\")\n-\t\t\t\t\t\t\t.isTrue();\n-\n-\t\t\t\t\tif (orig instanceof BigDecimal) {\n-\t\t\t\t\t\tassertThat((BigDecimal) bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.usingComparator(BigDecimal::compareTo)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.STRING) {\n-\t\t\t\t\t\tassertThat(((AStringType<?>) impCol.getType()).getElement(bucket.getString(i, fake)))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.REAL) {\n-\t\t\t\t\t\tassertThat(bucket.getReal(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isCloseTo((Double) orig, Offset.offset(requiredPrecision));\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tassertThat(bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t\tbucket.calculateMap(i, bucket.getImp());\n-\t\t}\n-\t\tCentralRegistry registry = new CentralRegistry();\n-\t\tregistry.register(bucket.getImp());\n-\n-\t\tSerializationTestUtil\n-\t\t\t\t.forType(Bucket.class)\n-\t\t\t\t.registry(registry)\n-\t\t\t\t.test(bucket);\n-\t}\n-}\n+//package com.bakdata.conquery.models.events.generation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2Nzc0Ng=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyOTUxNg==", "bodyText": "Daf\u00fcr schulde ich dir jetzt ParserTests", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533329516", "createdAt": "2020-12-01T11:14:17Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +1,290 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {\n-\n-\tprivate static final double requiredPrecision = Math.ulp(100f);\n-\n-\tpublic static Stream<Arguments> createRandomContent() {\n-\t\treturn IntStream\n-\t\t\t\t\t   .of(100)\n-\t\t\t\t\t   .mapToObj(numberOfValues -> {\n-\t\t\t\t\t\t\t\t\t Random r = new Random(7);\n-\t\t\t\t\t\t\t\t\t ArrayList<Object[]> arrays = new ArrayList<>();\n-\t\t\t\t\t\t\t\t\t for (int i = 0; i < numberOfValues; i++) {\n-\t\t\t\t\t\t\t\t\t\t Object[] event = new Object[20];\n-\t\t\t\t\t\t\t\t\t\t arrays.add(event);\n-\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[0] = (CDate.ofLocalDate(LocalDate.now()));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[1] = Long.toHexString(r.nextLong());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[2] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[3] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[4] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[5] = Integer.valueOf((byte) r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[6] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[7] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[8] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[9] = Integer.valueOf(r.nextInt()).toString();\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[10] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(10) - 5);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[11] = Long.valueOf((byte) r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t event[12] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t event[13] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t //event[14] = null;\n-\t\t\t\t\t\t\t\t\t\t event[15] = Long.valueOf(r.nextInt());\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[16] = BigDecimal.valueOf(r.nextInt(4), r.nextInt(120) - 60);\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[17] = Integer.toString(r.nextInt(800));\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Inside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[18] = r.nextDouble() * 99d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t\t // Outside ULP\n-\t\t\t\t\t\t\t\t\t\t if (r.nextBoolean()) {\n-\t\t\t\t\t\t\t\t\t\t\t event[19] = r.nextDouble() * 1000d;\n-\t\t\t\t\t\t\t\t\t\t }\n-\n-\t\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t\t\t\t\t arrays.trimToSize();\n-\n-\t\t\t\t\t\t\t\t\t return Arguments.of(numberOfValues, arrays);\n-\t\t\t\t\t\t\t\t }\n-\t\t\t\t\t   );\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testParallelSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException, InterruptedException {\n-\t\tExecutorService pool = Executors.newFixedThreadPool(100);\n-\t\tList<Future<?>> futures = new ArrayList<>();\n-\t\tfor (int i = 0; i < 30; i++) {\n-\t\t\tList<Object[]> l = arrays.stream().map(v -> Arrays.copyOf(v, v.length)).collect(Collectors.toList());\n-\t\t\tfutures.add(pool.submit(() -> generateBucket(l)));\n-\t\t}\n-\t\tpool.shutdown();\n-\t\tfor (Future<?> f : futures) {\n-\t\t\tassertThatCode(() -> f.get()).doesNotThrowAnyException();\n-\t\t}\n-\t\tpool.awaitTermination(1, TimeUnit.HOURS);\n-\t}\n-\n-\tpublic Bucket generateBucket(List<Object[]> arrays) throws IOException {\n-\t\tfinal ParserConfig parserConfig = new ParserConfig();\n-\t\tparserConfig.setMinPrecision(requiredPrecision);\n-\n-\t\tParser[] parser = new Parser[]{\n-\t\t\t\tMajorTypeId.DATE.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.INTEGER.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.DECIMAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.STRING.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig),\n-\t\t\t\tMajorTypeId.REAL.createParser(parserConfig)\n-\t\t};\n-\n-\t\tassertThat(parser.length)\n-\t\t\t\t.describedAs(\"Length of Parsers and Rows.\")\n-\t\t\t\t.isEqualTo(arrays.get(0).length);\n-\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\t\ttry {\n-\t\t\t\t\t//only parse strings, this test otherwise already creates parsed values\n-\t\t\t\t\tif (parser[i] instanceof StringParser && event[i] != null) {\n-\t\t\t\t\t\tevent[i] = parser[i].parse((String) event[i]);\n-\t\t\t\t\t}\n-\t\t\t\t\tparser[i].addLine(event[i]);\n-\t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Column \" + i, e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfinal int entityBucketSize = ConqueryConfig.getInstance().getCluster().getEntityBucketSize();\n-\n-\t\tImport imp = new Import(entityBucketSize);\n-\t\timp.setTable(new TableId(new DatasetId(\"test_dataset\"), \"table\"));\n-\t\timp.setName(\"import\");\n-\t\timp.setColumns(IntStream.range(0, parser.length)\n-\t\t\t\t\t\t\t\t.mapToObj(i -> column(imp, i))\n-\t\t\t\t\t\t\t\t.toArray(ImportColumn[]::new)\n-\t\t);\n-\n-\t\tDecision[] decisions = Arrays.stream(parser).map(Parser::findBestType).toArray(Decision[]::new);\n-\t\tfor (int i = 0; i < parser.length; i++) {\n-\t\t\timp.getColumns()[i].setType(decisions[i].getType());\n-\t\t\tlog.info(\"{}: {} mapped to {}\", imp.getColumns()[i], parser[i], imp.getColumns()[i].getType());\n-\t\t}\n-\n-\t\tList<Object[]> result = new ArrayList<>(arrays.size());\n-\t\tfor (Object[] event : arrays) {\n-\t\t\tObject[] line = Arrays.copyOf(event, event.length);\n-\t\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\t\tif (event[i] != null) {\n-\t\t\t\t\tline[i] = decisions[i].getTransformer().transform(event[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tresult.add(line);\n-\t\t}\n-\t\tfor (int i = 0; i < imp.getColumns().length; i++) {\n-\t\t\timp.getColumns()[i].getType().writeHeader(new NullOutputStream());\n-\t\t}\n-\n-\t\treturn imp.getBlockFactory().create(imp, result);\n-\t}\n-\n-\tprivate ImportColumn column(Import imp, int pos) {\n-\t\tImportColumn col = new ImportColumn();\n-\t\tcol.setName(String.format(\"@column%02d\", pos));\n-\t\tcol.setParent(imp);\n-\t\tcol.setPosition(pos);\n-\t\treturn col;\n-\t}\n-\n-\t@ParameterizedTest(name = \"{0}\")\n-\t@MethodSource(\"createRandomContent\")\n-\tpublic void testSerialization(int numberOfValues, List<Object[]> arrays)\n-\t\t\tthrows ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NoSuchMethodException, SecurityException, JSONException {\n-\t\tList<Object[]> originalArrays = new ArrayList<>(arrays);\n-\t\toriginalArrays.replaceAll(v -> Arrays.copyOf(v, v.length));\n-\n-\t\tBucket bucket = generateBucket(arrays);\n-\t\tfor (int i = 0; i < arrays.size(); i++) {\n-\t\t\tfor (int c = 0; c < arrays.get(i).length; c++) {\n-\t\t\t\tColumn fake = new Column();\n-\t\t\t\tfake.setPosition(c);\n-\n-\t\t\t\tObject orig = originalArrays.get(i)[c];\n-\t\t\t\tString message = \"checking \" + c + \" \" + bucket.getImp().getColumns()[c].getType() + \":\" + i + \" = \" + orig;\n-\n-\t\t\t\tif (orig == null) {\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t.isFalse();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tImportColumn impCol = bucket.getImp().getColumns()[c];\n-\t\t\t\t\tassertThat(bucket.has(i, fake))\n-\t\t\t\t\t\t\t.as(message + \" is not null\")\n-\t\t\t\t\t\t\t.isTrue();\n-\n-\t\t\t\t\tif (orig instanceof BigDecimal) {\n-\t\t\t\t\t\tassertThat((BigDecimal) bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.usingComparator(BigDecimal::compareTo)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.STRING) {\n-\t\t\t\t\t\tassertThat(((AStringType<?>) impCol.getType()).getElement(bucket.getString(i, fake)))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (impCol.getType().getTypeId() == MajorTypeId.REAL) {\n-\t\t\t\t\t\tassertThat(bucket.getReal(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isCloseTo((Double) orig, Offset.offset(requiredPrecision));\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tassertThat(bucket.getAsObject(i, fake))\n-\t\t\t\t\t\t\t\t.as(message)\n-\t\t\t\t\t\t\t\t.isEqualTo(orig);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t}\n-\t\t\tbucket.calculateMap(i, bucket.getImp());\n-\t\t}\n-\t\tCentralRegistry registry = new CentralRegistry();\n-\t\tregistry.register(bucket.getImp());\n-\n-\t\tSerializationTestUtil\n-\t\t\t\t.forType(Bucket.class)\n-\t\t\t\t.registry(registry)\n-\t\t\t\t.test(bucket);\n-\t}\n-}\n+//package com.bakdata.conquery.models.events.generation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2Nzc0Ng=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTYwNTk3OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/types/SerializationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzoyMjo1OVrOH143Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTozMDo0OFrOH8obZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2ODIxMQ==", "bodyText": "Achtung aus kommentiert", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r526268211", "createdAt": "2020-11-18T17:22:59Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/types/SerializationTest.java", "diffHunk": "@@ -1,96 +1,96 @@\n-package com.bakdata.conquery.models.types;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.io.cps.CPSTypeIdResolver;\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.Range.IntegerRange;\n-import com.bakdata.conquery.models.dictionary.Dictionary;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.types.specific.BooleanTypeBoolean;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypeDateRange;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypePacked;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypeQuarter;\n-import com.bakdata.conquery.models.types.specific.DateTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.DecimalTypeBigDecimal;\n-import com.bakdata.conquery.models.types.specific.DecimalTypeScaled;\n-import com.bakdata.conquery.models.types.specific.IntegerTypeLong;\n-import com.bakdata.conquery.models.types.specific.IntegerTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.MoneyTypeLong;\n-import com.bakdata.conquery.models.types.specific.MoneyTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.RealTypeDouble;\n-import com.bakdata.conquery.models.types.specific.RealTypeFloat;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.StringTypeNumber;\n-import com.bakdata.conquery.models.types.specific.StringTypePrefix;\n-import com.bakdata.conquery.models.types.specific.StringTypeSingleton;\n-import com.bakdata.conquery.models.types.specific.StringTypeSuffix;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeByte;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeShort;\n-import com.fasterxml.jackson.core.JsonParseException;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-public class SerializationTest {\n-\n-\tpublic static List<CType<?,?>> createCTypes() {\n-\t\treturn Arrays.asList(\n-\t\t\tnew DecimalTypeScaled(13, new IntegerTypeLong(-1,1)),\n-\t\t\tnew IntegerTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew MoneyTypeLong(),\n-\t\t\tnew DecimalTypeBigDecimal(),\n-\t\t\tnew BooleanTypeBoolean(),\n-\t\t\tnew MoneyTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew RealTypeDouble(),\n-\t\t\tnew DateTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew StringTypeDictionary(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase),\n-\t\t\tnew StringTypePrefix(new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase), \"a\"),\n-\t\t\tnew StringTypeSuffix(new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase), \"a\"),\n-\t\t\tnew StringTypeNumber(new IntegerRange(0,7), new VarIntTypeInt(0, 7)),\n-\t\t\tnew StringTypeSingleton(\"a\"),\n-\t\t\tnew IntegerTypeLong(-1,+1),\n-\t\t\tnew DateRangeTypeDateRange(),\n-\t\t\tnew DateRangeTypeQuarter(),\n-\t\t\tnew DateRangeTypePacked(),\n-\t\t\tnew DateTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew VarIntTypeInt(-1, +1),\n-\t\t\tnew VarIntTypeByte((byte)-1, (byte)+1),\n-\t\t\tnew VarIntTypeShort((short)-1, (short)+1),\n-\t\t\tnew RealTypeFloat()\n-\t\t);\n-\t}\n-\t\n-\t@Test @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-\tpublic void testAllTypesCovered() {\n-\t\tassertThat(\n-\t\t\tcreateCTypes()\n-\t\t\t\t.stream()\n-\t\t\t\t.map(Object::getClass)\n-\t\t\t\t.collect(Collectors.toSet())\n-\t\t)\n-\t\t.containsAll(\n-\t\t\t(Set)CPSTypeIdResolver.listImplementations(CType.class)\n-\t\t);\n-\t}\n-\n-\t@ParameterizedTest @MethodSource(\"createCTypes\")\n-\tpublic void testSerialization(CType<?,?> type) throws JsonParseException, JsonMappingException, JsonProcessingException, IOException, JSONException {\n-\t\tSerializationTestUtil\n-\t\t\t.forType(CType.class)\n-\t\t\t.ignoreClasses(Arrays.asList(Dictionary.class))\n-\t\t\t.test(type);\n-\t}\n-}\n+//package com.bakdata.conquery.models.types;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzODk4MA==", "bodyText": "wieder drin", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r533338980", "createdAt": "2020-12-01T11:30:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/types/SerializationTest.java", "diffHunk": "@@ -1,96 +1,96 @@\n-package com.bakdata.conquery.models.types;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import com.bakdata.conquery.io.cps.CPSTypeIdResolver;\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.Range.IntegerRange;\n-import com.bakdata.conquery.models.dictionary.Dictionary;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.types.specific.BooleanTypeBoolean;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypeDateRange;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypePacked;\n-import com.bakdata.conquery.models.types.specific.DateRangeTypeQuarter;\n-import com.bakdata.conquery.models.types.specific.DateTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.DecimalTypeBigDecimal;\n-import com.bakdata.conquery.models.types.specific.DecimalTypeScaled;\n-import com.bakdata.conquery.models.types.specific.IntegerTypeLong;\n-import com.bakdata.conquery.models.types.specific.IntegerTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.MoneyTypeLong;\n-import com.bakdata.conquery.models.types.specific.MoneyTypeVarInt;\n-import com.bakdata.conquery.models.types.specific.RealTypeDouble;\n-import com.bakdata.conquery.models.types.specific.RealTypeFloat;\n-import com.bakdata.conquery.models.types.specific.StringTypeDictionary;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded;\n-import com.bakdata.conquery.models.types.specific.StringTypeEncoded.Encoding;\n-import com.bakdata.conquery.models.types.specific.StringTypeNumber;\n-import com.bakdata.conquery.models.types.specific.StringTypePrefix;\n-import com.bakdata.conquery.models.types.specific.StringTypeSingleton;\n-import com.bakdata.conquery.models.types.specific.StringTypeSuffix;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeByte;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeInt;\n-import com.bakdata.conquery.models.types.specific.VarIntTypeShort;\n-import com.fasterxml.jackson.core.JsonParseException;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-public class SerializationTest {\n-\n-\tpublic static List<CType<?,?>> createCTypes() {\n-\t\treturn Arrays.asList(\n-\t\t\tnew DecimalTypeScaled(13, new IntegerTypeLong(-1,1)),\n-\t\t\tnew IntegerTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew MoneyTypeLong(),\n-\t\t\tnew DecimalTypeBigDecimal(),\n-\t\t\tnew BooleanTypeBoolean(),\n-\t\t\tnew MoneyTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew RealTypeDouble(),\n-\t\t\tnew DateTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew StringTypeDictionary(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase),\n-\t\t\tnew StringTypePrefix(new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase), \"a\"),\n-\t\t\tnew StringTypeSuffix(new StringTypeEncoded(new StringTypeDictionary(new VarIntTypeInt(-1, +1)),Encoding.Base16LowerCase), \"a\"),\n-\t\t\tnew StringTypeNumber(new IntegerRange(0,7), new VarIntTypeInt(0, 7)),\n-\t\t\tnew StringTypeSingleton(\"a\"),\n-\t\t\tnew IntegerTypeLong(-1,+1),\n-\t\t\tnew DateRangeTypeDateRange(),\n-\t\t\tnew DateRangeTypeQuarter(),\n-\t\t\tnew DateRangeTypePacked(),\n-\t\t\tnew DateTypeVarInt(new VarIntTypeInt(-1, +1)),\n-\t\t\tnew VarIntTypeInt(-1, +1),\n-\t\t\tnew VarIntTypeByte((byte)-1, (byte)+1),\n-\t\t\tnew VarIntTypeShort((short)-1, (short)+1),\n-\t\t\tnew RealTypeFloat()\n-\t\t);\n-\t}\n-\t\n-\t@Test @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-\tpublic void testAllTypesCovered() {\n-\t\tassertThat(\n-\t\t\tcreateCTypes()\n-\t\t\t\t.stream()\n-\t\t\t\t.map(Object::getClass)\n-\t\t\t\t.collect(Collectors.toSet())\n-\t\t)\n-\t\t.containsAll(\n-\t\t\t(Set)CPSTypeIdResolver.listImplementations(CType.class)\n-\t\t);\n-\t}\n-\n-\t@ParameterizedTest @MethodSource(\"createCTypes\")\n-\tpublic void testSerialization(CType<?,?> type) throws JsonParseException, JsonMappingException, JsonProcessingException, IOException, JSONException {\n-\t\tSerializationTestUtil\n-\t\t\t.forType(CType.class)\n-\t\t\t.ignoreClasses(Arrays.asList(Dictionary.class))\n-\t\t\t.test(type);\n-\t}\n-}\n+//package com.bakdata.conquery.models.types;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2ODIxMQ=="}, "originalCommit": {"oid": "fdf3b6dffe93f7eae60e7c2efcc4714fa90e2654"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Mjc0NTk3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/jackson/serializer/BitSetSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODoxNDo1OFrOIAan1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODozNTo0OFrOIAbXsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwNzA5Mw==", "bodyText": "Ich habe gesehen, dass du einen neuen Serialisierungstest erstellt hast, aber da habe ich einen Bitstore nicht auf den ersten Blick gesehen.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r537307093", "createdAt": "2020-12-07T08:14:58Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/jackson/serializer/BitSetSerializer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.bakdata.conquery.io.jackson.serializer;\n+\n+import java.io.IOException;\n+import java.util.BitSet;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+\n+public class BitSetSerializer extends StdSerializer<BitSet> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "848c7579f7ecc3179cf19785a0c877f6f7a88f0a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMxOTM0Nw==", "bodyText": "BooleanStore", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r537319347", "createdAt": "2020-12-07T08:35:48Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/io/jackson/serializer/BitSetSerializer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.bakdata.conquery.io.jackson.serializer;\n+\n+import java.io.IOException;\n+import java.util.BitSet;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+\n+public class BitSetSerializer extends StdSerializer<BitSet> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwNzA5Mw=="}, "originalCommit": {"oid": "848c7579f7ecc3179cf19785a0c877f6f7a88f0a"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Mjc1NTI1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespaceStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODoxNzoyMVrOIAas9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwODoxNzoyMVrOIAas9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMwODQwNg==", "bodyText": "Einmal bitte auf develop rebasen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r537308406", "createdAt": "2020-12-07T08:17:21Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespaceStorage.java", "diffHunk": "@@ -36,4 +37,7 @@ public static NamespaceStorage tryLoad(Validator validator, StorageConfig config\n \t\n \tPersistentIdMap getIdMapping();\n \tvoid updateIdMapping(PersistentIdMap idMap) throws JSONException;\n+\n+\tvoid setWorkerToBucketsMap(WorkerToBucketsMap map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "848c7579f7ecc3179cf19785a0c877f6f7a88f0a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzQ1NjQ4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespacedStorageImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1MDoyOVrOIUNccQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMzo0MzowNVrOIUcyDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA2MjcwNQ==", "bodyText": "Warum m\u00fcssen die ImportColumns registriert werden?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558062705", "createdAt": "2021-01-15T08:50:29Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespacedStorageImpl.java", "diffHunk": "@@ -129,16 +131,29 @@ protected void createStores(Multimap<Environment, KeyIncludingStore<?, ?>> envir\n \t\t\t\t\t\t  .onAdd(imp -> {\n \t\t\t\t\t\t\t  imp.loadExternalInfos(this);\n \n-\t\t\t\t\t\t\t  if (registerImports) {\n-\t\t\t\t\t\t\t\t  for (Concept<?> c : getAllConcepts()) {\n-\t\t\t\t\t\t\t\t\t  for (Connector con : c.getConnectors()) {\n-\t\t\t\t\t\t\t\t\t\t  if (con.getTable().getId().equals(imp.getTable())) {\n-\t\t\t\t\t\t\t\t\t\t\t  con.addImport(imp);\n-\t\t\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t  });\n+\t\t\t\tif (registerImports) {\n+\t\t\t\t\tfor (Concept<?> c : getAllConcepts()) {\n+\t\t\t\t\t\tfor (Connector con : c.getConnectors()) {\n+\t\t\t\t\t\t\tif (con.getTable().getId().equals(imp.getTable())) {\n+\t\t\t\t\t\t\t\tcon.addImport(imp);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tcentralRegistry.register(imp);\n+\n+\t\t\t\tfor (ImportColumn column : imp.getColumns()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxMzk5OA==", "bodyText": "sieht nicht so aus als w\u00e4re das noch notwendig, habe es mal entfernt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558313998", "createdAt": "2021-01-15T13:43:05Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/NamespacedStorageImpl.java", "diffHunk": "@@ -129,16 +131,29 @@ protected void createStores(Multimap<Environment, KeyIncludingStore<?, ?>> envir\n \t\t\t\t\t\t  .onAdd(imp -> {\n \t\t\t\t\t\t\t  imp.loadExternalInfos(this);\n \n-\t\t\t\t\t\t\t  if (registerImports) {\n-\t\t\t\t\t\t\t\t  for (Concept<?> c : getAllConcepts()) {\n-\t\t\t\t\t\t\t\t\t  for (Connector con : c.getConnectors()) {\n-\t\t\t\t\t\t\t\t\t\t  if (con.getTable().getId().equals(imp.getTable())) {\n-\t\t\t\t\t\t\t\t\t\t\t  con.addImport(imp);\n-\t\t\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t\t  }\n-\t\t\t\t\t\t  });\n+\t\t\t\tif (registerImports) {\n+\t\t\t\t\tfor (Concept<?> c : getAllConcepts()) {\n+\t\t\t\t\t\tfor (Connector con : c.getConnectors()) {\n+\t\t\t\t\t\t\tif (con.getTable().getId().equals(imp.getTable())) {\n+\t\t\t\t\t\t\t\tcon.addImport(imp);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tcentralRegistry.register(imp);\n+\n+\t\t\t\tfor (ImportColumn column : imp.getColumns()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA2MjcwNQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzQ4MDcwOnYy", "diffSide": "LEFT", "path": "backend/src/main/java/com/bakdata/conquery/models/config/CouchDBConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1MzoxM1rOIUNslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1MzoxM1rOIUNslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA2NjgzOA==", "bodyText": "Ist mir noch nie aufgefallen, diese Datei", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558066838", "createdAt": "2021-01-15T08:53:13Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/config/CouchDBConfig.java", "diffHunk": "@@ -1,5 +0,0 @@\n-package com.bakdata.conquery.models.config;\n-\n-public class CouchDBConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzQ4NDI2OnYy", "diffSide": "LEFT", "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Column.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1MzozOFrOIUNu_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1MzozOFrOIUNu_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA2NzQ1NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558067455", "createdAt": "2021-01-15T08:53:38Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Column.java", "diffHunk": "@@ -21,7 +21,6 @@\n public class Column extends Labeled<ColumnId> {\n \n \tpublic static final int UNKNOWN_POSITION = -1;\n-\tpublic static final int PRIMARY_POSITION = -2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzUxMTIxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/ImportColumn.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1NjoyNVrOIUN_2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMzo0NToxMVrOIUc3Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3MTc2OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558071768", "createdAt": "2021-01-15T08:56:25Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/ImportColumn.java", "diffHunk": "@@ -1,47 +1,30 @@\n package com.bakdata.conquery.models.datasets;\n \n import javax.validation.Valid;\n-import javax.validation.constraints.Min;\n import javax.validation.constraints.NotNull;\n \n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n import com.bakdata.conquery.models.identifiable.NamedImpl;\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportColumnId;\n-import com.bakdata.conquery.models.types.CType;\n import com.fasterxml.jackson.annotation.JsonBackReference;\n-import com.fasterxml.jackson.annotation.JsonIgnore;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-import lombok.Setter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n \n-@Getter @Setter @NoArgsConstructor\n+@Data\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n public class ImportColumn extends NamedImpl<ImportColumnId> {\n+\t// TODO reduce usage of this class, it does nothing except hold a description", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3MjIyNg==", "bodyText": "und einen Namen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558072226", "createdAt": "2021-01-15T08:56:43Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/ImportColumn.java", "diffHunk": "@@ -1,47 +1,30 @@\n package com.bakdata.conquery.models.datasets;\n \n import javax.validation.Valid;\n-import javax.validation.constraints.Min;\n import javax.validation.constraints.NotNull;\n \n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n import com.bakdata.conquery.models.identifiable.NamedImpl;\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportColumnId;\n-import com.bakdata.conquery.models.types.CType;\n import com.fasterxml.jackson.annotation.JsonBackReference;\n-import com.fasterxml.jackson.annotation.JsonIgnore;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-import lombok.Setter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n \n-@Getter @Setter @NoArgsConstructor\n+@Data\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n public class ImportColumn extends NamedImpl<ImportColumnId> {\n+\t// TODO reduce usage of this class, it does nothing except hold a description", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3MTc2OA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxNTI2Nw==", "bodyText": "Wobei die ganze Klasse aktuell nur noch zur Absch\u00e4tzung des Speichervrebrauchs benutzt wird", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558315267", "createdAt": "2021-01-15T13:45:11Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/ImportColumn.java", "diffHunk": "@@ -1,47 +1,30 @@\n package com.bakdata.conquery.models.datasets;\n \n import javax.validation.Valid;\n-import javax.validation.constraints.Min;\n import javax.validation.constraints.NotNull;\n \n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n import com.bakdata.conquery.models.identifiable.NamedImpl;\n import com.bakdata.conquery.models.identifiable.ids.specific.ImportColumnId;\n-import com.bakdata.conquery.models.types.CType;\n import com.fasterxml.jackson.annotation.JsonBackReference;\n-import com.fasterxml.jackson.annotation.JsonIgnore;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-import lombok.Setter;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n \n-@Getter @Setter @NoArgsConstructor\n+@Data\n+@RequiredArgsConstructor(onConstructor_ = {@JsonCreator})\n public class ImportColumn extends NamedImpl<ImportColumnId> {\n+\t// TODO reduce usage of this class, it does nothing except hold a description", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3MTc2OA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzUyNDgxOnYy", "diffSide": "LEFT", "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Table.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwODo1Nzo0MlrOIUOIlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjoxMDozMlrOIUZ4jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3NDAwNg==", "bodyText": "Hier m\u00fcssen dann die Tables umgeschrieben werden, oder?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558074006", "createdAt": "2021-01-15T08:57:42Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Table.java", "diffHunk": "@@ -29,14 +29,7 @@\n \n \t@NsIdRef\n \tprivate Dataset dataset;\n-\n-\t@NotNull\n-\t@Valid\n-\t@JsonManagedReference\n-\tprivate Column primaryColumn; // TODO this is not used anywhere.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2NjUxMA==", "bodyText": "Habe schon einen branch f\u00fcr vorbereitet, ist ein jq einzeiler", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558266510", "createdAt": "2021-01-15T12:10:32Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/datasets/Table.java", "diffHunk": "@@ -29,14 +29,7 @@\n \n \t@NsIdRef\n \tprivate Dataset dataset;\n-\n-\t@NotNull\n-\t@Valid\n-\t@JsonManagedReference\n-\tprivate Column primaryColumn; // TODO this is not used anywhere.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3NDAwNg=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzU1MTczOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTowMDoyOVrOIUObWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMzo0Njo1MVrOIUc62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3ODgwOA==", "bodyText": "Es sieht so aus als hat das DictionaryMapping jetzt eine persistentere Rolle. Kannst du bitte noch Doku hinzuf\u00fcgen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558078808", "createdAt": "2021-01-15T09:00:29Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java", "diffHunk": "@@ -19,20 +17,21 @@\n @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n @Getter\n @Slf4j\n+@ToString\n public class DictionaryMapping {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMxNjI0OQ==", "bodyText": "Ne hat die gleiche Rolle wie davor und lebt nur im ImportJob", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558316249", "createdAt": "2021-01-15T13:46:51Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/DictionaryMapping.java", "diffHunk": "@@ -19,20 +17,21 @@\n @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n @Getter\n @Slf4j\n+@ToString\n public class DictionaryMapping {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA3ODgwOA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzU2NTA3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTowMjowNVrOIUOkrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowODoyM1rOIVvi7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA4MTE5Nw==", "bodyText": "Bitte Doku, weshalb das Encoding hier notwendig ist und warum es nicht fix sein kann.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558081197", "createdAt": "2021-01-15T09:02:05Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.bakdata.conquery.models.dictionary;\n+\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n+\n+public class EncodedDictionary {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2OTk5Nw==", "bodyText": "Das Encoding ist fix, aber Dictionaries haben keins", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r559669997", "createdAt": "2021-01-18T16:08:23Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.bakdata.conquery.models.dictionary;\n+\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n+\n+public class EncodedDictionary {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA4MTE5Nw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMzU3MjA1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTowMjo1MFrOIUOpgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNDo1Mjo1NlrOIUferg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA4MjQzMg==", "bodyText": "new Object() ?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558082432", "createdAt": "2021-01-15T09:02:50Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.bakdata.conquery.models.dictionary;\n+\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n+\n+public class EncodedDictionary {\n+\n+\tprivate final Dictionary dict;\n+\tprivate final StringTypeEncoded.Encoding encoding;\n+\n+\tpublic EncodedDictionary(Dictionary dict, StringTypeEncoded.Encoding encoding) {\n+\t\tsuper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1ODE5MA==", "bodyText": "Die Klasse erbt nichts explizt meinte ich damit ;)", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558358190", "createdAt": "2021-01-15T14:52:56Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/dictionary/EncodedDictionary.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.bakdata.conquery.models.dictionary;\n+\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n+\n+public class EncodedDictionary {\n+\n+\tprivate final Dictionary dict;\n+\tprivate final StringTypeEncoded.Encoding encoding;\n+\n+\tpublic EncodedDictionary(Dictionary dict, StringTypeEncoded.Encoding encoding) {\n+\t\tsuper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODA4MjQzMg=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDA2MzA4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/EmptyStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTo1ODozMFrOIUT1hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwOTo1ODozMFrOIUT1hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2NzQzMQ==", "bodyText": "Doku f\u00fcr diesen SpecialStore bitte", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558167431", "createdAt": "2021-01-15T09:58:30Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/EmptyStore.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.bakdata.conquery.models.events;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+\n+@CPSType(base = ColumnStore.class, id = \"EMPTY\")\n+public class EmptyStore<T> extends ColumnStore<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDA4NzMxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/MajorTypeId.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDowMToxN1rOIUUGvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNDo1NTozNVrOIUflYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3MTgzOA==", "bodyText": "Warum ist der hier special?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558171838", "createdAt": "2021-01-15T10:01:17Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/MajorTypeId.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.bakdata.conquery.models.events.parser;\n+\n+import java.util.function.Function;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.parser.specific.BooleanParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateRangeParser;\n+import com.bakdata.conquery.models.events.parser.specific.DecimalParser;\n+import com.bakdata.conquery.models.events.parser.specific.IntegerParser;\n+import com.bakdata.conquery.models.events.parser.specific.MoneyParser;\n+import com.bakdata.conquery.models.events.parser.specific.RealParser;\n+import com.bakdata.conquery.models.events.parser.specific.string.StringParser;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public enum MajorTypeId {\n+\n+\tSTRING(false, StringParser::new),\n+\tINTEGER(false, t -> new IntegerParser()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1OTg1MQ==", "bodyText": "ists nicht, ich war nur faul", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558359851", "createdAt": "2021-01-15T14:55:30Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/MajorTypeId.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.bakdata.conquery.models.events.parser;\n+\n+import java.util.function.Function;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.parser.specific.BooleanParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateRangeParser;\n+import com.bakdata.conquery.models.events.parser.specific.DecimalParser;\n+import com.bakdata.conquery.models.events.parser.specific.IntegerParser;\n+import com.bakdata.conquery.models.events.parser.specific.MoneyParser;\n+import com.bakdata.conquery.models.events.parser.specific.RealParser;\n+import com.bakdata.conquery.models.events.parser.specific.string.StringParser;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public enum MajorTypeId {\n+\n+\tSTRING(false, StringParser::new),\n+\tINTEGER(false, t -> new IntegerParser()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3MTgzOA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM1OTkwNQ==", "bodyText": "ist behoben", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558359905", "createdAt": "2021-01-15T14:55:35Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/MajorTypeId.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.bakdata.conquery.models.events.parser;\n+\n+import java.util.function.Function;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.parser.specific.BooleanParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateParser;\n+import com.bakdata.conquery.models.events.parser.specific.DateRangeParser;\n+import com.bakdata.conquery.models.events.parser.specific.DecimalParser;\n+import com.bakdata.conquery.models.events.parser.specific.IntegerParser;\n+import com.bakdata.conquery.models.events.parser.specific.MoneyParser;\n+import com.bakdata.conquery.models.events.parser.specific.RealParser;\n+import com.bakdata.conquery.models.events.parser.specific.string.StringParser;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public enum MajorTypeId {\n+\n+\tSTRING(false, StringParser::new),\n+\tINTEGER(false, t -> new IntegerParser()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3MTgzOA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDMwOTc2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/string/MapTypeGuesser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDoyODoyMlrOIUWdww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDoyODoyMlrOIUWdww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxMDQ5OQ==", "bodyText": "Doku f\u00fcr die String Guesser bitte", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558210499", "createdAt": "2021-01-15T10:28:22Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/string/MapTypeGuesser.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.bakdata.conquery.models.events.parser.specific.string;\n+\n+import com.bakdata.conquery.models.dictionary.MapDictionary;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.events.stores.specific.string.StringType;\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeDictionary;\n+import com.bakdata.conquery.models.events.stores.specific.string.StringTypeEncoded;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public class MapTypeGuesser implements TypeGuesser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDM2MzU2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDozNjozN1rOIUXB_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNjowNzozM1rOIVvg2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxOTc3Mg==", "bodyText": "nullLines wird hier nur als Statistik genutzt, oder?\nK\u00f6nnte man dem Member nicht auch die tats\u00e4chlichen nullLines geben und so die Berechnung vereinfachen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558219772", "createdAt": "2021-01-15T10:36:37Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {\n+\n+\tprivate int lines = 0;\n+\tprivate int nullLines = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY2OTQ2NA==", "bodyText": "Habs entfernt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r559669464", "createdAt": "2021-01-18T16:07:33Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {\n+\n+\tprivate int lines = 0;\n+\tprivate int nullLines = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxOTc3Mg=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDM2NjU1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDozNzoyOFrOIUXDvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDozODowOVrOIUXFZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyMDIyMA==", "bodyText": "Doku", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558220220", "createdAt": "2021-01-15T10:37:28Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {\n+\n+\tprivate int lines = 0;\n+\tprivate int nullLines = 0;\n+\n+\t/**\n+\t * Helper method to select partitions of an array. Resulting array is of length sum(lengths). Incoming type T has to be of ArrayType or this will fail.\n+\t */\n+\tpublic static <T> T selectArray(int[] starts, int[] lengths, T values, Function<Integer, T> provider) {\n+\t\tint length = Arrays.stream(lengths).sum();\n+\n+\t\tfinal T out = provider.apply(length);\n+\n+\t\tint pos = 0;\n+\n+\t\tfor (int index = 0; index < starts.length; index++) {\n+\t\t\tSystem.arraycopy(values, starts[index], out, pos, lengths[index]);\n+\t\t\tpos += lengths[index];\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic Object createPrintValue(JAVA_TYPE value) {\n+\t\treturn value != null ? createScriptValue(value) : \"\";\n+\t}\n+\n+\tpublic Object createScriptValue(JAVA_TYPE value) {\n+\t\treturn value;\n+\t}\n+\n+\tpublic long estimateMemoryConsumption() {\n+\t\tlong bytes = estimateEventBits();\n+\n+\t\treturn getLines() * bytes;\n+\t}\n+\n+\tpublic abstract long estimateEventBits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyMDY0Nw==", "bodyText": "public?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558220647", "createdAt": "2021-01-15T10:38:09Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {\n+\n+\tprivate int lines = 0;\n+\tprivate int nullLines = 0;\n+\n+\t/**\n+\t * Helper method to select partitions of an array. Resulting array is of length sum(lengths). Incoming type T has to be of ArrayType or this will fail.\n+\t */\n+\tpublic static <T> T selectArray(int[] starts, int[] lengths, T values, Function<Integer, T> provider) {\n+\t\tint length = Arrays.stream(lengths).sum();\n+\n+\t\tfinal T out = provider.apply(length);\n+\n+\t\tint pos = 0;\n+\n+\t\tfor (int index = 0; index < starts.length; index++) {\n+\t\t\tSystem.arraycopy(values, starts[index], out, pos, lengths[index]);\n+\t\t\tpos += lengths[index];\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic Object createPrintValue(JAVA_TYPE value) {\n+\t\treturn value != null ? createScriptValue(value) : \"\";\n+\t}\n+\n+\tpublic Object createScriptValue(JAVA_TYPE value) {\n+\t\treturn value;\n+\t}\n+\n+\tpublic long estimateMemoryConsumption() {\n+\t\tlong bytes = estimateEventBits();\n+\n+\t\treturn getLines() * bytes;\n+\t}\n+\n+\tpublic abstract long estimateEventBits();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyMDIyMA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDM5Njc0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DecimalStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDo0NTo0N1rOIUXVtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNDo1OToyMVrOIUfvqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNDgyMA==", "bodyText": "Ist die storeSize nicht (lines-nullLines)*56 bytes?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558224820", "createdAt": "2021-01-15T10:45:47Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DecimalStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import java.math.BigDecimal;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DECIMALS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DecimalStore extends ColumnStore<BigDecimal> {\n+\n+\tprivate final BigDecimal[] values;\n+\n+\t@JsonCreator\n+\tpublic DecimalStore(BigDecimal[] values) {\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static DecimalStore create(int size) {\n+\t\treturn new DecimalStore(new BigDecimal[size]);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn 500; // It's a lot but non-deterministic so we have no idea :)\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2NzE4OQ==", "bodyText": "Woher hast du die Zahl? die 500 war davor auch schon drin", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558267189", "createdAt": "2021-01-15T12:12:04Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DecimalStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import java.math.BigDecimal;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DECIMALS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DecimalStore extends ColumnStore<BigDecimal> {\n+\n+\tprivate final BigDecimal[] values;\n+\n+\t@JsonCreator\n+\tpublic DecimalStore(BigDecimal[] values) {\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static DecimalStore create(int size) {\n+\t\treturn new DecimalStore(new BigDecimal[size]);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn 500; // It's a lot but non-deterministic so we have no idea :)\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNDgyMA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2MjUzNg==", "bodyText": "Ah 56 bytes scheint BigInteger zu sein. BigDecimal ist dann 32 byte * 8 = 256 bit\nhttp://javamoods.blogspot.com/2009/03/how-big-is-bigdecimal.html", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558362536", "createdAt": "2021-01-15T14:59:21Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/DecimalStore.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import java.math.BigDecimal;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@CPSType(id = \"DECIMALS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class DecimalStore extends ColumnStore<BigDecimal> {\n+\n+\tprivate final BigDecimal[] values;\n+\n+\t@JsonCreator\n+\tpublic DecimalStore(BigDecimal[] values) {\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static DecimalStore create(int size) {\n+\t\treturn new DecimalStore(new BigDecimal[size]);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn 500; // It's a lot but non-deterministic so we have no idea :)\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNDgyMA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQyNDE3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/IntegerStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDo1MzozMFrOIUXl3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTo0NDo1MlrOIVumcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODk1OQ==", "bodyText": "Was passiert wenn value.equals(nullValue)?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558228959", "createdAt": "2021-01-15T10:53:30Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/IntegerStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+/**\n+ * Store values as ints, can only store 2^32-1 values, as MAX is used as NULL signifier.\n+ *\n+ * @apiNote do not instantiate this directly, but use {@link com.bakdata.conquery.models.events.parser.specific.IntegerParser}\n+ */\n+@CPSType(id = \"INTEGERS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class IntegerStore extends ColumnStore<Long> {\n+\n+\tprivate final int nullValue;\n+\tprivate final int[] values;\n+\n+\t@JsonCreator\n+\tpublic IntegerStore(int[] values, int nullValue) {\n+\t\tthis.nullValue = nullValue;\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static IntegerStore create(int size) {\n+\t\treturn new IntegerStore(new int[size], Integer.MAX_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn Integer.SIZE;\n+\t}\n+\n+\tpublic IntegerStore select(int[] starts, int[] ends) {\n+\t\treturn new IntegerStore(ColumnStore.selectArray(starts, ends, values, int[]::new), nullValue);\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2NzQ2Nw==", "bodyText": "Ist durch den Parser ausgeschlossen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558267467", "createdAt": "2021-01-15T12:12:42Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/IntegerStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+/**\n+ * Store values as ints, can only store 2^32-1 values, as MAX is used as NULL signifier.\n+ *\n+ * @apiNote do not instantiate this directly, but use {@link com.bakdata.conquery.models.events.parser.specific.IntegerParser}\n+ */\n+@CPSType(id = \"INTEGERS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class IntegerStore extends ColumnStore<Long> {\n+\n+\tprivate final int nullValue;\n+\tprivate final int[] values;\n+\n+\t@JsonCreator\n+\tpublic IntegerStore(int[] values, int nullValue) {\n+\t\tthis.nullValue = nullValue;\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static IntegerStore create(int size) {\n+\t\treturn new IntegerStore(new int[size], Integer.MAX_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn Integer.SIZE;\n+\t}\n+\n+\tpublic IntegerStore select(int[] starts, int[] ends) {\n+\t\treturn new IntegerStore(ColumnStore.selectArray(starts, ends, values, int[]::new), nullValue);\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODk1OQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2NzU3NA==", "bodyText": "ah au\u00dfer hier nat\u00fcrlich, du hast recht.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558267574", "createdAt": "2021-01-15T12:12:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/IntegerStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+/**\n+ * Store values as ints, can only store 2^32-1 values, as MAX is used as NULL signifier.\n+ *\n+ * @apiNote do not instantiate this directly, but use {@link com.bakdata.conquery.models.events.parser.specific.IntegerParser}\n+ */\n+@CPSType(id = \"INTEGERS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class IntegerStore extends ColumnStore<Long> {\n+\n+\tprivate final int nullValue;\n+\tprivate final int[] values;\n+\n+\t@JsonCreator\n+\tpublic IntegerStore(int[] values, int nullValue) {\n+\t\tthis.nullValue = nullValue;\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static IntegerStore create(int size) {\n+\t\treturn new IntegerStore(new int[size], Integer.MAX_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn Integer.SIZE;\n+\t}\n+\n+\tpublic IntegerStore select(int[] starts, int[] ends) {\n+\t\treturn new IntegerStore(ColumnStore.selectArray(starts, ends, values, int[]::new), nullValue);\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODk1OQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY1NDUxNQ==", "bodyText": "ok, ich habe einen check und ein todo eingabut f\u00fcr den LongStore, dass ich das auf null-bits umstelle", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r559654515", "createdAt": "2021-01-18T15:44:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/base/IntegerStore.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.bakdata.conquery.models.events.stores.base;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+\n+/**\n+ * Store values as ints, can only store 2^32-1 values, as MAX is used as NULL signifier.\n+ *\n+ * @apiNote do not instantiate this directly, but use {@link com.bakdata.conquery.models.events.parser.specific.IntegerParser}\n+ */\n+@CPSType(id = \"INTEGERS\", base = ColumnStore.class)\n+@Getter\n+@ToString(onlyExplicitlyIncluded = true)\n+public class IntegerStore extends ColumnStore<Long> {\n+\n+\tprivate final int nullValue;\n+\tprivate final int[] values;\n+\n+\t@JsonCreator\n+\tpublic IntegerStore(int[] values, int nullValue) {\n+\t\tthis.nullValue = nullValue;\n+\t\tthis.values = values;\n+\t}\n+\n+\tpublic static IntegerStore create(int size) {\n+\t\treturn new IntegerStore(new int[size], Integer.MAX_VALUE);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn Integer.SIZE;\n+\t}\n+\n+\tpublic IntegerStore select(int[] starts, int[] ends) {\n+\t\treturn new IntegerStore(ColumnStore.selectArray(starts, ends, values, int[]::new), nullValue);\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODk1OQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQ0Mzg5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDo1ODo0NlrOIUXxKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjoxNDoxMFrOIUZ-uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMTg0OQ==", "bodyText": "Die anderen Stores sind nicht Iterable oder?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558231849", "createdAt": "2021-01-15T10:58:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringType.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.NoArgsConstructor;\n+\n+/**\n+ * Every implementation must guarantee IDs between 0 and size.\n+ *\n+ * Abstract\n+ */\n+@NoArgsConstructor\n+public abstract class StringType extends ColumnStore<Integer> implements Iterable<String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2ODA5MQ==", "bodyText": "ne, ich will das eigentlich auch noch entfernen, weil das quatsch ist.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558268091", "createdAt": "2021-01-15T12:14:10Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringType.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.NoArgsConstructor;\n+\n+/**\n+ * Every implementation must guarantee IDs between 0 and size.\n+ *\n+ * Abstract\n+ */\n+@NoArgsConstructor\n+public abstract class StringType extends ColumnStore<Integer> implements Iterable<String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMTg0OQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQ0NjY4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDo1OTozMFrOIUXy0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNTowMTozMlrOIUf1uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMjI3Mw==", "bodyText": "Sollte ein Store nach seiner bef\u00fcllung noch mutable sein?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558232273", "createdAt": "2021-01-15T10:59:30Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2ODQ5OA==", "bodyText": "W\u00e4re mir lieber wenn nicht, aber das DictionaryMapping erzwingt das, bzw dann m\u00fcssten wir ihn komplett neu schreiben. und das w\u00fcrde auch ein paar andere methoden komplizieren.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558268498", "createdAt": "2021-01-15T12:15:14Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMjI3Mw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2NDA4OQ==", "bodyText": "okay, wenn er n\u00e4mlich immutable w\u00e4re, dann w\u00fcrde es das hier nicht geben", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558364089", "createdAt": "2021-01-15T15:01:32Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.bakdata.conquery.models.events.stores;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+import javax.annotation.CheckForNull;\n+\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+@ToString\n+public abstract class ColumnStore<JAVA_TYPE> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMjI3Mw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQ1NzY5OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTowMjo1MFrOIUX5cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxMzowNjo1MlrOIdgXfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzk3MA==", "bodyText": "Oder erstmal eine DictionaryId, dann musst du sie dir nicht immer wieder zusammen bauen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558233970", "createdAt": "2021-01-15T11:02:50Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2Njk5OQ==", "bodyText": "Das ist die gleiche implementierung wie du sie letztens f\u00fcr develop schon gemacht hast? :D", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558366999", "createdAt": "2021-01-15T15:06:29Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzk3MA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2ODQyMA==", "bodyText": "resemblance is uncanny", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558368420", "createdAt": "2021-01-15T15:08:23Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzk3MA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgwOTcyNA==", "bodyText": "Das kann man noch aggressiver mit IdSystem machen, w\u00fcrde ich mir aber f\u00fcr einen weiteren PR aufsparen.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567809724", "createdAt": "2021-02-01T13:06:31Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzk3MA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgwOTkxNg==", "bodyText": "Indem man in 2 Phasen importiert, kann man die Dictionaries ohne gehudel einfach decoden.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567809916", "createdAt": "2021-02-01T13:06:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzk3MA=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQ2MjI3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTowNDoxM1rOIUX8Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwNzozNjowM1rOIVc2dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNDY3NQ==", "bodyText": "bekommst du name, bzw. die id,  nicht aus dem dictionary", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558234675", "createdAt": "2021-01-15T11:04:13Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;\n+\n+\t@InternalOnly\n+\tprivate DatasetId dataset;\n+\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, Dictionary dictionary, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.dictionary = dictionary;\n+\t\tthis.name = name;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM3MjUwNA==", "bodyText": "Musste gerade selber nachschauen, warum ich das so komisch mache: Die Id des Dictionaries ist erst sehr sp\u00e4t bekannt, und dann dient das hier als JsonCreator. Wenn wir die Dictionaries in NsIdRef bekommen kann das weg.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558372504", "createdAt": "2021-01-15T15:14:32Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;\n+\n+\t@InternalOnly\n+\tprivate DatasetId dataset;\n+\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, Dictionary dictionary, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.dictionary = dictionary;\n+\t\tthis.name = name;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNDY3NQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MzcwMQ==", "bodyText": "Aber ich glaube, dass du dir ein sp\u00e4ter einen Neuimport sparen kannst, wenn du jetzt schon direkt die Id (de)serialisieren l\u00e4sst, an statt sie dir selber zusammen zu bauen", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r559363701", "createdAt": "2021-01-18T07:36:03Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;\n+\n+\t@InternalOnly\n+\tprivate DatasetId dataset;\n+\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, Dictionary dictionary, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.dictionary = dictionary;\n+\t\tthis.name = name;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNDY3NQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDQ2NzQ1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTowNTozMlrOIUX_HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNTowOTowMlrOIUgIXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNTQyMQ==", "bodyText": "Wann w\u00fcrde man diese Funktion nehmen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558235421", "createdAt": "2021-01-15T11:05:32Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;\n+\n+\t@InternalOnly\n+\tprivate DatasetId dataset;\n+\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, Dictionary dictionary, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.dictionary = dictionary;\n+\t\tthis.name = name;\n+\t}\n+\n+\t@JsonCreator\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, DatasetId dataset, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.name = name;\n+\t\tthis.dataset = dataset;\n+\t}\n+\n+\t@Override\n+\tpublic Object createScriptValue(Integer value) {\n+\t\treturn getElement(value);\n+\t}\n+\n+\tpublic byte[] getElement(int value) {\n+\t\treturn dictionary.getElement(value);\n+\t}\n+\n+\t@Override\n+\tpublic Object createPrintValue(Integer value) {\n+\t\treturn getElement(value);\n+\t}\n+\n+\n+\tpublic void loadDictionaries(NamespacedStorage storage) {\n+\t\t// todo consider implementing this with Id-Injection instead of hand-wiring.\n+\t\tfinal DictionaryId dictionaryId = new DictionaryId(getDataset(), getName());\n+\t\tlog.trace(\"Loading Dictionary[{}]\", dictionaryId);\n+\t\tdictionary = Objects.requireNonNull(storage.getDictionary(dictionaryId));\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn dictionary.size();\n+\t}\n+\n+\tpublic int getId(byte[] value) {\n+\t\treturn dictionary.getId(value);\n+\t}\n+\n+\tpublic Iterator<byte[]> iterator() {\n+\t\tif(dictionary == null){\n+\t\t\treturn Collections.emptyIterator();\n+\t\t}\n+\n+\t\treturn Iterators.transform(dictionary.iterator(), DictionaryEntry::getValue);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"StringTypeDictionary[dictionary=\" + dictionary + \", numberType=\" + numberType + \"]\";\n+\t}\n+\n+\t@Override\n+\tpublic long estimateTypeSize() {\n+\t\treturn dictionary.estimateMemoryConsumption();\n+\t}\n+\n+\n+\tpublic void setUnderlyingDictionary(DictionaryId newDict) {\n+\t\tname = newDict.getDictionary();\n+\t\tthis.dataset = newDict.getDataset();\n+\t}\n+\n+\t@Override\n+\tpublic StringTypeDictionary select(int[] starts, int[] length) {\n+\t\treturn new StringTypeDictionary(numberType.select(starts, length), getDataset(), getName());\n+\t}\n+\n+\t@Override\n+\tpublic int getString(int event) {\n+\t\treturn (int) getNumberType().getInteger(event);\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn numberType.estimateEventBits();\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tif (value == null) {\n+\t\t\tnumberType.set(event, null);\n+\t\t}\n+\t\telse {\n+\t\t\tnumberType.set(event, value.longValue());\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic final boolean has(int event) {\n+\t\treturn numberType.has(event);\n+\t}\n+\n+\tpublic void setIndexStore(ColumnStore<Long> newType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2ODg2MQ==", "bodyText": "das passiert wenn das Dictionary neu gemapped wird. Hab doku dran gemacht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558368861", "createdAt": "2021-01-15T15:09:02Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.dictionary.DictionaryEntry;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.Iterators;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Getter\n+@Setter\n+@Slf4j\n+@CPSType(base = ColumnStore.class, id = \"STRING_DICTIONARY\")\n+public class StringTypeDictionary extends ColumnStore<Integer> {\n+\n+\tprotected ColumnStore<Long> numberType;\n+\n+\t@JsonIgnore\n+\tprivate transient Dictionary dictionary;\n+\n+\t// todo use NsIdRef\n+\tprivate String name;\n+\n+\t@InternalOnly\n+\tprivate DatasetId dataset;\n+\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, Dictionary dictionary, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.dictionary = dictionary;\n+\t\tthis.name = name;\n+\t}\n+\n+\t@JsonCreator\n+\tpublic StringTypeDictionary(ColumnStore<Long> numberType, DatasetId dataset, String name) {\n+\t\tthis.numberType = numberType;\n+\t\tthis.name = name;\n+\t\tthis.dataset = dataset;\n+\t}\n+\n+\t@Override\n+\tpublic Object createScriptValue(Integer value) {\n+\t\treturn getElement(value);\n+\t}\n+\n+\tpublic byte[] getElement(int value) {\n+\t\treturn dictionary.getElement(value);\n+\t}\n+\n+\t@Override\n+\tpublic Object createPrintValue(Integer value) {\n+\t\treturn getElement(value);\n+\t}\n+\n+\n+\tpublic void loadDictionaries(NamespacedStorage storage) {\n+\t\t// todo consider implementing this with Id-Injection instead of hand-wiring.\n+\t\tfinal DictionaryId dictionaryId = new DictionaryId(getDataset(), getName());\n+\t\tlog.trace(\"Loading Dictionary[{}]\", dictionaryId);\n+\t\tdictionary = Objects.requireNonNull(storage.getDictionary(dictionaryId));\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn dictionary.size();\n+\t}\n+\n+\tpublic int getId(byte[] value) {\n+\t\treturn dictionary.getId(value);\n+\t}\n+\n+\tpublic Iterator<byte[]> iterator() {\n+\t\tif(dictionary == null){\n+\t\t\treturn Collections.emptyIterator();\n+\t\t}\n+\n+\t\treturn Iterators.transform(dictionary.iterator(), DictionaryEntry::getValue);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"StringTypeDictionary[dictionary=\" + dictionary + \", numberType=\" + numberType + \"]\";\n+\t}\n+\n+\t@Override\n+\tpublic long estimateTypeSize() {\n+\t\treturn dictionary.estimateMemoryConsumption();\n+\t}\n+\n+\n+\tpublic void setUnderlyingDictionary(DictionaryId newDict) {\n+\t\tname = newDict.getDictionary();\n+\t\tthis.dataset = newDict.getDataset();\n+\t}\n+\n+\t@Override\n+\tpublic StringTypeDictionary select(int[] starts, int[] length) {\n+\t\treturn new StringTypeDictionary(numberType.select(starts, length), getDataset(), getName());\n+\t}\n+\n+\t@Override\n+\tpublic int getString(int event) {\n+\t\treturn (int) getNumberType().getInteger(event);\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn numberType.estimateEventBits();\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tif (value == null) {\n+\t\t\tnumberType.set(event, null);\n+\t\t}\n+\t\telse {\n+\t\t\tnumberType.set(event, value.longValue());\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic final boolean has(int event) {\n+\t\treturn numberType.has(event);\n+\t}\n+\n+\tpublic void setIndexStore(ColumnStore<Long> newType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNTQyMQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDUzMzIyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeEncoded.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMToyNjozNVrOIUYm8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNTowOToyMlrOIUgJSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0NTYxNg==", "bodyText": "Ein 1 Byte Encoding w\u00e4re noch cool", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558245616", "createdAt": "2021-01-15T11:26:35Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeEncoded.java", "diffHunk": "@@ -147,35 +75,109 @@ public String next() {\n \t\t\t}\n \t\t};\n \t}\n-\t\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"StringTypeEncoded[encoding=\" + encoding + \", subType=\" + subType + \"]\";\n \t}\n-\t\n+\n \t@Override\n-\tpublic long estimateMemoryBitWidth() {\n-\t\treturn subType.estimateMemoryBitWidth();\n+\tpublic long estimateEventBits() {\n+\t\treturn subType.estimateEventBits();\n \t}\n-\t\n+\n \t@Override\n \tpublic long estimateMemoryConsumption() {\n \t\treturn subType.estimateMemoryConsumption();\n \t}\n-\t\n+\n \t@Override\n \tpublic long estimateTypeSize() {\n \t\treturn subType.estimateTypeSize();\n \t}\n-\t\n+\n \t@Override\n \tpublic Dictionary getUnderlyingDictionary() {\n \t\treturn subType.getDictionary();\n \t}\n-\t\n+\n \t@Override\n-\tpublic void adaptUnderlyingDictionary(Dictionary newDict, VarIntType newNumberType) {\n-\t\tsubType.adaptUnderlyingDictionary(newDict, newNumberType);\n-\t\tthis.setPrimitiveType(newNumberType.getPrimitiveType());\n+\tpublic void setUnderlyingDictionary(DictionaryId newDict) {\n+\t\tsubType.setUnderlyingDictionary(newDict);\n+\t}\n+\n+\t@Override\n+\tpublic void setIndexStore(ColumnStore<Long> newType) {\n+\t\tsubType.setIndexStore(newType);\n+\t}\n+\n+\t@Override\n+\tpublic StringTypeEncoded select(int[] starts, int[] length) {\n+\t\treturn new StringTypeEncoded(subType.select(starts, length), getEncoding());\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tsubType.set(event, value);\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic int getString(int event) {\n+\t\treturn subType.getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic boolean has(int event) {\n+\t\treturn subType.has(event);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Encoding {\n+\t\t// Order is for precedence, least specific encodings go last.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM2OTA5Nw==", "bodyText": "Was meinst du?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558369097", "createdAt": "2021-01-15T15:09:22Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeEncoded.java", "diffHunk": "@@ -147,35 +75,109 @@ public String next() {\n \t\t\t}\n \t\t};\n \t}\n-\t\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"StringTypeEncoded[encoding=\" + encoding + \", subType=\" + subType + \"]\";\n \t}\n-\t\n+\n \t@Override\n-\tpublic long estimateMemoryBitWidth() {\n-\t\treturn subType.estimateMemoryBitWidth();\n+\tpublic long estimateEventBits() {\n+\t\treturn subType.estimateEventBits();\n \t}\n-\t\n+\n \t@Override\n \tpublic long estimateMemoryConsumption() {\n \t\treturn subType.estimateMemoryConsumption();\n \t}\n-\t\n+\n \t@Override\n \tpublic long estimateTypeSize() {\n \t\treturn subType.estimateTypeSize();\n \t}\n-\t\n+\n \t@Override\n \tpublic Dictionary getUnderlyingDictionary() {\n \t\treturn subType.getDictionary();\n \t}\n-\t\n+\n \t@Override\n-\tpublic void adaptUnderlyingDictionary(Dictionary newDict, VarIntType newNumberType) {\n-\t\tsubType.adaptUnderlyingDictionary(newDict, newNumberType);\n-\t\tthis.setPrimitiveType(newNumberType.getPrimitiveType());\n+\tpublic void setUnderlyingDictionary(DictionaryId newDict) {\n+\t\tsubType.setUnderlyingDictionary(newDict);\n+\t}\n+\n+\t@Override\n+\tpublic void setIndexStore(ColumnStore<Long> newType) {\n+\t\tsubType.setIndexStore(newType);\n+\t}\n+\n+\t@Override\n+\tpublic StringTypeEncoded select(int[] starts, int[] length) {\n+\t\treturn new StringTypeEncoded(subType.select(starts, length), getEncoding());\n+\t}\n+\n+\t@Override\n+\tpublic void set(int event, Integer value) {\n+\t\tsubType.set(event, value);\n+\t}\n+\n+\t@Override\n+\tpublic Integer get(int event) {\n+\t\treturn getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic int getString(int event) {\n+\t\treturn subType.getString(event);\n+\t}\n+\n+\t@Override\n+\tpublic boolean has(int event) {\n+\t\treturn subType.has(event);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Encoding {\n+\t\t// Order is for precedence, least specific encodings go last.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0NTYxNg=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDUzOTc0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypePrefixSuffix.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMToyODozN1rOIUYq2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMToyODozN1rOIUYq2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0NjYxOA==", "bodyText": "prefix +suffix", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558246618", "createdAt": "2021-01-15T11:28:37Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypePrefixSuffix.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package com.bakdata.conquery.models.events.stores.specific.string;\n+\n+import java.util.Iterator;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.xodus.NamespacedStorage;\n+import com.bakdata.conquery.models.dictionary.Dictionary;\n+import com.bakdata.conquery.models.events.stores.ColumnStore;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DictionaryId;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@Getter\n+@Setter\n+@CPSType(base = ColumnStore.class, id = \"STRING_PREFIX\")\n+@ToString(of = {\"prefix\", \"suffix\", \"subType\"})\n+public class StringTypePrefixSuffix extends StringType {\n+\n+\t@Nonnull\n+\tprotected StringType subType;\n+\n+\t@NonNull\n+\tprivate String prefix;\n+\n+\t@NonNull\n+\tprivate String suffix;\n+\n+\t@JsonCreator\n+\tpublic StringTypePrefixSuffix(StringType subType, String prefix, String suffix) {\n+\t\tsuper();\n+\t\tthis.subType = subType;\n+\t\tthis.prefix = prefix;\n+\t\tthis.suffix = suffix;\n+\t}\n+\n+\t@Override\n+\tpublic String getElement(int value) {\n+\t\treturn prefix + subType.getElement(value) + suffix;\n+\t}\n+\n+\t@Override\n+\tpublic String createScriptValue(Integer value) {\n+\t\treturn prefix + subType.createScriptValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic int getId(String value) {\n+\t\tif (value.startsWith(prefix)) {\n+\t\t\treturn subType.getId(value.substring(prefix.length()));\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\t@Override\n+\tpublic void setIndexStore(ColumnStore<Long> indexStore) {\n+\t\tsubType.setIndexStore(indexStore);\n+\t}\n+\n+\t@Override\n+\tpublic Iterator<String> iterator() {\n+\t\tIterator<String> subIt = subType.iterator();\n+\t\treturn new Iterator<String>() {\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn subIt.hasNext();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String next() {\n+\t\t\t\treturn prefix + subIt.next();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\n+\t@Override\n+\tpublic StringTypePrefixSuffix select(int[] starts, int[] length) {\n+\t\treturn new StringTypePrefixSuffix(subType.select(starts, length), getPrefix(), getSuffix());\n+\t}\n+\n+\t@Override\n+\tpublic void loadDictionaries(NamespacedStorage storage) {\n+\t\tsubType.loadDictionaries(storage);\n+\t}\n+\n+\t@Override\n+\tpublic int size() {\n+\t\treturn subType.size();\n+\t}\n+\n+\t@Override\n+\tpublic long estimateEventBits() {\n+\t\treturn subType.estimateEventBits();\n+\t}\n+\n+\t@Override\n+\tpublic long estimateMemoryConsumption() {\n+\t\treturn subType.estimateMemoryConsumption();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDU0NzQwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTozMTowOVrOIUYvfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjoxNjozOFrOIUaCtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0NzgwNQ==", "bodyText": "Das ist von einem anderen Feature oder?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558247805", "createdAt": "2021-01-15T11:31:09Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "diffHunk": "@@ -99,18 +104,29 @@ private void calculateEntityDateIndices(CBlock cBlock, Bucket bucket) {\n \n \t\t\t\tCDateRange range = bucket.getAsDateRange(entry.getEvent(), column);\n \n-\t\t\t\tcBlock.getMinDate()[entry.getLocalEntity()] = Math.min(cBlock.getMinDate()[entry.getLocalEntity()], range.getMinValue());\n+\t\t\t\tif (range.hasLowerBound()) {\n+\t\t\t\t\tint min = Math.min(\n+\t\t\t\t\t\t\tcBlock.getMinDate().getOrDefault(entry.getEntity(), Integer.MAX_VALUE),\n+\t\t\t\t\t\t\trange.getMinValue()\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tcBlock.getMinDate()\n+\t\t\t\t\t\t  .put(entry.getEntity(), min);\n+\t\t\t\t}\n+\n+\t\t\t\tif (range.hasUpperBound()) {\n+\t\t\t\t\tint max = Math.max(\n+\t\t\t\t\t\t\tcBlock.getMaxDate().getOrDefault(entry.getEntity(), Integer.MIN_VALUE),\n+\t\t\t\t\t\t\trange.getMaxValue()\n+\t\t\t\t\t);\n \n-\t\t\t\tcBlock.getMaxDate()[entry.getLocalEntity()] = Math.max(cBlock.getMaxDate()[entry.getLocalEntity()], range.getMaxValue());\n+\t\t\t\t\tcBlock.getMaxDate()\n+\t\t\t\t\t\t  .put(entry.getEntity(), max);\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2OTExMQ==", "bodyText": "ne das ist der gleiche code wie davor, aber ohne dieses localEntity gehudel", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558269111", "createdAt": "2021-01-15T12:16:38Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/jobs/CalculateCBlocksJob.java", "diffHunk": "@@ -99,18 +104,29 @@ private void calculateEntityDateIndices(CBlock cBlock, Bucket bucket) {\n \n \t\t\t\tCDateRange range = bucket.getAsDateRange(entry.getEvent(), column);\n \n-\t\t\t\tcBlock.getMinDate()[entry.getLocalEntity()] = Math.min(cBlock.getMinDate()[entry.getLocalEntity()], range.getMinValue());\n+\t\t\t\tif (range.hasLowerBound()) {\n+\t\t\t\t\tint min = Math.min(\n+\t\t\t\t\t\t\tcBlock.getMinDate().getOrDefault(entry.getEntity(), Integer.MAX_VALUE),\n+\t\t\t\t\t\t\trange.getMinValue()\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tcBlock.getMinDate()\n+\t\t\t\t\t\t  .put(entry.getEntity(), min);\n+\t\t\t\t}\n+\n+\t\t\t\tif (range.hasUpperBound()) {\n+\t\t\t\t\tint max = Math.max(\n+\t\t\t\t\t\t\tcBlock.getMaxDate().getOrDefault(entry.getEntity(), Integer.MIN_VALUE),\n+\t\t\t\t\t\t\trange.getMaxValue()\n+\t\t\t\t\t);\n \n-\t\t\t\tcBlock.getMaxDate()[entry.getLocalEntity()] = Math.max(cBlock.getMaxDate()[entry.getLocalEntity()], range.getMaxValue());\n+\t\t\t\t\tcBlock.getMaxDate()\n+\t\t\t\t\t\t  .put(entry.getEntity(), max);\n+\t\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0NzgwNQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDU4MjQxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/DateRestrictingNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo0MjoyMFrOIUZEVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo0MjoyMFrOIUZEVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1MzE0Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558253142", "createdAt": "2021-01-15T11:42:20Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/specific/DateRestrictingNode.java", "diffHunk": "@@ -56,26 +56,24 @@ public void nextTable(QueryExecutionContext ctx, TableId currentTable) {\n \tpublic boolean isOfInterest(Bucket bucket) {\n \t\tCBlock cBlock = Objects.requireNonNull(preCurrentRow.get(bucket.getId()));\n \n-\t\tif(validityDateColumn == null) {\n+\t\tif (validityDateColumn == null) {\n \t\t\t// If there is no validity date set for a concept there is nothing to restrict\n \t\t\treturn true;\n \t\t}\n \n-\t\tint localId = bucket.toLocal(entity.getId());\n+\t\tint entityId = entity.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDU5MzY2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/resources/admin/ui/DatasetsUIResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo0NjowMFrOIUZK7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo0NjowMFrOIUZK7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NDgyOA==", "bodyText": "Ich wusste nicht, dass es hierf\u00fcr templates gibt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558254828", "createdAt": "2021-01-15T11:46:00Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/resources/admin/ui/DatasetsUIResource.java", "diffHunk": "@@ -100,6 +102,16 @@ public View getDataset() {\n \t\t);\n \t}\n \n+\t@GET\n+\t@Path(\"mapping\")\n+\tpublic View getIdMapping() {\n+\t\tPersistentIdMap mapping = namespace.getStorage().getIdMapping();\n+\t\tif (mapping != null && mapping.getCsvIdToExternalIdMap() != null) {\n+\t\t\treturn new UIView<>(\"idmapping.html.ftl\", processor.getUIContext(), mapping.getCsvIdToExternalIdMap());\n+\t\t}\n+\t\treturn new UIView<>(\"add_idmapping.html.ftl\", processor.getUIContext(), namespace.getDataset().getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDYwNjU4OnYy", "diffSide": "LEFT", "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo1MDowMFrOIUZSew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNDozMzoxOVrOIUerKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1Njc2Mw==", "bodyText": "Den wollen wir einfach nicht mehr?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558256763", "createdAt": "2021-01-15T11:50:00Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +0,0 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2OTM4MA==", "bodyText": "Der hat die Code Generierung getestet", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558269380", "createdAt": "2021-01-15T12:17:09Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +0,0 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1Njc2Mw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2OTQ0Mg==", "bodyText": "Die es jetzt nicht mehr gibt", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558269442", "createdAt": "2021-01-15T12:17:16Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +0,0 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1Njc2Mw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM0NTAwMA==", "bodyText": "Stimmt \ud83d\ude48", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558345000", "createdAt": "2021-01-15T14:33:19Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/generation/GenerationTests.java", "diffHunk": "@@ -1,290 +0,0 @@\n-package com.bakdata.conquery.models.events.generation;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatCode;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.math.BigDecimal;\n-import java.time.LocalDate;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import com.bakdata.conquery.io.jackson.serializer.SerializationTestUtil;\n-import com.bakdata.conquery.models.common.CDate;\n-import com.bakdata.conquery.models.config.ConqueryConfig;\n-import com.bakdata.conquery.models.config.ParserConfig;\n-import com.bakdata.conquery.models.datasets.Column;\n-import com.bakdata.conquery.models.datasets.Import;\n-import com.bakdata.conquery.models.datasets.ImportColumn;\n-import com.bakdata.conquery.models.events.Bucket;\n-import com.bakdata.conquery.models.exceptions.JSONException;\n-import com.bakdata.conquery.models.identifiable.CentralRegistry;\n-import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n-import com.bakdata.conquery.models.identifiable.ids.specific.TableId;\n-import com.bakdata.conquery.models.types.MajorTypeId;\n-import com.bakdata.conquery.models.types.parser.Decision;\n-import com.bakdata.conquery.models.types.parser.Parser;\n-import com.bakdata.conquery.models.types.parser.specific.string.StringParser;\n-import com.bakdata.conquery.models.types.specific.AStringType;\n-import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.output.NullOutputStream;\n-import org.assertj.core.data.Offset;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-@Slf4j\n-public class GenerationTests {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1Njc2Mw=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDYxMDU1OnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/events/parser/specific/DecimalParserTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo1MToxNlrOIUZU0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjoxNzoyMlrOIUaEOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NzM2MQ==", "bodyText": "\ud83e\udd14", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558257361", "createdAt": "2021-01-15T11:51:16Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/parser/specific/DecimalParserTest.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.bakdata.conquery.models.events.parser.specific;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import org.junit.jupiter.api.Test;\n+\n+class DecimalParserTest {\n+\n+\t@Test\n+\tpublic void test(){\n+\t\tfinal DecimalParser parser = new DecimalParser(new ParserConfig());\n+\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2OTQ5Nw==", "bodyText": "oh", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558269497", "createdAt": "2021-01-15T12:17:22Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/parser/specific/DecimalParserTest.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.bakdata.conquery.models.events.parser.specific;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import org.junit.jupiter.api.Test;\n+\n+class DecimalParserTest {\n+\n+\t@Test\n+\tpublic void test(){\n+\t\tfinal DecimalParser parser = new DecimalParser(new ParserConfig());\n+\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NzM2MQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDYyMTMwOnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/events/stores/types/MajorTypesTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo1NToxMFrOIUZbfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjoxODo1M1rOIUaHXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1OTA2OQ==", "bodyText": "Was genau wird hier getestet?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558259069", "createdAt": "2021-01-15T11:55:10Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/stores/types/MajorTypesTest.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.bakdata.conquery.models.events.stores.types;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.parser.MajorTypeId;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MajorTypesTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3MDMwMg==", "bodyText": "Ah, guter Punkt das war ein alter Test der garantiert, dass es f\u00fcr jeden MajorType funktioniert. Mache Doku dazu", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558270302", "createdAt": "2021-01-15T12:18:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/stores/types/MajorTypesTest.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.bakdata.conquery.models.events.stores.types;\n+\n+import com.bakdata.conquery.models.config.ParserConfig;\n+import com.bakdata.conquery.models.events.parser.MajorTypeId;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MajorTypesTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1OTA2OQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDYyOTYwOnYy", "diffSide": "RIGHT", "path": "backend/src/test/java/com/bakdata/conquery/models/events/stores/types/StringEncodingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo1NzozOVrOIUZgeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMTo1NzozOVrOIUZgeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2MDM0Ng==", "bodyText": "Ist dfas mit dem randomUUID so wichtig? kann man nicht einfach eine neue UUID erzeugen?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558260346", "createdAt": "2021-01-15T11:57:39Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/java/com/bakdata/conquery/models/events/stores/types/StringEncodingTest.java", "diffHunk": "@@ -37,35 +30,43 @@ private UUID randomUUID(Random random) {\n \t\tStringTypeEncoded.Encoding encoding = StringTypeEncoded.Encoding.Base64;\n \n \t\treturn Stream.generate(() -> randomUUID(random).toString().replace(\"-\", \"\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDYzODcyOnYy", "diffSide": "LEFT", "path": "backend/src/test/resources/tests/filter/NUMBER_INTEGER/content_NUMBER_Filter.csv", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjowMDoxNlrOIUZl1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxNTozNjowNFrOIVuQOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2MTcxOQ==", "bodyText": "Der Content ge\u00e4ndert?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558261719", "createdAt": "2021-01-15T12:00:16Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/resources/tests/filter/NUMBER_INTEGER/content_NUMBER_Filter.csv", "diffHunk": "@@ -12,5 +12,3 @@ pid,nr,datum\n 7,,2010-08-14\n 8,,2010-08-15\n 8,200,2012-05-29\n-9,,2010-08-15\n-9,300,2012-05-29", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY0ODgyNA==", "bodyText": "habs r\u00fcckg\u00e4ngig gemacht", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r559648824", "createdAt": "2021-01-18T15:36:04Z", "author": {"login": "awildturtok"}, "path": "backend/src/test/resources/tests/filter/NUMBER_INTEGER/content_NUMBER_Filter.csv", "diffHunk": "@@ -12,5 +12,3 @@ pid,nr,datum\n 7,,2010-08-14\n 8,,2010-08-15\n 8,200,2012-05-29\n-9,,2010-08-15\n-9,300,2012-05-29", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2MTcxOQ=="}, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNDY0NzY0OnYy", "diffSide": "LEFT", "path": "backend/src/test/resources/tests/query/MULTIPLE_TABLES_ICD_QUERY2/arzt-content.csv", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjowMzozMVrOIUZrWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMjowMzozMVrOIUZrWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI2MzEyOA==", "bodyText": "existiert die Datei jetzt noch? github zeigt sie mir gerade nicht als gel\u00f6scht an", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r558263128", "createdAt": "2021-01-15T12:03:31Z", "author": {"login": "thoniTUB"}, "path": "backend/src/test/resources/tests/query/MULTIPLE_TABLES_ICD_QUERY2/arzt-content.csv", "diffHunk": "@@ -1,37 +0,0 @@\n-pid,icd_code,behandlungsquartal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6854c15bd3c37a57b5e915350def055cabd6c28"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3NzY3Mzg0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxMzoyOTo0NFrOIdhTHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxMzoyOTo0NFrOIdhTHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgyNTE4MA==", "bodyText": "shenanigans :D", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567825180", "createdAt": "2021-02-01T13:29:44Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/specific/string/StringTypeDictionary.java", "diffHunk": "@@ -19,6 +19,11 @@\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * Strings are stored in a Dictionary, ids are handles into the Dictionary.\n+ *\n+ * @implNote this is NOT a {@link StringType}, but is the base class of it. This enables some shenanigans with encodings.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3NzY5Mjc1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxMzozNDoxMlrOIdherA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDozMTo0MlrOIdj6Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgyODE0MA==", "bodyText": "Wof\u00fcr ist das notwendig. Ist der resultierende ColumnStore dann valide, wenn er leer ist, aber dennoch Lines hat?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567828140", "createdAt": "2021-02-01T13:34:12Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -51,31 +61,49 @@ public Object createScriptValue(JAVA_TYPE value) {\n \t\treturn value;\n \t}\n \n-\tpublic long estimateMemoryConsumption() {\n+\t/**\n+\t * Calculate estimate of total bytes used by this store.\n+\t */\n+\tpublic long estimateMemoryConsumptionBytes() {\n \t\tlong bits = estimateEventBits();\n \n-\t\treturn getLines() * bits;\n+\t\treturn Math.floorDiv(getLines() * bits, Byte.SIZE);\n \t}\n \n+\t/**\n+\t * Number of bits required to store a single value.\n+\t */\n \tpublic abstract long estimateEventBits();\n \n-\tpublic long estimateTypeSize() {\n+\t/**\n+\t * Bytes required to store auxilary data.\n+\t */\n+\tpublic long estimateTypeSizeBytes() {\n \t\treturn 0;\n \t}\n \n+\n+\tpublic abstract ColumnStore<JAVA_TYPE> doSelect(int[] starts, int[] lengths);\n+\n \t/**\n \t * Select the partition of this store.\n \t * The returning store has to accept queries up to {@code sum(lenghts)}, values may not be reordered.\n \t */\n-\tpublic abstract ColumnStore<JAVA_TYPE> select(int[] starts, int[] lengths);\n+\tpublic ColumnStore<JAVA_TYPE> select(int[] starts, int[] lengths){\n+\t\t//TODO FK: this is just WIP as getLines is only used for isEmpty and AdminEnd description, but detangling requires a lot of refactoring.\n+\t\tfinal ColumnStore<JAVA_TYPE> select = doSelect(starts, lengths);\n+\t\tselect.setLines(Arrays.stream(lengths).sum());\n+\t\treturn select;\n+\t}\n+\n+\n \n \t/**\n \t * Create an empty store that's only a description of the transformation.\n \t */\n \tpublic ColumnStore<JAVA_TYPE> createDescription() {\n-\t\tfinal ColumnStore<JAVA_TYPE> select = select(new int[0], new int[0]);\n+\t\tfinal ColumnStore<JAVA_TYPE> select = doSelect(new int[0], new int[0]);\n \t\tselect.setLines(getLines());\n-\t\tselect.setNullLines(getNullLines());\n \t\treturn select;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg2Nzk4Nw==", "bodyText": "Ist nur eine description, deswegen ist das auch so komisch gewrapped. das will ich anders l\u00f6sen.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567867987", "createdAt": "2021-02-01T14:31:42Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/stores/ColumnStore.java", "diffHunk": "@@ -51,31 +61,49 @@ public Object createScriptValue(JAVA_TYPE value) {\n \t\treturn value;\n \t}\n \n-\tpublic long estimateMemoryConsumption() {\n+\t/**\n+\t * Calculate estimate of total bytes used by this store.\n+\t */\n+\tpublic long estimateMemoryConsumptionBytes() {\n \t\tlong bits = estimateEventBits();\n \n-\t\treturn getLines() * bits;\n+\t\treturn Math.floorDiv(getLines() * bits, Byte.SIZE);\n \t}\n \n+\t/**\n+\t * Number of bits required to store a single value.\n+\t */\n \tpublic abstract long estimateEventBits();\n \n-\tpublic long estimateTypeSize() {\n+\t/**\n+\t * Bytes required to store auxilary data.\n+\t */\n+\tpublic long estimateTypeSizeBytes() {\n \t\treturn 0;\n \t}\n \n+\n+\tpublic abstract ColumnStore<JAVA_TYPE> doSelect(int[] starts, int[] lengths);\n+\n \t/**\n \t * Select the partition of this store.\n \t * The returning store has to accept queries up to {@code sum(lenghts)}, values may not be reordered.\n \t */\n-\tpublic abstract ColumnStore<JAVA_TYPE> select(int[] starts, int[] lengths);\n+\tpublic ColumnStore<JAVA_TYPE> select(int[] starts, int[] lengths){\n+\t\t//TODO FK: this is just WIP as getLines is only used for isEmpty and AdminEnd description, but detangling requires a lot of refactoring.\n+\t\tfinal ColumnStore<JAVA_TYPE> select = doSelect(starts, lengths);\n+\t\tselect.setLines(Arrays.stream(lengths).sum());\n+\t\treturn select;\n+\t}\n+\n+\n \n \t/**\n \t * Create an empty store that's only a description of the transformation.\n \t */\n \tpublic ColumnStore<JAVA_TYPE> createDescription() {\n-\t\tfinal ColumnStore<JAVA_TYPE> select = select(new int[0], new int[0]);\n+\t\tfinal ColumnStore<JAVA_TYPE> select = doSelect(new int[0], new int[0]);\n \t\tselect.setLines(getLines());\n-\t\tselect.setNullLines(getNullLines());\n \t\treturn select;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgyODE0MA=="}, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3Nzg3NTMwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/IntegerParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDoxNjoyMlrOIdjN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDozMDoxNlrOIdj2hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1NjYyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif(maxValue == Integer.MAX_VALUE){\n          \n          \n            \n            \t\tif(maxValue >= Integer.MAX_VALUE){\n          \n      \n    \n    \n  \n\nNur dass es mich beruhigt, weil maxValue  ein Long ist", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567856624", "createdAt": "2021-02-01T14:16:22Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/IntegerParser.java", "diffHunk": "@@ -87,6 +87,10 @@ protected void registerValue(Long v) {\n \t\t\treturn new RebasingStore(minValue, Integer.MIN_VALUE, IntegerStore.create(getLines()));\n \t\t}\n \n+\t\tif(maxValue == Integer.MAX_VALUE){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg2Njg4MQ==", "bodyText": "Ne, das ist falsch maxValue muss Long.MAX_VALUE sein, dann k\u00f6nnen wir es nicht abbilden. deswegen auch das todo, hier auf nullbits umzusteigen, falls n\u00f6tig.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567866881", "createdAt": "2021-02-01T14:30:08Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/IntegerParser.java", "diffHunk": "@@ -87,6 +87,10 @@ protected void registerValue(Long v) {\n \t\t\treturn new RebasingStore(minValue, Integer.MIN_VALUE, IntegerStore.create(getLines()));\n \t\t}\n \n+\t\tif(maxValue == Integer.MAX_VALUE){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1NjYyNA=="}, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg2NzAxMg==", "bodyText": "Habs behoben", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567867012", "createdAt": "2021-02-01T14:30:16Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/IntegerParser.java", "diffHunk": "@@ -87,6 +87,10 @@ protected void registerValue(Long v) {\n \t\t\treturn new RebasingStore(minValue, Integer.MIN_VALUE, IntegerStore.create(getLines()));\n \t\t}\n \n+\t\tif(maxValue == Integer.MAX_VALUE){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1NjYyNA=="}, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3Nzg4NTIzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/DateParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDoxODoyM1rOIdjTyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNDozMjoxM1rOIdj7lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1ODEyMg==", "bodyText": "dateStore.setLines(getLines()); delegated nicht an den unterliegenden store?", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567858122", "createdAt": "2021-02-01T14:18:23Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/DateParser.java", "diffHunk": "@@ -47,6 +47,9 @@ public Integer addLine(Integer v) {\n \t@Override\n \tprotected DateStore decideType() {\n \t\tColumnStore<Long> subDecision = subType.findBestType();\n-\t\treturn new DateStore(subDecision);\n+\t\tsubDecision.setLines(getLines());\n+\t\tfinal DateStore dateStore = new DateStore(subDecision);\n+\t\tdateStore.setLines(getLines());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg2ODMwOQ==", "bodyText": "Nein, weil die Info eigentlich egal ist, das wird direkt der Folge PR das umzubauen.", "url": "https://github.com/bakdata/conquery/pull/1431#discussion_r567868309", "createdAt": "2021-02-01T14:32:13Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/events/parser/specific/DateParser.java", "diffHunk": "@@ -47,6 +47,9 @@ public Integer addLine(Integer v) {\n \t@Override\n \tprotected DateStore decideType() {\n \t\tColumnStore<Long> subDecision = subType.findBestType();\n-\t\treturn new DateStore(subDecision);\n+\t\tsubDecision.setLines(getLines());\n+\t\tfinal DateStore dateStore = new DateStore(subDecision);\n+\t\tdateStore.setLines(getLines());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg1ODEyMg=="}, "originalCommit": {"oid": "49446e8bf304e9fe2868b0a7873d0494ba9b1538"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1534, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}