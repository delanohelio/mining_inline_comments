{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwMzAxMjgz", "number": 1058, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMzozNVrODjKiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjowMTo0OVrODjb_YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTk5MzkwOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/QueryProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMzozNVrOFu0hLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMzozNVrOFu0hLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzOTI3OA==", "bodyText": "Kannst du evtl 5min \u00fcberlegen, ob man das Dataset auch komplett aus der Query kriegt und dann in der Ausf\u00fchrung erst aufl\u00f6st?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384639278", "createdAt": "2020-02-26T17:13:35Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/QueryProcessor.java", "diffHunk": "@@ -65,43 +66,53 @@ public ExecutionStatus postQuery(Dataset dataset, IQuery query, URLBuilder urlb,\n \t\t\t}\n \t\t}\n \t\t\n-\t\tManagedQuery mq = namespace.getQueryManager().runQuery(query, user);\n \n+\t\tManagedExecution<?> mq = ExecutionManager.runQuery(storage, namespaces, query, user.getId(), dataset.getId());\n \t\t// Set abilities for submitted query\n \t\tuser.addPermission(storage, QueryPermission.onInstance(AbilitySets.QUERY_CREATOR, mq.getId()));\n \n+\t\tif(query instanceof IQuery) {\n+\t\t\ttranslateToOtherDatasets(dataset, query, user, mq);\n+\t\t}\n+\n+\t\t// return status\n+\t\treturn getStatus(dataset, mq, urlb, user);\n+\t}\n+\n+\tprivate void translateToOtherDatasets(Dataset dataset, SubmittedQuery query, User user, ManagedExecution<?> mq) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjAwMDkyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/Form.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxNToxNVrOFu0lSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxNToxNVrOFu0lSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDMyOQ==", "bodyText": "semicolon", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384640329", "createdAt": "2020-02-26T17:15:15Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/Form.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.bakdata.conquery.apiv1.forms;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.permissions.Ability;\n+import com.bakdata.conquery.models.auth.permissions.FormPermission;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+\n+/**\n+ * API representation of a form query.\n+ */\n+@Getter\n+@Setter\n+public abstract class Form implements SubmittedQuery {\n+\n+\tpublic abstract Map<String, List<ManagedQuery>> createSubQueries(Namespaces namespaces, UserId userId, DatasetId submittedDataset);\n+\n+\t/**\n+\t * Executed upon Execution initialization.\n+\t * E.g. Manipulate or add concepts to the form.\n+\t * @param namespaces\n+\t */\n+\tpublic void init(Namespaces namespaces) {\n+\t\t// Do nothing if not necessary\n+\t};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjAxMjI2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/TimeSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxODoxNVrOFu0sSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxODoxNVrOFu0sSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MjEyMw==", "bodyText": "Warum gibt es diese Klasse einfach als kopie der anderen? Wegen den Namen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384642123", "createdAt": "2020-02-26T17:18:15Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/TimeSelector.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.bakdata.conquery.apiv1.forms;\n+\n+import java.util.OptionalInt;\n+\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.query.concept.specific.temporal.TemporalSampler;\n+\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public enum TimeSelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjAyMDM3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/filters/Filter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyMDozNFrOFu0xXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoyMDozNFrOFu0xXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MzQyMQ==", "bodyText": "brauchst das noch?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384643421", "createdAt": "2020-02-26T17:20:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/concepts/filters/Filter.java", "diffHunk": "@@ -43,7 +43,7 @@ public final boolean requiresColumn(Column c) {\n \t\treturn ArrayUtils.contains(getRequiredColumns(), c);\n \t}\n \n-\tpublic abstract FilterNode createAggregator(FE_TYPE filterValue);\n+\tpublic abstract FilterNode createAggregator(FE_TYPE filterValue);//, QueryPlanContext ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d11a5f27695a4b352bd2ef56045805444f9e90"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIwODcyOnYy", "diffSide": "RIGHT", "path": "autodoc/src/main/java/com/bakdata/conquery/handler/GroupHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo0NzozNFrOFvJhVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjozMDozM1rOFvQa4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4MzM4MA==", "bodyText": "these classes?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384983380", "createdAt": "2020-02-27T08:47:34Z", "author": {"login": "awildturtok"}, "path": "autodoc/src/main/java/com/bakdata/conquery/handler/GroupHandler.java", "diffHunk": "@@ -371,6 +372,11 @@ private String printType(Ctx ctx, TypeSignature type) {\n \t\t\t\t\t+ \" to \"\n \t\t\t\t\t+ printType(ctx.withGeneric(true), classRef.getTypeArguments().get(1));\n \t\t\t}\n+\t\t\tif(ClassToInstanceMap.class.isAssignableFrom(cl)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA5NjQxNw==", "bodyText": "Ist ja normaler Weise ein SuperType, sonst w\u00e4re eine ClassToInstanceMap ja immer ein Singelton", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385096417", "createdAt": "2020-02-27T12:30:33Z", "author": {"login": "thoniTUB"}, "path": "autodoc/src/main/java/com/bakdata/conquery/handler/GroupHandler.java", "diffHunk": "@@ -371,6 +372,11 @@ private String printType(Ctx ctx, TypeSignature type) {\n \t\t\t\t\t+ \" to \"\n \t\t\t\t\t+ printType(ctx.withGeneric(true), classRef.getTypeArguments().get(1));\n \t\t\t}\n+\t\t\tif(ClassToInstanceMap.class.isAssignableFrom(cl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4MzM4MA=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIxMzY4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/AbsExportGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo0OToyOFrOFvJkgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo0OToyOFrOFvJkgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NDE5NQ==", "bodyText": "Kannst du nicht noch einen Konstruktor f\u00fcr childQueries machen? Das w\u00fcrde den Code ordentlicher machen", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384984195", "createdAt": "2020-02-27T08:49:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/AbsExportGenerator.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.bakdata.conquery.models.forms.export;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.export_form.AbsoluteMode;\n+import com.bakdata.conquery.models.forms.managed.AbsoluteFormQuery;\n+import com.bakdata.conquery.models.forms.util.ConceptManipulator;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.CQElement;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class AbsExportGenerator {\n+\t\n+\tpublic static AbsoluteFormQuery generate(Namespaces namespaces, AbsoluteMode mode, DateContextMode resolution, UserId userId, DatasetId submittedDataset) {\n+\t\tManagedQuery prerequisite = (ManagedQuery)namespaces.getMetaStorage().getExecution(mode.getForm().getQueryGroup());\n+\t\n+\t\t// Apply defaults to user concept\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getFeatures(), namespaces);\n+\t\t\n+\t\tAbsoluteFormQuery query = new AbsoluteFormQuery(\n+\t\t\t(ConceptQuery) prerequisite.getQuery(),\n+\t\t\tmode.getDateRange(),\n+\t\t\tcreateSubQuery(mode.getFeatures()),\n+\t\t\tresolution\n+\t\t);\n+\t\t\n+\t\treturn query;\n+\t}\n+\t\n+\tpublic static ArrayConceptQuery createSubQuery(List<CQElement> features) {\n+\t\tList<ConceptQuery> cqWraps = features.stream().map(ConceptQuery::new).collect(Collectors.toList());\n+\t\treturn createSubPlanFromQueries(cqWraps);\n+\t}\n+\t\n+\tpublic static ArrayConceptQuery createSubPlanFromQueries(List<ConceptQuery> featureQueries) {\n+\t\tArrayConceptQuery subQuery = new ArrayConceptQuery();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIxNzgyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/RelExportGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1MDo0N1rOFvJm-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1MDo0N1rOFvJm-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NDgyNg==", "bodyText": "Die Funktion ist komisch, aber einziehen in das AbsExport w\u00e4re wohl auch nicht gut?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384984826", "createdAt": "2020-02-27T08:50:47Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/export/RelExportGenerator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.bakdata.conquery.models.forms.export;\n+\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.export_form.RelativeMode;\n+import com.bakdata.conquery.models.forms.managed.RelativeFormQuery;\n+import com.bakdata.conquery.models.forms.util.ConceptManipulator;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.concept.specific.ResultInfoDecorator;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.google.common.collect.ImmutableClassToInstanceMap;\n+import lombok.AllArgsConstructor;\n+\n+@AllArgsConstructor\n+public class RelExportGenerator {\n+\t\n+\tpublic static RelativeFormQuery generate(Namespaces namespaces, RelativeMode mode, UserId userId, DatasetId submittedDataset) {\n+\t\tManagedQuery prerequisite = (ManagedQuery)namespaces.getMetaStorage().getExecution(mode.getForm().getQueryGroup());\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getFeatures(), namespaces);\n+\t\tConceptManipulator.DEFAULT_SELECTS_WHEN_EMPTY.consume(mode.getOutcomes(), namespaces);\n+\t\t\n+\t\tRelativeFormQuery query = new RelativeFormQuery(\n+\t\t\t(ConceptQuery) prerequisite.getQuery(),\n+\t\t\tsetInfos(\n+\t\t\t\tAbsExportGenerator.createSubQuery(mode.getFeatures()),\n+\t\t\t\tFeatureGroup.FEATURE\n+\t\t\t),\n+\t\t\tsetInfos(\n+\t\t\t\tAbsExportGenerator.createSubQuery(mode.getOutcomes()),\n+\t\t\t\tFeatureGroup.OUTCOME\n+\t\t\t),\n+\t\t\tmode.getIndexSelector(),\n+\t\t\tmode.getIndexPlacement(),\n+\t\t\tmode.getTimeCountBefore(),\n+\t\t\tmode.getTimeCountAfter(),\n+\t\t\tmode.getTimeUnit()\n+\t\t);\n+\t\treturn query;\n+\t}\n+\t\n+\tprivate static ArrayConceptQuery setInfos(ArrayConceptQuery arrayQuery, FeatureGroup group) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIzMDY4OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/FormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1NDo1NVrOFvJukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjozMjowM1rOFvQdhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Njc3MQ==", "bodyText": "Was macht das?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384986771", "createdAt": "2020-02-27T08:54:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/FormQueryPlan.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.forms.util.DateContext;\n+import com.bakdata.conquery.models.forms.util.ResultModifier;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public class FormQueryPlan implements QueryPlan {\n+\n+\tprivate final List<DateContext> dateContexts;\n+\tprivate final ArrayConceptQueryPlan features;\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tList<Object[]> resultValues = new ArrayList<>(dateContexts.size());\n+\t\t\n+\t\tfor(DateContext dateContext : dateContexts) {\n+\t\t\t\n+\t\t\tCloneContext clCtx = new CloneContext(ctx.getStorage());\n+\t\t\t\t\t\t\n+\t\t\tArrayConceptQueryPlan subPlan = features.clone(clCtx);\n+\t\n+\t\t\tCDateSet dateRestriction = CDateSet.create(ctx.getDateRestriction());\n+\t\t\tdateRestriction.retainAll(dateContext.getDateRange());\n+\t\t\tEntityResult subResult = subPlan.execute(ctx.withDateRestriction(dateRestriction), entity);\n+\t\t\t\n+\t\t\tresultValues.addAll(\n+\t\t\t\tResultModifier.modify(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA5NzA5NA==", "bodyText": "Das packt den DateContext/Restriction an die Ergebniszeile", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385097094", "createdAt": "2020-02-27T12:32:03Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/FormQueryPlan.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.forms.util.DateContext;\n+import com.bakdata.conquery.models.forms.util.ResultModifier;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public class FormQueryPlan implements QueryPlan {\n+\n+\tprivate final List<DateContext> dateContexts;\n+\tprivate final ArrayConceptQueryPlan features;\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tList<Object[]> resultValues = new ArrayList<>(dateContexts.size());\n+\t\t\n+\t\tfor(DateContext dateContext : dateContexts) {\n+\t\t\t\n+\t\t\tCloneContext clCtx = new CloneContext(ctx.getStorage());\n+\t\t\t\t\t\t\n+\t\t\tArrayConceptQueryPlan subPlan = features.clone(clCtx);\n+\t\n+\t\t\tCDateSet dateRestriction = CDateSet.create(ctx.getDateRestriction());\n+\t\t\tdateRestriction.retainAll(dateContext.getDateRange());\n+\t\t\tEntityResult subResult = subPlan.execute(ctx.withDateRestriction(dateRestriction), entity);\n+\t\t\t\n+\t\t\tresultValues.addAll(\n+\t\t\t\tResultModifier.modify(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Njc3MQ=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIzNTgzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1NjoyOFrOFvJxrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1NjoyOFrOFvJxrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4NzU2NQ==", "bodyText": "weg", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384987565", "createdAt": "2020-02-27T08:56:28Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDIzNzc1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1NzowM1rOFvJyzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjo0ODowMlrOFvY2mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Nzg1NA==", "bodyText": "Haben die keine Id o\u00e4 \u00fcber die du sie identifizieren kannst?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384987854", "createdAt": "2020-02-27T08:57:03Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA5Nzg5Ng==", "bodyText": "Ah, ja ich k\u00f6nnte hier eine IdMap nehmen", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385097896", "createdAt": "2020-02-27T12:33:46Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Nzg1NA=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzNDU4NQ==", "bodyText": "Doch nicht, aber f\u00fcr die flat map", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385234585", "createdAt": "2020-02-27T16:48:02Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4Nzg1NA=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDI0MzYyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1ODo1NlrOFvJ2Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1ODo1NlrOFvJ2Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4ODczNQ==", "bodyText": "Kannst du das nicht vereinfachen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384988735", "createdAt": "2020-02-27T08:58:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/ManagedForm.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.URLBuilder;\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.jackson.InternalOnly;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.execution.ExecutionStatus;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.forms.managed.ManagedForm.FormSharedResult;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.ManagedQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.ToString;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Internal runtime representation of a form query.\n+ */\n+//@NoArgsConstructor\n+@Getter\n+@Setter\n+@ToString\n+@Slf4j\n+@CPSType(base = ManagedExecution.class, id = \"MANAGED_FORM\")\n+public class ManagedForm extends ManagedExecution<FormSharedResult> {\n+\t\n+\t/**\n+\t * The form that was submitted through the api.\n+\t */\n+\tprivate Form submittedForm;\n+\t\n+\t@JsonIgnore\n+\tprotected Map<String,List<ManagedQuery>> subQueries;\n+\n+\t@InternalOnly\n+\tprivate Map<ManagedExecutionId,ManagedQuery> flatSubQueries;\n+\t\n+\t@JsonIgnore\n+\tprivate transient AtomicInteger openSubQueries;\n+\t\n+\tpublic ManagedForm(MasterMetaStorage storage, Form submittedForm, UserId owner, DatasetId submittedDataset) {\n+\t\tsuper(storage,  owner, submittedDataset);\n+\t\tthis.submittedForm = submittedForm;\n+\t}\n+\t\n+\n+\n+\t@Override\n+\tpublic void initExecutable(@NonNull Namespaces namespaces) {\n+\t\tsubmittedForm.init(namespaces);\n+\t\t// init all subqueries\n+\t\tsubQueries = submittedForm.createSubQueries(namespaces, super.getOwner(), super.getDataset());\n+\t\tflatSubQueries = subQueries.values().stream().flatMap(List::stream).collect(Collectors.toMap(ManagedQuery::getId, Function.identity()));\n+\t\tflatSubQueries.values().forEach(mq -> mq.initExecutable(namespaces));\n+\t\topenSubQueries = new AtomicInteger(flatSubQueries.values().size());\n+\t}\n+\t\n+\t@Override\n+\tpublic void start() {\n+\t\tflatSubQueries.values().forEach(ManagedQuery::start);\n+\t\tsuper.start();\n+\t}\n+\t\n+\t@Override\n+\tpublic ExecutionStatus buildStatus(URLBuilder url, User user) {\n+\t\tExecutionStatus status = super.buildStatus(url, user);\n+\t\t// Send null here, because no usable value can be reported to the user for a form\n+\t\tstatus.setNumberOfResults(null);\n+\t\treturn status;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ManagedQuery> toResultQuery() {\n+\t\tif(subQueries.size() == 1) {\n+\t\t\t// Get the query, only if there is only one in the whole execution\n+\t\t\treturn subQueries.values().iterator().next();\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Can't return the result query of a multi query form\");\n+\t}\n+\n+\t@Override\n+\tpublic Set<NamespacedId> getUsedNamespacedIds() {\n+\t\tNamespacedIdCollector collector = new NamespacedIdCollector();\n+\n+\t\tfor( Map.Entry<String, List<ManagedQuery>> entry : subQueries.entrySet()) {\n+\t\t\tfor(ManagedQuery subquery : entry.getValue()) {\n+\t\t\t\tsubquery.getQuery().visit(collector);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn collector.getIds();\n+\t}\n+\n+\t// Executed on Worker\n+\t@Override\n+\tpublic Map<ManagedExecutionId,QueryPlan> createQueryPlans(QueryPlanContext context) {\n+\t\tMap<ManagedExecutionId,QueryPlan> plans = new HashMap<>();\n+\t\tfor( ManagedQuery subQuery : flatSubQueries.values()) {\n+\t\t\tplans.putAll(subQuery.createQueryPlans(context));\n+\t\t}\n+\t\treturn plans;\n+\t}\n+\n+\t/**\n+\t * Distribute the result to a sub query.\n+\t */\n+\t@Override\n+\tpublic void addResult(FormSharedResult result) {\n+\t\tManagedQuery subQuery = flatSubQueries.get(result.getSubqueryId());\n+\t\tsubQuery.addResult(result);\n+\t\tswitch(subQuery.getState()) {\n+\t\t\tcase CANCELED:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDI0NjczOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1OTo1NFrOFvJ4LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODo1OTo1NFrOFvJ4LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk4OTIyOA==", "bodyText": "doku", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r384989228", "createdAt": "2020-02-27T08:59:54Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQuery.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import javax.validation.Valid;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.ConqueryConstants;\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeSelector;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.query.IQuery;\n+import com.bakdata.conquery.models.query.QueryPlanContext;\n+import com.bakdata.conquery.models.query.QueryResolveContext;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.ArrayConceptQuery;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@CPSType(id=\"RELATIVE_FORM_QUERY\", base=SubmittedQuery.class)\n+@Getter\n+@RequiredArgsConstructor(onConstructor_=@JsonCreator)\n+public class RelativeFormQuery extends IQuery {\n+\t@NotNull @Valid\n+\tprivate final ConceptQuery query;\n+\t@NotNull @Valid\n+\tprivate final ArrayConceptQuery features;\n+\t@NotNull @Valid\n+\tprivate final ArrayConceptQuery outcomes;\n+\t@NotNull\n+\tprivate final TimeSelector indexSelector;\n+\t@NotNull\n+\tprivate final IndexPlacement indexPlacement;\n+\t@Min(0)\n+\tprivate final int timeCountBefore;\n+\t@Min(0)\n+\tprivate final int timeCountAfter;\n+\t@NotNull\n+\tprivate final TimeUnit timeUnit;\n+\t\n+\t@Override\n+\tpublic RelativeFormQuery resolve(QueryResolveContext context) {\n+\t\treturn new RelativeFormQuery(\n+\t\t\tquery.resolve(context),\n+\t\t\tfeatures.resolve(context),\n+\t\t\toutcomes.resolve(context),\n+\t\t\tindexSelector,\n+\t\t\tindexPlacement,\n+\t\t\ttimeCountBefore,\n+\t\t\ttimeCountAfter,\n+\t\t\ttimeUnit\n+\t\t);\n+\t}\n+\t\n+\t@Override\n+\tpublic RelativeFormQueryPlan createQueryPlan(QueryPlanContext context) {\n+\t\treturn new RelativeFormQueryPlan(\n+\t\t\tquery.createQueryPlan(context.withGenerateSpecialDateUnion(true)),\n+\t\t\tfeatures.createQueryPlan(context.withGenerateSpecialDateUnion(false)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDMzOTMzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyNzo1OFrOFvKxww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyNzo1OFrOFvKxww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMzk3MQ==", "bodyText": "Das - 2 solltest du begr\u00fcnden", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385003971", "createdAt": "2020-02-27T09:27:58Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package com.bakdata.conquery.models.forms.managed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeSelector;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.forms.util.DateContext;\n+import com.bakdata.conquery.models.query.QueryExecutionContext;\n+import com.bakdata.conquery.models.query.entity.Entity;\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.ConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.clone.CloneContext;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.query.results.MultilineContainedEntityResult;\n+import com.bakdata.conquery.models.query.results.SinglelineContainedEntityResult;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+@Getter @RequiredArgsConstructor\n+public class RelativeFormQueryPlan implements QueryPlan {\n+\n+\tprivate final ConceptQueryPlan query;\n+\tprivate final ArrayConceptQueryPlan featurePlan;\n+\tprivate final ArrayConceptQueryPlan outcomePlan;\n+\tprivate final TimeSelector indexSelector;\n+\tprivate final IndexPlacement indexPlacement;\n+\tprivate final int timeCountBefore;\n+\tprivate final int timeCountAfter;\n+\tprivate final TimeUnit timeUnit;\n+\n+\t@Override\n+\tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tEntityResult preResult = query.execute(ctx, entity);\n+\t\tif (preResult.isFailed() || !preResult.isContained()) {\n+\t\t\treturn preResult;\n+\t\t}\n+\n+\t\tSinglelineContainedEntityResult contained = (SinglelineContainedEntityResult) preResult;\n+\t\tCDateSet dateSet = CDateSet.parse(Objects.toString(contained.getValues()[0]));\n+\t\tfinal OptionalInt sampled = indexSelector.sample(dateSet);\n+\n+\t\t// dateset is empty or sampling failed.\n+\t\tif (!sampled.isPresent()) {\n+\t\t\tlog.warn(\"Sampled empty result for Entity[{}]: `{}({})`\", contained.getEntityId(), indexSelector, dateSet);\n+\t\t\treturn preResult;\n+\t\t}\n+\n+\t\tint sample = sampled.getAsInt();\n+\t\tList<DateContext> contexts = DateContext\n+\t\t\t.generateRelativeContexts(sample, indexPlacement, timeCountBefore, timeCountAfter, true, timeUnit);\n+\n+\t\tSubResult featureResult = executeSubQuery(ctx, FeatureGroup.FEATURE, entity, contexts);\n+\t\tSubResult outcomeResult = executeSubQuery(ctx, FeatureGroup.OUTCOME, entity, contexts);\n+\n+\t\tList<Object[]> values = new ArrayList<>();\n+\t\tint featureLength = featureResult.getValues().get(0).length;\n+\t\tint outcomeLength = outcomeResult.getValues().get(0).length;\n+\t\tint size = featureLength + outcomeLength - 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM0Mzc1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ConceptManipulator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyOTowN1rOFvK0cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyOTowN1rOFvK0cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDY1Nw==", "bodyText": "Klammern", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385004657", "createdAt": "2020-02-27T09:29:07Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ConceptManipulator.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.List;\n+\n+import com.bakdata.conquery.models.forms.util.DefaultSelectConceptManipulator.FillMethod;\n+import com.bakdata.conquery.models.query.Visitable;\n+import com.bakdata.conquery.models.query.concept.CQElement;\n+import com.bakdata.conquery.models.query.concept.specific.CQConcept;\n+import com.bakdata.conquery.models.query.visitor.QueryVisitor;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+\n+public interface ConceptManipulator {\n+\t// Often used manipulators, that can be statically instantiated\n+\tpublic final static ConceptManipulator DEFAULT_SELECTS_WHEN_EMPTY = new DefaultSelectConceptManipulator(FillMethod.ADD_TO_COMPLETE_EMPTY);\n+\t\n+\tvoid consume(CQConcept concept, Namespaces namespaces);\n+\t\n+\tdefault void consume(List<? extends CQElement> userFeatures, Namespaces namespaces) {\n+\t\tfor(CQElement feature : userFeatures) {\n+\t\t\tfeature.visit(new QueryVisitor() {\n+\t\t\t\t\n+\t\t\t\t@Override\n+\t\t\t\tpublic void accept(Visitable element) {\n+\t\t\t\t\tif (element instanceof CQConcept)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM0NTIxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyOTozNFrOFvK1eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyOTozNFrOFvK1eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDkyMg==", "bodyText": "die ganzen returns k\u00f6nnen hier weg", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385004922", "createdAt": "2020-02-27T09:29:34Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM0NjM0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyOTo1M1rOFvK2HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzowMToyNFrOFxsVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNTA4NA==", "bodyText": "OptionalInt?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385005084", "createdAt": "2020-02-27T09:29:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1MDg0Mg==", "bodyText": "Integer ist hier besser, weil null gleich als leerer Print-value genommen werden kann.", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r387650842", "createdAt": "2020-03-04T13:01:24Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNTA4NA=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM2Mjk2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTozNDozMFrOFvLAKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMzowNToyOFrOFxscwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzY1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));\n          \n          \n            \n            \t\t\t\t\t\t.getFirstDayOfQuarter(CDate.toLocalDate(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385007657", "createdAt": "2020-02-27T09:34:30Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredDays();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredDays();\n+\t\t\t} else if (timeUnit.equals(TimeUnit.QUARTERS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredQuarters();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredQuarters();\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Resolution \" + timeUnit + \" not supported.\");\n+\t\t\t}\n+\n+\t\t\tint numRanges = featureRanges.size();\n+\t\t\tint idx = indexPlacement.equals(IndexPlacement.BEFORE) ? numRanges - 1 : numRanges;\n+\t\t\tfor (CDateRange range : featureRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.FEATURE, -idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx--;\n+\t\t\t}\n+\n+\t\t\tnumRanges = outcomeRanges.size();\n+\t\t\tidx = indexPlacement.equals(IndexPlacement.AFTER) ? 0 : 1;\n+\t\t\tfor (CDateRange range : outcomeRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.OUTCOME, idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcl;\n+\t}\n+\n+\t/**\n+\t * Calculates the feature range.\n+\t * \n+\t * @param event       The event date to which the range is relative.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the event index\n+\t *                    belongs.\n+\t * @param featureTime the time units to be included.\n+\t * @param timeUnit  The time unit.\n+\t * @return The feature range.\n+\t */\n+\tprivate static CDateRange generateFeatureRange(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\tTimeUnit timeUnit) {\n+\t\tif (indexPlacement.equals(IndexPlacement.BEFORE)) {\n+\t\t\tswitch (timeUnit) {\n+\t\t\t\tcase DAYS:\n+\t\t\t\t\treturn CDateRange.of(event - featureTime + 1, event);\n+\t\t\t\tcase QUARTERS:\n+\t\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY1MjgwMQ==", "bodyText": "Oki, habs f\u00fcr alle angepasst", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r387652801", "createdAt": "2020-03-04T13:05:28Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredDays();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredDays();\n+\t\t\t} else if (timeUnit.equals(TimeUnit.QUARTERS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredQuarters();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredQuarters();\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Resolution \" + timeUnit + \" not supported.\");\n+\t\t\t}\n+\n+\t\t\tint numRanges = featureRanges.size();\n+\t\t\tint idx = indexPlacement.equals(IndexPlacement.BEFORE) ? numRanges - 1 : numRanges;\n+\t\t\tfor (CDateRange range : featureRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.FEATURE, -idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx--;\n+\t\t\t}\n+\n+\t\t\tnumRanges = outcomeRanges.size();\n+\t\t\tidx = indexPlacement.equals(IndexPlacement.AFTER) ? 0 : 1;\n+\t\t\tfor (CDateRange range : outcomeRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.OUTCOME, idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcl;\n+\t}\n+\n+\t/**\n+\t * Calculates the feature range.\n+\t * \n+\t * @param event       The event date to which the range is relative.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the event index\n+\t *                    belongs.\n+\t * @param featureTime the time units to be included.\n+\t * @param timeUnit  The time unit.\n+\t * @return The feature range.\n+\t */\n+\tprivate static CDateRange generateFeatureRange(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\tTimeUnit timeUnit) {\n+\t\tif (indexPlacement.equals(IndexPlacement.BEFORE)) {\n+\t\t\tswitch (timeUnit) {\n+\t\t\t\tcase DAYS:\n+\t\t\t\t\treturn CDateRange.of(event - featureTime + 1, event);\n+\t\t\t\tcase QUARTERS:\n+\t\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzY1Nw=="}, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM2NDYzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTozNDo1NlrOFvLBNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTozNDo1NlrOFvLBNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzkyNw==", "bodyText": "so", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385007927", "createdAt": "2020-02-27T09:34:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredDays();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredDays();\n+\t\t\t} else if (timeUnit.equals(TimeUnit.QUARTERS)) {\n+\t\t\t\tfeatureRanges = featureRange.getCoveredQuarters();\n+\t\t\t\toutcomeRanges = outcomeRange.getCoveredQuarters();\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Resolution \" + timeUnit + \" not supported.\");\n+\t\t\t}\n+\n+\t\t\tint numRanges = featureRanges.size();\n+\t\t\tint idx = indexPlacement.equals(IndexPlacement.BEFORE) ? numRanges - 1 : numRanges;\n+\t\t\tfor (CDateRange range : featureRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.FEATURE, -idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx--;\n+\t\t\t}\n+\n+\t\t\tnumRanges = outcomeRanges.size();\n+\t\t\tidx = indexPlacement.equals(IndexPlacement.AFTER) ? 0 : 1;\n+\t\t\tfor (CDateRange range : outcomeRanges) {\n+\t\t\t\tdcl.add(new DateContext(range, FeatureGroup.OUTCOME, idx, CDate.toLocalDate(event)));\n+\t\t\t\tidx++;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcl;\n+\t}\n+\n+\t/**\n+\t * Calculates the feature range.\n+\t * \n+\t * @param event       The event date to which the range is relative.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the event index\n+\t *                    belongs.\n+\t * @param featureTime the time units to be included.\n+\t * @param timeUnit  The time unit.\n+\t * @return The feature range.\n+\t */\n+\tprivate static CDateRange generateFeatureRange(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\tTimeUnit timeUnit) {\n+\t\tif (indexPlacement.equals(IndexPlacement.BEFORE)) {\n+\t\t\tswitch (timeUnit) {\n+\t\t\t\tcase DAYS:\n+\t\t\t\t\treturn CDateRange.of(event - featureTime + 1, event);\n+\t\t\t\tcase QUARTERS:\n+\t\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime - 1, IsoFields.QUARTER_YEARS));\n+\t\t\t\t\tLocalDate eventRangeEnd = QuarterUtils.getLastDayOfQuarter(event);\n+\t\t\t\t\treturn CDateRange.of(eventRangeStart, eventRangeEnd);\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Unsupported Resolution: \" + timeUnit);\n+\t\t\t}\n+\t\t}\n+\t\t// eventIndex == NEUTRAL or AFTER\n+\t\tswitch (timeUnit) {\n+\t\t\tcase DAYS:\n+\t\t\t\treturn CDateRange.of(event - featureTime, event - 1);\n+\t\t\tcase QUARTERS:\n+\t\t\t\tLocalDate eventRangeStart = QuarterUtils\n+\t\t\t\t\t\t.getFirstDayOfQuarter(LocalDate.ofEpochDay(event).minus(featureTime, IsoFields.QUARTER_YEARS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM2ODQxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTozNTo1NVrOFvLDcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTozNTo1NVrOFvLDcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODQ5OQ==", "bodyText": "switch case?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385008499", "createdAt": "2020-02-27T09:35:55Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.time.LocalDate;\n+import java.time.temporal.IsoFields;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.forms.DateContextMode;\n+import com.bakdata.conquery.apiv1.forms.FeatureGroup;\n+import com.bakdata.conquery.apiv1.forms.IndexPlacement;\n+import com.bakdata.conquery.apiv1.forms.TimeUnit;\n+import com.bakdata.conquery.models.common.CDate;\n+import com.bakdata.conquery.models.common.QuarterUtils;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+@EqualsAndHashCode\n+@ToString\n+public class DateContext {\n+\n+\t/**\n+\t * The date range.\n+\t *\n+\t * @return The date range\n+\t */\n+\t@Getter\n+\tprivate final CDateRange dateRange;\n+\n+\t/**\n+\t * Indicates to which group the context belongs.\n+\t *\n+\t * @return The groups.\n+\t */\n+\t@Getter\n+\t@Setter\n+\tprivate FeatureGroup featureGroup;\n+\n+\t/**\n+\t * Indicates the relative position of the context to the event context.\n+\t *\n+\t * @return The index.\n+\t */\n+\t@Getter\n+\tprivate Integer index = null;\n+\t\n+\t/**\n+\t * The date from which the relative context were generated.\n+\t * \n+\t * @return The event date\n+\t */\n+\t@Getter @Setter\n+\tprivate LocalDate eventDate = null;\n+\n+\t/**\n+\t * Returns the date ranges that fit into a mask specified as date range, which\n+\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n+\t *\n+\t * @param dateRangeMask The mask that is applied onto the dates.\n+\t * @param resultMode    The subdivision mode that defines the granularity of the\n+\t *                      result.\n+\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n+\t *         mask.\n+\t */\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode resultMode) {\n+\t\tList<DateContext> dcList = new ArrayList<>();\n+\n+\t\t// Add whole time span\n+\t\tDateContext dc = new DateContext(dateRangeMask);\n+\t\tdc.setFeatureGroup(FeatureGroup.OUTCOME);\n+\t\tdcList.add(dc);\n+\n+\t\tint index = 0;\n+\t\t// Handle years\n+\t\tif (resultMode == DateContextMode.YEAR_WISE) {\n+\t\t\tList<CDateRange> maskYears = dateRangeMask.getCoveredYears();\n+\t\t\tfor (CDateRange yearInMask : maskYears) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tyearInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Handle quarters\n+\t\tif (resultMode == DateContextMode.QUARTER_WISE) {\n+\t\t\tList<CDateRange> maskQuarters = dateRangeMask.getCoveredQuarters();\n+\t\t\tfor (CDateRange quarterInMask : maskQuarters) {\n+\t\t\t\tdc = new DateContext(\n+\t\t\t\t\tquarterInMask,\n+\t\t\t\t\tFeatureGroup.OUTCOME,\n+\t\t\t\t\tindex++,\n+\t\t\t\t\tnull\n+\t\t\t\t);\n+\t\t\t\tdcList.add(dc);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn dcList;\n+\t}\n+\n+\t/**\n+\t * Returns the date ranges that are in the specified range around the event.\n+\t * \n+\t * @param event       The date (as days from {@link EPOCH_DAY} from which the\n+\t *                    relative range is calculated.\n+\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n+\t *                    event belongs.\n+\t * @param featureTime The number of feature timeunit ranges.\n+\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * @param resultMode\n+\t * @param timeUnit\n+\t * @return\n+\t */\n+\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\n+\t\t\tint outcomeTime, boolean sliced, TimeUnit timeUnit) {\n+\t\tif (featureTime < 1 || outcomeTime < 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Relative times were smaller than 1 (featureTime: \" + featureTime\n+\t\t\t\t\t+ \"; outcomeTime: \" + outcomeTime + \")\");\n+\t\t}\n+\t\tList<DateContext> dcl = new ArrayList<>();\n+\n+\t\tCDateRange featureRange = generateFeatureRange(event, indexPlacement, featureTime, timeUnit);\n+\t\tCDateRange outcomeRange = generateOutcomeRange(event, indexPlacement, outcomeTime, timeUnit);\n+\n+\t\tdcl.add(new DateContext(featureRange, FeatureGroup.FEATURE, null, CDate.toLocalDate(event)));\n+\t\tdcl.add(new DateContext(outcomeRange, FeatureGroup.OUTCOME, null, CDate.toLocalDate(event)));\n+\n+\t\tif (sliced) {\n+\t\t\tList<CDateRange> featureRanges = null;\n+\t\t\tList<CDateRange> outcomeRanges = null;\n+\n+\t\t\tif (timeUnit.equals(TimeUnit.DAYS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM4ODgzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ResultModifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0MTowMVrOFvLPTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0MTowMVrOFvLPTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMTUzMg==", "bodyText": "else kanst du dir hier sparen macht das auch \u00fcbersichtlicher", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385011532", "createdAt": "2020-02-27T09:41:01Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ResultModifier.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.UnaryOperator;\n+\n+import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.ConceptQueryPlan;\n+import com.bakdata.conquery.models.query.queryplan.aggregators.Aggregator;\n+import com.bakdata.conquery.models.query.queryplan.aggregators.specific.ExistsAggregator;\n+import com.bakdata.conquery.models.query.results.EntityResult;\n+import com.bakdata.conquery.models.query.results.MultilineContainedEntityResult;\n+import com.bakdata.conquery.models.query.results.SinglelineContainedEntityResult;\n+\n+public class ResultModifier {\n+\n+\t/**\n+\t * Modifies the given result lines with the given function.\n+\t * \n+\t * If the result is not contained this method creates a default result row anyways.\n+\t */\n+\tpublic static List<Object[]> modify(EntityResult inResult, ConceptQueryPlan subPlan, UnaryOperator<Object[]> modification) {\n+\t\tif(inResult.isFailed()) {\n+\t\t\tthrow new RuntimeException(\"failed result can't be modified: \"+inResult);\n+\t\t}\n+\t\tif(!inResult.isContained()) {\n+\t\t\tObject[] result = new Object[subPlan.getAggregatorSize()];\n+\t\t\tint aggIdx = 0;\n+\t\t\tfor(Aggregator<?> agg : subPlan.getAggregators()) {\n+\t\t\t\t// Fill with null, except for EXIST aggregators\n+\t\t\t\tif(agg instanceof ExistsAggregator) {\n+\t\t\t\t\tresult[aggIdx] = false;\n+\t\t\t\t}\n+\t\t\t\taggIdx++;\n+\t\t\t}\n+\t\t\treturn Collections.singletonList(modification.apply(result));\n+\t\t}\n+\t\tif(inResult instanceof SinglelineContainedEntityResult) {\n+\t\t\treturn Collections.singletonList(\n+\t\t\t\tmodification.apply(\n+\t\t\t\t\t((SinglelineContainedEntityResult) inResult).getValues()\n+\t\t\t\t)\n+\t\t\t);\n+\t\t}\n+\t\telse if(inResult instanceof MultilineContainedEntityResult) {\n+\t\t\tvar values = ((MultilineContainedEntityResult) inResult).getValues();\n+\t\t\tList<Object[]> result = new ArrayList<>(values);\n+\t\t\tresult.replaceAll(modification);\n+\t\t\treturn result;\n+\t\t}\n+\t\telse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDM5NTI0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/TableManipulator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0MjozOFrOFvLTMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0MjozOFrOFvLTMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMjUzMA==", "bodyText": "Erkl\u00e4ren was und warum du das machst", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385012530", "createdAt": "2020-02-27T09:42:38Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/TableManipulator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.concepts.select.Select;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ConnectorSelectId;\n+import com.bakdata.conquery.models.query.concept.filter.CQTable;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+/**\n+ * Manipulates a given Table based on the provided blacklisting or whitelisting\n+ * for {@link ConnectorSelectId}s. After this filtering, the defined default\n+ * values are added if the corresponding list is empty.\n+ */\n+@Getter\n+@Setter\n+@Builder(builderClassName = \"TableManipulatorInternalBuilder\", builderMethodName = \"internalBuilder\")\n+public class TableManipulator {\n+\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectBlacklist = Collections.emptyList();\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectWhitelist = Collections.emptyList();\n+\t@Builder.Default\n+\tprivate List<ConnectorSelectId> selectDefault = Collections.emptyList();\n+\n+\tprivate void init() {\n+\n+\t\tif (!selectBlacklist.isEmpty() && !selectWhitelist.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"Either blacklist or whitelist needs to be empty.\");\n+\t\t}\n+\n+\t\tSet<ConnectorSelectId> blackDefaultIntersection = selectBlacklist\n+\t\t\t.stream()\n+\t\t\t.distinct()\n+\t\t\t.filter(selectDefault::contains)\n+\t\t\t.collect(Collectors.toSet());\n+\t\tif (!blackDefaultIntersection.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString\n+\t\t\t\t\t.format(\n+\t\t\t\t\t\t\"The list of default selects intersects with the blacklist. Intersecting Elements:\\t\",\n+\t\t\t\t\t\tblackDefaultIntersection.toString()));\n+\t\t}\n+\n+\t}\n+\n+\tpublic void consume(CQTable table, Namespaces namespaces) {\n+\n+\t\tList<Select> selects = table.getSelects();\n+\t\tif (!selectBlacklist.isEmpty()) {\n+\t\t\tselects.removeIf(s -> selectBlacklist.contains(s.getId()));\n+\t\t}\n+\t\telse if (!selectWhitelist.isEmpty()) {\n+\t\t\tselects.removeIf(s -> !selectWhitelist.contains(s.getId()));\n+\t\t}\n+\n+\t\t// Add default selects if none is present anymore\n+\t\tif (selects.isEmpty()) {\n+\t\t\ttable.setSelects(selectDefault.stream().map(namespaces::resolve).collect(Collectors.toList()));\n+\t\t}\n+\t}\n+\n+\tpublic static TableManipulatorBuilder builder() {\n+\t\treturn new TableManipulatorBuilder();\n+\t}\n+\n+\tpublic static class TableManipulatorBuilder extends TableManipulatorInternalBuilder {\n+\n+\t\tpublic TableManipulatorBuilder() {\n+\t\t\tsuper();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic TableManipulator build() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDU1NTI0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/ExecutionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDoyNjoyNlrOFvM0aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDoyNjoyNlrOFvM0aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzQxOQ==", "bodyText": "*Query weg machen", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385037419", "createdAt": "2020-02-27T10:26:26Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ExecutionManager.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.bakdata.conquery.models.query;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.execution.ManagedExecution;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.messages.namespaces.specific.ExecuteQuery;\n+import com.bakdata.conquery.models.query.results.ShardResult;\n+import com.bakdata.conquery.models.worker.Namespace;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.models.worker.WorkerInformation;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public class ExecutionManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDYyNDM3OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/IQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0NTo1M1rOFvNehw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0NTo1M1rOFvNehw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0ODE5OQ==", "bodyText": "public", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385048199", "createdAt": "2020-02-27T10:45:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/IQuery.java", "diffHunk": "@@ -1,35 +1,68 @@\n package com.bakdata.conquery.models.query;\n \n import java.util.HashSet;\n+import java.util.Optional;\n import java.util.Set;\n \n-import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.apiv1.SubmittedQuery;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.identifiable.ids.NamespacedId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n import com.bakdata.conquery.models.query.queryplan.QueryPlan;\n import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.bakdata.conquery.util.QueryUtils;\n+import com.bakdata.conquery.util.QueryUtils.NamespacedIdCollector;\n+import com.google.common.collect.MoreCollectors;\n \n-@JsonTypeInfo(use=JsonTypeInfo.Id.CUSTOM, property=\"type\")\n-@CPSBase\n-public interface IQuery extends Visitable {\n+public abstract class IQuery implements SubmittedQuery {\n \n-\tIQuery resolve(QueryResolveContext context);\n-\tQueryPlan createQueryPlan(QueryPlanContext context);\n+\tpublic abstract IQuery resolve(QueryResolveContext context);\n+\tpublic abstract QueryPlan createQueryPlan(QueryPlanContext context);\n \t\n-\tvoid collectRequiredQueries(Set<ManagedExecutionId> requiredQueries);\n+\tpublic abstract void collectRequiredQueries(Set<ManagedExecutionId> requiredQueries);\n \t\n-\tdefault Set<ManagedExecutionId> collectRequiredQueries() {\n+\tpublic Set<ManagedExecutionId> collectRequiredQueries() {\n \t\tHashSet<ManagedExecutionId> set = new HashSet<>();\n \t\tthis.collectRequiredQueries(set);\n \t\treturn set;\n \t}\n \n-\tdefault ResultInfoCollector collectResultInfos(PrintSettings config) {\n+\tpublic ResultInfoCollector collectResultInfos(PrintSettings config) {\n \t\tResultInfoCollector collector = new ResultInfoCollector(config);\n \t\tcollectResultInfos(collector);\n \t\treturn collector;\n \t}\n \t\n-\tvoid collectResultInfos(ResultInfoCollector collector);\n+\tpublic abstract void collectResultInfos(ResultInfoCollector collector);\n+\t\n+\t@Override\n+\tpublic ManagedQuery toManagedExecution(MasterMetaStorage storage, Namespaces namespaces, UserId userId, DatasetId submittedDataset) {\n+\t\tDatasetId dataset = IQuery.getDataset(this, submittedDataset);\n+\t\tIQuery query = this.resolve(new QueryResolveContext(\n+\t\t\tstorage,\n+\t\t\tnamespaces.get(dataset)\n+\t\t\t));\n+\t\tManagedQuery managed = new ManagedQuery(storage, query,userId, dataset);\n+\t\treturn managed;\n+\t}\n+\n+\t/**\n+\t * Tries to extract the {@link DatasetId} from the submitted query.\n+\t * If none could be extracted the alternative dataset is chosen.\n+\t * When more than one {@link DatasetId} is found an {@link IllegalArgumentException} is thrown.\n+\t */\n+\tstatic DatasetId getDataset(IQuery query, DatasetId alternativeDataset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDYzNDc2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0ODo1M1rOFvNk7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0ODo1M1rOFvNk7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0OTgzNw==", "bodyText": "Das sieht komisch aus, was macht das?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385049837", "createdAt": "2020-02-27T10:48:53Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "diffHunk": "@@ -130,4 +139,30 @@ public ManagedQuery toResultQuery() {\n \t\tquery.visit(collector);\n \t\treturn collector.getIds();\n \t}\n+\n+\t@Override\n+\tpublic Map<ManagedExecutionId,QueryPlan> createQueryPlans(QueryPlanContext context) {\n+\t\tif(context.getDataset().equals(getDataset())) {\t\t\t\n+\t\t\treturn Map.of(this.getId(), query.createQueryPlan(context));\n+\t\t}\n+\t\tlog.trace(\"Did not create a QueryPlan for the query {} because the plan corresponds to dataset {} but the execution worker belongs to {}.\", getId(), getDataset(), context.getDataset());\n+\t\treturn Collections.emptyMap();\n+\t}\n+\n+\t@Override\n+\tpublic ShardResult getInitializedShardResult(Entry<ManagedExecutionId, QueryPlan> entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDYzNzE2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0OTozMVrOFvNmOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo0OTozMVrOFvNmOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDE3MQ==", "bodyText": "Sind die meisten jetzt nicht eh teil der ManagedQuery und du kannst sie reinziehen?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385050171", "createdAt": "2020-02-27T10:49:31Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/query/ManagedQuery.java", "diffHunk": "@@ -112,16 +121,16 @@ public ResultInfoCollector collectResultInfos(PrintSettings config) {\n \t@Override\n \tpublic ExecutionStatus buildStatus(URLBuilder url, User user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8707638d140d8c4d45ec2c37794d8a02095b6a7c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDg1MzQ1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/resources/api/FormProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjowMTo0OVrOFvPosg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjowMTo0OVrOFvPosg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzU3MA==", "bodyText": "warum iterierst du das nicht normal?", "url": "https://github.com/bakdata/conquery/pull/1058#discussion_r385083570", "createdAt": "2020-02-27T12:01:49Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/resources/api/FormProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package com.bakdata.conquery.resources.api;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.regex.Pattern;\n+\n+import com.bakdata.conquery.apiv1.forms.Form;\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.cps.CPSTypeIdResolver;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.permissions.Ability;\n+import com.bakdata.conquery.models.auth.permissions.FormPermission;\n+import com.bakdata.conquery.models.worker.Namespaces;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.github.classgraph.Resource;\n+import io.github.classgraph.ResourceList;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@RequiredArgsConstructor\n+@Getter @Slf4j\n+public class FormProcessor {\n+\n+\tprivate final Namespaces namespaces;\n+\tprivate final MasterMetaStorage storage;\n+\tprivate static final Map<Class<? extends Form>, JsonNode> FRONTEND_FORM_CONFIGS = generateFEFormConfigMap();\n+\n+\tprivate static Map<Class<? extends Form>, JsonNode> generateFEFormConfigMap() {\n+\t\tMap<String, Class<? extends Form>> forms = new HashMap<>();\n+\t\tfor( Class<?> subclass : CPSTypeIdResolver.SCAN_RESULT.getSubclasses(Form.class.getName()).loadClasses()) {\n+\t\t\tif(Modifier.isAbstract(subclass.getModifiers())){\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tCPSType anno = subclass.getAnnotation(CPSType.class);\n+\t\t\tif(anno == null) {\n+\t\t\t\tlog.warn(\"Implemented Form {} has no CPSType annotation\", subclass);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tforms.put(anno.id(), (Class<? extends Form>) subclass);\n+\t\t}\n+\t\t\n+\t\tMap<Class<? extends Form>, JsonNode> result = new HashMap<>();\n+\t\tResourceList frontendConfigs = CPSTypeIdResolver.SCAN_RESULT\n+\t\t\t.getResourcesMatchingPattern(Pattern.compile(\".*\\\\.frontend_conf\\\\.json\"));\n+\t\tObjectReader reader = io.dropwizard.jackson.Jackson.newObjectMapper().reader();\n+\t\tfinal String infoFormat = \"\\t%-20s %-50s %-20s\\n\";\n+\t\tStringBuilder info = new StringBuilder(String.format(infoFormat, \"Form Type\", \"Frontend Config\", \"Backend Class\"));\n+\t\tfor (Resource config : frontendConfigs) {\n+\t\t\tJsonNode configTree;\n+\t\t\ttry {\n+\t\t\t\tconfigTree = reader.readTree(config.open());\n+\t\t\t}\n+\t\t\tcatch (IOException e) {\n+\t\t\t\tthrow new IllegalArgumentException(String.format(\"Could not parse the frontend config: %s\", config.getPath()), e);\n+\t\t\t}\n+\t\t\tString formType = configTree.get(\"type\").asText();\n+\t\t\tClass<? extends Form> formClass = forms.get(formType);\n+\t\t\tif(formClass == null) {\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Found frontend config for form %s but could not find an corresponding backend implementation.\", formType));\n+\t\t\t}\n+\t\t\tJsonNode prev = result.put(formClass, configTree);\n+\t\t\tif(prev != null ) {\t\t\t\t\n+\t\t\t\tthrow new IllegalStateException(String.format(\"Could not map %s to form %s because there was already a mapping:\\n%s\", config.getPathRelativeToClasspathElement(), formType, prev));\n+\t\t\t}\n+\t\t\tinfo.append(String.format(infoFormat, formType, config.getPathRelativeToClasspathElement(), formClass));\n+\t\t}\n+\t\tlog.info(\"Found form config mapping for form:\\n{}\", info.toString());\n+\t\t\n+\t\treturn result;\n+\t}\n+\n+\tpublic Collection<JsonNode> getFormsForUser(User user) {\n+\t\tList<JsonNode> allowedForms = new ArrayList<>();\n+\t\tIterator<Entry<Class<? extends Form>, JsonNode>> it = FRONTEND_FORM_CONFIGS.entrySet().iterator();\n+\t\twhile(it.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a486bd5890b4c3397de14c2116301876b46546"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1424, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}