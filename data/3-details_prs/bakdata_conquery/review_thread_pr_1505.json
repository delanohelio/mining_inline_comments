{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNDAyNzk0", "number": 1505, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNDo1NlrOFGEL_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0NjoxMFrOFGIDhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTA0MzgyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNDo1NlrOIG5TGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNDo1NlrOIG5TGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTE0Ng==", "bodyText": "falsche Anno", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101146", "createdAt": "2020-12-16T08:24:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTA0NzYyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNTo1MlrOIG5VYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNTo1MlrOIG5VYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTcyOQ==", "bodyText": "den else branch finde ich nicht sauber, mach lieber eine Liste draus oder besser eine Methode", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101729", "createdAt": "2020-12-16T08:25:52Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull\n+\tpublic static List<ExportForm.ResolutionAndAlignment> getResolutionAlignmentMap(List<DateContext.Resolution> resolutions, DateContext.Alignment alignmentHint) {\n+\n+\t\treturn resolutions.stream()\n+\t\t\t\t.map(r -> ResolutionAndAlignment.of(r, r.getSupportedAlignments().contains(alignmentHint)? alignmentHint : r.getSupportedAlignments().iterator().next()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTA2MDgxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyODo1MFrOIG5cvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyMToyN1rOIHAdag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA==", "bodyText": "Warum handlest du die unterschiedlich? Kann es denn vorkommen, dass du das enum direkt bekommst und nicht den String oder andersrum?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544103614", "createdAt": "2020-12-16T08:28:50Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "diffHunk": "@@ -42,13 +42,13 @@ public String print(PrintSettings cfg, Object f) {\n \n \t\t@Override\n \t\tpublic String print(PrintSettings cfg, Object f) {\n-\t\t\tif (f instanceof DateContextMode) {\n-\t\t\t\treturn ((DateContextMode) f).toString(cfg.getLocale());\n+\t\t\tif (f instanceof DateContext.Resolution) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODExNA==", "bodyText": "Der Fall im TryBlock ist momentan die Regel. Ich hatte das if statement mal hinzugef\u00fcgt, sollten wir eine strengere typisierung haben. Ich werde mal versuchen das If-Statement zum standard zu machen", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544218114", "createdAt": "2020-12-16T11:20:50Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "diffHunk": "@@ -42,13 +42,13 @@ public String print(PrintSettings cfg, Object f) {\n \n \t\t@Override\n \t\tpublic String print(PrintSettings cfg, Object f) {\n-\t\t\tif (f instanceof DateContextMode) {\n-\t\t\t\treturn ((DateContextMode) f).toString(cfg.getLocale());\n+\t\t\tif (f instanceof DateContext.Resolution) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA=="}, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODQ3NA==", "bodyText": "Okay, ich lasse es", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544218474", "createdAt": "2020-12-16T11:21:27Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "diffHunk": "@@ -42,13 +42,13 @@ public String print(PrintSettings cfg, Object f) {\n \n \t\t@Override\n \t\tpublic String print(PrintSettings cfg, Object f) {\n-\t\t\tif (f instanceof DateContextMode) {\n-\t\t\t\treturn ((DateContextMode) f).toString(cfg.getLocale());\n+\t\t\tif (f instanceof DateContext.Resolution) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA=="}, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTA2Njg1OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODozMDoxM1rOIG5gIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODozMDoxM1rOIG5gIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDQ4Mg==", "bodyText": "del", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104482", "createdAt": "2020-12-16T08:30:13Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -25,6 +25,7 @@\n import com.fasterxml.jackson.annotation.JsonCreator;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.tuple.Pair;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTA2OTEzOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODozMDo1MFrOIG5hbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo1NzozMFrOIG_hmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgxNA==", "bodyText": "JsonIgnore? Oder kann das FE uns das schicken?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104814", "createdAt": "2020-12-16T08:30:50Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -38,7 +39,7 @@\n \t@NotNull @Valid\n \tprivate final ArrayConceptQuery features;\n \t@NotNull\n-\tprivate final List<DateContextMode> resolutions;\n+\tprivate final List<ExportForm.ResolutionAndAlignment> resolutionsAndAlignmentMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwMzE2MQ==", "bodyText": "Das JupyEnd k\u00f6nnte es schicken, aber es nutzt soweit ich wei\u00df die FormDescription", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544203161", "createdAt": "2020-12-16T10:57:30Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -38,7 +39,7 @@\n \t@NotNull @Valid\n \tprivate final ArrayConceptQuery features;\n \t@NotNull\n-\tprivate final List<DateContextMode> resolutions;\n+\tprivate final List<ExportForm.ResolutionAndAlignment> resolutionsAndAlignmentMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgxNA=="}, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTE2ODIyOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo1NDowNlrOIG6bCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjowOTo0MlrOIHCPWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExOTU2MQ==", "bodyText": "was bedeutet es, dass es an stelle 0 und 1 ist?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544119561", "createdAt": "2020-12-16T08:54:06Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -189,13 +189,13 @@ private boolean hasCompleteDateContexts(List<DateContext> contexts) {\n \t\tif (featurePlan.getAggregatorSize() > 0 && outcomePlan.getAggregatorSize() > 0) {\n \t\t\t// We have features and outcomes check if both have complete date ranges (they should be at the beginning of the list)\n \t\t\treturn contexts.size()>=2\n-\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n-\t\t\t\t&& contexts.get(1).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n+\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContext.Resolution.COMPLETE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NzY0Mw==", "bodyText": "Das ist leider in implizierter Contract, dass wenn ein COMPLETE Context gefordert ist, diese am Anfang der Context-Liste stehen", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544247643", "createdAt": "2020-12-16T12:09:42Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -189,13 +189,13 @@ private boolean hasCompleteDateContexts(List<DateContext> contexts) {\n \t\tif (featurePlan.getAggregatorSize() > 0 && outcomePlan.getAggregatorSize() > 0) {\n \t\t\t// We have features and outcomes check if both have complete date ranges (they should be at the beginning of the list)\n \t\t\treturn contexts.size()>=2\n-\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n-\t\t\t\t&& contexts.get(1).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n+\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContext.Resolution.COMPLETE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExOTU2MQ=="}, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTE3Mjc0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo1NTowNlrOIG6dwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo1NTowNlrOIG6dwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMDI1Nw==", "bodyText": "Da fehlt auf jeden Fall Doku", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544120257", "createdAt": "2020-12-16T08:55:06Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTIwMjY0OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTowMTo0M1rOIG6vWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjo1NzoyOVrOIHEC0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyNDc2MA==", "bodyText": "das                        interessant\n  Formatting ist", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544124760", "createdAt": "2020-12-16T09:01:43Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI3NzIwMw==", "bodyText": "Ich habs nur einheitlich gemacht bei allen ;)", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544277203", "createdAt": "2020-12-16T12:57:29Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyNDc2MA=="}, "originalCommit": {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTY2NjY2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0MzozMlrOIG--Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjowMzowNlrOIHB_KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDExOA==", "bodyText": "das OOB'd wenn aligendSubdivisions empt ist", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194118", "createdAt": "2020-12-16T10:43:32Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0MzQ5Nw==", "bodyText": "Danke sehr, gut gesehen", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544243497", "createdAt": "2020-12-16T12:03:06Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDExOA=="}, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTY2ODI2OnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0Mzo1NlrOIG-_Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0Mzo1NlrOIG-_Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDM2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n          \n          \n            \n            \t * Generates a list of date contexts around an index date which belong either to a feature date range (before the index)", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194366", "createdAt": "2020-12-16T10:43:56Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));\n+\t\t\t}\n+\n+\t\t\treturn alignRef.getAlignedIterationDirection(result);\n+\t\t};\n+\t}\n+\n \t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTY3NzUxOnYy", "diffSide": "RIGHT", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateRangeSubDivider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDo0NjoxMFrOIG_Emg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTowMTozMVrOIG_rqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NTczOA==", "bodyText": "CDateSet ?", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544195738", "createdAt": "2020-12-16T10:46:10Z", "author": {"login": "awildturtok"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateRangeSubDivider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public interface DateRangeSubDivider {\n+\n+    List<CDateRange> subdivideRange(CDateRange range);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwNTczOA==", "bodyText": "Die DateRanges werden letztendlich in DateRestricting Nodes der einzelnen SubQueries gef\u00fcttert. Das w\u00e4re hier nicht sinnvoll eine komplexe Stuktur noch herumzubauen, um sie letztendlich wieder auszupacken.", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544205738", "createdAt": "2020-12-16T11:01:31Z", "author": {"login": "thoniTUB"}, "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateRangeSubDivider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public interface DateRangeSubDivider {\n+\n+    List<CDateRange> subdivideRange(CDateRange range);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NTczOA=="}, "originalCommit": {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1575, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}