{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NDk4Njcx", "number": 662, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowNzo0MlrOERUIsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODowNzo1MlrOETXiww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTkxMTU1OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowNzo0MlrOG19QYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNDo0ODoyNFrOG38eMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ==", "bodyText": "This is the single most important line -- the core purpose -- of this PR.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231329", "createdAt": "2020-07-23T06:07:42Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5ODQ2NQ==", "bodyText": "What's the effect of the timeout operator? Does it wait for the categoryInitializationsPending to be counted down up to PLUGIN_INIT_TIMEOUT_MSms and then tries to start the orchestrator?\nIf there's no connectivity, will this be retried on any interaction with the DataStore?", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459398465", "createdAt": "2020-07-23T12:03:58Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNDM1Ng==", "bodyText": "What's the effect of the timeout operator? Does it wait for the categoryInitializationsPending to be counted down up to PLUGIN_INIT_TIMEOUT_MSms and then tries to start the orchestrator?\n\nI think that's how it's working, yes. That was the intent, anyway.\n\nIf there's no connectivity, will this be retried on any interaction with the DataStore?\n\nYes, offline or not signed in. I guess we probably don't want to block on its completion?", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459434356", "createdAt": "2020-07-23T13:07:20Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MTg1OQ==", "bodyText": "I believe so...at least when calling from beforeOperation. I think the only piece of the orchestrator that is necessary before we can allow interaction with the DataStore is the StorageObserver. Without that, any save operations against the DataStore would not be queued up for sync.\nThe other components can probably be treated as fire-and-forget. For the SubscriptionProcessor, I added a retry mechanism. Maybe that's something we should do for the SyncProcessor and MutationProcessor?", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459491859", "createdAt": "2020-07-23T14:28:05Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzODc0Mw==", "bodyText": "I believe so...at least when calling from beforeOperation. I think the only piece of the orchestrator that is necessary before we can allow interaction with the DataStore is the StorageObserver. Without that, any save operations against the DataStore would not be queued up for sync. The other components can probably be treated as fire-and-forget.\n\nAgree; this makes sense.\n\nFor the SubscriptionProcessor, I added a retry mechanism. Maybe that's something we should do for the SyncProcessor and MutationProcessor?\n\nActually, simply adding retries to the sync processor might be the quickest solution to solving the problem at hand.\nIdeally, though, I think we want to retry orchestrator setup as an atomic entity, not just the individual components. The order in which the components come online and start modifying data is import, for maintaining data integrity.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459538743", "createdAt": "2020-07-23T15:31:22Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNTYzMg==", "bodyText": "Resolution: I ended up doing the second thing re: \"atomic entity.\"", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461315632", "createdAt": "2020-07-28T04:48:24Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTkxMjk1OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowODoyN1rOG19ROA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNDo1MDowOVrOG38gHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA==", "bodyText": "If we don't have a clean start, we should teardown again, so we're back to a deterministic stop state.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231544", "createdAt": "2020-07-23T06:08:27Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQwMDYxNg==", "bodyText": "This makes sense. Only concern I have is similar to what I mentioned earlier. If a connection is not available what the impact on calls to the DataStore APIs?", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459400616", "createdAt": "2020-07-23T12:08:36Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzMTU0Nw==", "bodyText": "If a connection is not available what the impact on calls to the DataStore APIs?\n\nThanks for bringing this case to my attention. This is an indeed an issue:\n\nDevice is offline;\nUser is not signed in;\nA call to save(...) is made;\nNo response is rendered until initializeOrchestrator() fails.\nAt that point, the onResult consumer is triggered as desired, indicating successful use of the local storage.\n\n(4) is a problem.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459431547", "createdAt": "2020-07-23T13:03:20Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxOTEyNQ==", "bodyText": "To build on my response to the other comment, I think we only need to block interactions with the local DataStore until the StorageObserver is ready.\nMaybe we need to account for more than just started/stopped for the orchestrator.\nif Orchestrator is STOPPED => // need to start everything and signal when StorageObserver is ready.\n   triggerStartAndWaitForStorageObserver\n   if StorageObserver STARTED =>\n      emit storageObserverReady //This unlocks callers\n   else\n      Set Orchestrator back to STOPPED\n      throw error back to caller.      \n   [MutationProcessor, SubscriptionProcessor, SyncProcessor].asyncStart \n   if [MutationProcessor, SubscriptionProcessor, SyncProcessor] STARTED\n     set Orchestrator STARTED\n   else\n     set Orchestrator FAILED\n\nif STARTED => nothing to do, it's ready to go\n\nif FAILED => trigger non-blocking retry.\n   [MutationProcessor, SubscriptionProcessor, SyncProcessor].asyncStart \n   if [MutationProcessor, SubscriptionProcessor, SyncProcessor] STARTED\n     set Orchestrator STARTED\n   else\n     set Orchestrator FAILED", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459519125", "createdAt": "2020-07-23T15:04:21Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjEyNw==", "bodyText": "Resolution: I decoupled the initialization of the API synchronization code, from the code which observes the storage. Now, there is always a storage observer when beforeOperation() completes, and so any customer-provided data will be observed. The API sync may start at a later time.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461316127", "createdAt": "2020-07-28T04:50:09Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, "originalCommit": null, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTkxMzM5OnYy", "diffSide": "LEFT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowODo1MVrOG19RiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowODo1MVrOG19RiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTYyNA==", "bodyText": "According to Lint, the handler is never null.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231624", "createdAt": "2020-07-23T06:08:51Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -118,18 +118,15 @@ Completable hydrate() {\n                         LOG.warn(\"Initial cloud sync failed.\", failureToSync);\n                         DataStoreErrorHandler dataStoreErrorHandler =\n                             dataStoreConfigurationProvider.getConfiguration().getDataStoreErrorHandler();\n-                        if (dataStoreErrorHandler != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTkxNDgyOnYy", "diffSide": "LEFT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowOTozNFrOG19SRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjowOTozNFrOG19SRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTgxMg==", "bodyText": "I need the hydrate() call to surface its failures, so that the orchestrator can respond to them by cleaning up and shutting down.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231812", "createdAt": "2020-07-23T06:09:34Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -118,18 +118,15 @@ Completable hydrate() {\n                         LOG.warn(\"Initial cloud sync failed.\", failureToSync);\n                         DataStoreErrorHandler dataStoreErrorHandler =\n                             dataStoreConfigurationProvider.getConfiguration().getDataStoreErrorHandler();\n-                        if (dataStoreErrorHandler != null) {\n-                            dataStoreErrorHandler.accept(\n-                                new DataStoreException(\n-                                    \"Initial cloud sync failed.\",\n-                                    failureToSync,\n-                                    \"Check your internet connection.\"));\n-                        }\n+                        dataStoreErrorHandler.accept(\n+                            new DataStoreException(\n+                                \"Initial cloud sync failed.\",\n+                                failureToSync,\n+                                \"Check your internet connection.\"));\n                     })\n                     .doOnComplete(() ->\n                         LOG.info(\"Successfully sync'd down model state from cloud.\")\n                     )\n-                    .onErrorComplete()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTkyMDE5OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjoxMTo1MVrOG19VNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjoxMTo1MVrOG19VNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMjU2Nw==", "bodyText": "(This used to be at the end of hydrate().)", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459232567", "createdAt": "2020-07-23T06:11:51Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -499,9 +500,10 @@ private Completable initializeOrchestrator() {\n                 // This callback is invoked when the local storage observer gets initialized.\n                 isOrchestratorReady.set(true);\n             })\n-            .repeatUntil(() -> isOrchestratorReady.get())\n+            .repeatUntil(isOrchestratorReady::get)\n             .observeOn(Schedulers.io())\n-            .subscribeOn(Schedulers.io());\n+            .subscribeOn(Schedulers.io())\n+            .onErrorComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjY0MTgxOnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyODoyOFrOG280aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMTowODoyN1rOG29zrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA==", "bodyText": "One issue I ran into here was that if I add the DataStore plugin before the API plugin, the Orchestrator goes into LOCAL_ONLY mode:\n// Starts in LOCAL_ONLY\n Amplify.addPlugin(AWSDataStorePlugin())\nAmplify.addPlugin(AWSApiPlugin())\n\nas compared to:\n// Starts in SYNC_VIA_API\nAmplify.addPlugin(AWSApiPlugin())\nAmplify.addPlugin(AWSDataStorePlugin())\n\nIt's kind of a similar situation that we ran into for pluginConfiguration, where we ended up going with a provider-style configuration to delay evaluation of the expression.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460272744", "createdAt": "2020-07-24T20:28:28Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -75,34 +74,28 @@\n     // Keeps track of whether of not the category is initialized yet\n     private final CountDownLatch categoryInitializationsPending;\n \n-    private final AtomicBoolean isOrchestratorReady;\n-\n-    // Used to interrogate plugins, to understand if sync should be automatically turned on\n-    private final ApiCategory api;\n-\n     // User-provided configuration for the plugin.\n     private final DataStoreConfiguration userProvidedConfiguration;\n \n     // Configuration for the plugin that contains settings from the JSON file plus any\n     // overrides provided via the userProvidedConfiguration\n     private DataStoreConfiguration pluginConfiguration;\n \n-    @SuppressLint(\"CheckResult\")\n     private AWSDataStorePlugin(\n             @NonNull ModelProvider modelProvider,\n             @NonNull ModelSchemaRegistry modelSchemaRegistry,\n             @NonNull ApiCategory api,\n             @Nullable DataStoreConfiguration userProvidedConfiguration) {\n         this.sqliteStorageAdapter = SQLiteStorageAdapter.forModels(modelSchemaRegistry, modelProvider);\n         this.categoryInitializationsPending = new CountDownLatch(1);\n-        this.isOrchestratorReady = new AtomicBoolean(false);\n-        this.api = api;\n+        // Used to interrogate plugins, to understand if sync should be automatically turned on\n         this.orchestrator = new Orchestrator(\n             modelProvider,\n             modelSchemaRegistry,\n             sqliteStorageAdapter,\n             AppSyncClient.via(api),\n-            () -> pluginConfiguration\n+            () -> pluginConfiguration,\n+            api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4ODk0Mw==", "bodyText": "Ahhh, yup, absolutely. Great catch.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460288943", "createdAt": "2020-07-24T21:08:27Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -75,34 +74,28 @@\n     // Keeps track of whether of not the category is initialized yet\n     private final CountDownLatch categoryInitializationsPending;\n \n-    private final AtomicBoolean isOrchestratorReady;\n-\n-    // Used to interrogate plugins, to understand if sync should be automatically turned on\n-    private final ApiCategory api;\n-\n     // User-provided configuration for the plugin.\n     private final DataStoreConfiguration userProvidedConfiguration;\n \n     // Configuration for the plugin that contains settings from the JSON file plus any\n     // overrides provided via the userProvidedConfiguration\n     private DataStoreConfiguration pluginConfiguration;\n \n-    @SuppressLint(\"CheckResult\")\n     private AWSDataStorePlugin(\n             @NonNull ModelProvider modelProvider,\n             @NonNull ModelSchemaRegistry modelSchemaRegistry,\n             @NonNull ApiCategory api,\n             @Nullable DataStoreConfiguration userProvidedConfiguration) {\n         this.sqliteStorageAdapter = SQLiteStorageAdapter.forModels(modelSchemaRegistry, modelProvider);\n         this.categoryInitializationsPending = new CountDownLatch(1);\n-        this.isOrchestratorReady = new AtomicBoolean(false);\n-        this.api = api;\n+        // Used to interrogate plugins, to understand if sync should be automatically turned on\n         this.orchestrator = new Orchestrator(\n             modelProvider,\n             modelSchemaRegistry,\n             sqliteStorageAdapter,\n             AppSyncClient.via(api),\n-            () -> pluginConfiguration\n+            () -> pluginConfiguration,\n+            api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA=="}, "originalCommit": {"oid": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NjgxNzY2OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo1NDo1NlrOG3fQqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxODoyMTo1MFrOG3uPNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA==", "bodyText": "Need a blank line.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460837034", "createdAt": "2020-07-27T11:54:56Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4MjQyMA==", "bodyText": "Thanks!", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461082420", "createdAt": "2020-07-27T18:21:50Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA=="}, "originalCommit": {"oid": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179"}, "originalPosition": 410}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NjgyNjAzOnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo1NzoyNVrOG3fVlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo1NzoyNVrOG3fVlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzODI5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Orchestrator.Mode.SYNC_VIA_API\n          \n          \n            \n                            () -> Orchestrator.Mode.SYNC_VIA_API", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460838294", "createdAt": "2020-07-27T11:57:25Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -84,15 +84,17 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n                 modelSchemaRegistry,\n                 localStorageAdapter,\n                 appSync,\n-                DataStoreConfiguration::defaults\n+                DataStoreConfiguration::defaults,\n+                Orchestrator.Mode.SYNC_VIA_API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODM5MTUxOnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxODoyMjo1MlrOG3uRgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxODoyMjo1MlrOG3uRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4MzAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n            \n          \n          \n            \n                /**", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461083008", "createdAt": "2020-07-27T18:22:52Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 410}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzQ0MTMxOnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODowNzo1MlrOG5EJMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjoyNDo0NFrOG5gt_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg==", "bodyText": "TLDR version: The DataStore.clear call may have to wait for the orchestrator to start. We might need to do something like this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!isCategoryInitialized) {\n          \n          \n            \n                    if (!isCategoryInitialized || !orchestrator.isStarted()) {\n          \n      \n    \n    \n  \n\nIf the clear API is called immediately after calling Amplify.configure but before the Orchestrator has a chance to fully start (i.e. it's in LOCAL_ONLY mode and in the process doing stuff before going into SYNC_VIA_API), the call to DataStore.clear() does the following:\n\nCall orchestrator.stop() (which is correct); however, the call to transitionToStopped only stops the storage observer because the current status of the orchestrator is LOCAL_ONLY.\nSubscription attempt is interrupted but the rest of the startApiSync continues because we're not re-throwing the interrupted exception.\nOrchestrator status is set to STOPPED.\nDataStore is cleared. (also correct)\n[Original call to orchestrator.start()] Somehow, the startApiSync call completes and sets the status SYNC_VIA_API\nCalls orchestrator.start() but this results in a no-op because the status is already SYNC_VIA_API. The problem is that at this point, the SubscriptionProcessor and MutationProcessor are in an unknown state.\n\nUsing my sample app, the app does not crash but mutations are not being sent and subscriptions are not started.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462489906", "createdAt": "2020-07-29T18:07:52Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -438,70 +424,50 @@ public void observe(\n      * @param onComplete Invoked if the call is successful.\n      * @param onError Invoked if not successful\n      */\n+    @SuppressWarnings(\"unused\")\n     @Override\n     public void clear(@NonNull Action onComplete,\n                       @NonNull Consumer<DataStoreException> onError) {\n         // We shouldn't call beforeOperation when clearing the DataStore. The\n         // only thing we have to wait for is the category initialization latch.\n         boolean isCategoryInitialized = false;\n         try {\n-            isCategoryInitialized = categoryInitializationsPending.await(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            isCategoryInitialized = categoryInitializationsPending.await(LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException exception) {\n             LOG.warn(\"Execution interrupted while waiting for DataStore to be initialized.\");\n         }\n         if (!isCategoryInitialized) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDYwMQ==", "bodyText": "Thanks for this detailed analysis!\nI started looking at additional steps that could be taken to tighten up the serialization guarantees in the Orchestrator. I think we can still do that.\nBut, in the interest of delivering this current fix, I will go with the !orchestrator.isStarted() approach you suggest. It isn't ideal, but as you note, we've solved most of the problems by now and are into the long tail.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462624601", "createdAt": "2020-07-29T22:23:43Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -438,70 +424,50 @@ public void observe(\n      * @param onComplete Invoked if the call is successful.\n      * @param onError Invoked if not successful\n      */\n+    @SuppressWarnings(\"unused\")\n     @Override\n     public void clear(@NonNull Action onComplete,\n                       @NonNull Consumer<DataStoreException> onError) {\n         // We shouldn't call beforeOperation when clearing the DataStore. The\n         // only thing we have to wait for is the category initialization latch.\n         boolean isCategoryInitialized = false;\n         try {\n-            isCategoryInitialized = categoryInitializationsPending.await(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            isCategoryInitialized = categoryInitializationsPending.await(LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException exception) {\n             LOG.warn(\"Execution interrupted while waiting for DataStore to be initialized.\");\n         }\n         if (!isCategoryInitialized) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg=="}, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODA3OA==", "bodyText": "Totally agree with this. I think we can continue to iterate on this as needed, but I also feel that with that change, this PR should be considered ready to go.", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462958078", "createdAt": "2020-07-30T12:24:44Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -438,70 +424,50 @@ public void observe(\n      * @param onComplete Invoked if the call is successful.\n      * @param onError Invoked if not successful\n      */\n+    @SuppressWarnings(\"unused\")\n     @Override\n     public void clear(@NonNull Action onComplete,\n                       @NonNull Consumer<DataStoreException> onError) {\n         // We shouldn't call beforeOperation when clearing the DataStore. The\n         // only thing we have to wait for is the category initialization latch.\n         boolean isCategoryInitialized = false;\n         try {\n-            isCategoryInitialized = categoryInitializationsPending.await(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            isCategoryInitialized = categoryInitializationsPending.await(LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException exception) {\n             LOG.warn(\"Execution interrupted while waiting for DataStore to be initialized.\");\n         }\n         if (!isCategoryInitialized) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg=="}, "originalCommit": null, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1114, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}