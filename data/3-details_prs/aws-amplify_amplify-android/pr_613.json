{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwOTc5NzEz", "number": 613, "title": "fix(DataStore): use a LinkedList and HashMap to improve the time comp\u2026", "bodyText": "Previously we need to traverse the entire mutation list to perform lots of pending mutation operation, which results in a O(N) time complexity\n\nupdateExistingQueueItemOrAppendNew\nremoveFromQueue\nfindPendingMutationById\n\nUse above mentioned data structure to optimise them , which uses O(1) time complexity\nAll tests passed.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-06-28T00:25:06Z", "url": "https://github.com/aws-amplify/amplify-android/pull/613", "merged": true, "mergeCommit": {"oid": "42f29e20c8895bd2c9ae3beeb115bc3c88f7978a"}, "closed": true, "closedAt": "2020-08-19T18:54:49Z", "author": {"login": "richardissuperman"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcv6yN4AFqTQzODkwNTc3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAgSV_AFqTQ0MzM2NTUzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4OTA1Nzc0", "url": "https://github.com/aws-amplify/amplify-android/pull/613#pullrequestreview-438905774", "createdAt": "2020-06-29T06:01:41Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwNjowMTo0MVrOGqF3_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwNjowOTo0N1rOGqGB_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4OTYzMA==", "bodyText": "After your refactor, you have several wrapper methods left inside of PersistentMutationOutbox, which are ~one line long. I would remove these, and just call your dat astructure directly, instead of through these wrapper methods:\n\nupdateExitingQueueItemOrAppendNew\nnextMutationForModelId\nremoveFromQueue\nfindPendingMutationById", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446789630", "createdAt": "2020-06-29T06:01:41Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -137,16 +132,7 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n     }\n \n     private <T extends Model> void updateExistingQueueItemOrAppendNew(PendingMutation<T> pendingMutation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDUyNA==", "bodyText": "How about private final MutationQueue mutationQueue, as the data structure's name.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446790524", "createdAt": "2020-06-29T06:04:50Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -55,15 +55,15 @@\n     private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n \n     private final LocalStorageAdapter storage;\n-    private final LinkedList<PendingMutation<? extends Model>> mutationQueue;\n+    private final MutationLinkedList mutationQueue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTA4Ng==", "bodyText": "Should you implement any of the standard Java contracts? extends LinkedHashMap,  implements List, ... implements Comparable<T>, implements Collection<T>, etc.?\n\nAlso for name, I'd use MutationQueue. The PersistentMutationOutbox documentation should be updated to desribe how it differs from a MutationQueue -- that is, the outbox applies (what?) rules about populating the queue, etc.\n\nThis new class should have a corresponding MutationQueueTest.java which tests it as an isolated unit.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446791086", "createdAt": "2020-06-29T06:06:22Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationLinkedList.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.HashMap;\n+\n+/*\n+ * The {@link MutationLinkedList} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ */\n+public class MutationLinkedList {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MjE5MQ==", "bodyText": "Instead of maintaining your own head and tail, can you use a linked list/map or some kind directly? \"Mutation linked list has a (some type of) list, composed into it?\"", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446792191", "createdAt": "2020-06-29T06:09:47Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationLinkedList.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.HashMap;\n+\n+/*\n+ * The {@link MutationLinkedList} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ */\n+public class MutationLinkedList {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationLinkedList() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    public synchronized void remove(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {\n+            Node removingNode = mutationMap.get(id);\n+            Node removingPrev = removingNode.prev;\n+            Node removingNext = removingNode.next;\n+            //remove from map\n+            mutationMap.remove(id);\n+            //remove from current linkedlist\n+            removingPrev.next = removingNext;\n+            removingNext.prev = removingPrev;\n+        }\n+    }\n+\n+    public synchronized void clear() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+        mutationMap.clear();\n+    }\n+\n+    public synchronized boolean isEmpty() {\n+        return mutationMap.isEmpty();\n+    }\n+\n+    public synchronized void addLast(PendingMutation<? extends Model> pendingMutation) {\n+        //constructing a new node\n+        Node pendingNode = new Node();\n+        pendingNode.id = pendingMutation.getMutationId();\n+        pendingNode.mutation = pendingMutation;\n+        //insert the new node into the current linkedlist\n+        Node addingPrev = dummyTail.prev;\n+        addingPrev.next = pendingNode;\n+        dummyTail.prev = pendingNode;\n+        pendingNode.prev = addingPrev;\n+        pendingNode.next = dummyTail;\n+        //put the mutation into the mutationmap\n+        mutationMap.put(pendingMutation.getMutationId(), pendingNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4OTA5MDM4", "url": "https://github.com/aws-amplify/amplify-android/pull/613#pullrequestreview-438909038", "createdAt": "2020-06-29T06:10:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTQzOTc1", "url": "https://github.com/aws-amplify/amplify-android/pull/613#pullrequestreview-440543975", "createdAt": "2020-07-01T04:50:51Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNDo1MDo1MVrOGrWsVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNTowMDowMlrOGrW0-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExMzc0OQ==", "bodyText": "^ Please include standard copyright header (same for any new file in this PR.)", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448113749", "createdAt": "2020-07-01T04:50:51Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDM5MQ==", "bodyText": "A better pattern in test code would be:\n@Before\npublic void setup() {\n    this.mutationQueue = new MutationQueue(...);\n    this.outbox = new MutationOutbox(..., mutationQueue, ...);\n}\n\n@Test\npublic void someTest() {\n    // Access the queue directly instead of exposing a getter on the outbox\n    mutationQueue.doSomething();\n}", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448114391", "createdAt": "2020-07-01T04:53:36Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutboxTest.java", "diffHunk": "@@ -764,7 +764,7 @@ public void nextItemForModelIdReturnsFirstEnqueued() throws DataStoreException {\n \n         assertEquals(\n             firstMutation,\n-            mutationOutbox.nextMutationForModelId(originalJoe.getId())\n+            mutationOutbox.getMutationQueue().nextMutationForModelId(originalJoe.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDkyOA==", "bodyText": "I believe the checkstyle will want a separate import group between java.* and io.*. You can check by running ./gradlew check. Our build treats checkstyle issues as errors, not warnings.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448114928", "createdAt": "2020-07-01T04:55:37Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTIwNQ==", "bodyText": "minor: by convention, the rest of the code base separates declaration and assignment. So, these assignments would be moved to the constructor, to match the existing code style.\nAll of these variables can be marked as final.\nThe mutationMap can be just a private final Map<TimeBasedUuid, Node> mutationMap unless you need some special functionality of the HashMap when you interact with it, in particular.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115205", "createdAt": "2020-07-01T04:56:49Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTU3MA==", "bodyText": "Capital F, end with .. Fill out @param and @return -- same for all.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115570", "createdAt": "2020-07-01T04:58:21Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTc2MQ==", "bodyText": "I would invert this, to be:\nif (!mutationMap.containsKey(id)) {\n    return false;\n}\n// Save 4 columns for the remainder ....\nreturn true;", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115761", "createdAt": "2020-07-01T04:59:16Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id\n+     * @param modelId\n+     * @return\n+     */\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * remove the {@link PendingMutation} from {@link MutationQueue} by its Id.\n+     * this operation should be consuming constant time\n+     * @param id uuid\n+     * @return\n+     */\n+    public synchronized boolean removeById(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTg4Ng==", "bodyText": "You use public in a number of places in this PR. Do you need to? Can you reduce the access to package-private?", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115886", "createdAt": "2020-07-01T04:59:50Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id\n+     * @param modelId\n+     * @return\n+     */\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * remove the {@link PendingMutation} from {@link MutationQueue} by its Id.\n+     * this operation should be consuming constant time\n+     * @param id uuid\n+     * @return\n+     */\n+    public synchronized boolean removeById(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {\n+            Node removingNode = mutationMap.get(id);\n+            Node removingPrev = removingNode.prev;\n+            Node removingNext = removingNode.next;\n+            //remove from map\n+            mutationMap.remove(id);\n+            //remove from current linkedlist\n+            removingPrev.next = removingNext;\n+            removingNext.prev = removingPrev;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * add a {@link PendingMutation} to the tail of this Queue\n+     * @param pendingMutation\n+     * @return\n+     */\n+    private synchronized boolean addToTail(PendingMutation<? extends Model> pendingMutation) {\n+        //constructing a new node\n+        Node pendingNode = new Node();\n+        pendingNode.id = pendingMutation.getMutationId();\n+        pendingNode.mutation = pendingMutation;\n+        //insert the new node into the current linkedlist\n+        Node addingPrev = dummyTail.prev;\n+        addingPrev.next = pendingNode;\n+        dummyTail.prev = pendingNode;\n+        pendingNode.prev = addingPrev;\n+        pendingNode.next = dummyTail;\n+        //put the mutation into the mutationmap\n+        mutationMap.put(pendingMutation.getMutationId(), pendingNode);\n+        return true;\n+    }\n+\n+    /**\n+     * replace an existing {@link PendingMutation} inside the Queue\n+     * @param id\n+     * @param pendingMutation\n+     */\n+    public synchronized void updateExistingQueueItemOrAppendNew(TimeBasedUuid id, PendingMutation<? extends Model> pendingMutation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTk2MA==", "bodyText": "Can be a final class, most likely.\nThe Queue<...> ends up bringing in a lot of methods, actually. Now that you've investigate that route, do you think they add value? Or not? It was an interesting idea, to implement the Queue interface, but perhaps it is overkill. Particularly if many will just throw an exception.", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115960", "createdAt": "2020-07-01T05:00:02Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MDQ4NzEy", "url": "https://github.com/aws-amplify/amplify-android/pull/613#pullrequestreview-456048712", "createdAt": "2020-07-27T18:53:28Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "03e52bc07a0c3c9626a5a23f8da476b4e92db731", "author": {"user": null}, "url": "https://github.com/aws-amplify/amplify-android/commit/03e52bc07a0c3c9626a5a23f8da476b4e92db731", "committedDate": "2020-08-04T03:42:54Z", "message": "fix(DataStore): use a LinkedList and HashMap to improve the time complexity\n\nPreviously we need to traverse the entire mutation list to perform lots of pending mutation operation, which results in a O(N) time complexity\n\n        updateExistingQueueItemOrAppendNew\n        removeFromQueue\n        findPendingMutationById\n        Use above mentioned data structure to optimise them , which uses O(1) time complexity\n\nAll tests passed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23787778f61f2cd76ea04a08b007bf648706f284", "author": {"user": null}, "url": "https://github.com/aws-amplify/amplify-android/commit/23787778f61f2cd76ea04a08b007bf648706f284", "committedDate": "2020-08-04T03:42:54Z", "message": "fix(DataStore): add unit test class for MutationQueue data structure"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "23787778f61f2cd76ea04a08b007bf648706f284", "author": {"user": null}, "url": "https://github.com/aws-amplify/amplify-android/commit/23787778f61f2cd76ea04a08b007bf648706f284", "committedDate": "2020-08-04T03:42:54Z", "message": "fix(DataStore): add unit test class for MutationQueue data structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "author": {"user": null}, "url": "https://github.com/aws-amplify/amplify-android/commit/40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "committedDate": "2020-08-04T04:15:53Z", "message": "fix(Auth):  fix a broken unit test, user agent was included in prod code but not in the unit test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "author": {"user": null}, "url": "https://github.com/aws-amplify/amplify-android/commit/40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "committedDate": "2020-08-04T04:15:53Z", "message": "fix(Auth):  fix a broken unit test, user agent was included in prod code but not in the unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzY1NTMw", "url": "https://github.com/aws-amplify/amplify-android/pull/613#pullrequestreview-443365530", "createdAt": "2020-07-06T19:54:05Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOTo1NDowNlrOGtlE3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOTo1NDowNlrOGtlE3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0NjU1OA==", "bodyText": "2020", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r450446558", "createdAt": "2020-07-06T19:54:06Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1842, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}