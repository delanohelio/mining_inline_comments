{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NzYyMjM0", "number": 737, "title": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords", "bodyText": "Currently, DataStore only syncs up to 1_000 items for each model.  The sync query response includes a \"nextToken\" if there are more pages of results available, but this is currently ignored.\nThis PR adds support for fetching additional pages of results.\n\nCustomers can set syncPageSize on the DataStoreConfiguration to control the number of results per page.   This defaults to 1_000. Customers may need to lower this number if the model is large, because the result set from a DDB Scan is limited to 1 MB per call.\nCustomers can set syncMaxRecords on the DataStoreConfiguration to control the total number of items to sync.  This defaults to 10_000`.\n\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-08-18T21:43:33Z", "url": "https://github.com/aws-amplify/amplify-android/pull/737", "merged": true, "mergeCommit": {"oid": "ec0006bea996ff953829086c91d75d916650132a"}, "closed": true, "closedAt": "2020-08-26T21:09:31Z", "author": {"login": "richardmcclellan"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAo66PgFqTQ3MTIxNDgzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCxdLRAH2gAyNDY5NzYyMjM0OjZmYmFiMzk1NTNjZjQwY2RhN2Q1OTRlYzY5MDE4NmM0YmQzOGU4M2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjE0ODM1", "url": "https://github.com/aws-amplify/amplify-android/pull/737#pullrequestreview-471214835", "createdAt": "2020-08-20T04:39:58Z", "commit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNDozOTo1OFrOHDpR9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNDo1Mjo0NVrOHDpetQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDExOA==", "bodyText": "I like to use +8 for method params, so that the body is clearly distinguished at +4\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n          \n          \n            \n                    SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n          \n          \n            \n                    Set<ModelWithMetadata<T>> emittedValue) {\n          \n          \n            \n                        GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n          \n          \n            \n                        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n          \n          \n            \n                        Set<ModelWithMetadata<T>> emittedValue) {", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584118", "createdAt": "2020-08-20T04:39:58Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -166,28 +168,41 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n      *  2. Make a request to the AppSync endpoint. If the last sync time is within a recent window\n      *     of time, then request a *delta* sync. If the last sync time is outside a recent window of time,\n      *     perform a *base* sync. A base sync is preformed by passing null.\n-     *  3. Update the\n+     *  3. Continue fetching paged results until !hasNextPage() or we have synced the max records.\n      * @param modelClass The model class to sync\n-     * @param <T> The type of model to sync\n+     * @param <T> The type of model to sync.\n      * @return An {@link Single} which emits sync content, on success, {@link DataStoreException} on failure\n      */\n     private <T extends Model> Single<Iterable<ModelWithMetadata<T>>> syncModel(\n             Class<T> modelClass, SyncTime syncTime) {\n         final Long lastSyncTimeAsLong = syncTime.exists() ? syncTime.toLong() : null;\n         return Single.<Iterable<ModelWithMetadata<T>>>create(emitter -> {\n-            final Cancelable cancelable =\n-                appSync.sync(modelClass, lastSyncTimeAsLong, metadataEmitter(emitter), emitter::onError);\n-            emitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n+            final Integer syncPageSize = dataStoreConfigurationProvider.getConfiguration().getSyncPageSize();\n+            GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request =\n+                    appSync.buildSyncRequest(modelClass, lastSyncTimeAsLong, syncPageSize);\n+            syncPage(request, emitter, new HashSet<>());\n         }).doOnSuccess(results ->\n             LOG.debug(\"Successfully sync'd down cloud state for model type = \" + modelClass.getSimpleName())\n         ).doOnError(failureToSync ->\n             LOG.warn(\"Failed to sync down cloud state for model type = \" + modelClass.getSimpleName(), failureToSync)\n         );\n     }\n \n-    private static <T extends Model> Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> metadataEmitter(\n-        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter) {\n-        return resultFromEndpoint -> {\n+    /**\n+     * Recursively fetches each page for a sync, until there are no more pages available, or we have fetched the maximum\n+     * configured number of records to sync (syncMaxRecords).\n+     * @param request GraphQLRequest object for the sync, obtained from appsync.buildFirstPageSyncRequest, or from\n+     *                response.getData().getRequestForNextResult() for subsequent requests.\n+     * @param singleEmitter A SingleEmitter which emits an Iterable&lt;ModelWithMetadata&gt;, a concatenation of the\n+     *                      results from all pages.\n+     * @param emittedValue a Set&lt;ModelWithMetadata&lt;T&gt;&gt; containing the concatenated results of all requests.\n+     * @param <T> The type of model to sync.\n+     */\n+    private <T extends Model> void syncPage(\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n+        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n+        Set<ModelWithMetadata<T>> emittedValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDY3MQ==", "bodyText": "Is this a realistic scenario?\nIf so, can we handle this in the code which build the configuration object, instead? S.t. the configuration always has some sane value, by the time we get here to access it?", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584671", "createdAt": "2020-08-20T04:41:57Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -198,13 +213,26 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n                     \"Empty response from AppSync.\", \"Report to AWS team.\"\n                 ));\n             } else {\n-                final Set<ModelWithMetadata<T>> emittedValue = new HashSet<>();\n-                for (ModelWithMetadata<T> modelWithMetadata : resultFromEndpoint.getData()) {\n+                for (ModelWithMetadata<T> modelWithMetadata : resultFromEndpoint.getData().getItems()) {\n                     emittedValue.add(modelWithMetadata);\n                 }\n-                singleEmitter.onSuccess(emittedValue);\n+                if (resultFromEndpoint.getData().hasNextResult() && emittedValue.size() < syncMaxRecords()) {\n+                    syncPage(resultFromEndpoint.getData().getRequestForNextResult(), singleEmitter, emittedValue);\n+                } else {\n+                    singleEmitter.onSuccess(emittedValue);\n+                }\n             }\n-        };\n+        }, singleEmitter::onError);\n+        singleEmitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n+    }\n+\n+    private Integer syncMaxRecords() {\n+        try {\n+            return dataStoreConfigurationProvider.getConfiguration().getSyncMaxRecords();\n+        } catch (DataStoreException exception) {\n+            LOG.warn(\"Failed to retrieve datastore configuration, using default syncMaxRecords value.\", exception);\n+            return DEFAULT_SYNC_MAX_RECORDS;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDgzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(new ArrayList<>(), null);\n          \n          \n            \n                    mockApiResponse(new GraphQLResponse<>(data, new ArrayList<>()));\n          \n          \n            \n                    PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(Collections.emptyList(), null);\n          \n          \n            \n                    mockApiResponse(new GraphQLResponse<>(data, Collections.emptyList()));", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584832", "createdAt": "2020-08-20T04:42:44Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncClientTest.java", "diffHunk": "@@ -68,7 +69,8 @@ public void setup() {\n \n         // We need it to response with **something** by default.\n         // Use this same method to send more interesting test values back...\n-        mockApiResponse(new GraphQLResponse<>(new ArrayList<>(), new ArrayList<>()));\n+        PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(new ArrayList<>(), null);\n+        mockApiResponse(new GraphQLResponse<>(data, new ArrayList<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NzE3NQ==", "bodyText": "Method name: matchesRequest? It'll look cool above when you write argThat(matchesRequest(!", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473587175", "createdAt": "2020-08-20T04:51:55Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMocking.java", "diffHunk": "@@ -213,91 +224,159 @@ public static OnDeleteConfigurator onDelete(AppSync mock) {\n         /**\n          * Constructs a new SyncConfigurator.\n          * @param appSync A mock AppSync instance\n+         * @throws DataStoreException if a ModelSchema cannot be created in order to build the sync request.\n          */\n-        SyncConfigurator(AppSync appSync) {\n+        SyncConfigurator(AppSync appSync) throws DataStoreException {\n             this.appSync = appSync;\n+            this.mockBuildSyncRequest();\n             this.mockSuccessResponses();\n         }\n \n+        private <M extends Model> SyncConfigurator mockBuildSyncRequest() throws DataStoreException {\n+            when(appSync.buildSyncRequest(any(), any(), any()))\n+                    .thenAnswer((Answer<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>>) invocation -> {\n+                        Class<M> modelClass = invocation.getArgument(0);\n+                        Long lastSync = invocation.getArgument(1);\n+                        Integer syncPageSize = invocation.getArgument(2);\n+                        return AppSyncRequestFactory.buildSyncRequest(modelClass, lastSync, syncPageSize);\n+                    });\n+            return this;\n+        }\n+\n         /**\n          * By default, return an empty list of items when attempting to sync any/all Model classes.\n+         * @param <M> Type of model for which a response is mocked.\n          * @return Configurator instance\n          */\n         @NonNull\n-        public SyncConfigurator mockSuccessResponses() {\n-            doAnswer(invocation -> {\n-                // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<? extends Model>>>> consumer =\n-                    invocation.getArgument(argumentPositionForResponseConsumer);\n-\n-                // Call the response consumer, and pass EMPTY items inside of a GraphQLResponse wrapper\n-                consumer.accept(new GraphQLResponse<>(Collections.emptyList(), Collections.emptyList()));\n-\n-                // Return a NoOp cancelable via the sync() method's return.\n-                return new NoOpCancelable();\n-            }).when(appSync).sync(\n-                any(), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+        public <M extends Model> SyncConfigurator mockSuccessResponses() {\n+            return mockSuccessResponse(\n+                arg -> true, // Match all GraphQLRequest objects.\n+                new GraphQLResponse<>(\n+                    new PaginatedResult<>(Collections.emptyList(), null),\n+                    Collections.emptyList()\n+                )\n             );\n-            return this;\n         }\n \n         /**\n          * Configures an instance of an {@link AppSync} to provide a fake response when asked to\n-         * to {@link AppSync#sync(Class, Long, Consumer, Consumer)}. The response callback will\n+         * to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}. The response callback will\n          * be invoked, and will contain the provided ModelWithMetadata in its response.\n          * @param modelClass Class of models for which the endpoint should respond\n          * @param responseItems The items that should be included in the mocked response, for the model class\n-         * @param <T> Type of models for which a response is mocked\n+         * @param <M> Type of models for which a response is mocked\n          * @return The same Configurator instance, to enable chaining of calls\n          */\n         @SuppressWarnings(\"varargs\")\n         @SafeVarargs\n-        public final <T extends Model> SyncConfigurator mockSuccessResponse(\n-                Class<T> modelClass, ModelWithMetadata<T>... responseItems) {\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass, ModelWithMetadata<M>... responseItems) {\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, null),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(new HashSet<>(Arrays.asList(responseItems)), null),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback when asked to\n+         * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}, with the ability to specify a nextToken to match,\n+         * and a nextToken to return in the response, for testing pagination.\n+         * @param modelClass Class of models for which the endpoint should respond\n+         * @param token nextToken to be expected on the GraphQLRequest for which the endpoint should respond.\n+         * @param nextToken nextToken that should be used to build the requestForNextResult on the GraphQLResponse.\n+         * @param responseItems The items that should be included in the mocked response, for the model class\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         * @throws AmplifyException if a ModelSchema cannot be created in order to build the sync request.\n+         */\n+        @SuppressWarnings(\"varargs\")\n+        @SafeVarargs\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass,\n+                String token,\n+                String nextToken,\n+                ModelWithMetadata<M>... responseItems) throws AmplifyException {\n+            final Iterable<ModelWithMetadata<M>> items = new HashSet<>(Arrays.asList(responseItems));\n+            AppSyncGraphQLRequest<PaginatedResult<ModelWithMetadata<M>>> requestForNextResult = null;\n+            if (nextToken != null) {\n+                requestForNextResult = AppSyncRequestFactory.buildSyncRequest(modelClass, null, null)\n+                        .newBuilder()\n+                        .variable(\"nextToken\", \"String\", nextToken)\n+                        .build();\n+            }\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, token),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(items, requestForNextResult),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback with the provided mockResponse\n+         * when asked to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}.\n+         * @param requestMatcher ArgumentMatcher which returns true if the GraphQLRequest should be mocked.\n+         * @param mockResponse GraphQLResponse to be passed back in the response callback.\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         */\n+        public <M extends Model> SyncConfigurator mockSuccessResponse(\n+                ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> requestMatcher,\n+                GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>> mockResponse) {\n             doAnswer(invocation -> {\n                 // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> consumer =\n+                // Response consumer is the second param, at index 1 (@0, @1, @2).\n+                final int argumentPositionForResponseConsumer = 1;\n+                final Consumer<GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>> consumer =\n                     invocation.getArgument(argumentPositionForResponseConsumer);\n \n-                // Call the response consumer, and pass the mocked items\n-                // inside of a GraphQLResponse wrapper\n-                final Iterable<ModelWithMetadata<T>> data = new HashSet<>(Arrays.asList(responseItems));\n-                consumer.accept(new GraphQLResponse<>(data, Collections.emptyList()));\n+                // Call the response consumer, and pass the mocked response\n+                consumer.accept(mockResponse);\n \n                 // Return a NoOp cancelable via the sync() method's return.\n                 return new NoOpCancelable();\n             }).when(appSync).sync(\n-                eq(modelClass), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+                argThat(requestMatcher),\n+                any(), // Consumer<GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>>\n+                any()  // Consumer<DataStoreException>\n             );\n             return SyncConfigurator.this;\n         }\n \n+        private <M extends Model> ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> matcherFor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NzM4MQ==", "bodyText": "I really appreciate you taking the time and consideration to update some of this ancillary stuff. This would be easy to overlook, and often is.", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473587381", "createdAt": "2020-08-20T04:52:45Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMocking.java", "diffHunk": "@@ -213,91 +224,159 @@ public static OnDeleteConfigurator onDelete(AppSync mock) {\n         /**\n          * Constructs a new SyncConfigurator.\n          * @param appSync A mock AppSync instance\n+         * @throws DataStoreException if a ModelSchema cannot be created in order to build the sync request.\n          */\n-        SyncConfigurator(AppSync appSync) {\n+        SyncConfigurator(AppSync appSync) throws DataStoreException {\n             this.appSync = appSync;\n+            this.mockBuildSyncRequest();\n             this.mockSuccessResponses();\n         }\n \n+        private <M extends Model> SyncConfigurator mockBuildSyncRequest() throws DataStoreException {\n+            when(appSync.buildSyncRequest(any(), any(), any()))\n+                    .thenAnswer((Answer<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>>) invocation -> {\n+                        Class<M> modelClass = invocation.getArgument(0);\n+                        Long lastSync = invocation.getArgument(1);\n+                        Integer syncPageSize = invocation.getArgument(2);\n+                        return AppSyncRequestFactory.buildSyncRequest(modelClass, lastSync, syncPageSize);\n+                    });\n+            return this;\n+        }\n+\n         /**\n          * By default, return an empty list of items when attempting to sync any/all Model classes.\n+         * @param <M> Type of model for which a response is mocked.\n          * @return Configurator instance\n          */\n         @NonNull\n-        public SyncConfigurator mockSuccessResponses() {\n-            doAnswer(invocation -> {\n-                // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<? extends Model>>>> consumer =\n-                    invocation.getArgument(argumentPositionForResponseConsumer);\n-\n-                // Call the response consumer, and pass EMPTY items inside of a GraphQLResponse wrapper\n-                consumer.accept(new GraphQLResponse<>(Collections.emptyList(), Collections.emptyList()));\n-\n-                // Return a NoOp cancelable via the sync() method's return.\n-                return new NoOpCancelable();\n-            }).when(appSync).sync(\n-                any(), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+        public <M extends Model> SyncConfigurator mockSuccessResponses() {\n+            return mockSuccessResponse(\n+                arg -> true, // Match all GraphQLRequest objects.\n+                new GraphQLResponse<>(\n+                    new PaginatedResult<>(Collections.emptyList(), null),\n+                    Collections.emptyList()\n+                )\n             );\n-            return this;\n         }\n \n         /**\n          * Configures an instance of an {@link AppSync} to provide a fake response when asked to\n-         * to {@link AppSync#sync(Class, Long, Consumer, Consumer)}. The response callback will\n+         * to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}. The response callback will\n          * be invoked, and will contain the provided ModelWithMetadata in its response.\n          * @param modelClass Class of models for which the endpoint should respond\n          * @param responseItems The items that should be included in the mocked response, for the model class\n-         * @param <T> Type of models for which a response is mocked\n+         * @param <M> Type of models for which a response is mocked\n          * @return The same Configurator instance, to enable chaining of calls\n          */\n         @SuppressWarnings(\"varargs\")\n         @SafeVarargs\n-        public final <T extends Model> SyncConfigurator mockSuccessResponse(\n-                Class<T> modelClass, ModelWithMetadata<T>... responseItems) {\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass, ModelWithMetadata<M>... responseItems) {\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, null),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(new HashSet<>(Arrays.asList(responseItems)), null),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback when asked to\n+         * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}, with the ability to specify a nextToken to match,\n+         * and a nextToken to return in the response, for testing pagination.\n+         * @param modelClass Class of models for which the endpoint should respond\n+         * @param token nextToken to be expected on the GraphQLRequest for which the endpoint should respond.\n+         * @param nextToken nextToken that should be used to build the requestForNextResult on the GraphQLResponse.\n+         * @param responseItems The items that should be included in the mocked response, for the model class\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         * @throws AmplifyException if a ModelSchema cannot be created in order to build the sync request.\n+         */\n+        @SuppressWarnings(\"varargs\")\n+        @SafeVarargs\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass,\n+                String token,\n+                String nextToken,\n+                ModelWithMetadata<M>... responseItems) throws AmplifyException {\n+            final Iterable<ModelWithMetadata<M>> items = new HashSet<>(Arrays.asList(responseItems));\n+            AppSyncGraphQLRequest<PaginatedResult<ModelWithMetadata<M>>> requestForNextResult = null;\n+            if (nextToken != null) {\n+                requestForNextResult = AppSyncRequestFactory.buildSyncRequest(modelClass, null, null)\n+                        .newBuilder()\n+                        .variable(\"nextToken\", \"String\", nextToken)\n+                        .build();\n+            }\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, token),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(items, requestForNextResult),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback with the provided mockResponse\n+         * when asked to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}.\n+         * @param requestMatcher ArgumentMatcher which returns true if the GraphQLRequest should be mocked.\n+         * @param mockResponse GraphQLResponse to be passed back in the response callback.\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         */\n+        public <M extends Model> SyncConfigurator mockSuccessResponse(\n+                ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> requestMatcher,\n+                GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>> mockResponse) {\n             doAnswer(invocation -> {\n                 // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> consumer =\n+                // Response consumer is the second param, at index 1 (@0, @1, @2).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316"}, "originalPosition": 183}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0bd85f723c725ec1566250ff48447ccb9eba8e4", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f0bd85f723c725ec1566250ff48447ccb9eba8e4", "committedDate": "2020-08-21T20:34:12Z", "message": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords config params"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e207db3055dd918ef460dd11d21bb28b36174316", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/e207db3055dd918ef460dd11d21bb28b36174316", "committedDate": "2020-08-18T21:34:30Z", "message": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords config params"}, "afterCommit": {"oid": "f0bd85f723c725ec1566250ff48447ccb9eba8e4", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f0bd85f723c725ec1566250ff48447ccb9eba8e4", "committedDate": "2020-08-21T20:34:12Z", "message": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords config params"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7bbe33910add5be38176a9fe6804744554e9a37", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f7bbe33910add5be38176a9fe6804744554e9a37", "committedDate": "2020-08-24T21:50:54Z", "message": "Merge from main"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de40c5b1c4110b0d1c21fd96a4728704eaa4a905", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/de40c5b1c4110b0d1c21fd96a4728704eaa4a905", "committedDate": "2020-08-25T20:41:41Z", "message": "Merge branch 'main' into rm/ds-paging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5c1bab96b3a03994512eabe96a314ac17e9d71", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/da5c1bab96b3a03994512eabe96a314ac17e9d71", "committedDate": "2020-08-26T04:21:31Z", "message": "Fix stackoverflow error when paginating lots of pages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "da5c1bab96b3a03994512eabe96a314ac17e9d71", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/da5c1bab96b3a03994512eabe96a314ac17e9d71", "committedDate": "2020-08-26T04:21:31Z", "message": "Fix stackoverflow error when paginating lots of pages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a33c6ac950450062a73458c4c2e27527d66dec6d", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/a33c6ac950450062a73458c4c2e27527d66dec6d", "committedDate": "2020-08-26T14:39:41Z", "message": "Update aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncClientTest.java\n\nCo-authored-by: Jameson Williams <jhwill@amazon.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NTY0MDYz", "url": "https://github.com/aws-amplify/amplify-android/pull/737#pullrequestreview-475564063", "createdAt": "2020-08-26T14:45:22Z", "commit": {"oid": "a33c6ac950450062a73458c4c2e27527d66dec6d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo0NToyMlrOHHPoeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNDo0NToyMlrOHHPoeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1ODIwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Validate the sync can handle 500 of pages.  Even with a recursive, functional algorithm, this should pass.\n          \n          \n            \n                 * Validate the sync can handle 100 of pages.  Even with a recursive, functional algorithm, this should pass.", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477358201", "createdAt": "2020-08-26T14:45:22Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java", "diffHunk": "@@ -402,6 +423,138 @@ public void userProvidedErrorCallbackInvokedOnFailure() {\n         assertEquals(1, errorHandlerCallCount);\n     }\n \n+    /**\n+     * Validate that all records are synced, via pagination.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void modelWithMultiplePagesSyncsAllPages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(5, 10);\n+    }\n+\n+    /**\n+     * Validate that sync stops after retrieving syncMaxRecords results, even if there are more pages available.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncStopsAfterMaxRecords() throws AmplifyException, InterruptedException {\n+        syncAndExpect(10, 5);\n+    }\n+\n+    /**\n+     * Validate the sync can handle 500 of pages.  Even with a recursive, functional algorithm, this should pass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a33c6ac950450062a73458c4c2e27527d66dec6d"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c335bf41967eb32c264022ef00bf965b213de08", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/4c335bf41967eb32c264022ef00bf965b213de08", "committedDate": "2020-08-26T14:45:27Z", "message": "Update aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NzI3NTQ3", "url": "https://github.com/aws-amplify/amplify-android/pull/737#pullrequestreview-475727547", "createdAt": "2020-08-26T17:57:24Z", "commit": {"oid": "4c335bf41967eb32c264022ef00bf965b213de08"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzo1NzoyNFrOHHXX7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODowMToyNVrOHHXhTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NTAzOQ==", "bodyText": "Woo-hoo!!", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477485039", "createdAt": "2020-08-26T17:57:24Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java", "diffHunk": "@@ -402,6 +423,138 @@ public void userProvidedErrorCallbackInvokedOnFailure() {\n         assertEquals(1, errorHandlerCallCount);\n     }\n \n+    /**\n+     * Validate that all records are synced, via pagination.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void modelWithMultiplePagesSyncsAllPages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(5, 10);\n+    }\n+\n+    /**\n+     * Validate that sync stops after retrieving syncMaxRecords results, even if there are more pages available.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncStopsAfterMaxRecords() throws AmplifyException, InterruptedException {\n+        syncAndExpect(10, 5);\n+    }\n+\n+    /**\n+     * Validate the sync can handle 100 of pages.  Even with a recursive, functional algorithm, this should pass.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncCanHandle100Pages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(100, 10000);\n+    }\n+\n+    /**\n+     * Validate that sync can handle 1000 more pages.  This fails with a StackOverflowError if sync is implemented\n+     * recursively, because each call to the sync method is saved on the stack before execution\n+     * begins.  The solution is to use an iterative algorithm.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncCanHandle1000Pages() throws AmplifyException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c335bf41967eb32c264022ef00bf965b213de08"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NzQzNw==", "bodyText": "189-200 -- some advanced stuff going on here, very cool!", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477487437", "createdAt": "2020-08-26T18:01:25Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -172,45 +169,62 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n      *  2. Make a request to the AppSync endpoint. If the last sync time is within a recent window\n      *     of time, then request a *delta* sync. If the last sync time is outside a recent window of time,\n      *     perform a *base* sync. A base sync is preformed by passing null.\n-     *  3. Update the\n+     *  3. Continue fetching paged results until !hasNextResult() or we have synced the max records.\n+     *\n      * @param modelClass The model class to sync\n-     * @param <T> The type of model to sync\n-     * @return An {@link Single} which emits sync content, on success, {@link DataStoreException} on failure\n+     * @param syncTime The time of a last successful sync.\n+     * @param <T> The type of model to sync.\n+     * @return a stream of all ModelWithMetadata&lt;T&gt; objects from all pages for the provided model.\n+     * @throws DataStoreException if dataStoreConfigurationProvider.getConfiguration() fails\n      */\n-    private <T extends Model> Single<Iterable<ModelWithMetadata<T>>> syncModel(\n-            Class<T> modelClass, SyncTime syncTime) {\n+    private <T extends Model> Flowable<ModelWithMetadata<T>> syncModel(Class<T> modelClass, SyncTime syncTime)\n+            throws DataStoreException {\n         final Long lastSyncTimeAsLong = syncTime.exists() ? syncTime.toLong() : null;\n-        return Single.<Iterable<ModelWithMetadata<T>>>create(emitter -> {\n-            final Cancelable cancelable =\n-                appSync.sync(modelClass, lastSyncTimeAsLong, metadataEmitter(emitter), emitter::onError);\n-            emitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n-        }).doOnSuccess(results ->\n-            LOG.debug(\"Successfully sync'd down cloud state for model type = \" + modelClass.getSimpleName())\n-        ).doOnError(failureToSync ->\n-            LOG.warn(\"Failed to sync down cloud state for model type = \" + modelClass.getSimpleName(), failureToSync)\n-        );\n+        final Integer syncPageSize = dataStoreConfigurationProvider.getConfiguration().getSyncPageSize();\n+\n+        // Create a BehaviorProcessor, and set the default value to a GraphQLRequest that fetches the first page.\n+        BehaviorProcessor<GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>>> processor =\n+                BehaviorProcessor.createDefault(appSync.buildSyncRequest(modelClass, lastSyncTimeAsLong, syncPageSize));\n+\n+        return processor.concatMap(request -> syncPage(request).toFlowable())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c335bf41967eb32c264022ef00bf965b213de08"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fbab39553cf40cda7d594ec690186c4bd38e83f", "author": {"user": {"login": "richardmcclellan", "name": "Richard McClellan"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/6fbab39553cf40cda7d594ec690186c4bd38e83f", "committedDate": "2020-08-26T20:02:18Z", "message": "import Collections"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1969, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}