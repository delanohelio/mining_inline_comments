{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NzE5MTA2", "number": 398, "title": "add support for non-model types in DataStore", "bodyText": "Note: this PR contains the commit(s) from #418 in order to get a green build. The diff should be adjusted once that one is merged to master.\nDataStore custom types (aka \"non-model types\")\nGraphQL schemas support the declaration of types that are not annotated with @model and they can be used as types of properties. For example:\ntype Author {\n  name: String!\n  email: String!\n}\n\ntype Todo @model {\n  id: ID!\n  title: String!\n  author: Author\n}\nThe author property in there is not a model, which means it is not saved to its own table. It is used as a nested value. On the SQLite implementation, GSON is used so those types are serialized into a JSON string and saved in a text column.\nArrays\nArrays of standard scalars, enums or custom types are also considered a custom type itself. Therefore as of this PR the following is also supported:\ntype Post @model {\n  id: ID!\n  title: String!\n  tags: [String]!\n}\nThe same logic applies and the array is handled as any other custom type (i.e. as a JSON string).\nThe value conversion clean-up: ModelFieldTypeConverter\nThe code for value conversion between Model and SQLite's Cursor was relying on a handful of different functions inside the adapter implementation. It was really hard to track and maintain. A problem that also existed on iOS as well and it was solved on this PR: aws-amplify/amplify-ios@aada5e7#diff-f8bf0cd6f02f8c59720e23a8c1fd9cf8R11\nThe solution doesn't drastically change the Enum logic we currently have, but re-organizes it into a more predictable way of converting properties to/from the Model.\nCodegen\nAmplify CLI has a PR out (aws-amplify/amplify-cli#3976) that adds support for custom types on Android. The test models on this PR were generated using the code from that PR, so this validates the output is valid and that PR is ready to ship.\nTODO\nAfter the work on Date/Time types is done, changes to the code in this PR will be necessary. They are marked with a TODO (@richardmcclellan).\nDisclaimer\nIt's been a few years I don't do anything in Java, so please treat it with care, even nit-picking comments are more than welcome.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-04-24T19:10:45Z", "url": "https://github.com/aws-amplify/amplify-android/pull/398", "merged": true, "mergeCommit": {"oid": "f1b2034e088f1a0a0ac2f57b1c4802267223d16c"}, "closed": true, "closedAt": "2020-05-01T20:26:19Z", "author": {"login": "drochetti"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABca2BTygH2gAyNDA4NzE5MTA2OmQxOGY2ZmYxMjhlODk0NTNiYjEzNzJiYTUwMzRiZTEzNjk5NjUxZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdD-LbgH2gAyNDA4NzE5MTA2OjA0MjFkNjM0N2QwNGEzYzVhMzI0MDI3YThlY2FiMzkzYmNmNzUwM2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/d18f6ff128e89453bb1372ba5034be13699651f5", "committedDate": "2020-04-24T18:44:25Z", "message": "add support for non-model types in DataStore\n\n**Notes:**\n\n- GraphQL schemas can contain custom types that are not annotated with\n@model, these \"custom types\" are now handled and saved as JSON strings\nin SQLite and correctly deserialized when querying the models.\n- Cleanup of the value conversion logic, organized the standalone\nprivate methods into a `ModelFieldTypeConverter` interface with a\ndefault SQLite implementation\n- Added a new set of models for testing custom types"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDc0NTE4", "url": "https://github.com/aws-amplify/amplify-android/pull/398#pullrequestreview-400474518", "createdAt": "2020-04-26T08:20:06Z", "commit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwODoyMDowN1rOGMA7MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwOToxMDo1N1rOGMBiRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MTI0OQ==", "bodyText": "For all of the assertEquals(.., ...) calls -- you have actual and expected backwards. The correct ordering is to put the expected value first, and the actual value second.\nIt doesn't make a huge different, except in how jUnit does reporting, when things go wrong. Right now, the message would print something like:\n\nWanted actual value! But actually, it was expected value.\n\nWhere-as it would ordinarily say:\n\nWanted the expected value, but actually, it was this actual value.", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415251249", "createdAt": "2020-04-26T08:20:07Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterModelConverterTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.todo.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.todo.Todo;\n+import com.amplifyframework.testmodels.todo.TodoOwner;\n+import com.amplifyframework.testmodels.todo.TodoStatus;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public final class SQLiteStorageAdapterModelConverterTest {\n+\n+    private static final Date MAY_THE_FOURTH = new Date(1588627200000L);\n+\n+    private SynchronousStorageAdapter adapter;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        this.adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+    }\n+\n+    @After\n+    public void teardown() {\n+        if (adapter != null) {\n+            TestStorageAdapter.cleanup(adapter);\n+        }\n+    }\n+\n+    /**\n+     * Assert that save a model instance with fields of different types in the SQLite database correctly.\n+     * Then after save succeeds, query it and compare the values against the original model.\n+     *\n+     * @throws DataStoreException On unexpected failure manipulating items in/out of DataStore\n+     */\n+    @Test\n+    public void saveModelWithAllTypesThenQuery() throws DataStoreException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MjI3Nw==", "bodyText": "For any of these blocks where you drill down into an object's individual fields, it should be possible instead to do:\nassertEquals(\n   expectedHighLevelObject,\n    actualHighLevelObject\n);\n\nThis will work so long as the class implements a sane equals(...) function.\n(There's a few layers of complexity before it arrives here, but the assert* family all just basically check expected.equals(actual), here.", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415252277", "createdAt": "2020-04-26T08:25:12Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterModelConverterTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.todo.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.todo.Todo;\n+import com.amplifyframework.testmodels.todo.TodoOwner;\n+import com.amplifyframework.testmodels.todo.TodoStatus;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public final class SQLiteStorageAdapterModelConverterTest {\n+\n+    private static final Date MAY_THE_FOURTH = new Date(1588627200000L);\n+\n+    private SynchronousStorageAdapter adapter;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        this.adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+    }\n+\n+    @After\n+    public void teardown() {\n+        if (adapter != null) {\n+            TestStorageAdapter.cleanup(adapter);\n+        }\n+    }\n+\n+    /**\n+     * Assert that save a model instance with fields of different types in the SQLite database correctly.\n+     * Then after save succeeds, query it and compare the values against the original model.\n+     *\n+     * @throws DataStoreException On unexpected failure manipulating items in/out of DataStore\n+     */\n+    @Test\n+    public void saveModelWithAllTypesThenQuery() throws DataStoreException {\n+        final Todo todo = createTestTodoModel();\n+        this.adapter.save(todo);\n+\n+        final List<Todo> result = this.adapter.query(Todo.class, Todo.ID.eq(todo.getId()));\n+        assertEquals(result.size(), 1);\n+\n+        final Todo queriedTodo = result.get(0);\n+        assertNotNull(queriedTodo);\n+\n+        // Test common scalar types\n+        assertEquals(queriedTodo.getTitle(), todo.getTitle());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NTI2Mw==", "bodyText": "Most Java documents in this project are grouping instance variables together tightly, without newlines, right now.", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415255263", "createdAt": "2020-04-26T08:40:25Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzEwNQ==", "bodyText": "So far, and in the interest of keeping the tag short, all of these just say \"amplify:aws-datastore\", right now. (Well okay, I lied. The integration tests use \"amplify:aws-datastore:test\". This strategy is a little bit different from the ordinary private static final Sting LOG = CurrentClassName.class.getName() that is often used. The thinking was that we could  thinking of logging in a more wholistic way across a module, and then everything under a shared slug would be self-consistent (and also, terse.)", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257105", "createdAt": "2020-04-26T08:49:22Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzQzMg==", "bodyText": "It it possible to catch (AFewSpecific | KnownExceptionTypes conversionFailure) here, as opposed to catch (Exception allPossibleErrors)?", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257432", "createdAt": "2020-04-26T08:51:12Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzY3OQ==", "bodyText": "Hmm. Maybe, check the schema? Or, report a bug to AWS? Or, check the type in the annotation in the model?", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257679", "createdAt": "2020-04-26T08:52:20Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1OTI1OA==", "bodyText": "What do you think about gson.toJson(fieldValue) as a default?", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415259258", "createdAt": "2020-04-26T09:00:27Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MDgyMg==", "bodyText": "If we assume that models only come from the code-generator, it might be over-kill to fall back on field inspection, here.\nIn practice, there's a whole set of expectations our code base has about M extends Model type classes. The interface says they need a method called getId(), but in reality, we have all of the (currently required) annotations, etc. Should we just assume they have getter methods? Or if we do the field access thing, should we respect the private access of the field? (I guess, tools like GSON don't, they just read the private field ...)\nAs a note on construction - can we avoid nesting the try/catch in a try/catch here?\nMaybe the flow could be like:\ntry {\n   return favorableApproach();\n} catch (DidntPanOutException favorableDidntWork) {\n    // ...\n}\ntry {\n    return fallbackApprach();\n} catch (FlalbackException alsoDidntWork) {\n    // ...\n}\n\n?", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415260822", "createdAt": "2020-04-26T09:08:23Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;\n+        }\n+    }\n+\n+    private Object getModelValue(Model model, String fieldName) throws DataStoreException {\n+        Class<? extends Model> modelClass = model.getClass();\n+        final String getterName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\n+        try {\n+            final Method fieldGetter = modelClass.getMethod(getterName);\n+            return fieldGetter.invoke(model);\n+        } catch (Exception exception) {\n+            LOGGER.debug(\"Could not find \" + getterName + \"() on \" + modelClass.getName()\n+                    + \". Fallback to direct field access.\");\n+            // fallback to direct field access", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MTI1Mg==", "bodyText": "This is sort of a rule about the model classes. I wonder if we could make this a utility on one of them. Like ModelSchema.getterForField(fieldName)?  Maybe not ModelSchema itself...", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415261252", "createdAt": "2020-04-26T09:10:57Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;\n+        }\n+    }\n+\n+    private Object getModelValue(Model model, String fieldName) throws DataStoreException {\n+        Class<? extends Model> modelClass = model.getClass();\n+        final String getterName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18f6ff128e89453bb1372ba5034be13699651f5"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26089ae974050b8a5decca07d763eeea2ca5ca14", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/26089ae974050b8a5decca07d763eeea2ca5ca14", "committedDate": "2020-04-28T23:01:23Z", "message": "fix test assertion parameter order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48cca716a82a17ed02759ab6f458f0944ea8a27e", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/48cca716a82a17ed02759ab6f458f0944ea8a27e", "committedDate": "2020-04-28T23:02:00Z", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25b4ee75356da0a52ed4ac7dbe36253ac7c0d493", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/25b4ee75356da0a52ed4ac7dbe36253ac7c0d493", "committedDate": "2020-04-30T01:05:15Z", "message": "address PR feedback\n\n**Notes:**\n\n- added a common \"report to aws\" exception suggestion\n- added a `forCategory` on `Amplify.Logging`\n- extracted the `getValue` to model helper class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29b0d6d4c064c7a66f097d3b2488696fade444c6", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/29b0d6d4c064c7a66f097d3b2488696fade444c6", "committedDate": "2020-04-30T01:08:12Z", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "482df3528d0103ac036c86583cdc25804953f551", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/482df3528d0103ac036c86583cdc25804953f551", "committedDate": "2020-04-30T01:38:06Z", "message": "fix checkstyle violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b661e03fa3cab486d15d901e8196b5dda54c6efd", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/b661e03fa3cab486d15d901e8196b5dda54c6efd", "committedDate": "2020-05-01T05:46:58Z", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4adaf6b65d690bb45f92dd9415c2ec71c85a192e", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/4adaf6b65d690bb45f92dd9415c2ec71c85a192e", "committedDate": "2020-05-01T07:23:05Z", "message": "fix datastore javadoc checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b87a6dfac02bd6172135d23a54b36297bbfd399", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/2b87a6dfac02bd6172135d23a54b36297bbfd399", "committedDate": "2020-05-01T10:01:32Z", "message": "fix javadoc class link"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0421d6347d04a3c5a324027a8ecab393bcf7503f", "author": {"user": {"login": "drochetti", "name": "Daniel Rochetti"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/0421d6347d04a3c5a324027a8ecab393bcf7503f", "committedDate": "2020-05-01T16:07:31Z", "message": "Merge branch 'master' of https://github.com/aws-amplify/amplify-android into feature/nonmodel-types"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2725, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}