{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMjM0Nzgz", "number": 904, "title": "feature: resolve conflicts according to strategies", "bodyText": "The DataStore's sync engine will periodically try to publish local\nchanges up to AppSync. If AppSync already has a copy of the model\ninstance, a versioning conflict may occur. In this case, AppSync may\nreturn a ConflictUnhandledError to the client, in the GraphQL response\nerror list.\nAs a customer, you can supply a handler to define custom logic when such\na conflict occurs. To do so, you provide a DataStoreConflictHandler to\nthe DataStoreConfiguration when constructing the AWSDataStorePlugin:\nDataStoreConfiguration config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler(DataStoreConflictHandler.alwaysApplyRemote())\n    .build();\nAmplify.addPlugin(new AWSDataStorePlugin(config));\nThe ultimate goal of the user-provided handler will be to identify a\nConflictResolutionDecision, to be used to address the conflict:\n\nConflictResolutionDecision.applyRemote():\nJust accept the remote copy of the data, and overwrite whatever we\nhave locally\nConflictResolutionDecision.retryLocal():\nTry to publish the local mutation again. If it fails a second time,\nsurface an error, and do not rety additional times.\nConflictResolutionDecision.retry(T userProvidedModel):\nTry to publish a new version of the model up to AppSync.\nIf using this decision, please take care to ensure the model ID\nmatches the ID of the data in conflict.\n\nIn the above configuration example, the\nDataStoreConflictHandler.alwaysApplyRemote() configures a handler that\nalways chosen to accept the server's version of the data. A similar\nDataStoreConfigurationHandler.alwaysRetryLocal() is also provided for\nconvenience. Fully-custom handlers may be provided as well, by\nimplementing the DataSToreConfigurationHandler interface's single\nmethod, onConflictDetected.\nOnce you have elected a strategy in the handler, the DataStore's sync\nengine will take over and fulfill the strategy you've requested. Prior\nto the current commit, the conflict handler didn't actually do anything\non your behalf -- you were expected to code all resolution logic\ndirectly in your handler. This is no longer necessary.\nResolves: #841", "createdAt": "2020-10-14T09:23:06Z", "url": "https://github.com/aws-amplify/amplify-android/pull/904", "merged": true, "mergeCommit": {"oid": "4bcacc07fd89069768422cb9e95f45f0267514ca"}, "closed": true, "closedAt": "2020-10-15T19:05:23Z", "author": {"login": "jamesonwilliams"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSaBXrABqjM4NzU2OTM4Mjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdS2miFABqjM4ODMxNDgxNzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4ce476be03225ea39f2c7c8e3d8d01f50ddec86", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/b4ce476be03225ea39f2c7c8e3d8d01f50ddec86", "committedDate": "2020-10-14T09:20:40Z", "message": "feature: resolve conflicts according to strategies"}, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDQ4MDc2", "url": "https://github.com/aws-amplify/amplify-android/pull/904#pullrequestreview-509448076", "createdAt": "2020-10-15T14:34:02Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDozNDowMlrOHiK9-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDozNDowMlrOHiK9-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MzMzOA==", "bodyText": "There's the possibility here for a user key to conflict with a metadata key. Are we making it clear to the user somewhere what these reserved metadata keys are so they don't accidentally make a property with the same name?", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505593338", "createdAt": "2020-10-15T14:34:02Z", "author": {"login": "TrekSoft"}, "path": "aws-api-appsync/src/main/java/com/amplifyframework/datastore/appsync/ModelWithMetadataAdapter.java", "diffHunk": "@@ -58,4 +64,24 @@ public static void register(@NonNull GsonBuilder builder) {\n         ModelMetadata metadata = context.deserialize(json, ModelMetadata.class);\n         return new ModelWithMetadata<>(model, metadata);\n     }\n+\n+    @Override\n+    public JsonElement serialize(\n+            ModelWithMetadata<? extends Model> src, Type typeOfSrc, JsonSerializationContext context) {\n+        JsonObject result = new JsonObject();\n+\n+        // Flatten out the fields of the model and its metadata into a flat key-value map.\n+        // To do this, serialize each individually, and then add the key/value pairs for each\n+        // object into a new container.\n+        JsonObject serializedMetadata = (JsonObject) context.serialize(src.getSyncMetadata());\n+        for (Map.Entry<java.lang.String, JsonElement> entry : serializedMetadata.entrySet()) {\n+            result.add(entry.getKey(), entry.getValue());\n+        }\n+        JsonObject serializedModel = (JsonObject) context.serialize(src.getModel());\n+        for (Map.Entry<java.lang.String, JsonElement> entry : serializedModel.entrySet()) {\n+            result.add(entry.getKey(), entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDcyNDU2", "url": "https://github.com/aws-amplify/amplify-android/pull/904#pullrequestreview-509472456", "createdAt": "2020-10-15T14:55:45Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1NTo0NVrOHiMAxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDo1NTo0NVrOHiMAxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDQzOQ==", "bodyText": "Would it make sense to have the inverse of this, alwaysApplyLocal()?", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505610439", "createdAt": "2020-10-15T14:55:45Z", "author": {"login": "TrekSoft"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/DataStoreConflictHandler.java", "diffHunk": "@@ -16,23 +16,288 @@\n package com.amplifyframework.datastore;\n \n import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.core.util.ObjectsCompat;\n \n import com.amplifyframework.core.Consumer;\n import com.amplifyframework.core.model.Model;\n \n+import java.util.Objects;\n+\n /**\n- * Handles conflicts between models observed during model synchronization in the DataStore.\n- * Such conflicts may arise between version of models kept locally, and competing versions\n- * found in the remote AppSync system.\n+ * A hook to handle a conflict between local and remote copies of a model.\n+ * The DataStore customer can implement their own version of this handler,\n+ * and provide that handler to the {@link DataStoreConfiguration} while constructing\n+ * the DataStore plugin using\n+ * {@link AWSDataStorePlugin#AWSDataStorePlugin(DataStoreConfiguration)}.\n  */\n public interface DataStoreConflictHandler {\n     /**\n-     * Resolves a DataStore conflict.\n-     * @param conflictData Data about the conflict.\n-     * @param onResult A callback that should be invoked when the conflict handling is complete.\n-     * @param <T> The type of model for which a conflict was observed\n+     * Factory to obtain a handler that always applies the remote copy\n+     * of the data.\n+     * @return A DataStore conflict handler that always applies the remote\n+     *         copy of the data.\n+     */\n+    static DataStoreConflictHandler alwaysApplyRemote() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTAxMTY1", "url": "https://github.com/aws-amplify/amplify-android/pull/904#pullrequestreview-509501165", "createdAt": "2020-10-15T15:23:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToyMzozOVrOHiNY4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNToyMzozOVrOHiNY4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzMjk5NA==", "bodyText": "It looks like this is done in all three cases below - don't understand the first part of the comment.", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505632994", "createdAt": "2020-10-15T15:23:39Z", "author": {"login": "TrekSoft"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/ConflictResolver.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreConfiguration;\n+import com.amplifyframework.datastore.DataStoreConfigurationProvider;\n+import com.amplifyframework.datastore.DataStoreConflictHandler;\n+import com.amplifyframework.datastore.DataStoreConflictHandler.ConflictData;\n+import com.amplifyframework.datastore.DataStoreConflictHandler.ConflictResolutionDecision;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSync;\n+import com.amplifyframework.datastore.appsync.AppSyncConflictUnhandledError;\n+import com.amplifyframework.datastore.appsync.ModelMetadata;\n+import com.amplifyframework.datastore.appsync.ModelWithMetadata;\n+\n+import io.reactivex.rxjava3.core.Single;\n+\n+/**\n+ * ConflictResolver is a helper utility for the {@link MutationProcessor}.\n+ * It is built specifically to handle ConflictUnhandledError that may be\n+ * returned when the {@link MutationProcessor} attempts to publish\n+ * local data up to AppSync.\n+ *\n+ * ConflictResolver's primary entry point is the\n+ * {@link ConflictResolver#resolve(PendingMutation, AppSyncConflictUnhandledError)}.\n+ * This method will try to rectify state with AppSync by applying the conflict handler\n+ * in the {@link DataStoreConfigurationProvider#getConfiguration()}.\n+ *\n+ * The ConflictResolver will return a {@link ModelWithMetadata} that is understood\n+ * to be the final, resolved version of the data, to which both the server and local\n+ * database should agree.\n+ *\n+ * After {@link ConflictResolver#resolve(PendingMutation, AppSyncConflictUnhandledError)}\n+ * is invoked by the MutationProcessor, the MutationProcessor must merge the returned\n+ * {@link ModelWithMetadata} into the local store, unconditionally.\n+ */\n+final class ConflictResolver {\n+    private final DataStoreConfigurationProvider configurationProvider;\n+    private final AppSync appSync;\n+\n+    ConflictResolver(DataStoreConfigurationProvider configurationProvider, AppSync appSync) {\n+        this.configurationProvider = configurationProvider;\n+        this.appSync = appSync;\n+    }\n+\n+    @NonNull\n+    <T extends Model> Single<ModelWithMetadata<T>> resolve(\n+            @NonNull PendingMutation<T> pendingMutation,\n+            @NonNull AppSyncConflictUnhandledError<T> conflictUnhandledError) {\n+        final DataStoreConflictHandler conflictHandler;\n+        try {\n+            DataStoreConfiguration configuration = configurationProvider.getConfiguration();\n+            conflictHandler = configuration.getDataStoreConflictHandler();\n+        } catch (DataStoreException badConfigurationProvider) {\n+            return Single.error(badConfigurationProvider);\n+        }\n+\n+        ModelWithMetadata<T> serverData = conflictUnhandledError.getServerVersion();\n+        ModelMetadata metadata = serverData.getSyncMetadata();\n+        T remote = serverData.getModel();\n+        T local = pendingMutation.getMutatedItem();\n+        ConflictData<T> conflictData = ConflictData.create(local, remote);\n+\n+        return Single\n+            .<ConflictResolutionDecision<? extends Model>>create(emitter ->\n+                conflictHandler.onConflictDetected(conflictData, emitter::onSuccess)\n+            )\n+            .flatMap(decision -> {\n+                @SuppressWarnings(\"unchecked\")\n+                ConflictResolutionDecision<T> typedDecision = (ConflictResolutionDecision<T>) decision;\n+                return resolveModelAndMetadata(conflictData, metadata, typedDecision);\n+            });\n+    }\n+\n+    @NonNull\n+    private <T extends Model> Single<ModelWithMetadata<T>> resolveModelAndMetadata(\n+            @NonNull ConflictData<T> conflictData,\n+            @NonNull ModelMetadata metadata,\n+            @NonNull ConflictResolutionDecision<T> decision) {\n+        // If the strategy is apply remote or retry local, we already know the version we'll use.\n+        // We simply extract it from the conflict data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTgzNjE5", "url": "https://github.com/aws-amplify/amplify-android/pull/904#pullrequestreview-509583619", "createdAt": "2020-10-15T16:55:35Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "committedDate": "2020-10-15T18:34:18Z", "message": "feature: resolve conflicts according to strategies\n\nThe DataStore's sync engine will periodically try to publish local\nchanges up to AppSync. If AppSync already has a copy of the model\ninstance, a versioning conflict may occur. In this case, AppSync may\nreturn a `ConflictUnhandledError` to the client, in the GraphQL response\nerror list.\n\nAs a customer, you can supply a handler to define custom logic when such\na conflict occurs. To do so, you provide a `DataStoreConflictHandler` to\nthe `DataStoreConfiguration` when constructing the `AWSDataStorePlugin`:\n\n```java\nDataStoreConfiguration config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler(DataStoreConflictHandler.alwaysApplyRemote())\n    .build();\nAmplify.addPlugin(new AWSDataStorePlugin(config));\n```\n\nThe ultimate goal of the user-provided handler will be to identify a\n`ConflictResolutionDecision`, to be used to address the conflict:\n\n1. `ConflictResolutionDecision.applyRemote()`:\n   Just accept the remote copy of the data, and overwrite whatever we\n   have locally\n2. `ConflictResolutionDecision.retryLocal()`:\n   Try to publish the local mutation again. If it fails a second time,\n   surface an error, and do not rety additional times.\n3. `ConflictResolutionDecision.retry(T userProvidedModel)`:\n   Try to publish a new version of the model up to AppSync.\n   If using this decision, please take care to ensure the model ID\n   matches the ID of the data in conflict.\n\nIn the above configuration example, the\n`DataStoreConflictHandler.alwaysApplyRemote()` configures a handler that\nalways chosen to accept the server's version of the data. A similar\n`DataStoreConfigurationHandler.alwaysRetryLocal()` is also provided for\nconvenience. Fully-custom handlers may be provided as well, by\nimplementing the `DataSToreConfigurationHandler` interface's single\nmethod, `onConflictDetected`.\n\nOnce you have elected a strategy in the handler, the DataStore's sync\nengine will take over and fulfill the strategy you've requested. Prior\nto the current commit, the conflict handler didn't actually do anything\non your behalf -- you were expected to code all resolution logic\ndirectly in your handler. This is no longer necessary.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/841"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "committedDate": "2020-10-15T18:34:18Z", "message": "feature: resolve conflicts according to strategies\n\nThe DataStore's sync engine will periodically try to publish local\nchanges up to AppSync. If AppSync already has a copy of the model\ninstance, a versioning conflict may occur. In this case, AppSync may\nreturn a `ConflictUnhandledError` to the client, in the GraphQL response\nerror list.\n\nAs a customer, you can supply a handler to define custom logic when such\na conflict occurs. To do so, you provide a `DataStoreConflictHandler` to\nthe `DataStoreConfiguration` when constructing the `AWSDataStorePlugin`:\n\n```java\nDataStoreConfiguration config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler(DataStoreConflictHandler.alwaysApplyRemote())\n    .build();\nAmplify.addPlugin(new AWSDataStorePlugin(config));\n```\n\nThe ultimate goal of the user-provided handler will be to identify a\n`ConflictResolutionDecision`, to be used to address the conflict:\n\n1. `ConflictResolutionDecision.applyRemote()`:\n   Just accept the remote copy of the data, and overwrite whatever we\n   have locally\n2. `ConflictResolutionDecision.retryLocal()`:\n   Try to publish the local mutation again. If it fails a second time,\n   surface an error, and do not rety additional times.\n3. `ConflictResolutionDecision.retry(T userProvidedModel)`:\n   Try to publish a new version of the model up to AppSync.\n   If using this decision, please take care to ensure the model ID\n   matches the ID of the data in conflict.\n\nIn the above configuration example, the\n`DataStoreConflictHandler.alwaysApplyRemote()` configures a handler that\nalways chosen to accept the server's version of the data. A similar\n`DataStoreConfigurationHandler.alwaysRetryLocal()` is also provided for\nconvenience. Fully-custom handlers may be provided as well, by\nimplementing the `DataSToreConfigurationHandler` interface's single\nmethod, `onConflictDetected`.\n\nOnce you have elected a strategy in the handler, the DataStore's sync\nengine will take over and fulfill the strategy you've requested. Prior\nto the current commit, the conflict handler didn't actually do anything\non your behalf -- you were expected to code all resolution logic\ndirectly in your handler. This is no longer necessary.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/841"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1757, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}