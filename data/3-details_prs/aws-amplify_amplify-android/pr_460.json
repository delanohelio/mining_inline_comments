{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzgzMzUz", "number": 460, "title": "[aws-datastore] three-way merge logic for unconditional mutations", "bodyText": "Add enqueuing rules to ensure that there is always at most one mutation\nfor a given model ID, in the outbox, at a time.\nWhen there is an already-pending mutation for a given model ID, and\nanother mutation is requested to be enqueued, these rules are applied:\nexisting creation incoming creation -> error\nexisting creation incoming update   -> incoming data, existing ID\nexisting creation incoming deletion -> delete exiting\nexisting update   incoming creation -> error\nexisting update   incoming update   -> incoming data, existing ID\nexisting update   incoming deletion -> existing ID, type now deletion\nexisting delete   incoming creation -> error\nexisting delete   incoming update   -> error\nexisting delete   incoming deletion -> exiting retained\nWhen there is no existing mutation, a pending mutation is always\nenqueued.\nFuture work will address the scenario where the mutations have\nconditional predicates attached to them.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-05-14T06:38:18Z", "url": "https://github.com/aws-amplify/amplify-android/pull/460", "merged": true, "mergeCommit": {"oid": "6c74bf08612a353bb1aa4444c000a068ef0815d8"}, "closed": true, "closedAt": "2020-05-18T00:12:34Z", "author": {"login": "jamesonwilliams"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchG6J4AH2gAyNDE3NzgzMzUzOmM3ZjU5N2RlNDY1YWNmZTg1YTU4MjQzZTk2NGE3YTAyZjQ5OWQ4ZTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABciOnINgFqTQxMzE3NjUzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7f597de465acfe85a58243e964a7a02f499d8e4", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/c7f597de465acfe85a58243e964a7a02f499d8e4", "committedDate": "2020-05-14T05:48:32Z", "message": "[aws-datastore] three-way merge logic for unconditional mutations\n\nAdd enqueing rules to ensure that there is always at most one mutation\nfor a given model ID, in the outbox, at a time.\n\nWhen there is an already-pending mutation for a given model ID, and\nanother mutation is requested to be enqueued, these rules are applied:\n\nexisting creation incoming creation -> error\nexisting creation incoming update   -> incoming data, existing ID\nexisting creation incoming deletion -> delete exiting\n\nexisting update   incoming creation -> error\nexisting update   incoming update   -> incoming data, existing ID\nexisting update   incoming deletion -> existing ID, type now deletion\n\nexisting delete   incoming creation -> error\nexisting delete   incoming update   -> error\nexisting delete   incoming deletion -> exiting retained\n\nWhen there is no existing mutation, a pending mutation is alwas\nenqueued.\n\nFuture work will address the scenario where the mutations have\nconditional predicates attached to them."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77cbd48dce137e7c238580af1024726acad9575e", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/77cbd48dce137e7c238580af1024726acad9575e", "committedDate": "2020-05-17T13:23:49Z", "message": "Merge remote-tracking branch 'origin/master' into 3way_merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbb4b56188165a021215ffc4d267bae71e7c08f3", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/dbb4b56188165a021215ffc4d267bae71e7c08f3", "committedDate": "2020-05-17T15:35:41Z", "message": "Single threaded processing of the mutation outbox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/ca79ceb999d5f62871c0640ba3a4870c101c2da8", "committedDate": "2020-05-17T15:58:18Z", "message": "Merge remote-tracking branch 'origin/master' into 3way_merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTc5Mjg1", "url": "https://github.com/aws-amplify/amplify-android/pull/460#pullrequestreview-413179285", "createdAt": "2020-05-17T16:46:26Z", "commit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTc2NTM4", "url": "https://github.com/aws-amplify/amplify-android/pull/460#pullrequestreview-413176538", "createdAt": "2020-05-17T16:09:53Z", "commit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNjowOTo1M1rOGWh7iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNzowNzoyOVrOGWiQzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzc2OA==", "bodyText": "Given concerns on stability, this comment is alarming. What can we do to get it passing reliably?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277768", "createdAt": "2020-05-17T16:09:53Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/AWSDataStorePluginInstrumentedTest.java", "diffHunk": "@@ -57,19 +61,11 @@\n  * which were defined by the schema in:\n  * testmodels/src/main/java/com/amplifyframework/testmodels/commentsblog/schema.graphql.\n  */\n-@Ignore(\"AWSDataStorePlugin must not refer to Amplify.API - need to update source\")\n+@Ignore(\"This test is not reliably passing right now.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzk3NA==", "bodyText": "Is this order change meaningful?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277974", "createdAt": "2020-05-17T16:12:05Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/model/SystemModelsProviderFactory.java", "diffHunk": "@@ -43,6 +43,10 @@ public static ModelProvider create() {\n         return SimpleModelProvider.instance(\n             SYSTEM_MODELS_VERSION,\n \n+            // Used to create a persistent queue of mutations that need to be dispatched over\n+            // the network.\n+            PendingMutation.PersistentRecord.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ==", "bodyText": "So, in my theoretical situation where next cannot be committed to the store for whatever reason due to a failure that is not transient, this would just continually try in a loop and potentially batter AppSync. Perhaps a later thing, but do we need a backoff here or some other kind of back pressure? Seems like we need some retry-with-backoff-and-jitter sprinkles here. How do the other platforms handle this?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426279751", "createdAt": "2020-05-17T16:30:00Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MTU0NA==", "bodyText": "Instead of true, should this be a !mutationOutbox.isEmpty() condition? I assume we also need a breaker for reachability, so perhaps this will land in the that work?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426281544", "createdAt": "2020-05-17T16:49:32Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MzIxNA==", "bodyText": "I'm not sure I see this branch in the requirements of JS implementation -- why do we ignore mutations and clobber on a network update when it seems like the intent is wait until the last mutation is applied?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426283214", "createdAt": "2020-05-17T17:07:29Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Merger.java", "diffHunk": "@@ -145,4 +155,22 @@\n             }\n         }, failure -> onNotPresent.call());\n     }\n+\n+    /**\n+     * The strategy to use while merging. Whether to consider the contents of the mutation\n+     * outbox before saving data locally, or, to ignore it.\n+     */\n+    enum MergeStrategy {\n+        /**\n+         * When merging, the contents of the mutation outbox will *not* be considered.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2488, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}