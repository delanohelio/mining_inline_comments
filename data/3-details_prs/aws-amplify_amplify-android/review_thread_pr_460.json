{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzgzMzUz", "number": 460, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNjowOTo1M1rOD9LdFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNzowNzoyOVrOD9LtBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDc3Mzk3OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/AWSDataStorePluginInstrumentedTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNjowOTo1M1rOGWh7iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMzo1Njo0NVrOGWkfhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzc2OA==", "bodyText": "Given concerns on stability, this comment is alarming. What can we do to get it passing reliably?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277768", "createdAt": "2020-05-17T16:09:53Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/AWSDataStorePluginInstrumentedTest.java", "diffHunk": "@@ -57,19 +61,11 @@\n  * which were defined by the schema in:\n  * testmodels/src/main/java/com/amplifyframework/testmodels/commentsblog/schema.graphql.\n  */\n-@Ignore(\"AWSDataStorePlugin must not refer to Amplify.API - need to update source\")\n+@Ignore(\"This test is not reliably passing right now.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTc0OQ==", "bodyText": "Same. This is a top concern and priority for me.", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319749", "createdAt": "2020-05-17T23:56:45Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/AWSDataStorePluginInstrumentedTest.java", "diffHunk": "@@ -57,19 +61,11 @@\n  * which were defined by the schema in:\n  * testmodels/src/main/java/com/amplifyframework/testmodels/commentsblog/schema.graphql.\n  */\n-@Ignore(\"AWSDataStorePlugin must not refer to Amplify.API - need to update source\")\n+@Ignore(\"This test is not reliably passing right now.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzc2OA=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDc3NTQzOnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/model/SystemModelsProviderFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNjoxMjowNVrOGWh8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMzo1Nzo0NFrOGWkf4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzk3NA==", "bodyText": "Is this order change meaningful?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277974", "createdAt": "2020-05-17T16:12:05Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/model/SystemModelsProviderFactory.java", "diffHunk": "@@ -43,6 +43,10 @@ public static ModelProvider create() {\n         return SimpleModelProvider.instance(\n             SYSTEM_MODELS_VERSION,\n \n+            // Used to create a persistent queue of mutations that need to be dispatched over\n+            // the network.\n+            PendingMutation.PersistentRecord.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTg0MQ==", "bodyText": "It did fix a SQL foreign key violation for me. But, I haven't thought deeply about it yet to explain why it fixes a foreign key violation. Some other part of the system expects this thing to be around, early on, though.", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319841", "createdAt": "2020-05-17T23:57:44Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/model/SystemModelsProviderFactory.java", "diffHunk": "@@ -43,6 +43,10 @@ public static ModelProvider create() {\n         return SimpleModelProvider.instance(\n             SYSTEM_MODELS_VERSION,\n \n+            // Used to create a persistent queue of mutations that need to be dispatched over\n+            // the network.\n+            PendingMutation.PersistentRecord.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzk3NA=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDc4ODg2OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNjozMDowMFrOGWiDRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwMDowMzoxMVrOGWkiPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ==", "bodyText": "So, in my theoretical situation where next cannot be committed to the store for whatever reason due to a failure that is not transient, this would just continually try in a loop and potentially batter AppSync. Perhaps a later thing, but do we need a backoff here or some other kind of back pressure? Seems like we need some retry-with-backoff-and-jitter sprinkles here. How do the other platforms handle this?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426279751", "createdAt": "2020-05-17T16:30:00Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MTU0NA==", "bodyText": "Instead of true, should this be a !mutationOutbox.isEmpty() condition? I assume we also need a breaker for reachability, so perhaps this will land in the that work?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426281544", "createdAt": "2020-05-17T16:49:32Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyMDQ0Nw==", "bodyText": "The while (true) looks sketchy. I think its ~okay, though. The interior of the do { } says \"If the queue is empty, return now. It not empty, process the next. If that fails, return now.\" So the loop only proceeds when it was not empty, and the last item was successfully processed.\nAgree we do need some provisions around what happens when a publication fails, though.", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426320447", "createdAt": "2020-05-18T00:03:11Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NDgxNDc5OnYy", "diffSide": "RIGHT", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Merger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QxNzowNzoyOVrOGWiQzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMzo1NDo0NFrOGWkeuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MzIxNA==", "bodyText": "I'm not sure I see this branch in the requirements of JS implementation -- why do we ignore mutations and clobber on a network update when it seems like the intent is wait until the last mutation is applied?", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426283214", "createdAt": "2020-05-17T17:07:29Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Merger.java", "diffHunk": "@@ -145,4 +155,22 @@\n             }\n         }, failure -> onNotPresent.call());\n     }\n+\n+    /**\n+     * The strategy to use while merging. Whether to consider the contents of the mutation\n+     * outbox before saving data locally, or, to ignore it.\n+     */\n+    enum MergeStrategy {\n+        /**\n+         * When merging, the contents of the mutation outbox will *not* be considered.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTU0Nw==", "bodyText": "There are four sources of state in this system:\n\nUser's data, received from DataStoreAPI;\nMutation responses, received when user's data is published;\nSubscription responses, received when any data change occurs on the remote system;\nSync responses, received at system startup.\n\n3 and 4 don't have pending mutations, we just get inbound data. 1 generates a pending mutation, but doesn't process it.\n2 is unique. When the mutation processor starts processing a pending mutation, it is guaranteed that it is in the outbox (that's where it came from.) So by the time the merger gets a request to merge it, we expect, just short of demand, that it must (still) be in the outbox. One of the very next steps is to delete it from the outbox.", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319547", "createdAt": "2020-05-17T23:54:44Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Merger.java", "diffHunk": "@@ -145,4 +155,22 @@\n             }\n         }, failure -> onNotPresent.call());\n     }\n+\n+    /**\n+     * The strategy to use while merging. Whether to consider the contents of the mutation\n+     * outbox before saving data locally, or, to ignore it.\n+     */\n+    enum MergeStrategy {\n+        /**\n+         * When merging, the contents of the mutation outbox will *not* be considered.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MzIxNA=="}, "originalCommit": {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1243, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}