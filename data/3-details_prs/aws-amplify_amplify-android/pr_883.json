{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MDU0NDY3", "number": 883, "title": "feature(aws-datastore): handle mutation conflicts", "bodyText": "When the DataStore's sync engine attempts to publish a local change to the AppSync backend, it is possible that the AppSync backend already has a copy of the model being mutated. In such cases, AppSync may send back a GraphQL response that contains a ConflictUnhandled error.\nThe client can now recognize a ConflictUnhandled error, and will respond to it by invoking a conflict handling function. The user may supply their own conflict handling strategy, by passing it in aDataStoreConfiguration provided to the AWSDataStorePlugin:\nval config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler((conflictData, onResult) -> {\n        onResult.accept(DataStoreConflictHandlerResult.APPLY_REMOTE);\n    })\n    .build();\nAmplify.addPlugin(AWSDataStorePlugin(config))\nThis current work updates the DataStore to invoke the handler. Subsequent work will implement default logic for the various handling strategies (retry local change, apply remote change, and retry with a custom model.) Currently, the only strategy that has been implemented is \"apply remote.\"\nRefer: https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\nRefer: #841\n\nStatus\nTo keep the size down, I'm planning to do a followup PR which implements handlers for the three different conflict handling strategies.", "createdAt": "2020-10-07T07:49:21Z", "url": "https://github.com/aws-amplify/amplify-android/pull/883", "merged": true, "mergeCommit": {"oid": "d2987b79a717c0f6ff54a81e424febe43b5d17cf"}, "closed": true, "closedAt": "2020-10-08T18:32:04Z", "author": {"login": "jamesonwilliams"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQIR_hgBqjM4NDkxMTg3NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQlAGMgH2gAyNDk5MDU0NDY3OjJlNTgxMjdiMGM0YjBhNmI5ZDhhNDU3NWYwZjk2YzYwYTI3YWI2MWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MTk1NjYz", "url": "https://github.com/aws-amplify/amplify-android/pull/883#pullrequestreview-504195663", "createdAt": "2020-10-07T19:22:03Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOToyMjowM1rOHeCJHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTo0Nzo0M1rOHeC-ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NDQzMQ==", "bodyText": "Could we create an enum with all the error types like iOS?   I had intended to do it when I created AppSyncExtensions, but didn't get that far.", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501254431", "createdAt": "2020-10-07T19:22:03Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.util.Empty;\n+import com.amplifyframework.util.GsonFactory;\n+import com.amplifyframework.util.TypeMaker;\n+\n+import com.google.gson.Gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * It is possible for the client and server to have two copies of one logical entity,\n+ * each containing different contents, but each believing that it is the latest\n+ * copy of the data. When the client tries to mutate the server's data, AppSync's response\n+ * may contain a GraphQLError with errorType as ConflictUnhandled.\n+ *\n+ * This ConflictUnhandledError class models that response data.\n+ *\n+ * @param <T> Type of model for which a conflict occurred between client & server versions.\n+ * @see <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\">\n+ *     AppSync Conflict Detection & Sync Errors\n+ *     </a>\n+ */\n+public final class ConflictUnhandledError<T extends Model> {\n+    private final ModelWithMetadata<T> serverVersion;\n+\n+    private ConflictUnhandledError(ModelWithMetadata<T> serverVersion) {\n+        this.serverVersion = serverVersion;\n+    }\n+\n+    /**\n+     * Iterates over a list of GraphQL.Error, checking to see if any of them\n+     * contain 'ConflictUnhandled' as the errorType.\n+     * @param typeOfConflictingData The class of the model experiencing conflict\n+     * @param errors A list of GraphQL errors, as received in response to a mutation\n+     * @param <T> The type of model experiencing conflict, if applicable\n+     * @return A model of the first ConflictUnhandled error found in the GraphQL error list.\n+     *         If there is no ConflictUnhandledError in the list, returns null.\n+     */\n+    @Nullable\n+    public static <T extends Model> ConflictUnhandledError<T> findFirst(\n+            @NonNull Class<T> typeOfConflictingData,\n+            @Nullable List<GraphQLResponse.Error> errors) {\n+        if (Empty.check(errors)) {\n+            return null;\n+        }\n+\n+        Gson gson = GsonFactory.instance();\n+\n+        for (GraphQLResponse.Error error : errors) {\n+            if (Empty.check(error.getExtensions())) {\n+                continue;\n+            }\n+\n+            AppSyncExtensions appSyncExtensions =\n+                new AppSyncExtensions(error.getExtensions());\n+            if (!\"ConflictUnhandled\".equals(appSyncExtensions.getErrorType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NDQ0Mw==", "bodyText": "Neat! \ud83c\udf89", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501264443", "createdAt": "2020-10-07T19:40:54Z", "author": {"login": "richardmcclellan"}, "path": "testutils/src/main/java/com/amplifyframework/testutils/Varargs.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.testutils;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.util.Immutable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * A utility to convert an (possibly null) array into\n+ * an immutable list.\n+ */\n+public final class Varargs {\n+    private Varargs() {}\n+\n+    /**\n+     * Converts a (possibly null) array into a non-null (possibly empty) list.\n+     * @param items A possibly null array of items\n+     * @param <T> Type of items in the array\n+     * @return A non-null, possibly empty collection\n+     */\n+    @NonNull\n+    public static <T> List<T> toList(@Nullable T[] items) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NDk5NQ==", "bodyText": "Much needed, looks good.", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501264995", "createdAt": "2020-10-07T19:41:54Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -284,4 +371,114 @@ void publish(\n             Consumer<DataStoreException> onFailure\n         );\n     }\n+\n+    static final class Builder implements", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NTQzOA==", "bodyText": "Can you change this to take a Builder instead of a bunch of parameters?", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501265438", "createdAt": "2020-10-07T19:42:48Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -47,24 +57,40 @@\n     private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n     private static final long ITEM_PROCESSING_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(10);\n \n-    private final VersionRepository versionRepository;\n     private final Merger merger;\n-    private final AppSync appSync;\n+    private final VersionRepository versionRepository;\n+    private final SyncTimeRegistry syncTimeRegistry;\n     private final MutationOutbox mutationOutbox;\n+    private final AppSync appSync;\n+    private final DataStoreConfigurationProvider configurationProvider;\n     private final CompositeDisposable ongoingOperationsDisposable;\n \n-    MutationProcessor(\n+    private MutationProcessor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2ODA3NA==", "bodyText": "Temporal.Timestamp should always be in seconds, not milliseconds.", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501268074", "createdAt": "2020-10-07T19:47:43Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/test/resources/conflict-unhandled-response.json", "diffHunk": "@@ -0,0 +1,29 @@\n+{\n+  \"data\": {\n+    \"updateNote\": null\n+  },\n+  \"errors\": [\n+    {\n+      \"path\": [\n+        \"updateNote\"\n+      ],\n+      \"data\": {\n+        \"id\": \"KoolId22\",\n+        \"content\": \"Resurecting the dataz\",\n+        \"_version\": 7,\n+        \"_deleted\": true,\n+        \"_lastChangedAt\": 1601499066604", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "committedDate": "2020-10-08T10:25:34Z", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "committedDate": "2020-10-08T10:25:34Z", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NzQzMTQw", "url": "https://github.com/aws-amplify/amplify-android/pull/883#pullrequestreview-504743140", "createdAt": "2020-10-08T12:46:31Z", "commit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyMzo1MVrOHeeXtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoyMzo1MVrOHeeXtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjkxNg==", "bodyText": "\ud83e\udd2f", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501716916", "createdAt": "2020-10-08T13:23:51Z", "author": {"login": "rjuliano"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODI3NzEz", "url": "https://github.com/aws-amplify/amplify-android/pull/883#pullrequestreview-504827713", "createdAt": "2020-10-08T14:12:54Z", "commit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoxMjo1NFrOHego2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDo0NToxNFrOHeiMbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NDA3Mg==", "bodyText": "How about we move this inside of AppSyncExtensions and just make the getter return the enum?\nInstead of this current code:\npublic String getErrorType() {\n    return errorType;\n}\n\ndo something like:\npublic AppSyncErrorType getErrorType() {\n    return AppSyncErrorType.fromErrorType(errorType);\n}", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501754072", "createdAt": "2020-10-08T14:12:54Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.util.Empty;\n+import com.amplifyframework.util.GsonFactory;\n+import com.amplifyframework.util.TypeMaker;\n+\n+import com.google.gson.Gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * It is possible for the client and server to have two copies of one logical entity,\n+ * each containing different contents, but each believing that it is the latest\n+ * copy of the data. When the client tries to mutate the server's data, AppSync's response\n+ * may contain a GraphQLError with errorType as ConflictUnhandled.\n+ *\n+ * This ConflictUnhandledError class models that response data.\n+ *\n+ * @param <T> Type of model for which a conflict occurred between client & server versions.\n+ * @see <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\">\n+ *     AppSync Conflict Detection & Sync Errors\n+ *     </a>\n+ */\n+public final class ConflictUnhandledError<T extends Model> {\n+    private final ModelWithMetadata<T> serverVersion;\n+\n+    private ConflictUnhandledError(ModelWithMetadata<T> serverVersion) {\n+        this.serverVersion = serverVersion;\n+    }\n+\n+    /**\n+     * Iterates over a list of GraphQL.Error, checking to see if any of them\n+     * contain 'ConflictUnhandled' as the errorType.\n+     * @param typeOfConflictingData The class of the model experiencing conflict\n+     * @param errors A list of GraphQL errors, as received in response to a mutation\n+     * @param <T> The type of model experiencing conflict, if applicable\n+     * @return A model of the first ConflictUnhandled error found in the GraphQL error list.\n+     *         If there is no ConflictUnhandledError in the list, returns null.\n+     */\n+    @Nullable\n+    public static <T extends Model> ConflictUnhandledError<T> findFirst(\n+            @NonNull Class<T> typeOfConflictingData,\n+            @Nullable List<GraphQLResponse.Error> errors) {\n+        if (Empty.check(errors)) {\n+            return null;\n+        }\n+\n+        Gson gson = GsonFactory.instance();\n+\n+        for (GraphQLResponse.Error error : errors) {\n+            if (Empty.check(error.getExtensions())) {\n+                continue;\n+            }\n+\n+            AppSyncExtensions appSyncExtensions = new AppSyncExtensions(error.getExtensions());\n+            AppSyncErrorType errorType = AppSyncErrorType.fromErrorType(appSyncExtensions.getErrorType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3OTU2NA==", "bodyText": "Ick... so what's the issue exactly for needing this workaround?", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501779564", "createdAt": "2020-10-08T14:45:14Z", "author": {"login": "richardmcclellan"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.\n+ */\n+public final class AppSyncMockingTest {\n+    private static final long TIMEOUT_SECONDS = 2;\n+\n+    private AppSync appSync;\n+\n+    /**\n+     * Sets up an AppSync mock.\n+     */\n+    @Before\n+    public void setup() {\n+        this.appSync = mock(AppSync.class);\n+    }\n+\n+    /**\n+     * When mockFailure() is called on the SyncConfigurator, the AppSync mock\n+     * will emit the provided failure.\n+     * @throws DataStoreException On failure to get a SyncConfigurator via sync()\n+     */\n+    @Test\n+    public void mockFailureForSync() throws DataStoreException {\n+        DataStoreException failure = new DataStoreException(\"Foo\", \"Bar\");\n+        AppSyncMocking.sync(appSync).mockFailure(failure);\n+\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+        Single\n+            .create(emitter -> appSync.sync(request, emitter::onSuccess, emitter::onError))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertError(failure);\n+    }\n+\n+    /**\n+     * The {@link SyncConfigurator#mockSuccessResponse(Class, ModelWithMetadata[])}\n+     * method allows you to configure a collection of {@link ModelWithMetadata} to be\n+     * included in a successful {@link GraphQLResponse}, emitted from the\n+     * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)} operation.\n+     * @throws DataStoreException On failure to configure the mock behavior\n+     */\n+    @Test\n+    public void mockSuccessResponsesForSync() throws DataStoreException {\n+        // Act: configure the mock\n+        AppSyncMocking.sync(appSync)\n+            .mockSuccessResponse(BlogOwner.class, StrawMen.JOE, StrawMen.TONY);\n+\n+        // Build a request object. This will itself test the mockSuccessResponse(),\n+        // since that method configures this call to return a meaningful result.\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+\n+        // Lastly, when we actually call sync, we should see the expected response,\n+        // As a result of the mockSuccessResponse() on the AppSyncMocking.\n+        Single\n+            .<GraphQLResponse<PaginatedResult<ModelWithMetadata<BlogOwner>>>>create(emitter ->\n+                appSync.sync(request, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete()\n+            // TODO: response items change order. Why?\n+            .assertValue(response -> {\n+                if (response.hasErrors() || !response.hasData()) {\n+                    return false;\n+                }\n+                return Observable.fromIterable(response.getData().getItems())\n+                    .toList()\n+                    .map(HashSet::new)\n+                    .blockingGet()\n+                    .equals(new HashSet<>(Arrays.asList(StrawMen.JOE, StrawMen.TONY)));\n+            });\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will return a successful creation response\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockSuccessResponseForCreate() {\n+        AppSyncMocking.create(appSync).mockSuccessResponse(StrawMen.JOE_MODEL);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(StrawMen.JOE, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will emit a response containing the provided GraphQL errors\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockErrorResponseForCreate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.create(appSync).mockErrorResponse(StrawMen.JOE_MODEL, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the UpdateConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its update() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForUpdate() {\n+        AppSyncMocking.update(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata updatedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), false, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithUpdatedMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, updatedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithUpdatedMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.TONY_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * mockErrorResponse() on the UpdateConfigurator will prepare the\n+     * bound AppSync instance to return an error response whenever\n+     * its update() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForUpdate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.update(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.JOE_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForDelete() {\n+        AppSyncMocking.delete(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata deletedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), true, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithDeleteMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, deletedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithDeleteMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.delete(\n+                    BlogOwner.class,\n+                    StrawMen.TONY_MODEL.getId(),\n+                    1,\n+                    MatchAllQueryPredicate.instance(),\n+                    emitter::onSuccess,\n+                    emitter::onError\n+                )\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will be configured to emit an error\n+     * response whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForDelete() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.delete(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .create(emitter -> appSync.delete(\n+                BlogOwner.class,\n+                StrawMen.JOE_MODEL.getId(),\n+                1,\n+                MatchAllQueryPredicate.instance(),\n+                emitter::onSuccess,\n+                emitter::onError\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for creations events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnCreate() {\n+        AppSyncMocking.onCreate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onCreate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for update events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnUpdate() {\n+        AppSyncMocking.onUpdate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onUpdate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for delete events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnDelete() {\n+        AppSyncMocking.onDelete(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onDelete(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    private static Predicate<GraphQLResponse<ModelWithMetadata<BlogOwner>>> equalsRelaxingTimestamp(\n+            GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse) {\n+        return response -> {\n+            if (!ObjectsCompat.equals(expectedResponse.getErrors(), response.getErrors())) {\n+                return false;\n+            }\n+            ModelWithMetadata<BlogOwner> expectedMwm = expectedResponse.getData();\n+            ModelWithMetadata<BlogOwner> mwm = response.getData();\n+            return equalsRelaxingTimestamp(expectedMwm).test(mwm);\n+        };\n+    }\n+\n+    private static Predicate<ModelWithMetadata<BlogOwner>> equalsRelaxingTimestamp(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af"}, "originalPosition": 339}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f501a891a4f6befb36a838354f1e123d11d04175", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f501a891a4f6befb36a838354f1e123d11d04175", "committedDate": "2020-10-08T17:21:24Z", "message": "FIXUP: address PR feedback from Richard"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "author": {"user": {"login": "jamesonwilliams", "name": "Jameson Williams"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "committedDate": "2020-10-08T17:26:37Z", "message": "Merge remote-tracking branch 'origin/main' into conflict_handler"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1735, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}