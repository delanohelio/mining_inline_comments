{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMDQxMjAw", "number": 498, "title": "Implement conflict resolution rules for existing and incoming mutations for the same model", "bodyText": "Issue #, if available:\nDescription of changes:\nThe PR is a follow up to #496. It contains the business logic that handles conflicts when multiple mutations for the same model and enqueued. It takes into account whether a condition was included with the update/delete.\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-05-20T21:59:23Z", "url": "https://github.com/aws-amplify/amplify-android/pull/498", "merged": true, "mergeCommit": {"oid": "c097eb85426e6f908a823be44bde76293c48af9c"}, "closed": true, "closedAt": "2020-05-22T00:17:01Z", "author": {"login": "rjuliano"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjQRL2gH2gAyNDIxMDQxMjAwOmJmYmY4ZDE2N2U4NTMyYjM4N2QzNWFjNjhmMzI5ZmVlOWMyMGEzYTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjnEVmAFqTQxNjU3NDU5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bfbf8d167e8532b387d35ac68f329fee9c20a3a4", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/bfbf8d167e8532b387d35ac68f329fee9c20a3a4", "committedDate": "2020-05-20T21:50:41Z", "message": "[aws-datastore] Implement conflict resolution rules to account for predicates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97d23fd727724d4d64fdfddfb9bbe7131d5b58b2", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/97d23fd727724d4d64fdfddfb9bbe7131d5b58b2", "committedDate": "2020-05-20T22:01:47Z", "message": "Checkstyle fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "committedDate": "2020-05-21T01:22:46Z", "message": "Merge branch 'rjuliano/dspredicate-param' into rjuliano/dspredicate-param-rules"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MTQzODM5", "url": "https://github.com/aws-amplify/amplify-android/pull/498#pullrequestreview-416143839", "createdAt": "2020-05-21T13:28:19Z", "commit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzoyODoxOVrOGYyv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzoyODoxOVrOGYyv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MDQ4OQ==", "bodyText": "Did you mean to remove the inFlightMutations condition? I thought that was the piece Jameson just added.", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428650489", "createdAt": "2020-05-21T13:28:19Z", "author": {"login": "TrekSoft"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -83,21 +84,21 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         String modelId = incomingMutation.getMutatedItem().getId();\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n-        if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+        if (existingMutation == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MTQ1NDc2", "url": "https://github.com/aws-amplify/amplify-android/pull/498#pullrequestreview-416145476", "createdAt": "2020-05-21T13:30:22Z", "commit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozMDoyM1rOGYy0og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozMDoyM1rOGYy0og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MTY4Mg==", "bodyText": "It looks like before, it would always handle the mutation type but now you're only handling it if the existingMutation isn't null so just wanted to check that's intended behavior.", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428651682", "createdAt": "2020-05-21T13:30:23Z", "author": {"login": "TrekSoft"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -83,21 +84,21 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         String modelId = incomingMutation.getMutatedItem().getId();\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n-        if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+        if (existingMutation == null) {\n+            return save(incomingMutation)\n+                .andThen(notifyContentAvailable());\n+        } else {\n+            return resolveConflict(existingMutation, incomingMutation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MTUyNTk1", "url": "https://github.com/aws-amplify/amplify-android/pull/498#pullrequestreview-416152595", "createdAt": "2020-05-21T13:39:51Z", "commit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozOTo1MlrOGYzJ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMzozOTo1MlrOGYzJ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NzE0NA==", "bodyText": "Nit: Update suggestion to match others with a link - Jameson actually recently added a constant string to Amplify Exception for this type of suggestion you can use.", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428657144", "createdAt": "2020-05-21T13:39:52Z", "author": {"login": "TrekSoft"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -318,4 +264,158 @@ public Completable markInFlight(@NonNull TimeBasedUuid pendingMutationId) {\n         }\n         return null;\n     }\n+\n+    /**\n+     * Encapsulate the logic to determine which actions to take based on incoming and existing\n+     * mutations. Non-static so we can access instance methods of the outer class. Private because\n+     * we don't want this logic called from anywhere else.\n+     * @param <T> the model type\n+     */\n+    private final class IncomingMutationConflictHandler<T extends Model> {\n+        private final PendingMutation<T> existing;\n+        private final PendingMutation<T> incoming;\n+\n+        /**\n+         * Constructor for a IncomingMutationConflictHandler.\n+         * @param existing The existing mutation.\n+         * @param incoming The incoming mutation.\n+         */\n+        private IncomingMutationConflictHandler(@NonNull PendingMutation<T> existing,\n+                                                @NonNull PendingMutation<T> incoming) {\n+            this.existing = existing;\n+            this.incoming = incoming;\n+        }\n+\n+        /**\n+         * Handle the conflict based on the incoming mutation type.\n+         * @return A completable with the actions to resolve the conflict.\n+         */\n+        Completable resolve() {\n+            switch (incoming.getMutationType()) {\n+                case CREATE:\n+                    return handleIncomingCreate();\n+                case UPDATE:\n+                    return handleIncomingUpdate();\n+                case DELETE:\n+                    return handleIncomingDelete();\n+                default:\n+                    return unknownMutationType(existing.getMutationType());\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#CREATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingCreate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Double create, return an different error than in the default block of the switch\n+                    // statement. This way, we can differentiate between an incoming create being processed\n+                    // multiple times (this case), versus outgoing mutations being processed out of order.\n+                    return conflictingCreationError();\n+                default:\n+                    // A create mutation should never show up after an update or delete for the same modelId.\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#UPDATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingUpdate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Update after the create -> replace item of the create mutation (and keep it as a create).\n+                    // No condition needs to be provided, because as far as the remote store is concerned,\n+                    // we're simply performing the create (with the updated item item contents)\n+                    return overwriteExistingAndNotify(PendingMutation.Type.CREATE, null);\n+                case UPDATE:\n+                    if (incoming.getPredicate() == null) {\n+                        // If the incoming update does not have a condition, we want to delete any\n+                        // existing mutations for the modelId before saving the incoming one.\n+                        return remove(existing.getMutationId()).andThen(saveIncomingAndNotify());\n+                    } else {\n+                        // If it has a condition, we want to just add it to the queue\n+                        return saveIncomingAndNotify();\n+                    }\n+                case DELETE:\n+                    // Incoming update after a delete -> throw exception\n+                    return modelAlreadyScheduledForDeletion();\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#DELETE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingDelete() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    //\n+                    if (inFlightMutations.contains(existing.getMutationId())) {\n+                        // Existing create is already in flight, then save the delete\n+                        return save(incoming);\n+                    } else {\n+                        // The existing create mutation hasn't made it to the remote store, so we\n+                        // ignore the incoming and remove the existing create mutation from outbox.\n+                        return remove(existing.getMutationId());\n+                    }\n+                case UPDATE:\n+                case DELETE:\n+                    // If there's a pending update OR delete, we want to replace it with the incoming delete.\n+                    return overwriteExistingAndNotify(PendingMutation.Type.DELETE, incoming.getPredicate());\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        private Completable overwriteExistingAndNotify(@NonNull PendingMutation.Type type,\n+                                                       @Nullable QueryPredicate predicate) {\n+            // Keep the old mutation ID, but update the contents of that mutation.\n+            // Now, it will have the contents of the incoming update mutation.\n+            TimeBasedUuid id = existing.getMutationId();\n+            T item = incoming.getMutatedItem();\n+            Class<T> clazz = incoming.getClassOfMutatedItem();\n+            return save(PendingMutation.instance(id, item, clazz, type, predicate))\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable saveIncomingAndNotify() {\n+            return save(incoming)\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable conflictingCreationError() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model creation, but there is already a pending creation for that model ID.\",\n+                \"Please report at https://github.com/aws-amplify/amplify-android/issues.\"\n+            ));\n+        }\n+\n+        private Completable modelAlreadyScheduledForDeletion() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model mutation, but that model already had a delete mutation pending.\",\n+                \"This should not be possible. Please report on GitHub issues.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "originalPosition": 243}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MTU0MzIx", "url": "https://github.com/aws-amplify/amplify-android/pull/498#pullrequestreview-416154321", "createdAt": "2020-05-21T13:42:02Z", "commit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a83299b786ffb21001e1524c9a33523c9f984be", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/1a83299b786ffb21001e1524c9a33523c9f984be", "committedDate": "2020-05-21T13:50:13Z", "message": "Re-introduce the isInFlight check in the enqueue method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTc0NTkz", "url": "https://github.com/aws-amplify/amplify-android/pull/498#pullrequestreview-416574593", "createdAt": "2020-05-22T00:21:32Z", "commit": {"oid": "1a83299b786ffb21001e1524c9a33523c9f984be"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoyMTozM1rOGZG9Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoyNDowNVrOGZHAEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MTU4Ng==", "bodyText": "Hm, it wasn't me, actually! I thought it was you. It was @drochetti!", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428981586", "createdAt": "2020-05-22T00:21:33Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -318,4 +264,158 @@ public Completable markInFlight(@NonNull TimeBasedUuid pendingMutationId) {\n         }\n         return null;\n     }\n+\n+    /**\n+     * Encapsulate the logic to determine which actions to take based on incoming and existing\n+     * mutations. Non-static so we can access instance methods of the outer class. Private because\n+     * we don't want this logic called from anywhere else.\n+     * @param <T> the model type\n+     */\n+    private final class IncomingMutationConflictHandler<T extends Model> {\n+        private final PendingMutation<T> existing;\n+        private final PendingMutation<T> incoming;\n+\n+        /**\n+         * Constructor for a IncomingMutationConflictHandler.\n+         * @param existing The existing mutation.\n+         * @param incoming The incoming mutation.\n+         */\n+        private IncomingMutationConflictHandler(@NonNull PendingMutation<T> existing,\n+                                                @NonNull PendingMutation<T> incoming) {\n+            this.existing = existing;\n+            this.incoming = incoming;\n+        }\n+\n+        /**\n+         * Handle the conflict based on the incoming mutation type.\n+         * @return A completable with the actions to resolve the conflict.\n+         */\n+        Completable resolve() {\n+            switch (incoming.getMutationType()) {\n+                case CREATE:\n+                    return handleIncomingCreate();\n+                case UPDATE:\n+                    return handleIncomingUpdate();\n+                case DELETE:\n+                    return handleIncomingDelete();\n+                default:\n+                    return unknownMutationType(existing.getMutationType());\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#CREATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingCreate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Double create, return an different error than in the default block of the switch\n+                    // statement. This way, we can differentiate between an incoming create being processed\n+                    // multiple times (this case), versus outgoing mutations being processed out of order.\n+                    return conflictingCreationError();\n+                default:\n+                    // A create mutation should never show up after an update or delete for the same modelId.\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#UPDATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingUpdate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Update after the create -> replace item of the create mutation (and keep it as a create).\n+                    // No condition needs to be provided, because as far as the remote store is concerned,\n+                    // we're simply performing the create (with the updated item item contents)\n+                    return overwriteExistingAndNotify(PendingMutation.Type.CREATE, null);\n+                case UPDATE:\n+                    if (incoming.getPredicate() == null) {\n+                        // If the incoming update does not have a condition, we want to delete any\n+                        // existing mutations for the modelId before saving the incoming one.\n+                        return remove(existing.getMutationId()).andThen(saveIncomingAndNotify());\n+                    } else {\n+                        // If it has a condition, we want to just add it to the queue\n+                        return saveIncomingAndNotify();\n+                    }\n+                case DELETE:\n+                    // Incoming update after a delete -> throw exception\n+                    return modelAlreadyScheduledForDeletion();\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#DELETE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingDelete() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    //\n+                    if (inFlightMutations.contains(existing.getMutationId())) {\n+                        // Existing create is already in flight, then save the delete\n+                        return save(incoming);\n+                    } else {\n+                        // The existing create mutation hasn't made it to the remote store, so we\n+                        // ignore the incoming and remove the existing create mutation from outbox.\n+                        return remove(existing.getMutationId());\n+                    }\n+                case UPDATE:\n+                case DELETE:\n+                    // If there's a pending update OR delete, we want to replace it with the incoming delete.\n+                    return overwriteExistingAndNotify(PendingMutation.Type.DELETE, incoming.getPredicate());\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        private Completable overwriteExistingAndNotify(@NonNull PendingMutation.Type type,\n+                                                       @Nullable QueryPredicate predicate) {\n+            // Keep the old mutation ID, but update the contents of that mutation.\n+            // Now, it will have the contents of the incoming update mutation.\n+            TimeBasedUuid id = existing.getMutationId();\n+            T item = incoming.getMutatedItem();\n+            Class<T> clazz = incoming.getClassOfMutatedItem();\n+            return save(PendingMutation.instance(id, item, clazz, type, predicate))\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable saveIncomingAndNotify() {\n+            return save(incoming)\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable conflictingCreationError() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model creation, but there is already a pending creation for that model ID.\",\n+                \"Please report at https://github.com/aws-amplify/amplify-android/issues.\"\n+            ));\n+        }\n+\n+        private Completable modelAlreadyScheduledForDeletion() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model mutation, but that model already had a delete mutation pending.\",\n+                \"This should not be possible. Please report on GitHub issues.\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NzE0NA=="}, "originalCommit": {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjI4OQ==", "bodyText": "Should we be creating a new one every time, like this?", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428982289", "createdAt": "2020-05-22T00:24:05Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -84,20 +85,20 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n         if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+            return save(incomingMutation)\n+                .andThen(notifyContentAvailable());\n+        } else {\n+            return resolveConflict(existingMutation, incomingMutation);\n         }\n     }\n \n+    private <T extends Model> Completable resolveConflict(@NonNull PendingMutation<T> existingMutation,\n+                                                          @NonNull PendingMutation<T> incomingMutation) {\n+        IncomingMutationConflictHandler<T> mutationConflictHandler =\n+            new IncomingMutationConflictHandler<>(existingMutation, incomingMutation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a83299b786ffb21001e1524c9a33523c9f984be"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2532, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}