{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMzk5NDE0", "number": 416, "title": "[aws-datastore] Implement DataStore clear feature", "bodyText": "Issue #, if available:\nDescription of changes:\nDataStore clear\nAdding clear method to the DataStore plugin.\nThe intent of the functionality of the clear method is to blow away the entire underlying data store and reset it as needed. The current implementation of the DataStore plugin uses SQLite for the implementation of the LocalStorageAdapter interface.\nSummary of changes\n\n\nAdded clear method to the DataStoreCategory, DataStoreCategoryBehavior, and LocalStorageAdapter\n\n\nImplement clear for AWSDataStorePlugin. It stops the orchestrator, invokes the clear method of the storage adapter, and restarts the orchestrator.  The orchestrator is not restarted right away; instead, it is restarted upon the next interaction with the DataStore category.\n\n\nImplement clear for SQLiteStorageAdapter.\n\nThe implementation closes the adapter and the current handle to the DB connection. Then it deletes the database file using the context and attempts to re-initialize the adapter.\nKeep a reference to the Context object received in the configure method so we can use it to get access to the database file for clearing.\n\n\n\nUpdated some of the test classes that are used to create a synchronous interface to the storage adapter.\n\n\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-04-30T12:01:53Z", "url": "https://github.com/aws-amplify/amplify-android/pull/416", "merged": true, "mergeCommit": {"oid": "4f58ebde33c533601f04a77eb2cc370bd49eef60"}, "closed": true, "closedAt": "2020-05-22T18:09:33Z", "author": {"login": "rjuliano"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccj_XVgH2gAyNDExMzk5NDE0OmMzMzkyYjRmOGNiN2JlNTE2NjY3M2YyZDg3MDM3MTIyMDBkZDllY2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj1cG1AH2gAyNDExMzk5NDE0OmM5NTRkNmE5ZmIwZWM3MWE3YWVkMjJmNzIwYWE0NDNiOGI0OGY1MzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c3392b4f8cb7be5166673f2d8703712200dd9eca", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/c3392b4f8cb7be5166673f2d8703712200dd9eca", "committedDate": "2020-04-30T02:51:51Z", "message": "[aws-datastore] Implement DataStore clear feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/782eb601676c1e94b85718c4a66028784e90a802", "committedDate": "2020-04-30T12:07:03Z", "message": "checkstyle fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODg2NTQ5", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-403886549", "createdAt": "2020-04-30T21:21:18Z", "commit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMToyMToxOVrOGO6yEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMTozMTo0M1rOGO7EtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NjMzNg==", "bodyText": "nit: date change from. 2019 to 2020", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418296336", "createdAt": "2020-04-30T21:21:19Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5Njc3NA==", "bodyText": "Seems like this should be changed to: \"Invoked if not successful\" ?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418296774", "createdAt": "2020-04-30T21:22:22Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -390,6 +390,22 @@ public void observe(\n         onObservationFailure.accept(new DataStoreException(\"Not implemented yet, buster!\", \"Check back later!\"));\n     }\n \n+    /**\n+     * Stops all synchronization processes and deletes the\n+     * SQLite database from device's local storage.\n+     * @param onComplete Invoked if the call is successful.\n+     * @param onError Invoked if an exception occurs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5ODA2MA==", "bodyText": "Remove \"At a high level\"\nIn iOS, we are not making any guarantees on in-memory objects...  We still have some objects still in memory (that have read in configuration) so that customers  do not need to call configure() on amplify again if they want to use Datastore.\nThis comment seems to be duplicated from the \"*behavior.java\" class... I'm not familiar with your code base, but my preference would be to only have it at the interface level.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418298060", "createdAt": "2020-04-30T21:25:01Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/LocalStorageAdapter.java", "diffHunk": "@@ -186,4 +186,14 @@ Cancelable observe(\n      * @throws DataStoreException if something goes wrong during terminate\n      */\n     void terminate() throws DataStoreException;\n+\n+    /**\n+     * Each implementation of this adapter interface will have its own\n+     * interpretation of what clear means. At a high level, the intent is to destroy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDQyMA==", "bodyText": "For unit tests, I think it is a better test not to share constants between test code and production code.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418300420", "createdAt": "2020-04-30T21:30:16Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDk2Nw==", "bodyText": "is there a way to assert that the success handler gets called?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418300967", "createdAt": "2020-04-30T21:31:30Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);\n+    }\n+\n+    @After\n+    public void teardown() {\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Happy path test: saves a record to the database\n+     * then calls clear and verifies that the database\n+     * file has been deleted.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearDeletesDatabaseFromDisk() throws DataStoreException {\n+        final BlogOwner dummy = BlogOwner.builder()\n+            .name(\"Dummy Blogger\")\n+            .build();\n+\n+        adapter.save(dummy);\n+        List<BlogOwner> query = adapter.query(BlogOwner.class);\n+        assertEquals(1, query.size());\n+        //Check that exactly one event was received by the observer.\n+        observer.assertValueCount(1);\n+\n+        adapter.clear();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        //Assert the observer was terminated during the file removal.\n+        observer.assertTerminated();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMTEwOQ==", "bodyText": "is there a way to make sure that the error handler gets called?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418301109", "createdAt": "2020-04-30T21:31:43Z", "author": {"login": "wooj2"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);\n+    }\n+\n+    @After\n+    public void teardown() {\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Happy path test: saves a record to the database\n+     * then calls clear and verifies that the database\n+     * file has been deleted.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearDeletesDatabaseFromDisk() throws DataStoreException {\n+        final BlogOwner dummy = BlogOwner.builder()\n+            .name(\"Dummy Blogger\")\n+            .build();\n+\n+        adapter.save(dummy);\n+        List<BlogOwner> query = adapter.query(BlogOwner.class);\n+        assertEquals(1, query.size());\n+        //Check that exactly one event was received by the observer.\n+        observer.assertValueCount(1);\n+\n+        adapter.clear();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        //Assert the observer was terminated during the file removal.\n+        observer.assertTerminated();\n+    }\n+\n+    /**\n+     * Assert that the database was created. Then call clear and\n+     * assert the file was deleted; attempt to call clear again\n+     * and ensure there are no exceptions thrown.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearHandlesMissingFile() throws DataStoreException {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's subscribed\n+        observer.assertSubscribed();\n+\n+        adapter.clear();\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+\n+        adapter.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODg0MTk3", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-403884197", "createdAt": "2020-04-30T21:17:22Z", "commit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMToxNzoyMlrOGO6qtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMTozNjo1OFrOGO7N5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDQ1Mg==", "bodyText": "Ah yea, good call. The Await.result(...) thing could basically be replaced with a Single and a blockingGet(). At the time I wrote Await.result(...) we hadn't started using Rx from the tests across different modules. Here in the DataStore tests, its doubly okay, though, since the actual source code uses Rx.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418294452", "createdAt": "2020-04-30T21:17:22Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/SynchronousStorageAdapter.java", "diffHunk": "@@ -285,4 +286,14 @@ public void terminate() throws DataStoreException {\n             asyncDelegate.observe(emitter::onNext, emitter::onError, emitter::onComplete)\n         );\n     }\n+\n+    /**\n+     * Invokes the clear method of the underlying adapter and\n+     * either completes or throws an exception.\n+     */\n+    public void clear() {\n+        Completable.fromObservable(emitter -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDc0OQ==", "bodyText": "2020", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418294749", "createdAt": "2020-04-30T21:17:58Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTA1Nw==", "bodyText": "final", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418295057", "createdAt": "2020-04-30T21:18:36Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTI3MQ==", "bodyText": "Drop the outer (,)", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418295271", "createdAt": "2020-04-30T21:19:03Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NjExOA==", "bodyText": "There's a short-hand for this, Observable#test():\nTestObserver<StorageItemChange.Record> observer = adapter.observe().test();\n\nIt only saves a line there, but it doesn't need to be disposed, which is neat. And it's slightly more expressive of the intention.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418296118", "createdAt": "2020-04-30T21:20:50Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NzA5Mw==", "bodyText": "Nice this reads really well", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418297093", "createdAt": "2020-04-30T21:23:01Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);\n+    }\n+\n+    @After\n+    public void teardown() {\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Happy path test: saves a record to the database\n+     * then calls clear and verifies that the database\n+     * file has been deleted.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearDeletesDatabaseFromDisk() throws DataStoreException {\n+        final BlogOwner dummy = BlogOwner.builder()\n+            .name(\"Dummy Blogger\")\n+            .build();\n+\n+        adapter.save(dummy);\n+        List<BlogOwner> query = adapter.query(BlogOwner.class);\n+        assertEquals(1, query.size());\n+        //Check that exactly one event was received by the observer.\n+        observer.assertValueCount(1);\n+\n+        adapter.clear();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NzM0MQ==", "bodyText": "What happens if you do adapter.query(BlogOwner.class) at this point?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418297341", "createdAt": "2020-04-30T21:23:37Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);\n+    }\n+\n+    @After\n+    public void teardown() {\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Happy path test: saves a record to the database\n+     * then calls clear and verifies that the database\n+     * file has been deleted.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearDeletesDatabaseFromDisk() throws DataStoreException {\n+        final BlogOwner dummy = BlogOwner.builder()\n+            .name(\"Dummy Blogger\")\n+            .build();\n+\n+        adapter.save(dummy);\n+        List<BlogOwner> query = adapter.query(BlogOwner.class);\n+        assertEquals(1, query.size());\n+        //Check that exactly one event was received by the observer.\n+        observer.assertValueCount(1);\n+\n+        adapter.clear();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        //Assert the observer was terminated during the file removal.\n+        observer.assertTerminated();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5ODM1Mg==", "bodyText": "Ah, this is the actual // Act part of the test, right? That clear() can be called multiple times without raising hell? I missed it until my second read - can you highlight this via a comment or something?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418298352", "createdAt": "2020-04-30T21:25:41Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import io.reactivex.observers.TestObserver;\n+\n+import static com.amplifyframework.datastore.storage.sqlite.SQLiteStorageAdapter.DATABASE_NAME;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SQLiteStorageAdapterClearTest {\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange.Record> observer;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = (ApplicationProvider.getApplicationContext());\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        observer = TestObserver.create();\n+        adapter.observe().subscribe(observer);\n+    }\n+\n+    @After\n+    public void teardown() {\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Happy path test: saves a record to the database\n+     * then calls clear and verifies that the database\n+     * file has been deleted.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearDeletesDatabaseFromDisk() throws DataStoreException {\n+        final BlogOwner dummy = BlogOwner.builder()\n+            .name(\"Dummy Blogger\")\n+            .build();\n+\n+        adapter.save(dummy);\n+        List<BlogOwner> query = adapter.query(BlogOwner.class);\n+        assertEquals(1, query.size());\n+        //Check that exactly one event was received by the observer.\n+        observer.assertValueCount(1);\n+\n+        adapter.clear();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        //Assert the observer was terminated during the file removal.\n+        observer.assertTerminated();\n+    }\n+\n+    /**\n+     * Assert that the database was created. Then call clear and\n+     * assert the file was deleted; attempt to call clear again\n+     * and ensure there are no exceptions thrown.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     */\n+    @Test\n+    public void clearHandlesMissingFile() throws DataStoreException {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+        //check that it's subscribed\n+        observer.assertSubscribed();\n+\n+        adapter.clear();\n+        //check that it's not subscribed anymore.\n+        observer.assertNotSubscribed();\n+        assertFalse(context.getDatabasePath(DATABASE_NAME).exists());\n+\n+        adapter.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5OTA4MA==", "bodyText": "Maybe a note about how/when this stuff is able to resume, afterwards? What if I have some changes in the outbound mutations queue? Will they be sent to AppSync, still?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418299080", "createdAt": "2020-04-30T21:27:18Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -390,6 +390,22 @@ public void observe(\n         onObservationFailure.accept(new DataStoreException(\"Not implemented yet, buster!\", \"Check back later!\"));\n     }\n \n+    /**\n+     * Stops all synchronization processes and deletes the\n+     * SQLite database from device's local storage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDUyNQ==", "bodyText": "\ud83d\udc4d Good docs.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418300525", "createdAt": "2020-04-30T21:30:30Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/LocalStorageAdapter.java", "diffHunk": "@@ -186,4 +186,14 @@ Cancelable observe(\n      * @throws DataStoreException if something goes wrong during terminate\n      */\n     void terminate() throws DataStoreException;\n+\n+    /**\n+     * Each implementation of this adapter interface will have its own", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMTYzMQ==", "bodyText": "Maybe, for more clarity, \"Error while trying to clear data from the local DataStore storage\" ?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418301631", "createdAt": "2020-04-30T21:32:55Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -579,6 +579,25 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear(@NonNull Action onComplete,\n+                      @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            terminate();\n+            sqliteStorageHelper.deleteDatabaseFromDisk();\n+            onComplete.call();\n+        } catch (Exception exception) {\n+            DataStoreException dataStoreException = new DataStoreException(\n+                \"Error while trying to delete database from local storage.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMjA4MA==", "bodyText": "Let's try to make this exception handling more narrow. Which of these calls are actually expected to throw, and what types of exceptions will they throw?\nCan you do:\ntry {\n    justTheThingsThatThrow();\n} catch (OnePossibleCaseException | AnotherCaseException failureToClear) {\n    // wrap in DataStoreException and re-throw\n}", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418302080", "createdAt": "2020-04-30T21:33:55Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -579,6 +579,25 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear(@NonNull Action onComplete,\n+                      @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            terminate();\n+            sqliteStorageHelper.deleteDatabaseFromDisk();\n+            onComplete.call();\n+        } catch (Exception exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMzQ2MQ==", "bodyText": "Should you call super.close() first, to be safe?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r418303461", "createdAt": "2020-04-30T21:36:58Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageHelper.java", "diffHunk": "@@ -172,6 +175,13 @@ public synchronized void update(\n         }\n     }\n \n+    /**\n+     * Deletes the SQLite database file from the device's local storage.\n+     */\n+    public void deleteDatabaseFromDisk() {\n+        context.deleteDatabase(getDatabaseName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11eb100e90f819651301621b908e663c7fa8c52d", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/11eb100e90f819651301621b908e663c7fa8c52d", "committedDate": "2020-05-01T18:49:42Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9141c3a91c2eddfd867c88f99d90990eea251655", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/9141c3a91c2eddfd867c88f99d90990eea251655", "committedDate": "2020-05-04T21:36:09Z", "message": "Handles restarting processes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00fe4a45e7b09b73812951851ff5ea07699cade7", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/00fe4a45e7b09b73812951851ff5ea07699cade7", "committedDate": "2020-05-04T22:01:53Z", "message": "Addressing PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "134d76231465201f3ca9070451490df433d75d88", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/134d76231465201f3ca9070451490df433d75d88", "committedDate": "2020-05-04T22:55:21Z", "message": "More PR feedback stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66cb6589f41018286ff33e26f22dc15b223c6b4", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/d66cb6589f41018286ff33e26f22dc15b223c6b4", "committedDate": "2020-05-05T14:09:37Z", "message": "Minor tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f831d61545d2849941ec85e306f54d14297f8196", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f831d61545d2849941ec85e306f54d14297f8196", "committedDate": "2020-05-07T12:19:40Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8592b33b55f36161c0c6b7e0fc6928c398cd292", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/a8592b33b55f36161c0c6b7e0fc6928c398cd292", "committedDate": "2020-05-07T12:22:56Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9248030d4a76896ddec875552655fca6c1737ba9", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/9248030d4a76896ddec875552655fca6c1737ba9", "committedDate": "2020-05-07T13:02:35Z", "message": "Fix clear test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/373da7b9f21d7025f1111e51f392b7e1f0615fac", "committedDate": "2020-05-07T15:08:20Z", "message": "Fixing integration test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDI3NDc4", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-408027478", "createdAt": "2020-05-08T06:33:56Z", "commit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDI4Nzky", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-408028792", "createdAt": "2020-05-08T06:37:00Z", "commit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjozNzowMFrOGSa5WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjo0Nzo1OFrOGSbLQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2ODIxNg==", "bodyText": "Ah, cool beans. I've never seen or used the FileObserver, before! Good stuff.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421968216", "createdAt": "2020-05-08T06:37:00Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1.getName());\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+        //The ensures files are created at least 1 second apart\n+        Thread.sleep(1000);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2.getName());\n+        assertRecordIsNotInDb(blogger1.getName());\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (owner.item() instanceof BlogOwner &&\n+                blogger.getName().equals(((BlogOwner) owner.item()).getName())) {\n+                return;\n+            }\n+        }\n+        fail(\"Could not find \" + blogger + \" in event observer.\");\n+    }\n+\n+    private void assertRecordIsInDb(String name) throws DataStoreException {\n+        List<BlogOwner> blogOwners = adapter.query(BlogOwner.class, BlogOwner.NAME.eq(name));\n+        assertNotNull(blogOwners);\n+        assertEquals(1, blogOwners.size());\n+    }\n+\n+    private void assertRecordIsNotInDb(String name) throws DataStoreException {\n+        List<BlogOwner> blogOwners = adapter.query(BlogOwner.class, BlogOwner.NAME.eq(name));\n+        assertNotNull(blogOwners);\n+        assertEquals(0, blogOwners.size());\n+    }\n+\n+    private void assertDbFileExists() {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+    }\n+\n+    private static final class TestFileObserver extends FileObserver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2ODg3MQ==", "bodyText": ":-D", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421968871", "createdAt": "2020-05-08T06:38:33Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2OTYzNw==", "bodyText": "But how come? Is it necessary?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421969637", "createdAt": "2020-05-08T06:40:26Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1.getName());\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+        //The ensures files are created at least 1 second apart\n+        Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3MTg1MA==", "bodyText": "In theory you could achieve this with:\nassertEquals(blogger1, adapter.query(BlogOwner.class, blogger1.getId()).get(0));\n\nBut that gets kind of long, and loses the DAMP you have.\nMaybe:\nassertRecordIsInDB(BlogOwner.class, blogger1.getId());\n\nTo use the same type of arguments as the storage interface usually do, though?\nprivate <T extends Model> void assertRecordIsInDB(T item) {\n    List<T> results = adapter.query(item.getClass(), item.getId());\n    assertEquals(1, results.size());\n    assertEquals(item, results.get(0));\n}", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421971850", "createdAt": "2020-05-08T06:45:45Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3MjI3Nw==", "bodyText": "nit: an extra empty", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421972277", "createdAt": "2020-05-08T06:46:42Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1.getName());\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+        //The ensures files are created at least 1 second apart\n+        Thread.sleep(1000);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2.getName());\n+        assertRecordIsNotInDb(blogger1.getName());\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3MjgwMA==", "bodyText": "There is also an item.itemClass(), you could do like BlogOwner.class.isAssignableFrom(item.itemClass()) or something like that. (Or, BlogOwner.class.equals(item.itemClass()).)", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r421972800", "createdAt": "2020-05-08T06:47:58Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1.getName());\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+        //The ensures files are created at least 1 second apart\n+        Thread.sleep(1000);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2.getName());\n+        assertRecordIsNotInDb(blogger1.getName());\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (owner.item() instanceof BlogOwner &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "373da7b9f21d7025f1111e51f392b7e1f0615fac"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5efdb507691b6c6aa8472714480f40b900e8a622", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/5efdb507691b6c6aa8472714480f40b900e8a622", "committedDate": "2020-05-08T15:53:13Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c92ff788147fbfb694ef9e115c5f188815a79b59", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/c92ff788147fbfb694ef9e115c5f188815a79b59", "committedDate": "2020-05-08T18:06:58Z", "message": "Addressing PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4440ecf766bbbda757991520d2e753a7ca7ff06f", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/4440ecf766bbbda757991520d2e753a7ca7ff06f", "committedDate": "2020-05-12T00:16:33Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7f15164d01cb74222a6c13d480a7e8075e9ecf", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/6c7f15164d01cb74222a6c13d480a7e8075e9ecf", "committedDate": "2020-05-12T12:41:09Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8df0feb5170f1593cce4c67aee655796cde72f84", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/8df0feb5170f1593cce4c67aee655796cde72f84", "committedDate": "2020-05-13T00:07:28Z", "message": "Don't restart sync right away. Fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88a9ea1d02a3c086c639e916a0c3c224c8a26d2", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/d88a9ea1d02a3c086c639e916a0c3c224c8a26d2", "committedDate": "2020-05-13T00:15:06Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdd9e9c41b8436c17e97d1e47162ec6308193207", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/bdd9e9c41b8436c17e97d1e47162ec6308193207", "committedDate": "2020-05-13T00:16:47Z", "message": "updated comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed5732e00f81b50a542b784734b7771ddf384ff", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/bed5732e00f81b50a542b784734b7771ddf384ff", "committedDate": "2020-05-15T19:19:24Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9b18406a10c9250f80823466b882a3524f6085d", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/f9b18406a10c9250f80823466b882a3524f6085d", "committedDate": "2020-05-15T20:36:08Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/9f204d0a623fbc9c526bfe042e47a55105595316", "committedDate": "2020-05-16T22:56:02Z", "message": "Ensure subscriptions connections get closed on dispose"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTIwMjY1", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-413120265", "createdAt": "2020-05-17T01:36:59Z", "commit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMTozNjo1OVrOGWdnVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwMjozMDo1M1rOGWdyaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzA2MQ==", "bodyText": "I think we  should be using timeouts on all of these, like blockingAwait(TIMEOUT_MS, TimeUnit.MILLISECONDS), otherwise we might hang a thread permanently if the asyncDelegate doesn't fire back.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426207061", "createdAt": "2020-05-17T01:36:59Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/SynchronousStorageAdapter.java", "diffHunk": "@@ -286,4 +287,16 @@ public void terminate() throws DataStoreException {\n             asyncDelegate.observe(emitter::onNext, emitter::onError, emitter::onComplete)\n         );\n     }\n+\n+    /**\n+     * Invokes the clear method of the underlying adapter and\n+     * either completes or throws an exception.\n+     */\n+    public void clear() {\n+        Completable.fromSingle(single -> {\n+            asyncDelegate.clear(() -> {\n+                single.onSuccess(true);\n+            }, single::onError);\n+        }).blockingAwait();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzA3NA==", "bodyText": "(Same here, I'd add a timeout here.)", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426207074", "createdAt": "2020-05-17T01:37:15Z", "author": {"login": "jamesonwilliams"}, "path": "testutils/src/main/java/com/amplifyframework/testutils/sync/SynchronousDataStore.java", "diffHunk": "@@ -86,6 +88,17 @@ public static SynchronousDataStore delegatingTo(@NonNull DataStoreCategoryBehavi\n         throw new NoSuchElementException(\"No item in DataStore with class = \" + clazz + \" and id = \" + itemId);\n     }\n \n+    /**\n+     * Call the clear method of the underlying DataStore implementation.\n+     */\n+    public void clear() {\n+        Completable.fromSingle(single -> {\n+            asyncDelegate.clear(() -> {\n+                single.onSuccess(true);\n+            }, single::onError);\n+        }).blockingAwait();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzg0Ng==", "bodyText": "nit pick -- I'd assign this in the @Before with the rest", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426207846", "createdAt": "2020-05-17T01:51:46Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNzk2OQ==", "bodyText": "Oh, hm. The main value of the test() is just so you can get a TestObserver and then use all of its utility methods.\nBut if all you want to do is grab the Diposable, I wonder if it might be more straight-forward to do just:\ndisposable = adapter.observe().subscribe();", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426207969", "createdAt": "2020-05-17T01:54:37Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    /**\n+     * Enable strict mode.\n+     */\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    /**\n+     * Setup actions for every test in this class.\n+     */\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODEwMw==", "bodyText": "Matching on the name feels wrong, should you match on the unique ID?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208103", "createdAt": "2020-05-17T01:56:10Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    /**\n+     * Enable strict mode.\n+     */\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    /**\n+     * Setup actions for every test in this class.\n+     */\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    /**\n+     * Tearing down components created for each test.\n+     */\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1);\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2);\n+        assertRecordIsNotInDb(blogger1);\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (BlogOwner.class.isAssignableFrom(owner.itemClass()) &&\n+                blogger.getName().equals(((BlogOwner) owner.item()).getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODE2Mw==", "bodyText": "I think we should add a timeout to this\nMaybe not for this PR, since it was already like this", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208163", "createdAt": "2020-05-17T01:57:26Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -186,11 +186,9 @@ public void configure(\n     @WorkerThread\n     @Override\n     public void initialize(@NonNull Context context) {\n-        Completable completable = initializeStorageAdapter(context);\n-        if (!api.getPlugins().isEmpty()) {\n-            completable = completable.andThen(orchestrator.start());\n-        }\n-        completable.blockingAwait();\n+        initializeStorageAdapter(context)\n+            .andThen(initializeOrchestrator())\n+            .blockingAwait();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODI0OA==", "bodyText": "My initial reaction was \"not here!\", but then after I read the clear(), I remembered that @wooj2 is lazy initializing the orchestrator on iOS. This would be a reasonable place to do the same thing.\nRequest, though -- this method is no longer afterInitialization. Now, it is more like beforeOperation.\nIt's weird for \"after initialization\" to then do.... more initialization. I think we can just solve this with a rename.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208248", "createdAt": "2020-05-17T01:58:39Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -405,12 +403,39 @@ public void observe(\n         onObservationFailure.accept(new DataStoreException(\"Not implemented yet, buster!\", \"Check back later!\"));\n     }\n \n+    /**\n+     * Stops all synchronization processes and invokes\n+     * the clear method of the underlying storage\n+     * adapter. Any items pending synchronization in the outbound queue will\n+     * be lost. Synchronization processes will be restarted on the\n+     * next interaction with the DataStore.\n+     * @param onComplete Invoked if the call is successful.\n+     * @param onError Invoked if not successful\n+     */\n+    @Override\n+    public void clear(@NonNull Action onComplete,\n+                      @NonNull Consumer<DataStoreException> onError) {\n+        afterInitialization(() -> {\n+            orchestrator.stop();\n+            sqliteStorageAdapter.clear(onComplete, onError);\n+        });\n+    }\n+\n     private void afterInitialization(@NonNull final Runnable runnable) {\n         Completable.fromAction(categoryInitializationsPending::await)\n+            .andThen(initializeOrchestrator())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODM0Mw==", "bodyText": "Can we tighted this up at all? SQLSpecialException | SQLOtherSpecialException sqlError) ?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208343", "createdAt": "2020-05-17T02:00:31Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +572,35 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        sqliteStorageHelper.close();\n+        databaseConnectionHandle.close();\n+\n+        try {\n+            context.deleteDatabase(DATABASE_NAME);\n+        } catch (Exception exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYwMw==", "bodyText": "Let's align the naming of all of these to their corresponding start<whatever> methods. Here, this would be come:\nstorageObserver.isObservingStorageChanges()", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208603", "createdAt": "2020-05-17T02:05:49Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -95,22 +98,38 @@ public Orchestrator(\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n-    public Completable start() {\n-        return Completable.fromAction(() -> {\n-            storageObserver.startObservingStorageChanges();\n-            subscriptionProcessor.startSubscriptions();\n-            syncProcessor.hydrate().blockingAwait();\n-            mutationProcessor.startDrainingMutationOutbox();\n-            subscriptionProcessor.startDrainingMutationBuffer();\n+    public synchronized Completable start() {\n+        return Completable.fromSingle(single -> {\n+            try {\n+                if (!storageObserver.isObserving()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODYyNg==", "bodyText": "And this one,\nsubscriptionsProcessor.isSubcribed()\n\nOr\nsubscriptionsProcessor.hasSubscriptions()", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208626", "createdAt": "2020-05-17T02:06:18Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -95,22 +98,38 @@ public Orchestrator(\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n-    public Completable start() {\n-        return Completable.fromAction(() -> {\n-            storageObserver.startObservingStorageChanges();\n-            subscriptionProcessor.startSubscriptions();\n-            syncProcessor.hydrate().blockingAwait();\n-            mutationProcessor.startDrainingMutationOutbox();\n-            subscriptionProcessor.startDrainingMutationBuffer();\n+    public synchronized Completable start() {\n+        return Completable.fromSingle(single -> {\n+            try {\n+                if (!storageObserver.isObserving()) {\n+                    LOG.debug(\"Starting local storage observer.\");\n+                    storageObserver.startObservingStorageChanges();\n+                }\n+                if (!subscriptionProcessor.isObserving()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODY0Mw==", "bodyText": "mutationProcessor.isDrainingMutationOutbox()", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208643", "createdAt": "2020-05-17T02:06:39Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -95,22 +98,38 @@ public Orchestrator(\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n-    public Completable start() {\n-        return Completable.fromAction(() -> {\n-            storageObserver.startObservingStorageChanges();\n-            subscriptionProcessor.startSubscriptions();\n-            syncProcessor.hydrate().blockingAwait();\n-            mutationProcessor.startDrainingMutationOutbox();\n-            subscriptionProcessor.startDrainingMutationBuffer();\n+    public synchronized Completable start() {\n+        return Completable.fromSingle(single -> {\n+            try {\n+                if (!storageObserver.isObserving()) {\n+                    LOG.debug(\"Starting local storage observer.\");\n+                    storageObserver.startObservingStorageChanges();\n+                }\n+                if (!subscriptionProcessor.isObserving()) {\n+                    LOG.debug(\"Starting subscription processor.\");\n+                    subscriptionProcessor.startSubscriptions();\n+                }\n+                syncProcessor.hydrate().blockingAwait();\n+                if (!mutationProcessor.isObserving()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODY2Nw==", "bodyText": "How come this one doesn't need an if guard like the others?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208667", "createdAt": "2020-05-17T02:07:15Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -95,22 +98,38 @@ public Orchestrator(\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n-    public Completable start() {\n-        return Completable.fromAction(() -> {\n-            storageObserver.startObservingStorageChanges();\n-            subscriptionProcessor.startSubscriptions();\n-            syncProcessor.hydrate().blockingAwait();\n-            mutationProcessor.startDrainingMutationOutbox();\n-            subscriptionProcessor.startDrainingMutationBuffer();\n+    public synchronized Completable start() {\n+        return Completable.fromSingle(single -> {\n+            try {\n+                if (!storageObserver.isObserving()) {\n+                    LOG.debug(\"Starting local storage observer.\");\n+                    storageObserver.startObservingStorageChanges();\n+                }\n+                if (!subscriptionProcessor.isObserving()) {\n+                    LOG.debug(\"Starting subscription processor.\");\n+                    subscriptionProcessor.startSubscriptions();\n+                }\n+                syncProcessor.hydrate().blockingAwait();\n+                if (!mutationProcessor.isObserving()) {\n+                    LOG.debug(\"Starting mutation processor.\");\n+                    mutationProcessor.startDrainingMutationOutbox();\n+                }\n+                subscriptionProcessor.startDrainingMutationBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODg0MA==", "bodyText": "Would this be better as just:\nCompletable.create(emitter -> {\n    try {\n        tryToSucceed();\n        emitter.onComplete();\n    } catch (WhateverException whatever) {\n       emitter.onError(whatever);\n    } \n});\n\nfromCallable or fromAction or forRunnable ... one of these factories must do the exception handling for you, I think, too?\nlike,\nCompletable.fromAction(() -> {\n}).doOnError(thrownInsideOfAction -> {\n    // I need to look up if it works like this ...\n});", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208840", "createdAt": "2020-05-17T02:10:27Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -95,22 +98,38 @@ public Orchestrator(\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n-    public Completable start() {\n-        return Completable.fromAction(() -> {\n-            storageObserver.startObservingStorageChanges();\n-            subscriptionProcessor.startSubscriptions();\n-            syncProcessor.hydrate().blockingAwait();\n-            mutationProcessor.startDrainingMutationOutbox();\n-            subscriptionProcessor.startDrainingMutationBuffer();\n+    public synchronized Completable start() {\n+        return Completable.fromSingle(single -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwODk0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * Checks if the mutation processor is listening\n          \n          \n            \n                 * for events.\n          \n          \n            \n                 * @return True if there are listeners. False otherwise.\n          \n          \n            \n                 */\n          \n          \n            \n                boolean isObserving() {\n          \n          \n            \n                    return disposable.size() > 0;\n          \n          \n            \n                }\n          \n          \n            \n                /**\n          \n          \n            \n                 * Checks if the mutation processor is actively observing the mutation outbox.\n          \n          \n            \n                 * @return True if the mutation processor is subscribed the mutation outbox.\n          \n          \n            \n                 */\n          \n          \n            \n                boolean isDrainingMutationOutbox() {\n          \n          \n            \n                    return !disposable.isEmpty();\n          \n          \n            \n                }", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426208948", "createdAt": "2020-05-17T02:12:33Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -84,6 +84,15 @@ void startDrainingMutationOutbox() {\n         );\n     }\n \n+    /**\n+     * Checks if the mutation processor is listening\n+     * for events.\n+     * @return True if there are listeners. False otherwise.\n+     */\n+    boolean isObserving() {\n+        return disposable.size() > 0;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTA4Mw==", "bodyText": "L108 was supposed to do this.\n            emitter.setCancellable(cancelable::get);\n\nHowever, I think I found elsewhere, that setCancellable(...) doesn't do what I thought it was supposed to do. There is also emitter.setDispoable(Disposable...), though. I have a factory method elsewhere in the code base that builds a Disposable from our own Cancelable type. There's a note about \"pulling it out into a utility class\". Maybe its time.....", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209083", "createdAt": "2020-05-17T02:15:07Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessor.java", "diffHunk": "@@ -123,6 +125,18 @@ void startSubscriptions() {\n         .onErrorResumeNext(next -> {\n             next.onComplete();\n         })\n+        .doOnDispose(() -> {\n+            // When the observable is disposed, we need to call cancel() on the subscription\n+            // so it can properly dispose of resources if necessary. For the AWS API plugin,\n+            // this means means closing the underlying network connection.\n+            synchronized (cancelable) {\n+                Cancelable subscriptionOperation = cancelable.get();\n+                if (subscriptionOperation != null) {\n+                    LOG.info(\"Terminating subscription operation.\");\n+                    subscriptionOperation.cancel();\n+                }\n+            }\n+        })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTI5OQ==", "bodyText": "This one is tricker than in the other case, because the SubscriptionProcessor has an intermediate state, where it is buffering content, but is not processing it. So, we should decided which state we mean. From your current implementation, it would match two states:\n\nsubscribed, not processing\nsubscribed, processing under way\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * Checks if the subscription processor is listening\n          \n          \n            \n                 * for events.\n          \n          \n            \n                 * @return true if there are listeners. False otherwise.\n          \n          \n            \n                 */\n          \n          \n            \n                boolean isObserving() {\n          \n          \n            \n                    return disposable.size() > 0;\n          \n          \n            \n                }\n          \n          \n            \n                /**\n          \n          \n            \n                 * Checks if the subscription processor is currently buffering events from the remote AppSync instance.\n          \n          \n            \n                 * @return true if the subscription processor has active subscriptions to AppSync\n          \n          \n            \n                 */\n          \n          \n            \n                boolean isSubscribed() {\n          \n          \n            \n                    return !disposable.isEmpty();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n      \n    \n    \n  \n\nThe other meaning would also be easy to implement:\n/**\n * Checks if the subscription processor is actively processing events found on its AppSync subscriptions.\n * @return true if the subscription processor is actively processing subscription events\n */\npublic isDrainingEventBuffer() {\n    return disposable.size() == 2;\n}", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209299", "createdAt": "2020-05-17T02:19:54Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessor.java", "diffHunk": "@@ -149,6 +163,15 @@ void startDrainingMutationBuffer() {\n         );\n     }\n \n+    /**\n+     * Checks if the subscription processor is listening\n+     * for events.\n+     * @return true if there are listeners. False otherwise.\n+     */\n+    boolean isObserving() {\n+        return disposable.size() > 0;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTM0Ng==", "bodyText": "0 is already the default for AtomicInteger()", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209346", "createdAt": "2020-05-17T02:20:31Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -74,16 +84,17 @@\n     @Before\n     public void setup() {\n         this.context = getApplicationContext();\n-        modelProvider = spy(SimpleModelProvider.builder()\n-            .version(RandomString.string())\n-            .addModel(Person.class)\n-            .build());\n+        modelProvider = spy(AmplifyCliGeneratedModelProvider.singletonInstance());\n+        subscriptionCancelledCounter = new AtomicInteger(0);\n+        subscriptionStartedCounter = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTU1NA==", "bodyText": "Does this construct work? It looks like you're making assertFoo statements on a different thread, which the jUnit test runner thread would not capture.\nIf you put a fail() inside one these things, does the test runner thread catch it?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209554", "createdAt": "2020-05-17T02:24:22Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -158,29 +168,117 @@ public void configureAndInitializeInApiModeWithoutApi() throws JSONException, Am\n         }\n     }\n \n-    private void assertSyncProcessorStarted() {\n-        boolean syncProcessorInvoked = mockingDetails(modelProvider)\n-            .getInvocations()\n-            .stream()\n-            .anyMatch(invocation -> invocation.getLocation().getSourceFile().contains(\"SyncProcessor\"));\n+    /**\n+     * Verify that when the clear method is called, the following happens\n+     * - All remote synchronization processes are stopped\n+     * - The database is deleted.\n+     * - On the next interaction with the DataStore, the synchronization processes are restarted.\n+     * @throws JSONException on failure to arrange plugin config\n+     * @throws AmplifyException on failure to arrange API plugin via Amplify facade\n+     */\n+    @Test\n+    public void clearStopsSyncUntilNextInteraction() throws AmplifyException, JSONException {\n+        ApiCategory mockApiCategory = mockApiCategoryWithGraphQlApi();\n+        JSONObject dataStorePluginJson = new JSONObject()\n+            .put(\"syncIntervalInMinutes\", 60);\n+        AWSDataStorePlugin awsDataStorePlugin = new AWSDataStorePlugin(modelProvider, mockApiCategory);\n+        awsDataStorePlugin.configure(dataStorePluginJson, context);\n+        awsDataStorePlugin.initialize(context);\n+\n+        // Trick the DataStore since it's not getting initialized as part of the Amplify.initialize call chain\n+        Amplify.Hub.publish(HubChannel.DATASTORE, HubEvent.create(InitializationStatus.SUCCEEDED));\n+\n+        assertRemoteSubscriptionsStarted();\n+\n+        Person person1 = createPerson(\"Test\", \"Dummy I\");\n+        Person person2 = createPerson(\"Test\", \"Dummy II\");\n+        Completable.fromSingle(single -> { // Save a record to local store\n+            awsDataStorePlugin.save(person1, itemSaved -> {\n+                assertNotNull(itemSaved.item().getId());\n+                assertEquals(person1.getLastName(), itemSaved.item().getLastName());\n+                single.onSuccess(true);\n+            }, single::onError);\n+        }).andThen(\n+            Completable.fromSingle(single -> { // Verify the record has been saved\n+                awsDataStorePlugin.query(Person.class, results -> {\n+                    Person actualPerson = results.next();\n+                    assertNotNull(actualPerson);\n+                    assertFalse(results.hasNext()); // We should only have one result.\n+                    assertEquals(person1, actualPerson);\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Clear the local store.\n+                awsDataStorePlugin.clear(() -> {\n+                    // Make sure the remote subscription operations were cancelled\n+                    assertRemoteSubscriptionsCancelled();\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Save a new record to local store\n+                awsDataStorePlugin.save(person2, itemSaved -> {\n+                    assertEquals(person2.getLastName(), itemSaved.item().getLastName());\n+                    // Check if the sync process restarted.\n+                    assertRemoteSubscriptionsStarted();\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Verify the record has been saved\n+                awsDataStorePlugin.query(Person.class, results -> {\n+                    Person actualPerson = results.next();\n+                    assertNotNull(actualPerson);\n+                    assertFalse(results.hasNext()); //we should only have one result.\n+                    assertEquals(person2, actualPerson);\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).blockingGet(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTYzOQ==", "bodyText": "Since you ignore the result of the single, can't you just use Completable.create, Completable.fromAction, Completable.fromRunnable, etc?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209639", "createdAt": "2020-05-17T02:25:47Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -158,29 +168,117 @@ public void configureAndInitializeInApiModeWithoutApi() throws JSONException, Am\n         }\n     }\n \n-    private void assertSyncProcessorStarted() {\n-        boolean syncProcessorInvoked = mockingDetails(modelProvider)\n-            .getInvocations()\n-            .stream()\n-            .anyMatch(invocation -> invocation.getLocation().getSourceFile().contains(\"SyncProcessor\"));\n+    /**\n+     * Verify that when the clear method is called, the following happens\n+     * - All remote synchronization processes are stopped\n+     * - The database is deleted.\n+     * - On the next interaction with the DataStore, the synchronization processes are restarted.\n+     * @throws JSONException on failure to arrange plugin config\n+     * @throws AmplifyException on failure to arrange API plugin via Amplify facade\n+     */\n+    @Test\n+    public void clearStopsSyncUntilNextInteraction() throws AmplifyException, JSONException {\n+        ApiCategory mockApiCategory = mockApiCategoryWithGraphQlApi();\n+        JSONObject dataStorePluginJson = new JSONObject()\n+            .put(\"syncIntervalInMinutes\", 60);\n+        AWSDataStorePlugin awsDataStorePlugin = new AWSDataStorePlugin(modelProvider, mockApiCategory);\n+        awsDataStorePlugin.configure(dataStorePluginJson, context);\n+        awsDataStorePlugin.initialize(context);\n+\n+        // Trick the DataStore since it's not getting initialized as part of the Amplify.initialize call chain\n+        Amplify.Hub.publish(HubChannel.DATASTORE, HubEvent.create(InitializationStatus.SUCCEEDED));\n+\n+        assertRemoteSubscriptionsStarted();\n+\n+        Person person1 = createPerson(\"Test\", \"Dummy I\");\n+        Person person2 = createPerson(\"Test\", \"Dummy II\");\n+        Completable.fromSingle(single -> { // Save a record to local store\n+            awsDataStorePlugin.save(person1, itemSaved -> {\n+                assertNotNull(itemSaved.item().getId());\n+                assertEquals(person1.getLastName(), itemSaved.item().getLastName());\n+                single.onSuccess(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTczMQ==", "bodyText": "You could phrase this as,\nfinal int diffTypesOfSubscriptions  = SubscriptionType.values().length;\n\nand then get out of hte business of writing 3, while also clarifying its meaning.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209731", "createdAt": "2020-05-17T02:27:56Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -158,29 +168,117 @@ public void configureAndInitializeInApiModeWithoutApi() throws JSONException, Am\n         }\n     }\n \n-    private void assertSyncProcessorStarted() {\n-        boolean syncProcessorInvoked = mockingDetails(modelProvider)\n-            .getInvocations()\n-            .stream()\n-            .anyMatch(invocation -> invocation.getLocation().getSourceFile().contains(\"SyncProcessor\"));\n+    /**\n+     * Verify that when the clear method is called, the following happens\n+     * - All remote synchronization processes are stopped\n+     * - The database is deleted.\n+     * - On the next interaction with the DataStore, the synchronization processes are restarted.\n+     * @throws JSONException on failure to arrange plugin config\n+     * @throws AmplifyException on failure to arrange API plugin via Amplify facade\n+     */\n+    @Test\n+    public void clearStopsSyncUntilNextInteraction() throws AmplifyException, JSONException {\n+        ApiCategory mockApiCategory = mockApiCategoryWithGraphQlApi();\n+        JSONObject dataStorePluginJson = new JSONObject()\n+            .put(\"syncIntervalInMinutes\", 60);\n+        AWSDataStorePlugin awsDataStorePlugin = new AWSDataStorePlugin(modelProvider, mockApiCategory);\n+        awsDataStorePlugin.configure(dataStorePluginJson, context);\n+        awsDataStorePlugin.initialize(context);\n+\n+        // Trick the DataStore since it's not getting initialized as part of the Amplify.initialize call chain\n+        Amplify.Hub.publish(HubChannel.DATASTORE, HubEvent.create(InitializationStatus.SUCCEEDED));\n+\n+        assertRemoteSubscriptionsStarted();\n+\n+        Person person1 = createPerson(\"Test\", \"Dummy I\");\n+        Person person2 = createPerson(\"Test\", \"Dummy II\");\n+        Completable.fromSingle(single -> { // Save a record to local store\n+            awsDataStorePlugin.save(person1, itemSaved -> {\n+                assertNotNull(itemSaved.item().getId());\n+                assertEquals(person1.getLastName(), itemSaved.item().getLastName());\n+                single.onSuccess(true);\n+            }, single::onError);\n+        }).andThen(\n+            Completable.fromSingle(single -> { // Verify the record has been saved\n+                awsDataStorePlugin.query(Person.class, results -> {\n+                    Person actualPerson = results.next();\n+                    assertNotNull(actualPerson);\n+                    assertFalse(results.hasNext()); // We should only have one result.\n+                    assertEquals(person1, actualPerson);\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Clear the local store.\n+                awsDataStorePlugin.clear(() -> {\n+                    // Make sure the remote subscription operations were cancelled\n+                    assertRemoteSubscriptionsCancelled();\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Save a new record to local store\n+                awsDataStorePlugin.save(person2, itemSaved -> {\n+                    assertEquals(person2.getLastName(), itemSaved.item().getLastName());\n+                    // Check if the sync process restarted.\n+                    assertRemoteSubscriptionsStarted();\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).andThen(\n+            Completable.fromSingle(single -> { // Verify the record has been saved\n+                awsDataStorePlugin.query(Person.class, results -> {\n+                    Person actualPerson = results.next();\n+                    assertNotNull(actualPerson);\n+                    assertFalse(results.hasNext()); //we should only have one result.\n+                    assertEquals(person2, actualPerson);\n+                    single.onSuccess(true);\n+                }, single::onError);\n+            })\n+        ).blockingGet(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+\n+        // Verify that the API mutate method was called once for each model saved.\n+        verify(mockApiCategory, times(2)).mutate(Mockito.any(), Mockito.any(), Mockito.any());\n+    }\n+\n+    private void assertRemoteSubscriptionsCancelled() {\n+        // Check that we've had active subscriptions\n+        assertTrue(subscriptionStartedCounter.get() > 0);\n+        // And the number of started and cancelled are the same\n+        assertEquals(subscriptionStartedCounter.get(), subscriptionCancelledCounter.get());\n+    }\n \n-        assertTrue(syncProcessorInvoked);\n+    private void assertRemoteSubscriptionsStarted() {\n+        // For each model, there should be 3 subscriptions setup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTc4OA==", "bodyText": "Oh dang, looks like this wasn't doin' much before huh lol", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209788", "createdAt": "2020-05-17T02:29:34Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -194,16 +292,26 @@ private static ApiCategory mockApiCategoryWithGraphQlApi() throws AmplifyExcepti\n         doAnswer(invocation -> {\n             int indexOfResponseConsumer = 1;\n             Consumer<GraphQLResponse<String>> onResponse = invocation.getArgument(indexOfResponseConsumer);\n-            onResponse.accept(new GraphQLResponse<>(\"{}\", Collections.emptyList()));\n+            // Calling onResponse with an invalid input generates an error in MutationOutbox.hasPendingMutation.\n+            // Disabling it for now since it does not affect the assertions we need for this test.\n+            // onResponse.accept(new GraphQLResponse<>(\"{}\", Collections.emptyList()));\n             return null;\n         }).when(mockApiPlugin).mutate(any(GraphQLRequest.class), any(Consumer.class), any(Consumer.class));\n \n         // Make believe that subscriptions return response immediately\n         doAnswer(invocation -> {\n-            int indexOfStartConsumer = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTg5Nw==", "bodyText": "Oh fuck, a doAnswer inside of a doAnswer, Head just exploded.\nThe situation with the Cancelable return type and String \"on started\" token is such a nightmare, isn't it? On a brighter day, maybe we could cleanup that API signature so we don't have to get so clever about managing/mocking/testing it.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426209897", "createdAt": "2020-05-17T02:30:53Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -194,16 +292,26 @@ private static ApiCategory mockApiCategoryWithGraphQlApi() throws AmplifyExcepti\n         doAnswer(invocation -> {\n             int indexOfResponseConsumer = 1;\n             Consumer<GraphQLResponse<String>> onResponse = invocation.getArgument(indexOfResponseConsumer);\n-            onResponse.accept(new GraphQLResponse<>(\"{}\", Collections.emptyList()));\n+            // Calling onResponse with an invalid input generates an error in MutationOutbox.hasPendingMutation.\n+            // Disabling it for now since it does not affect the assertions we need for this test.\n+            // onResponse.accept(new GraphQLResponse<>(\"{}\", Collections.emptyList()));\n             return null;\n         }).when(mockApiPlugin).mutate(any(GraphQLRequest.class), any(Consumer.class), any(Consumer.class));\n \n         // Make believe that subscriptions return response immediately\n         doAnswer(invocation -> {\n-            int indexOfStartConsumer = 2;\n-            Consumer<String> onResponse = invocation.getArgument(indexOfStartConsumer);\n-            onResponse.accept(RandomString.string());\n-            return null;\n+            int indexOfStartConsumer = 1;\n+            Consumer<String> onStart = invocation.getArgument(indexOfStartConsumer);\n+            GraphQLOperation<?> mockOperation = mock(GraphQLOperation.class);\n+            doAnswer(opAnswer -> {\n+                this.subscriptionCancelledCounter.incrementAndGet();\n+                return null;\n+            }).when(mockOperation).cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "336d6e644bcc083da398a3ae17ae1db986f5a006", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/336d6e644bcc083da398a3ae17ae1db986f5a006", "committedDate": "2020-05-19T23:03:56Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acdf765f14e4d5dde8409a498590a2030e414654", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/acdf765f14e4d5dde8409a498590a2030e414654", "committedDate": "2020-05-20T14:33:27Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce38f767cd799717b493df7f154de8abc51dc22d", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/ce38f767cd799717b493df7f154de8abc51dc22d", "committedDate": "2020-05-20T16:34:41Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/59fd65a1499fe027231fc0da1213c04cd91fa320", "committedDate": "2020-05-22T01:47:21Z", "message": "Fixing race condition on restart"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTE1Mjcw", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-413115270", "createdAt": "2020-05-16T23:27:49Z", "commit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQyMzoyNzo0OVrOGWdMbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMjoyODo0OVrOGZIwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDE3Mg==", "bodyText": "Hmm, I might rephrase this for a user reading the JavaDoc to lead with the intent of the underlying implementations. I'd lead with what the behavior should be, it's expected that every implementation would be different given it's an interface.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426200172", "createdAt": "2020-05-16T23:27:49Z", "author": {"login": "jpignata"}, "path": "core/src/main/java/com/amplifyframework/datastore/DataStoreCategoryBehavior.java", "diffHunk": "@@ -225,4 +225,14 @@ void observe(\n             @NonNull Consumer<DataStoreException> onObservationFailure,\n             @NonNull Action onObservationCompleted\n     );\n+\n+    /**\n+     * Every class that implements this behavior will have its own", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDQ3NA==", "bodyText": "Does this delete other potential artifacts like journal or other logs? It appears to: https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase#deleteDatabase(java.io.File)", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426200474", "createdAt": "2020-05-16T23:33:07Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +572,35 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        sqliteStorageHelper.close();\n+        databaseConnectionHandle.close();\n+\n+        try {\n+            context.deleteDatabase(DATABASE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDc2Mg==", "bodyText": "Still getting my bearings, but I'm a little skeptical about docs like this - not sure they aid in comprehension or pull their weight.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426200762", "createdAt": "2020-05-16T23:38:08Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    /**\n+     * Enable strict mode.\n+     */\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    /**\n+     * Setup actions for every test in this class.\n+     */\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    /**\n+     * Tearing down components created for each test.\n+     */\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1);\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2);\n+        assertRecordIsNotInDb(blogger1);\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (BlogOwner.class.isAssignableFrom(owner.itemClass()) &&\n+                blogger.getName().equals(((BlogOwner) owner.item()).getName())) {\n+                return;\n+            }\n+        }\n+        fail(\"Could not find \" + blogger + \" in event observer.\");\n+    }\n+\n+    private <T extends Model> void assertRecordIsInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertEquals(1, results.size());\n+        assertEquals(item, results.get(0));\n+    }\n+\n+    private <T extends Model> void assertRecordIsNotInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertNotNull(results);\n+        assertEquals(0, results.size());\n+    }\n+\n+    private void assertDbFileExists() {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+    }\n+\n+    private static final class TestFileObserver extends FileObserver {\n+        private int createFileEventCount;\n+        private int deleteFileEventCount;\n+        /**\n+         * Equivalent to FileObserver(file, FileObserver.ALL_EVENTS).\n+         *\n+         * @param path Directory to watch\n+         */\n+\n+        @SuppressWarnings(\"deprecation\")\n+        TestFileObserver(@NonNull String path) {\n+            super(path, FileObserver.CREATE | FileObserver.DELETE | FileObserver.DELETE_SELF);\n+\n+            this.deleteFileEventCount = 0;\n+            this.createFileEventCount = 0;\n+        }\n+\n+        /**\n+         * The event handler, which must be implemented by subclasses.\n+         *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDgxMw==", "bodyText": "Curious about the conditions under which DELETE is fired versus DELETE_SELF. The docs imply that DELETE is when a directory is monitored and a file within it is deleted.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r426200813", "createdAt": "2020-05-16T23:39:44Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    /**\n+     * Enable strict mode.\n+     */\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    /**\n+     * Setup actions for every test in this class.\n+     */\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    /**\n+     * Tearing down components created for each test.\n+     */\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1);\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2);\n+        assertRecordIsNotInDb(blogger1);\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (BlogOwner.class.isAssignableFrom(owner.itemClass()) &&\n+                blogger.getName().equals(((BlogOwner) owner.item()).getName())) {\n+                return;\n+            }\n+        }\n+        fail(\"Could not find \" + blogger + \" in event observer.\");\n+    }\n+\n+    private <T extends Model> void assertRecordIsInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertEquals(1, results.size());\n+        assertEquals(item, results.get(0));\n+    }\n+\n+    private <T extends Model> void assertRecordIsNotInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertNotNull(results);\n+        assertEquals(0, results.size());\n+    }\n+\n+    private void assertDbFileExists() {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+    }\n+\n+    private static final class TestFileObserver extends FileObserver {\n+        private int createFileEventCount;\n+        private int deleteFileEventCount;\n+        /**\n+         * Equivalent to FileObserver(file, FileObserver.ALL_EVENTS).\n+         *\n+         * @param path Directory to watch\n+         */\n+\n+        @SuppressWarnings(\"deprecation\")\n+        TestFileObserver(@NonNull String path) {\n+            super(path, FileObserver.CREATE | FileObserver.DELETE | FileObserver.DELETE_SELF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNzg1OQ==", "bodyText": "Don't we need to explicitly shut down the threadpool?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429007859", "createdAt": "2020-05-22T02:13:49Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +573,40 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            LOG.debug(\"Shutting down thread pool for the storage adapter.\");\n+            threadPool.awaitTermination(THREAD_POOL_TERMINATE_TIMEOUT, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwODcxMg==", "bodyText": "I really like the use of finite state machines in the iOS codebase.. we should nick some of that.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429008712", "createdAt": "2020-05-22T02:17:50Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -94,32 +97,88 @@ public Orchestrator(\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n     }\n \n+    /**\n+     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n+     * @return True if the orchestrator is started, false otherwise.\n+     */\n+    public boolean isStarted() {\n+        return OrchestratorStatus.STARTED.equals(status.get());\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n     public Completable start() {\n-        return mutationOutbox.load()\n-            .andThen(Completable.fromAction(() -> {\n-                storageObserver.startObservingStorageChanges();\n-                subscriptionProcessor.startSubscriptions();\n-                syncProcessor.hydrate().blockingAwait();\n-                mutationProcessor.startDrainingMutationOutbox();\n-                subscriptionProcessor.startDrainingMutationBuffer();\n-                LOG.info(\"Cloud synchronization is now fully active.\");\n-            }));\n+        // Only start if it's stopped.\n+        if (OrchestratorStatus.STOPPED.equals(status.get())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwODgzNg==", "bodyText": "Agree! These are good docs!", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429008836", "createdAt": "2020-05-22T02:18:29Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/LocalStorageAdapter.java", "diffHunk": "@@ -186,4 +186,14 @@ Cancelable observe(\n      * @throws DataStoreException if something goes wrong during terminate\n      */\n     void terminate() throws DataStoreException;\n+\n+    /**\n+     * Each implementation of this adapter interface will have its own", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDUyNQ=="}, "originalCommit": {"oid": "782eb601676c1e94b85718c4a66028784e90a802"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwODk1Mg==", "bodyText": "Was it interrupted or just didn't stop within some timeframe?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429008952", "createdAt": "2020-05-22T02:19:04Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +573,40 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            LOG.debug(\"Shutting down thread pool for the storage adapter.\");\n+            threadPool.awaitTermination(THREAD_POOL_TERMINATE_TIMEOUT, TimeUnit.MILLISECONDS);\n+            LOG.debug(\"Storage adapter thread pool shutdown.\");\n+        } catch (InterruptedException exception) {\n+            LOG.warn(\"Storage adapter thread pool was interrupted during shutdown.\", exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTEzNw==", "bodyText": "maybe move the string to a new line instead of concatenating?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429009137", "createdAt": "2020-05-22T02:19:55Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +573,40 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            LOG.debug(\"Shutting down thread pool for the storage adapter.\");\n+            threadPool.awaitTermination(THREAD_POOL_TERMINATE_TIMEOUT, TimeUnit.MILLISECONDS);\n+            LOG.debug(\"Storage adapter thread pool shutdown.\");\n+        } catch (InterruptedException exception) {\n+            LOG.warn(\"Storage adapter thread pool was interrupted during shutdown.\", exception);\n+        }\n+        sqliteStorageHelper.close();\n+        databaseConnectionHandle.close();\n+        LOG.debug(\"Clearing DataStore.\");\n+        if (!context.deleteDatabase(DATABASE_NAME)) {\n+            DataStoreException dataStoreException = new DataStoreException(\n+                \"Error while trying to clear data from the local DataStore storage.\",\n+                \"See attached exception for details.\");\n+            onError.accept(dataStoreException);\n+        }\n+        LOG.debug(\"DataStore cleared. Re-initializing storage adapter.\");\n+\n+        //Re-initialize the adapter.\n+        initialize(context, schemaList -> {\n+            onComplete.call();\n+        }, exception -> {\n+                onError.accept(new DataStoreException(\"Error occurred whilte trying to re-initialize \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTQwOQ==", "bodyText": "Can you use the convenience method you created with this body above?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429009409", "createdAt": "2020-05-22T02:20:59Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -94,32 +97,88 @@ public Orchestrator(\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n     }\n \n+    /**\n+     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n+     * @return True if the orchestrator is started, false otherwise.\n+     */\n+    public boolean isStarted() {\n+        return OrchestratorStatus.STARTED.equals(status.get());\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n     public Completable start() {\n-        return mutationOutbox.load()\n-            .andThen(Completable.fromAction(() -> {\n-                storageObserver.startObservingStorageChanges();\n-                subscriptionProcessor.startSubscriptions();\n-                syncProcessor.hydrate().blockingAwait();\n-                mutationProcessor.startDrainingMutationOutbox();\n-                subscriptionProcessor.startDrainingMutationBuffer();\n-                LOG.info(\"Cloud synchronization is now fully active.\");\n-            }));\n+        // Only start if it's stopped.\n+        if (OrchestratorStatus.STOPPED.equals(status.get())) {\n+            LOG.debug(\"Starting the orchestrator.\");\n+            status.compareAndSet(OrchestratorStatus.STOPPED, OrchestratorStatus.STARTING);\n+            initializationCompletable = mutationOutbox.load()\n+                .andThen(\n+                    Completable.fromAction(() -> {\n+                        if (!storageObserver.isObservingStorageChanges()) {\n+                            LOG.debug(\"Starting local storage observer.\");\n+                            storageObserver.startObservingStorageChanges();\n+                        }\n+                        if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n+                            LOG.debug(\"Starting subscription processor.\");\n+                            subscriptionProcessor.startSubscriptions();\n+                        }\n+                        syncProcessor.hydrate().blockingAwait();\n+                        if (!mutationProcessor.isDrainingMutationOutbox()) {\n+                            LOG.debug(\"Starting mutation processor.\");\n+                            mutationProcessor.startDrainingMutationOutbox();\n+                        }\n+                        if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n+                            LOG.debug(\"Starting draining mutation buffer.\");\n+                            subscriptionProcessor.startDrainingMutationBuffer();\n+                        }\n+                        status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n+                    })\n+                );\n+        }\n+        return initializationCompletable;\n     }\n \n     /**\n      * Stop all model synchronization.\n      */\n     public void stop() {\n-        LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-        storageObserver.stopObservingStorageChanges();\n-        subscriptionProcessor.stopAllSubscriptionActivity();\n-        mutationProcessor.stopDrainingMutationOutbox();\n+        if (OrchestratorStatus.STARTED.equals(status.get())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTcxNA==", "bodyText": "Nit: extra line?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429009714", "createdAt": "2020-05-22T02:22:28Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AsyncUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.async.Cancelable;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+\n+/**\n+ * Utility class for functions used throughout DataStore.\n+ */\n+public final class AsyncUtils {\n+    private AsyncUtils() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTkwMw==", "bodyText": "Nit: maybe newline instead of concat?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429009903", "createdAt": "2020-05-22T02:23:18Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -185,12 +189,16 @@ public void configure(\n \n     @WorkerThread\n     @Override\n-    public void initialize(@NonNull Context context) {\n-        Completable completable = initializeStorageAdapter(context);\n-        if (!api.getPlugins().isEmpty()) {\n-            completable = completable.andThen(orchestrator.start());\n+    public void initialize(@NonNull Context context) throws AmplifyException {\n+        Throwable initError = initializeStorageAdapter(context)\n+            .andThen(initializeOrchestrator())\n+            .blockingGet(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        if (initError != null) {\n+            throw new AmplifyException(\"Failed to initialize the local storage \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTE0NA==", "bodyText": "Why is this more likely to happen after clear?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429011144", "createdAt": "2020-05-22T02:28:49Z", "author": {"login": "jpignata"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -185,12 +189,16 @@ public void configure(\n \n     @WorkerThread\n     @Override\n-    public void initialize(@NonNull Context context) {\n-        Completable completable = initializeStorageAdapter(context);\n-        if (!api.getPlugins().isEmpty()) {\n-            completable = completable.andThen(orchestrator.start());\n+    public void initialize(@NonNull Context context) throws AmplifyException {\n+        Throwable initError = initializeStorageAdapter(context)\n+            .andThen(initializeOrchestrator())\n+            .blockingGet(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        if (initError != null) {\n+            throw new AmplifyException(\"Failed to initialize the local storage \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTkwMw=="}, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/9bb26289c1ed56938daf43f5bfc8d230a9097548", "committedDate": "2020-05-22T02:46:17Z", "message": "Update thread pool shutdown"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjM1ODcz", "url": "https://github.com/aws-amplify/amplify-android/pull/416#pullrequestreview-416635873", "createdAt": "2020-05-22T04:10:01Z", "commit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNDoxMDowMVrOGZKFFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNDozNDo0NFrOGZKY-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzMjcyNA==", "bodyText": "I believe the best practice is not to provide Javadocs for @Override methods, since it will be mostly duplicative of the content of the interface/base class being overriden.\nThe JavadocMethod checkstyle has this a default setting:\n\nJavadoc is not required on a method that is tagged with the @OverRide annotation.\n\nIn a few place in this code base, we have the @inheritDoc Javadoc directive on @Overriden methods.\nA guy on StackOverflow goes on:\n\nI studied this problem during my PhD and found that in general folks will never be aware of the extra information in the overriding version if they are invoking through a supertype.\n\nHoly Cow. Talk about \"Diving Deep!\"", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429032724", "createdAt": "2020-05-22T04:10:01Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterClearTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.content.Context;\n+import android.os.FileObserver;\n+import android.os.Handler;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.StorageItemChange;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+import io.reactivex.observers.TestObserver;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public final class SQLiteStorageAdapterClearTest {\n+    private static final String DATABASE_NAME = \"AmplifyDatastore.db\";\n+\n+    private SynchronousStorageAdapter adapter;\n+    private Context context;\n+    private TestObserver<StorageItemChange<? extends Model>> observer;\n+    private AtomicReference<Disposable> subscriberDisposableRef = new AtomicReference<>();\n+    private TestFileObserver fileObserver;\n+\n+    /**\n+     * Enable strict mode.\n+     */\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    /**\n+     * Setup actions for every test in this class.\n+     */\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        context = ApplicationProvider.getApplicationContext();\n+        adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+        //Set subscriberDisposableRef = <value received from RxJava>.\n+        //Needed so we can make assertions on the state of the subscriber later.\n+        observer = adapter\n+            .observe()\n+            .doOnSubscribe(subscriberDisposableRef::set)\n+            .test();\n+\n+        fileObserver = new TestFileObserver(Objects.requireNonNull(context.getDatabasePath(DATABASE_NAME).getParent()));\n+        fileObserver.startWatching();\n+    }\n+\n+    /**\n+     * Tearing down components created for each test.\n+     */\n+    @After\n+    public void teardown() {\n+        fileObserver.stopWatching();\n+        TestStorageAdapter.cleanup(adapter);\n+    }\n+\n+    /**\n+     * Save a record to the database and verify it was saved.\n+     * Then call clear and verify that the database file is re-created\n+     * and is writable.\n+     * @throws DataStoreException bubbles up exceptions thrown from the adapter\n+     * @throws IOException if it can't ready file creation time\n+     * @throws InterruptedException if something happens when sleeping for 1 second\n+     */\n+    @Test\n+    public void clearDeletesAndRecreatesDatabase() throws DataStoreException, IOException, InterruptedException {\n+        assertDbFileExists();\n+        assertEquals(0, fileObserver.createFileEventCount);\n+        assertEquals(0, fileObserver.deleteFileEventCount);\n+        BlogOwner blogger1 = createBlogger(\"Dummy Blogger Sr.\");\n+        BlogOwner blogger2 = createBlogger(\"Dummy Blogger Jr.\");\n+        //Save a record and check if it's there\n+        adapter.save(blogger1);\n+        assertRecordIsInDb(blogger1);\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+        assertObserverReceivedRecord(blogger1);\n+\n+        adapter.clear();\n+        //Make sure file was deleted and re-created\n+        assertEquals(1, fileObserver.createFileEventCount);\n+        assertEquals(1, fileObserver.deleteFileEventCount);\n+        assertDbFileExists();\n+        //Verify observer is still alive\n+        assertFalse(subscriberDisposableRef.get().isDisposed());\n+\n+        //Make sure the new file is writable\n+        adapter.save(blogger2);\n+        //Check the new record is in the database\n+        //and the old record is not.\n+        assertRecordIsInDb(blogger2);\n+        assertRecordIsNotInDb(blogger1);\n+        assertObserverReceivedRecord(blogger2);\n+        //Terminate the adapter\n+        adapter.terminate();\n+        //Verify observer was disposed.\n+        assertTrue(subscriberDisposableRef.get().isDisposed());\n+    }\n+\n+    private BlogOwner createBlogger(String name) throws DataStoreException {\n+        return BlogOwner.builder()\n+            .name(name)\n+            .build();\n+    }\n+\n+    private void assertObserverReceivedRecord(BlogOwner blogger) {\n+        for (StorageItemChange<? extends Model> owner : observer.values()) {\n+            if (BlogOwner.class.isAssignableFrom(owner.itemClass()) &&\n+                blogger.getName().equals(((BlogOwner) owner.item()).getName())) {\n+                return;\n+            }\n+        }\n+        fail(\"Could not find \" + blogger + \" in event observer.\");\n+    }\n+\n+    private <T extends Model> void assertRecordIsInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertEquals(1, results.size());\n+        assertEquals(item, results.get(0));\n+    }\n+\n+    private <T extends Model> void assertRecordIsNotInDb(T item) throws DataStoreException {\n+        List<? extends Model> results = adapter.query(item.getClass(), Where.id(item.getId()));\n+        assertNotNull(results);\n+        assertEquals(0, results.size());\n+    }\n+\n+    private void assertDbFileExists() {\n+        assertTrue(context.getDatabasePath(DATABASE_NAME).exists());\n+    }\n+\n+    private static final class TestFileObserver extends FileObserver {\n+        private int createFileEventCount;\n+        private int deleteFileEventCount;\n+        /**\n+         * Equivalent to FileObserver(file, FileObserver.ALL_EVENTS).\n+         *\n+         * @param path Directory to watch\n+         */\n+\n+        @SuppressWarnings(\"deprecation\")\n+        TestFileObserver(@NonNull String path) {\n+            super(path, FileObserver.CREATE | FileObserver.DELETE | FileObserver.DELETE_SELF);\n+\n+            this.deleteFileEventCount = 0;\n+            this.createFileEventCount = 0;\n+        }\n+\n+        /**\n+         * The event handler, which must be implemented by subclasses.\n+         *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDc2Mg=="}, "originalCommit": {"oid": "9f204d0a623fbc9c526bfe042e47a55105595316"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNDU2NQ==", "bodyText": "@jpignata I don't think its more likely. I have this code in one of my PRs, too, though. Probably, we could carve this out into its own targeted PR. (Not saying we should, at this point, just that it would be possible.)\n@rjuliano and I have been talking offline about reducing/removing all of our dangerous blockPermanently() type calls, which can hose threads. We only have a few such calls in source code, but there are quite a few in the tests, right now. We should start whittling away at them by providing some sane timeouts, so that nothing is wedged with permanence.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429034565", "createdAt": "2020-05-22T04:18:40Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -185,12 +189,16 @@ public void configure(\n \n     @WorkerThread\n     @Override\n-    public void initialize(@NonNull Context context) {\n-        Completable completable = initializeStorageAdapter(context);\n-        if (!api.getPlugins().isEmpty()) {\n-            completable = completable.andThen(orchestrator.start());\n+    public void initialize(@NonNull Context context) throws AmplifyException {\n+        Throwable initError = initializeStorageAdapter(context)\n+            .andThen(initializeOrchestrator())\n+            .blockingGet(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        if (initError != null) {\n+            throw new AmplifyException(\"Failed to initialize the local storage \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwOTkwMw=="}, "originalCommit": {"oid": "59fd65a1499fe027231fc0da1213c04cd91fa320"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNTIzNw==", "bodyText": "Naming --\nI've been working hard for us to avoid having any FooUtils classes (by name).\nAsyncUtils could end up being abused in the future, and have all kinds of executors, schedulers, etc., in it., over time.\nWould it make sense to call this class Disposables?  Rx does have a class by this same name.\nDisposable disposable = Disposables.fromCancelable(cancelable);\n\nAlternately, we could call it:\nDisposable disposable = Cancelables.asDisposable(cancelable);", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429035237", "createdAt": "2020-05-22T04:22:05Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AsyncUtils.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.async.Cancelable;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.reactivex.disposables.Disposable;\n+\n+/**\n+ * Utility class for functions used throughout DataStore.\n+ */\n+public final class AsyncUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNTU0Nw==", "bodyText": "This solved a bug, right? This must have been very tricky to find. Nice work.", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429035547", "createdAt": "2020-05-22T04:23:33Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -568,6 +573,43 @@ public synchronized void terminate() throws DataStoreException {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear(@NonNull Action onComplete,\n+                                   @NonNull Consumer<DataStoreException> onError) {\n+        try {\n+            LOG.debug(\"Shutting down thread pool for the storage adapter.\");\n+            threadPool.shutdown();\n+            if (!threadPool.awaitTermination(THREAD_POOL_TERMINATE_TIMEOUT, TimeUnit.MILLISECONDS)) {\n+                threadPool.shutdownNow();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNjQ2Ng==", "bodyText": "To help with the indentation / nesting, can we invert this?\nif (!OrchestratorStatus.STOPPED.equals(status.get())) {\n    return initializationCompletable;\n}\n// Save 4 cols, here ...\n\nYou can save another eight more cols with the andThen( on L120, too, by:\ninitializationCompletable = mutationOutbox.load().andThen(Completable.fromAction(() -> {\n    // 8 left of where it was \n}", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429036466", "createdAt": "2020-05-22T04:27:43Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -94,32 +97,88 @@ public Orchestrator(\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n     }\n \n+    /**\n+     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n+     * @return True if the orchestrator is started, false otherwise.\n+     */\n+    public boolean isStarted() {\n+        return OrchestratorStatus.STARTED.equals(status.get());\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n     public Completable start() {\n-        return mutationOutbox.load()\n-            .andThen(Completable.fromAction(() -> {\n-                storageObserver.startObservingStorageChanges();\n-                subscriptionProcessor.startSubscriptions();\n-                syncProcessor.hydrate().blockingAwait();\n-                mutationProcessor.startDrainingMutationOutbox();\n-                subscriptionProcessor.startDrainingMutationBuffer();\n-                LOG.info(\"Cloud synchronization is now fully active.\");\n-            }));\n+        // Only start if it's stopped.\n+        if (OrchestratorStatus.STOPPED.equals(status.get())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNjgxNw==", "bodyText": "True 'nuff, but when it is stopping, what does that mean for the system -- request to start() will be denied? What are the valid input and output states, from this step?\nSame Q for all", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429036817", "createdAt": "2020-05-22T04:29:33Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -94,32 +97,88 @@ public Orchestrator(\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n     }\n \n+    /**\n+     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n+     * @return True if the orchestrator is started, false otherwise.\n+     */\n+    public boolean isStarted() {\n+        return OrchestratorStatus.STARTED.equals(status.get());\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      * @return A Completable operation to start the sync engine orchestrator\n      */\n     @NonNull\n     public Completable start() {\n-        return mutationOutbox.load()\n-            .andThen(Completable.fromAction(() -> {\n-                storageObserver.startObservingStorageChanges();\n-                subscriptionProcessor.startSubscriptions();\n-                syncProcessor.hydrate().blockingAwait();\n-                mutationProcessor.startDrainingMutationOutbox();\n-                subscriptionProcessor.startDrainingMutationBuffer();\n-                LOG.info(\"Cloud synchronization is now fully active.\");\n-            }));\n+        // Only start if it's stopped.\n+        if (OrchestratorStatus.STOPPED.equals(status.get())) {\n+            LOG.debug(\"Starting the orchestrator.\");\n+            status.compareAndSet(OrchestratorStatus.STOPPED, OrchestratorStatus.STARTING);\n+            initializationCompletable = mutationOutbox.load()\n+                .andThen(\n+                    Completable.fromAction(() -> {\n+                        if (!storageObserver.isObservingStorageChanges()) {\n+                            LOG.debug(\"Starting local storage observer.\");\n+                            storageObserver.startObservingStorageChanges();\n+                        }\n+                        if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n+                            LOG.debug(\"Starting subscription processor.\");\n+                            subscriptionProcessor.startSubscriptions();\n+                        }\n+                        syncProcessor.hydrate().blockingAwait();\n+                        if (!mutationProcessor.isDrainingMutationOutbox()) {\n+                            LOG.debug(\"Starting mutation processor.\");\n+                            mutationProcessor.startDrainingMutationOutbox();\n+                        }\n+                        if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n+                            LOG.debug(\"Starting draining mutation buffer.\");\n+                            subscriptionProcessor.startDrainingMutationBuffer();\n+                        }\n+                        status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n+                    })\n+                );\n+        }\n+        return initializationCompletable;\n     }\n \n     /**\n      * Stop all model synchronization.\n      */\n     public void stop() {\n-        LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-        storageObserver.stopObservingStorageChanges();\n-        subscriptionProcessor.stopAllSubscriptionActivity();\n-        mutationProcessor.stopDrainingMutationOutbox();\n+        if (OrchestratorStatus.STARTED.equals(status.get())) {\n+            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n+            status.compareAndSet(OrchestratorStatus.STARTED, OrchestratorStatus.STOPPING);\n+            subscriptionProcessor.stopAllSubscriptionActivity();\n+            storageObserver.stopObservingStorageChanges();\n+            mutationProcessor.stopDrainingMutationOutbox();\n+            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n+            LOG.debug(\"Stopped remote synchronization.\");\n+        }\n+\n+    }\n+\n+    /**\n+     * Represents possible status of the orchestrator.\n+     */\n+    enum OrchestratorStatus {\n+        /**\n+         * The orchestrator is stopping.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNzAyOA==", "bodyText": "I think this probably solves a bug I've been seeing lately. Thanks!", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429037028", "createdAt": "2020-05-22T04:30:31Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessor.java", "diffHunk": "@@ -114,15 +113,19 @@ void startSubscriptions() {\n         return Observable.<GraphQLResponse<ModelWithMetadata<T>>>create(emitter -> {\n             CountDownLatch latch = new CountDownLatch(1);\n             SubscriptionMethod method = subscriptionMethodFor(appSync, subscriptionType);\n-            AtomicReference<Cancelable> cancelable = new AtomicReference<>(NoOpCancelable::new);\n-            emitter.setCancellable(cancelable::get);\n-            cancelable.set(method.subscribe(\n+            Cancelable subscriptionCancelable = method.subscribe(\n                 clazz,\n                 token -> latch.countDown(),\n                 emitter::onNext,\n                 emitter::onError,\n                 emitter::onComplete\n-            ));\n+            );\n+            // When the observable is disposed, we need to call cancel() on the subscription\n+            // so it can properly dispose of resources if necessary. For the AWS API plugin,\n+            // this means means closing the underlying network connection.\n+            emitter.setDisposable(\n+                AsyncUtils.asDisposable(subscriptionCancelable)\n+            );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNzQxNw==", "bodyText": "Can you use the one on the org.mockito.Mockito facade, instead? org.mockito.Mockito.argThat?", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429037417", "createdAt": "2020-05-22T04:32:26Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -21,49 +21,60 @@\n import com.amplifyframework.api.ApiCategory;\n import com.amplifyframework.api.ApiException;\n import com.amplifyframework.api.ApiPlugin;\n+import com.amplifyframework.api.graphql.GraphQLOperation;\n import com.amplifyframework.api.graphql.GraphQLRequest;\n import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.SubscriptionType;\n import com.amplifyframework.core.Action;\n import com.amplifyframework.core.Amplify;\n import com.amplifyframework.core.Consumer;\n import com.amplifyframework.core.InitializationStatus;\n+import com.amplifyframework.core.category.CategoryType;\n import com.amplifyframework.core.model.ModelProvider;\n import com.amplifyframework.datastore.model.SimpleModelProvider;\n import com.amplifyframework.hub.HubChannel;\n import com.amplifyframework.hub.HubEvent;\n+import com.amplifyframework.testmodels.personcar.AmplifyCliGeneratedModelProvider;\n import com.amplifyframework.testmodels.personcar.Person;\n import com.amplifyframework.testutils.random.RandomString;\n+import com.amplifyframework.testutils.sync.SynchronousDataStore;\n+import com.amplifyframework.util.Time;\n \n import org.json.JSONException;\n import org.json.JSONObject;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n \n import java.util.Collections;\n-import java.util.concurrent.TimeUnit;\n-\n-import io.reactivex.Completable;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static androidx.test.core.app.ApplicationProvider.getApplicationContext;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.argThat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNzUzMA==", "bodyText": "= 1_000 /* ms */, or  = TimeUnit.SECONDS.toMillis(1);", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429037530", "createdAt": "2020-05-22T04:33:02Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -21,49 +21,60 @@\n import com.amplifyframework.api.ApiCategory;\n import com.amplifyframework.api.ApiException;\n import com.amplifyframework.api.ApiPlugin;\n+import com.amplifyframework.api.graphql.GraphQLOperation;\n import com.amplifyframework.api.graphql.GraphQLRequest;\n import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.SubscriptionType;\n import com.amplifyframework.core.Action;\n import com.amplifyframework.core.Amplify;\n import com.amplifyframework.core.Consumer;\n import com.amplifyframework.core.InitializationStatus;\n+import com.amplifyframework.core.category.CategoryType;\n import com.amplifyframework.core.model.ModelProvider;\n import com.amplifyframework.datastore.model.SimpleModelProvider;\n import com.amplifyframework.hub.HubChannel;\n import com.amplifyframework.hub.HubEvent;\n+import com.amplifyframework.testmodels.personcar.AmplifyCliGeneratedModelProvider;\n import com.amplifyframework.testmodels.personcar.Person;\n import com.amplifyframework.testutils.random.RandomString;\n+import com.amplifyframework.testutils.sync.SynchronousDataStore;\n+import com.amplifyframework.util.Time;\n \n import org.json.JSONException;\n import org.json.JSONObject;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatcher;\n import org.robolectric.RobolectricTestRunner;\n \n import java.util.Collections;\n-import java.util.concurrent.TimeUnit;\n-\n-import io.reactivex.Completable;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static androidx.test.core.app.ApplicationProvider.getApplicationContext;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.argThat;\n import static org.mockito.Mockito.any;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.mockingDetails;\n import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n @RunWith(RobolectricTestRunner.class)\n public final class AWSDataStorePluginTest {\n-    private static final long OPERATION_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(1);\n+    private static final String MOCK_API_PLUGIN_NAME = \"MockApiPlugin\";\n+    private static final int ASSERTION_TIMEOUT_MS = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAzNzgxNg==", "bodyText": "Oooh! I've never see this before. Nice find: timeout(value).atLeastOnce()", "url": "https://github.com/aws-amplify/amplify-android/pull/416#discussion_r429037816", "createdAt": "2020-05-22T04:34:44Z", "author": {"login": "jamesonwilliams"}, "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -127,60 +137,144 @@ public void configureAndInitializeInApiModeWithoutApi() throws JSONException, Am\n         JSONObject dataStorePluginJson = new JSONObject()\n             .put(\"syncIntervalInMinutes\", 60);\n         AWSDataStorePlugin awsDataStorePlugin = new AWSDataStorePlugin(modelProvider, mockApiCategory);\n+        SynchronousDataStore synchronousDataStore = SynchronousDataStore.delegatingTo(awsDataStorePlugin);\n         awsDataStorePlugin.configure(dataStorePluginJson, context);\n         awsDataStorePlugin.initialize(context);\n \n         // Trick the DataStore since it's not getting initialized as part of the Amplify.initialize call chain\n         Amplify.Hub.publish(HubChannel.DATASTORE, HubEvent.create(InitializationStatus.SUCCEEDED));\n \n         Person person1 = createPerson(\"Test\", \"Dummy I\");\n-        Throwable exception = Completable.fromSingle(single -> { // Save a record to local store\n-            awsDataStorePlugin.save(person1, itemSaved -> {\n-                assertNotNull(itemSaved.item().getId());\n-                assertEquals(person1.getLastName(), itemSaved.item().getLastName());\n-                single.onSuccess(true);\n-            }, single::onError);\n-        }).andThen(\n-            Completable.fromSingle(single -> { // Verify the record has been saved\n-                awsDataStorePlugin.query(Person.class, results -> {\n-                    Person actualPerson = results.next();\n-                    assertNotNull(actualPerson);\n-                    assertFalse(results.hasNext()); // We should only have one result.\n-                    assertEquals(person1, actualPerson);\n-                    single.onSuccess(true);\n-                }, single::onError);\n-            })\n-        ).doOnError(error -> {\n-            fail(error.getMessage());\n-        }).blockingGet(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        if (exception != null) {\n-            throw new AmplifyException(\"Unexpected exception.\", exception, \"Look at the stacktrace.\");\n-        }\n+        synchronousDataStore.save(person1);\n+        assertNotNull(person1.getId());\n+        Person person1FromDb = synchronousDataStore.get(Person.class, person1.getId());\n+        assertEquals(person1, person1FromDb);\n     }\n \n-    private void assertSyncProcessorStarted() {\n-        boolean syncProcessorInvoked = mockingDetails(modelProvider)\n-            .getInvocations()\n-            .stream()\n-            .anyMatch(invocation -> invocation.getLocation().getSourceFile().contains(\"SyncProcessor\"));\n+    /**\n+     * Verify that when the clear method is called, the following happens\n+     * - All remote synchronization processes are stopped\n+     * - The database is deleted.\n+     * - On the next interaction with the DataStore, the synchronization processes are restarted.\n+     * @throws JSONException on failure to arrange plugin config\n+     * @throws AmplifyException on failure to arrange API plugin via Amplify facade\n+     */\n+    @Test\n+    public void clearStopsSyncUntilNextInteraction() throws AmplifyException, JSONException {\n+        ApiCategory mockApiCategory = mockApiCategoryWithGraphQlApi();\n+        ApiPlugin<?> mockApiPlugin = mockApiCategory.getPlugin(MOCK_API_PLUGIN_NAME);\n+        JSONObject dataStorePluginJson = new JSONObject()\n+            .put(\"syncIntervalInMinutes\", 60);\n+        AWSDataStorePlugin awsDataStorePlugin = new AWSDataStorePlugin(modelProvider, mockApiCategory);\n+        SynchronousDataStore synchronousDataStore = SynchronousDataStore.delegatingTo(awsDataStorePlugin);\n+        awsDataStorePlugin.configure(dataStorePluginJson, context);\n+        awsDataStorePlugin.initialize(context);\n+\n+        // Trick the DataStore since it's not getting initialized as part of the Amplify.initialize call chain\n+        Amplify.Hub.publish(HubChannel.DATASTORE, HubEvent.create(InitializationStatus.SUCCEEDED));\n+\n+        assertRemoteSubscriptionsStarted();\n+\n+        // Setup objects\n+        Person person1 = createPerson(\"Test\", \"Dummy I\");\n+        Person person2 = createPerson(\"Test\", \"Dummy II\");\n+        ArgumentMatcher<GraphQLRequest<String>> person1Matcher = getMatcherFor(person1);\n+        ArgumentMatcher<GraphQLRequest<String>> person2Matcher = getMatcherFor(person2);\n+\n+        // Mock responses for person 1\n+        doAnswer(invocation -> {\n+            int indexOfResponseConsumer = 1;\n+            Consumer<GraphQLResponse<String>> onResponse = invocation.getArgument(indexOfResponseConsumer);\n+            String data = new JSONObject()\n+                .put(\"id\", person1.getId())\n+                .put(\"first_name\", person1.getFirstName())\n+                .put(\"last_name\", person1.getLastName())\n+                .put(\"_deleted\", false)\n+                .put(\"_version\", 1)\n+                .put(\"_lastSyncedAt\", Time.now())\n+                .toString();\n+            onResponse.accept(new GraphQLResponse<>(data, Collections.emptyList()));\n+            return mock(GraphQLOperation.class);\n+        }).when(mockApiPlugin).mutate(any(), any(), any());\n+\n+        // Save person 1\n+        synchronousDataStore.save(person1);\n+        Person result1 = synchronousDataStore.get(Person.class, person1.getId());\n+        assertEquals(person1, result1);\n+\n+        verify(mockApiCategory, timeout(ASSERTION_TIMEOUT_MS).atLeastOnce())\n+            .mutate(argThat(person1Matcher), any(), any());\n \n-        assertTrue(syncProcessorInvoked);\n+        // Mock responses for person 2\n+        doAnswer(invocation -> {\n+            int indexOfResponseConsumer = 1;\n+            Consumer<GraphQLResponse<String>> onResponse = invocation.getArgument(indexOfResponseConsumer);\n+            String data = new JSONObject()\n+                .put(\"id\", person2.getId())\n+                .put(\"first_name\", person2.getFirstName())\n+                .put(\"last_name\", person2.getLastName())\n+                .put(\"_deleted\", false)\n+                .put(\"_version\", 1)\n+                .put(\"_lastSyncedAt\", Time.now())\n+                .toString();\n+            onResponse.accept(new GraphQLResponse<>(data, Collections.emptyList()));\n+            return mock(GraphQLOperation.class);\n+        }).when(mockApiPlugin).mutate(any(), any(), any());\n+\n+        synchronousDataStore.clear();\n+        assertRemoteSubscriptionsCancelled();\n+\n+        // Save person 2\n+        synchronousDataStore.save(person2);\n+        Person result2 = synchronousDataStore.get(Person.class, person2.getId());\n+        assertEquals(person2, result2);\n+\n+        verify(mockApiCategory, timeout(ASSERTION_TIMEOUT_MS).atLeastOnce())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb26289c1ed56938daf43f5bfc8d230a9097548"}, "originalPosition": 229}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32d20954535ca7de79806b150e3c3f4f9a04436d", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/32d20954535ca7de79806b150e3c3f4f9a04436d", "committedDate": "2020-05-22T14:52:10Z", "message": "PR feedback and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2633c53045dcd0675d5fbe1b6f73b626c5aea1ae", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/2633c53045dcd0675d5fbe1b6f73b626c5aea1ae", "committedDate": "2020-05-22T16:53:24Z", "message": "Merge remote-tracking branch 'origin/master' into rjuliano/dsclear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c954d6a9fb0ec71a7aed22f720aa443b8b48f535", "author": {"user": {"login": "rjuliano", "name": "Rafael Juliano"}}, "url": "https://github.com/aws-amplify/amplify-android/commit/c954d6a9fb0ec71a7aed22f720aa443b8b48f535", "committedDate": "2020-05-22T17:09:06Z", "message": "Checkstyle things"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2762, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}