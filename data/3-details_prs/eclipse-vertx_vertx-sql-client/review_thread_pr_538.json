{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NzQ3OTUx", "number": 538, "reviewThreads": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyOVrODp1FEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0NzozM1rOD7tr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg3ODU5OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/BatchTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyOVrOF5Pt1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyOVrOF5Pt1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDY0Nw==", "bodyText": "How about naming it batchUpdate since it returns an asynchronous result of Void type?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r395570647", "createdAt": "2020-03-20T11:14:29Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/BatchTemplate.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.impl.BatchTemplateImpl;\n+import io.vertx.sqlclient.template.impl.QueryTemplateImpl;\n+import io.vertx.sqlclient.template.impl.TupleMapper;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@VertxGen\n+public interface BatchTemplate<T> {\n+\n+  @GenIgnore\n+  static BatchTemplate<Map<String, Object>> create(SqlClient client, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), tupleMapper::mapTuple);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Function<T, Tuple> mapper, String template) {\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Class<T> clazz, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    Function<T, Tuple> mapper = t -> tupleMapper.mapTuple(JsonObject.mapFrom(t).getMap());\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  @GenIgnore\n+  default Future<Void> batch(List<T> list) {\n+    Promise<Void> promise = Promise.promise();\n+    batch(list, promise);\n+    return promise.future();\n+  }\n+\n+  @GenIgnore\n+  void batch(List<T> list, Handler<AsyncResult<Void>> result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e66f7a582bdca254546bd8da1c371174a3ffb507"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk1MzM1OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0NzowOVrOGRD53w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0ODoxM1rOGRD6sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mjk0Mw==", "bodyText": "Use implementation rather than compile.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420542943", "createdAt": "2020-05-06T04:47:09Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzE1Mw==", "bodyText": "But that's a more general remark. compile is still here, but it's recommended to go with implementation for dependencies you consume, and api for dependencies you want to consume the re-export.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543153", "createdAt": "2020-05-06T04:48:13Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mjk0Mw=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk1NjgzOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0OToxMFrOGRD7xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0OToxMFrOGRD7xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzQzMQ==", "bodyText": "you can use {@link XYZ} instead.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543431", "createdAt": "2020-05-06T04:49:10Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk1ODQwOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1MDowNlrOGRD8ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1MDowNlrOGRD8ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzY1MQ==", "bodyText": "By default templates produce {...} as result type.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543651", "createdAt": "2020-05-06T04:50:06Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk1OTk0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1MTowNFrOGRD9fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1MTowNFrOGRD9fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mzg2OQ==", "bodyText": "I'd put to achieve row level mapping instead: here with the full function and template call below", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543869", "createdAt": "2020-05-06T04:51:04Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk2NDE4OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Mzo1MFrOGRD_tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Mzo1MFrOGRD_tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDQzOQ==", "bodyText": "annotationProcessor scope in Gradle", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420544439", "createdAt": "2020-05-06T04:53:50Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+compile \"io.vertx:vertx-codegen:${maven.version}:processor\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk2NTM3OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1NDozMFrOGREAYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1NDozMFrOGREAYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDYxMA==", "bodyText": "usually provide", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420544610", "createdAt": "2020-05-06T04:54:30Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+compile \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"\n+----\n+\n+IDE provides usually support for annotation processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzk2OTIwOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Njo1MlrOGRECig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Njo1MlrOGRECig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NTE2Mg==", "bodyText": "BTW you should have 2020 license headers in files (IntelliJ copyright update can help)", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420545162", "createdAt": "2020-05-06T04:56:52Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDMwODY0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxNjo0OVrOGRaz2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoyOTozNVrOGRwKGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODIzNQ==", "bodyText": "If i am not mistaken this is not used and can be removed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918235", "createdAt": "2020-05-06T16:16:49Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2Nzk5Mw==", "bodyText": "this is referenced from index.adoc", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267993", "createdAt": "2020-05-07T06:29:35Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODIzNQ=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDMxMTk0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxNzo0M1rOGRa2DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoyOToyMFrOGRwJvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODc5Nw==", "bodyText": "If i am not mistaken this is not used and can be removed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918797", "createdAt": "2020-05-06T16:17:43Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }\n+\n+  public void bindingRowWithCustomFunction(SqlClient client) {\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .mapTo(ROW_USER_MAPPER)\n+      .execute(Collections.singletonMap(\"id\", 1))\n+      .onSuccess(users -> {\n+        users.forEach(user -> {\n+          System.out.println(user.firstName + \" \" + user.lastName);\n+        });\n+      });\n+  }\n+\n+  private static final Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", user.id);\n+    params.put(\"firstName\", user.firstName);\n+    params.put(\"lastName\", user.lastName);\n+    return params;\n+  };\n+\n+  public void paramsUserMapper() {\n+    Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+      Map<String, Object> params = new HashMap<>();\n+      params.put(\"id\", user.id);\n+      params.put(\"firstName\", user.firstName);\n+      params.put(\"lastName\", user.lastName);\n+      return params;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzkwMw==", "bodyText": "this is referenced from index.adoc", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267903", "createdAt": "2020-05-07T06:29:20Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }\n+\n+  public void bindingRowWithCustomFunction(SqlClient client) {\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .mapTo(ROW_USER_MAPPER)\n+      .execute(Collections.singletonMap(\"id\", 1))\n+      .onSuccess(users -> {\n+        users.forEach(user -> {\n+          System.out.println(user.firstName + \" \" + user.lastName);\n+        });\n+      });\n+  }\n+\n+  private static final Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", user.id);\n+    params.put(\"firstName\", user.firstName);\n+    params.put(\"lastName\", user.lastName);\n+    return params;\n+  };\n+\n+  public void paramsUserMapper() {\n+    Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+      Map<String, Object> params = new HashMap<>();\n+      params.put(\"id\", user.id);\n+      params.put(\"firstName\", user.firstName);\n+      params.put(\"lastName\", user.lastName);\n+      return params;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODc5Nw=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDQyOTk0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NjoyNlrOGRcBKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NjoyNlrOGRcBKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODAyNA==", "bodyText": "Why not?\ndefault void execute(I parameters, Handler<AsyncResult<R>> handler) {\nexecute(parameters).onComplete(handler);\n}", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938024", "createdAt": "2020-05-06T16:46:26Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDQzMDM0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NjozMlrOGRcBbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoyODoxMVrOGRwIBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODA5Mg==", "bodyText": "Why not?\ndefault void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler) {\nexecuteBatch(batch).onComplete(handler);\n}", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938092", "createdAt": "2020-05-06T16:46:32Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);\n+\n+  /**\n+   * Like {@link #execute(Object, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<R> execute(I params);\n+\n+  /**\n+   * Execute a batch query with the {@code batch}.\n+   *\n+   * <p>Each item in the batch is mapped to a tuple.\n+   *\n+   * @param batch the batch\n+   * @param handler the result handler\n+   */\n+  void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzQ2MA==", "bodyText": "because in practice the underlying query will actually use internally a Promise<R> that is created from the handler, so if you pass a promise to an executeBatch it will not be rewrapped into another promise.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267460", "createdAt": "2020-05-07T06:28:11Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);\n+\n+  /**\n+   * Like {@link #execute(Object, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<R> execute(I params);\n+\n+  /**\n+   * Execute a batch query with the {@code batch}.\n+   *\n+   * <p>Each item in the batch is mapped to a tuple.\n+   *\n+   * @param batch the batch\n+   * @param handler the result handler\n+   */\n+  void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODA5Mg=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDQ0MjI0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/annotations/TemplateParam.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0OTozOFrOGRcJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0OTozOFrOGRcJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0MDA4NA==", "bodyText": "when this property when ?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420940084", "createdAt": "2020-05-06T16:49:38Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/annotations/TemplateParam.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.vertx.sqlclient.template.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotate a Vert.x data object property for custom configuration when this property when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDU3NDczOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzoyMjo0N1rOGRdcsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjoyNTo0NlrOGRwEiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTQ1Ng==", "bodyText": "This will not work for postgresql :: cast\nThis is how spring does it\nhttps://github.com/spring-projects/spring-framework/blob/4ca64684f6d5b7414ca3628a6b372a7c586fd2a6/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterUtils.java#L82\nAnother solution is to use ${name} via this pattern\nPattern.compile(\"\\\\$\\\\{\\\\s*(.*?)\\\\s*}\");\n\nWe could also cache the result", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420961456", "createdAt": "2020-05-06T17:22:47Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SqlTemplate {\n+\n+  private static Pattern PARAM_PATTERN = Pattern.compile(\":(\\\\p{javaUnicodeIdentifierStart}\\\\p{javaUnicodeIdentifierPart}*)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NjU3MQ==", "bodyText": "I like this idea", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421266571", "createdAt": "2020-05-07T06:25:46Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SqlTemplate {\n+\n+  private static Pattern PARAM_PATTERN = Pattern.compile(\":(\\\\p{javaUnicodeIdentifierStart}\\\\p{javaUnicodeIdentifierPart}*)\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTQ1Ng=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDU4MTQ5OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzoyNDoyMFrOGRdg8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozMTozNlrOGRwNKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjU0Ng==", "bodyText": "This can be remove if we use the default method on interface", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962546", "createdAt": "2020-05-06T17:24:20Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2ODc3OA==", "bodyText": "This is important to keep this and delegate to the original query", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421268778", "createdAt": "2020-05-07T06:31:36Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjU0Ng=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDU4MTk3OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzoyNDoyOFrOGRdhQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjozMTozMFrOGRwNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjYyNA==", "bodyText": "This can be remove if we use the default method on interface", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962624", "createdAt": "2020-05-06T17:24:28Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }\n+\n+  @Override\n+  public Future<R> execute(T params) {\n+    return queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(params));\n+  }\n+\n+  @Override\n+  public void executeBatch(List<T> batch, Handler<AsyncResult<R>> handler) {\n+    queryMapper.apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .executeBatch(batch\n+        .stream()\n+        .map(this::toTuple)\n+        .collect(Collectors.toList()), handler);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2ODczNg==", "bodyText": "This is important to keep this and delegate to the original query", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421268736", "createdAt": "2020-05-07T06:31:30Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }\n+\n+  @Override\n+  public Future<R> execute(T params) {\n+    return queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(params));\n+  }\n+\n+  @Override\n+  public void executeBatch(List<T> batch, Handler<AsyncResult<R>> handler) {\n+    queryMapper.apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .executeBatch(batch\n+        .stream()\n+        .map(this::toTuple)\n+        .collect(Collectors.toList()), handler);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjYyNA=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMDY5MDYxOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzo1MToxNVrOGRelQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzo1MToxNVrOGRelQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4MDAzMg==", "bodyText": "placeholder not place holder", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420980032", "createdAt": "2020-05-06T17:51:15Z", "author": {"login": "zenios"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.sqlclient.SqlClient;\n+\n+public interface SqlClientInternal extends SqlClient {\n+\n+  /**\n+   * Append a query place holder in the {@code query}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTg4NTk4OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNzoxOVrOGSQnUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNzoxOVrOGSQnUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5OTc2MQ==", "bodyText": "We should document the return value", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421799761", "createdAt": "2020-05-07T21:17:19Z", "author": {"login": "zenios"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -5,13 +5,13 @@\n public interface SqlClientInternal extends SqlClient {\n \n   /**\n-   * Append a query place holder in the {@code query}.\n+   * Append a query placeholder in the {@code query}.\n    *\n    * <p>The index starts at {@code 0}\n    *\n    * @param queryBuilder the builder to append to\n-   * @param index the place holder index\n+   * @param index the placeholder index\n    */\n-  int appendQueryPlaceHolder(StringBuilder queryBuilder, int index, int current);\n+  int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTkxMTY3OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToyNToxMFrOGSQ20w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNzoxMDoyNlrOGS5DZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMzczMQ==", "bodyText": "SQL Client templates", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421803731", "createdAt": "2020-05-07T21:25:10Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjMwOQ==", "bodyText": "we might actually rename this to simply \"SQL templates\"", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462309", "createdAt": "2020-05-09T07:10:26Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMzczMQ=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTkxMjYzOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToyNTozMFrOGSQ3bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToyNTozMFrOGSQ3bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMzg4NQ==", "bodyText": "library designed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421803885", "createdAt": "2020-05-07T21:25:30Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTkxNDUwOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToyNjoxMFrOGSQ4nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToyNjoxMFrOGSQ4nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwNDE5MQ==", "bodyText": "To use SQL client templates", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421804191", "createdAt": "2020-05-07T21:26:10Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTkyODQ0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozMDo0MFrOGSRBOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozMDo0MFrOGSRBOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwNjM5Mw==", "bodyText": "IDEs usually provide support for annotation processors.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421806393", "createdAt": "2020-05-07T21:30:40Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+annotationProcessor \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"\n+----\n+\n+IDE usually provide usually support for annotation processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTkzOTE1OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNDoyMVrOGSRH9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNDoyMVrOGSRH9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODExOA==", "bodyText": "An SQL template.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808118", "createdAt": "2020-05-07T21:34:21Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTk0MjA3OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNTozNVrOGSRJ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNTozNVrOGSRJ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODYxMQ==", "bodyText": "Create an SQL template", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808611", "createdAt": "2020-05-07T21:35:35Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTk0MjUyOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNTo0M1rOGSRKKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNTo0M1rOGSRKKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODY4MA==", "bodyText": "Create an SQL template", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808680", "createdAt": "2020-05-07T21:35:43Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = io.vertx.sqlclient.template.impl.SqlTemplate.create((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODcwNzM0OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjowNjozN1rOGSq1VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjowNjozN1rOGSq1VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyOTMzMw==", "bodyText": "foobar should be named queryMapper?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422229333", "createdAt": "2020-05-08T16:06:37Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODcyMDI2OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoxMDo0M1rOGSq9gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwNzoxMzoyNlrOGS5EgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzMTQyNg==", "bodyText": "we need to override this method in MSSQLConnectionImpl and MSSQLPoolImpl for sql server client.\nThe syntax is like postgres as:\n    queryBuilder.append('@').append(1 + index);\n    return index;", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422231426", "createdAt": "2020-05-08T16:10:43Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "diffHunk": "@@ -37,7 +37,13 @@\n import java.util.function.Function;\n import java.util.stream.Collector;\n \n-public abstract class SqlClientBase<C extends SqlClient> implements SqlClient, CommandScheduler {\n+public abstract class SqlClientBase<C extends SqlClient> implements SqlClientInternal, CommandScheduler {\n+\n+  @Override\n+  public int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current) {\n+    queryBuilder.append(\"?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjU5Mw==", "bodyText": "oh good to know I will do it", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462593", "createdAt": "2020-05-09T07:13:26Z", "author": {"login": "vietj"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "diffHunk": "@@ -37,7 +37,13 @@\n import java.util.function.Function;\n import java.util.stream.Collector;\n \n-public abstract class SqlClientBase<C extends SqlClient> implements SqlClient, CommandScheduler {\n+public abstract class SqlClientBase<C extends SqlClient> implements SqlClientInternal, CommandScheduler {\n+\n+  @Override\n+  public int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current) {\n+    queryBuilder.append(\"?\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzMTQyNg=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODc2NzI2OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyNToxNFrOGSraVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMToxODoyNVrOGTHq3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ==", "bodyText": "it seems we don't support mapping string/numeric datat type to enum type(name/ordinal). I wonder if we could support this here.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422238805", "createdAt": "2020-05-08T16:25:14Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MzA0Mg==", "bodyText": "I think we can map it to get/set String easily", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422463042", "createdAt": "2020-05-09T07:18:44Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MzE0Nw==", "bodyText": "at least for beginning, some might want to provide at some point a custom function for this type", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422463147", "createdAt": "2020-05-09T07:19:42Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTc4OQ==", "bodyText": "I've checked in such mapping support in master for PostgreSQL and implement support for templates in this PR.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422701789", "createdAt": "2020-05-10T21:18:25Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODc4NjEzOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjozMToxNFrOGSrlyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODoxMzowOVrOGTRbsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA==", "bodyText": "can we add tests for data object type like geometrics data object and numeric data object to check whether it works?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422241738", "createdAt": "2020-05-08T16:31:14Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2Mjc5Mw==", "bodyText": "yes, I'm not sure they work, we'll write the tests and figure out after :-)", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462793", "createdAt": "2020-05-09T07:15:41Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTQyMw==", "bodyText": "I added support and tests for such types", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861423", "createdAt": "2020-05-11T08:12:37Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTc0Ng==", "bodyText": "Actually they are mapped to generic types with row.get(Box.class, pos)", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861746", "createdAt": "2020-05-11T08:13:09Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODc5NzYyOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjozNDozN1rOGSrsnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwODoxMjoxOFrOGTRZ1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA==", "bodyText": "MySQL is using java.time.Duration type, can we add the mapping here using Row#get(java.time.Duration.class, index)?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422243484", "createdAt": "2020-05-08T16:34:37Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2Mjg1Nw==", "bodyText": "I will try adding a specific tests for this using test container and implement it.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462857", "createdAt": "2020-05-09T07:16:14Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTI2OA==", "bodyText": "I added support for this and specific integration tests", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861268", "createdAt": "2020-05-11T08:12:18Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA=="}, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTQwNzEwOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Njo0MlrOGUNKTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNzoxNVrOGUO8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDMzNA==", "bodyText": "should be vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840334", "createdAt": "2020-05-12T15:46:42Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTQ3Mw==", "bodyText": "right", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423869473", "createdAt": "2020-05-12T16:27:15Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDMzNA=="}, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTQwOTIzOnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0NzowOFrOGUNLoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNzoyOFrOGUO8ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDY3Mw==", "bodyText": "should be vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840673", "createdAt": "2020-05-12T15:47:08Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTU5OA==", "bodyText": "right", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423869598", "createdAt": "2020-05-12T16:27:28Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDY3Mw=="}, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTQxMDk4OnYy", "diffSide": "RIGHT", "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0NzozM1rOGUNM0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNzozMlrOGUO8zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDk3OQ==", "bodyText": "vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840979", "createdAt": "2020-05-12T15:47:33Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+annotationProcessor \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTY0NA==", "bodyText": "right", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423869644", "createdAt": "2020-05-12T16:27:32Z", "author": {"login": "vietj"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+annotationProcessor \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDk3OQ=="}, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4447, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}