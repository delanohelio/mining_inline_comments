{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NzQ3OTUx", "number": 538, "title": "Sql template", "bodyText": "SQL templates for Vert.x 4\nLatest generated documentation https://gist.github.com/vietj/db18ad21ea242f7260a8a824f6d6d3a8", "createdAt": "2020-03-13T12:19:39Z", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538", "merged": true, "mergeCommit": {"oid": "862d443fe27c0a4cab172d768923c7def938d235"}, "closed": true, "closedAt": "2020-05-13T10:56:54Z", "author": {"login": "vietj"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOKVPCABqjMxMzIyMDI0MDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgm4WYAH2gAyMzg3NzQ3OTUxOmEyNjY3MjdjYTFhY2E3ZjY5YTIzZWMzMzFmZTIxNWM1NTMxZTBjZjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "882a4252fed05ffaa0777d96be6dea9ecbe5abb5", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/882a4252fed05ffaa0777d96be6dea9ecbe5abb5", "committedDate": "2020-03-13T12:16:54Z", "message": "Perform mapping of arrays"}, "afterCommit": {"oid": "752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "committedDate": "2020-03-16T08:55:12Z", "message": "Template poc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "committedDate": "2020-03-16T08:55:12Z", "message": "Template poc"}, "afterCommit": {"oid": "0dce2e0728b22505f935d33689fd51f7e3d93bcb", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0dce2e0728b22505f935d33689fd51f7e3d93bcb", "committedDate": "2020-03-16T09:52:48Z", "message": "Template poc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dce2e0728b22505f935d33689fd51f7e3d93bcb", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0dce2e0728b22505f935d33689fd51f7e3d93bcb", "committedDate": "2020-03-16T09:52:48Z", "message": "Template poc"}, "afterCommit": {"oid": "46b7c9cce74bf349602425a28d0323ba23b493ca", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/46b7c9cce74bf349602425a28d0323ba23b493ca", "committedDate": "2020-03-17T08:40:11Z", "message": "Start data object to param mapping"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Mzk3Mzgx", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-378397381", "createdAt": "2020-03-20T11:14:29Z", "commit": {"oid": "e66f7a582bdca254546bd8da1c371174a3ffb507"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyOVrOF5Pt1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyOVrOF5Pt1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDY0Nw==", "bodyText": "How about naming it batchUpdate since it returns an asynchronous result of Void type?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r395570647", "createdAt": "2020-03-20T11:14:29Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/BatchTemplate.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.impl.BatchTemplateImpl;\n+import io.vertx.sqlclient.template.impl.QueryTemplateImpl;\n+import io.vertx.sqlclient.template.impl.TupleMapper;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@VertxGen\n+public interface BatchTemplate<T> {\n+\n+  @GenIgnore\n+  static BatchTemplate<Map<String, Object>> create(SqlClient client, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), tupleMapper::mapTuple);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Function<T, Tuple> mapper, String template) {\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Class<T> clazz, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    Function<T, Tuple> mapper = t -> tupleMapper.mapTuple(JsonObject.mapFrom(t).getMap());\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  @GenIgnore\n+  default Future<Void> batch(List<T> list) {\n+    Promise<Void> promise = Promise.promise();\n+    batch(list, promise);\n+    return promise.future();\n+  }\n+\n+  @GenIgnore\n+  void batch(List<T> list, Handler<AsyncResult<Void>> result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e66f7a582bdca254546bd8da1c371174a3ffb507"}, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a007d609f9804c2df4639e2f8223adef9ecb045e", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/a007d609f9804c2df4639e2f8223adef9ecb045e", "committedDate": "2020-03-22T11:07:30Z", "message": "Generate a mapping collector so it can be used without template"}, "afterCommit": {"oid": "43956b45a1b133dd0baaba456a3fd28a10995790", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/43956b45a1b133dd0baaba456a3fd28a10995790", "committedDate": "2020-03-24T09:01:23Z", "message": "New SqlTemplate essai"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43956b45a1b133dd0baaba456a3fd28a10995790", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/43956b45a1b133dd0baaba456a3fd28a10995790", "committedDate": "2020-03-24T09:01:23Z", "message": "New SqlTemplate essai"}, "afterCommit": {"oid": "45a19f26e820fdbb19e1f7b59d2d4a0808e65aad", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/45a19f26e820fdbb19e1f7b59d2d4a0808e65aad", "committedDate": "2020-04-30T14:46:48Z", "message": "More work"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6ad0af1205770132fca722c1146d0518631a590", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/d6ad0af1205770132fca722c1146d0518631a590", "committedDate": "2020-05-01T09:11:57Z", "message": "improve examples"}, "afterCommit": {"oid": "5534f9281a122885f98a09a369d65f27a656b88c", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/5534f9281a122885f98a09a369d65f27a656b88c", "committedDate": "2020-05-01T09:12:31Z", "message": "improve examples"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdf8a077959aee5dae5e95938ede700ac0edef0c", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/cdf8a077959aee5dae5e95938ede700ac0edef0c", "committedDate": "2020-05-05T09:39:28Z", "message": "Minor"}, "afterCommit": {"oid": "0d8de52ddde0d75d20b9c455ebc5e5413c5a26d0", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0d8de52ddde0d75d20b9c455ebc5e5413c5a26d0", "committedDate": "2020-05-05T09:42:28Z", "message": "Project modifications"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MzAxNDk3", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-406301497", "createdAt": "2020-05-06T04:47:09Z", "commit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo0NzowOVrOGRD53w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwNDo1Njo1MlrOGRECig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mjk0Mw==", "bodyText": "Use implementation rather than compile.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420542943", "createdAt": "2020-05-06T04:47:09Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzE1Mw==", "bodyText": "But that's a more general remark. compile is still here, but it's recommended to go with implementation for dependencies you consume, and api for dependencies you want to consume the re-export.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543153", "createdAt": "2020-05-06T04:48:13Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mjk0Mw=="}, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzQzMQ==", "bodyText": "you can use {@link XYZ} instead.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543431", "createdAt": "2020-05-06T04:49:10Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0MzY1MQ==", "bodyText": "By default templates produce {...} as result type.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543651", "createdAt": "2020-05-06T04:50:06Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0Mzg2OQ==", "bodyText": "I'd put to achieve row level mapping instead: here with the full function and template call below", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420543869", "createdAt": "2020-05-06T04:51:04Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDQzOQ==", "bodyText": "annotationProcessor scope in Gradle", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420544439", "createdAt": "2020-05-06T04:53:50Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+compile \"io.vertx:vertx-codegen:${maven.version}:processor\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NDYxMA==", "bodyText": "usually provide", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420544610", "createdAt": "2020-05-06T04:54:30Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,325 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use instead {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate}:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Row mapping\n+\n+Templates produces {@link io.vertx.sqlclient.Row} as default result.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+compile \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"\n+----\n+\n+IDE provides usually support for annotation processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NTE2Mg==", "bodyText": "BTW you should have 2020 license headers in files (IntelliJ copyright update can help)", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420545162", "createdAt": "2020-05-06T04:56:52Z", "author": {"login": "jponge"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzc0NDAw", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-406774400", "createdAt": "2020-05-06T16:16:49Z", "commit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxNjo0OVrOGRaz2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNzo1MToxNVrOGRelQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODIzNQ==", "bodyText": "If i am not mistaken this is not used and can be removed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918235", "createdAt": "2020-05-06T16:16:49Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODc5Nw==", "bodyText": "If i am not mistaken this is not used and can be removed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918797", "createdAt": "2020-05-06T16:17:43Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }\n+\n+  public void bindingRowWithCustomFunction(SqlClient client) {\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .mapTo(ROW_USER_MAPPER)\n+      .execute(Collections.singletonMap(\"id\", 1))\n+      .onSuccess(users -> {\n+        users.forEach(user -> {\n+          System.out.println(user.firstName + \" \" + user.lastName);\n+        });\n+      });\n+  }\n+\n+  private static final Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", user.id);\n+    params.put(\"firstName\", user.firstName);\n+    params.put(\"lastName\", user.lastName);\n+    return params;\n+  };\n+\n+  public void paramsUserMapper() {\n+    Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+      Map<String, Object> params = new HashMap<>();\n+      params.put(\"id\", user.id);\n+      params.put(\"firstName\", user.firstName);\n+      params.put(\"lastName\", user.lastName);\n+      return params;\n+    };\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODAyNA==", "bodyText": "Why not?\ndefault void execute(I parameters, Handler<AsyncResult<R>> handler) {\nexecute(parameters).onComplete(handler);\n}", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938024", "createdAt": "2020-05-06T16:46:26Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODA5Mg==", "bodyText": "Why not?\ndefault void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler) {\nexecuteBatch(batch).onComplete(handler);\n}", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938092", "createdAt": "2020-05-06T16:46:32Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);\n+\n+  /**\n+   * Like {@link #execute(Object, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<R> execute(I params);\n+\n+  /**\n+   * Execute a batch query with the {@code batch}.\n+   *\n+   * <p>Each item in the batch is mapped to a tuple.\n+   *\n+   * @param batch the batch\n+   * @param handler the result handler\n+   */\n+  void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0MDA4NA==", "bodyText": "when this property when ?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420940084", "createdAt": "2020-05-06T16:49:38Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/annotations/TemplateParam.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.vertx.sqlclient.template.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotate a Vert.x data object property for custom configuration when this property when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTQ1Ng==", "bodyText": "This will not work for postgresql :: cast\nThis is how spring does it\nhttps://github.com/spring-projects/spring-framework/blob/4ca64684f6d5b7414ca3628a6b372a7c586fd2a6/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterUtils.java#L82\nAnother solution is to use ${name} via this pattern\nPattern.compile(\"\\\\$\\\\{\\\\s*(.*?)\\\\s*}\");\n\nWe could also cache the result", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420961456", "createdAt": "2020-05-06T17:22:47Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SqlTemplate {\n+\n+  private static Pattern PARAM_PATTERN = Pattern.compile(\":(\\\\p{javaUnicodeIdentifierStart}\\\\p{javaUnicodeIdentifierPart}*)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjU0Ng==", "bodyText": "This can be remove if we use the default method on interface", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962546", "createdAt": "2020-05-06T17:24:20Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjYyNA==", "bodyText": "This can be remove if we use the default method on interface", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962624", "createdAt": "2020-05-06T17:24:28Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }\n+\n+  @Override\n+  public Future<R> execute(T params) {\n+    return queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(params));\n+  }\n+\n+  @Override\n+  public void executeBatch(List<T> batch, Handler<AsyncResult<R>> handler) {\n+    queryMapper.apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .executeBatch(batch\n+        .stream()\n+        .map(this::toTuple)\n+        .collect(Collectors.toList()), handler);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4MDAzMg==", "bodyText": "placeholder not place holder", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420980032", "createdAt": "2020-05-06T17:51:15Z", "author": {"login": "zenios"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.sqlclient.SqlClient;\n+\n+public interface SqlClientInternal extends SqlClient {\n+\n+  /**\n+   * Append a query place holder in the {@code query}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "830d45927f9e149a05cddd36dbe0dc66c3bc3174"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3ODQzNjU4", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-407843658", "createdAt": "2020-05-07T21:17:19Z", "commit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxNzoxOVrOGSQnUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNTo0M1rOGSRKKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5OTc2MQ==", "bodyText": "We should document the return value", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421799761", "createdAt": "2020-05-07T21:17:19Z", "author": {"login": "zenios"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -5,13 +5,13 @@\n public interface SqlClientInternal extends SqlClient {\n \n   /**\n-   * Append a query place holder in the {@code query}.\n+   * Append a query placeholder in the {@code query}.\n    *\n    * <p>The index starts at {@code 0}\n    *\n    * @param queryBuilder the builder to append to\n-   * @param index the place holder index\n+   * @param index the placeholder index\n    */\n-  int appendQueryPlaceHolder(StringBuilder queryBuilder, int index, int current);\n+  int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMzczMQ==", "bodyText": "SQL Client templates", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421803731", "createdAt": "2020-05-07T21:25:10Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMzg4NQ==", "bodyText": "library designed", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421803885", "createdAt": "2020-05-07T21:25:30Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwNDE5MQ==", "bodyText": "To use SQL client templates", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421804191", "createdAt": "2020-05-07T21:26:10Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwNjM5Mw==", "bodyText": "IDEs usually provide support for annotation processors.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421806393", "createdAt": "2020-05-07T21:30:40Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,332 @@\n+= Client SQL templates\n+:toc:\n+\n+SQL client templates is a small library design to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use client SQL templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.template.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL template component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.template.annotations.RowMapped} or {@link io.vertx.sqlclient.template.annotations.ParamsMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+annotationProcessor \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"\n+----\n+\n+IDE usually provide usually support for annotation processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODExOA==", "bodyText": "An SQL template.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808118", "createdAt": "2020-05-07T21:34:21Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODYxMQ==", "bodyText": "Create an SQL template", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808611", "createdAt": "2020-05-07T21:35:35Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODY4MA==", "bodyText": "Create an SQL template", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808680", "createdAt": "2020-05-07T21:35:43Z", "author": {"login": "zenios"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = io.vertx.sqlclient.template.impl.SqlTemplate.create((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzQ2MjEx", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-408346211", "createdAt": "2020-05-08T16:06:37Z", "commit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjowNjozN1rOGSq1VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjozNDozN1rOGSrsnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyOTMzMw==", "bodyText": "foobar should be named queryMapper?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422229333", "createdAt": "2020-05-08T16:06:37Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzMTQyNg==", "bodyText": "we need to override this method in MSSQLConnectionImpl and MSSQLPoolImpl for sql server client.\nThe syntax is like postgres as:\n    queryBuilder.append('@').append(1 + index);\n    return index;", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422231426", "createdAt": "2020-05-08T16:10:43Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "diffHunk": "@@ -37,7 +37,13 @@\n import java.util.function.Function;\n import java.util.stream.Collector;\n \n-public abstract class SqlClientBase<C extends SqlClient> implements SqlClient, CommandScheduler {\n+public abstract class SqlClientBase<C extends SqlClient> implements SqlClientInternal, CommandScheduler {\n+\n+  @Override\n+  public int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current) {\n+    queryBuilder.append(\"?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ==", "bodyText": "it seems we don't support mapping string/numeric datat type to enum type(name/ordinal). I wonder if we could support this here.", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422238805", "createdAt": "2020-05-08T16:25:14Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA==", "bodyText": "can we add tests for data object type like geometrics data object and numeric data object to check whether it works?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422241738", "createdAt": "2020-05-08T16:31:14Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA==", "bodyText": "MySQL is using java.time.Duration type, can we add the mapping here using Row#get(java.time.Duration.class, index)?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422243484", "createdAt": "2020-05-08T16:34:37Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "040029de3c2c0c1b292364ee6dd3164a3666de58"}, "originalPosition": 182}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92e5460cdb82fd929fa97f4eec575719d8263502", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/92e5460cdb82fd929fa97f4eec575719d8263502", "committedDate": "2020-05-09T07:14:33Z", "message": "MS SQL uses the same parameter mapping than PG"}, "afterCommit": {"oid": "99d0e6996328ecf695239dd332aee526e006c7dd", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/99d0e6996328ecf695239dd332aee526e006c7dd", "committedDate": "2020-05-10T21:16:24Z", "message": "Support enum types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2228b0280dcad79604c6d7c2be77f756713baee6", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2228b0280dcad79604c6d7c2be77f756713baee6", "committedDate": "2020-05-11T08:06:02Z", "message": "SQL template feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da90c8d93aa4225205ebb19da528c0c17d763583", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/da90c8d93aa4225205ebb19da528c0c17d763583", "committedDate": "2020-05-11T08:06:02Z", "message": "Project modifications"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac84a73ddf132750187d1209ed55320dcd5008f1", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/ac84a73ddf132750187d1209ed55320dcd5008f1", "committedDate": "2020-05-11T08:06:02Z", "message": "Implement correctly the actual SQL formatting for each database independently of place holder syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abddc8531f6e94ce14b7c9372a46daa07ee785e5", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/abddc8531f6e94ce14b7c9372a46daa07ee785e5", "committedDate": "2020-05-11T08:06:02Z", "message": "Use ${...} for properties as it eliminates ambiguity when parsing templates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2082edbc58b130bb97e025e67c6f81dfb8ecdb91", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2082edbc58b130bb97e025e67c6f81dfb8ecdb91", "committedDate": "2020-05-11T08:06:02Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "182bb749ab8a32bd8e81c3d40000aa03a486a430", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/182bb749ab8a32bd8e81c3d40000aa03a486a430", "committedDate": "2020-05-11T08:06:02Z", "message": "Typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3458e3a290e65d7c3340ef7a4ff248dfcb89e7a", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/c3458e3a290e65d7c3340ef7a4ff248dfcb89e7a", "committedDate": "2020-05-11T08:06:02Z", "message": "Typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e7a564b72e9befd48b5d54ada2c7ea857616c6a", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/9e7a564b72e9befd48b5d54ada2c7ea857616c6a", "committedDate": "2020-05-11T08:06:02Z", "message": "Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8155345d5a13a0c670c9b3c7c5cec2a07ba61989", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/8155345d5a13a0c670c9b3c7c5cec2a07ba61989", "committedDate": "2020-05-11T08:06:02Z", "message": "Typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15073af21cd13f06c860d3b8c0792e4fc35ad59", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/d15073af21cd13f06c860d3b8c0792e4fc35ad59", "committedDate": "2020-05-11T08:06:02Z", "message": "MS SQL uses the same parameter mapping than PG"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61df1b54e91dd0e2c1b1dc2c969d2ed795f2e402", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/61df1b54e91dd0e2c1b1dc2c969d2ed795f2e402", "committedDate": "2020-05-11T08:06:02Z", "message": "Minor cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7c8cd3ce3cc2f4886acbc6a2307f12d7028822a", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/c7c8cd3ce3cc2f4886acbc6a2307f12d7028822a", "committedDate": "2020-05-11T08:06:02Z", "message": "Support enum types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "committedDate": "2020-05-11T08:07:42Z", "message": "Map any java class using its class and consequently mapping MySQL duration and PosgreSQL specific data types"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99d0e6996328ecf695239dd332aee526e006c7dd", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/99d0e6996328ecf695239dd332aee526e006c7dd", "committedDate": "2020-05-10T21:16:24Z", "message": "Support enum types"}, "afterCommit": {"oid": "2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "committedDate": "2020-05-11T08:07:42Z", "message": "Map any java class using its class and consequently mapping MySQL duration and PosgreSQL specific data types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4ac5d0926c70be7649bfda161fa6a2c453ed40", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/3d4ac5d0926c70be7649bfda161fa6a2c453ed40", "committedDate": "2020-05-11T08:42:03Z", "message": "Rename ParamsMapper -> ParametersMapped and ParamMapper -> ParametersMapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e81b867f2fd752e30183c33039fead92dbac2883", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/e81b867f2fd752e30183c33039fead92dbac2883", "committedDate": "2020-05-11T08:59:34Z", "message": "Rename to SQL Templates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a9aaffbc187fdaa39b0b3c6c9edf244f8022301", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0a9aaffbc187fdaa39b0b3c6c9edf244f8022301", "committedDate": "2020-05-11T13:40:32Z", "message": "Finally rename to Vert.x SQL Templates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/b75cdcc7870e5090d064ef45c65586d5535e12af", "committedDate": "2020-05-11T13:42:27Z", "message": "Fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMTc4ODg3", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#pullrequestreview-410178887", "createdAt": "2020-05-12T15:46:41Z", "commit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0Njo0MlrOGUNKTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNTo0NzozM1rOGUNM0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDMzNA==", "bodyText": "should be vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840334", "createdAt": "2020-05-12T15:46:42Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDY3Mw==", "bodyText": "should be vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840673", "createdAt": "2020-05-12T15:47:08Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg0MDk3OQ==", "bodyText": "vertx-sql-client-templates?", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r423840979", "createdAt": "2020-05-12T15:47:33Z", "author": {"login": "BillyYccc"}, "path": "vertx-sql-client-templates/src/main/asciidoc/index.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+= SQL Client Templates\n+:toc:\n+\n+SQL Client Templates is a small library designed to facilitate the execution of SQL queries.\n+\n+== Usage\n+\n+To use SQL Client Templates add the following dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>${maven.groupId}</groupId>\n+  <artifactId>${maven.artifactId}</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  implementation '${maven.groupId}:${maven.artifactId}:${maven.version}'\n+}\n+----\n+\n+== Getting started\n+\n+Here is the simplest way to use an SQL template.\n+\n+A SQL template consumes _named_ parameters and thus takes (by default) a map as parameters sources instead of a tuple.\n+\n+A SQL template produces (by default) a `RowSet<Row>` like a client `PreparedQuery`. In fact the template is a thin\n+wrapper for a `PreparedQuery`.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#queryExample}\n+----\n+\n+When you need to perform an insert or update operation and you do not care of the result, you can use {@link io.vertx.sqlclient.templates.SqlTemplate#forUpdate} instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#insertExample}\n+----\n+\n+== Template syntax\n+\n+The template syntax uses `${XXX}` syntax where `XXX` is a valid https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8[java identifier] string\n+(without the keyword restriction).\n+\n+You can use the backslash char `\\` to escape  any `$` character, i.e `\\${foo}` will be interpreted as `${foo}` string without a `foo` parameter.\n+\n+== Row mapping\n+\n+By default templates produce {@link io.vertx.sqlclient.Row} as result type.\n+\n+You can provide a function to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#rowUserMapper}\n+----\n+\n+[[row_mapping_with_custom_function]]\n+to achieve row level mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithCustomFunction}\n+----\n+\n+== Parameters mapping\n+\n+Templates consume `Map<String, Object>` as default input.\n+\n+You can provide a function:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#paramsUserMapper}\n+----\n+\n+[[params_mapping_with_custom_function]]\n+to achieve parameter mapping instead:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithCustomFunction}\n+----\n+\n+You can also perform batching easily:\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#batchBindingParamsWithCustomFunction}\n+----\n+\n+== Mapping with Jackson databind\n+\n+You can do mapping using Jackson databind capabilities.\n+\n+You need to add the Jackson databind dependency to the _dependencies_ section of your build descriptor:\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.core</groupId>\n+  <artifactId>jackson-databind</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.core:jackson-databind:${jackson.version}'\n+}\n+----\n+\n+Row mapping is achieved by creating a `JsonObject` using the row key/value pairs and then calling\n+{@link io.vertx.core.json.JsonObject#mapTo} to map it to any Java class with Jackson databind.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingRowWithJacksonDatabind}\n+----\n+\n+Likewise parameters mapping is achieved by mapping the object to a `JsonObject` using  {@link io.vertx.core.json.JsonObject#mapFrom}\n+and then using the key/value pairs to produce template parameters.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#bindingParamsWithJacksonDatabind}\n+----\n+\n+=== Java Date/Time API mapping\n+\n+You can map `java.time` types with the _jackson-modules-java8_ Jackson extension.\n+\n+You need to add the Jackson JSR 310 datatype dependency to the _dependencies_ section of your build descriptor:\n+\n+\n+* Maven (in your `pom.xml`):\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>com.fasterxml.jackson.datatype</groupId>\n+  <artifactId>jackson-datatype-jsr310</artifactId>\n+  <version>${jackson.version}</version>\n+</dependency>\n+----\n+* Gradle (in your `build.gradle` file):\n+\n+[source,groovy]\n+----\n+dependencies {\n+  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jackson.version}'\n+}\n+----\n+\n+Then you need to register the time module to the Jackson `ObjectMapper`:\n+\n+[source,java]\n+----\n+ObjectMapper mapper = io.vertx.core.json.jackson.DatabindCodec.mapper();\n+\n+mapper.registerModule(new JavaTimeModule());\n+----\n+\n+You can now use `java.time` types such as `LocalDateTime`:\n+\n+[source,java]\n+----\n+public class LocalDateTimePojo {\n+\n+  public LocalDateTime localDateTime;\n+\n+}\n+----\n+\n+== Mapping with Vert.x data objects\n+\n+The SQL Client Templates component can generate mapping function for Vert.x data objects.\n+\n+A Vert.x data object is a simple Java bean class annotated with the `@DataObject` annotation.\n+\n+[source,$lang]\n+----\n+{@link examples.TemplateExamples#baseDataObject}\n+----\n+\n+=== Code generation\n+\n+Any data object annotated by {@link io.vertx.sqlclient.templates.annotations.RowMapped} or {@link io.vertx.sqlclient.templates.annotations.ParametersMapped}\n+will trigger  the generation of a corresponding mapper class.\n+\n+The _codegen_ annotation processor generates these classes at compilation time. It is a feature of the Java\n+compiler so _no extra step_ is required, it is just a matter of configuring correctly your build:\n+\n+Just add the `io.vertx:vertx-codegen:processor` and `io.vertx:vertx-sql-client-template`\n+dependencies to your build.\n+\n+Here a configuration example for Maven:\n+\n+[source,xml]\n+----\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-codegen</artifactId>\n+  <version>${maven.version}</version>\n+  <classifier>processor</classifier>\n+</dependency>\n+<dependency>\n+  <groupId>io.vertx</groupId>\n+  <artifactId>vertx-sql-client-template</artifactId>\n+  <version>${maven.version}</version>\n+</dependency>\n+----\n+\n+This feature can also be used in Gradle:\n+\n+[source]\n+----\n+annotationProcessor \"io.vertx:vertx-codegen:${maven.version}:processor\"\n+compile \"io.vertx:vertx-sql-client-template:${maven.version}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a266727ca1aca7f69a23ec331fe215c5531e0cf1", "author": {"user": {"login": "vietj", "name": "Julien Viet"}}, "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/a266727ca1aca7f69a23ec331fe215c5531e0cf1", "committedDate": "2020-05-12T16:29:36Z", "message": "Use ${maven.artifactId} instead of vertx-sql-client-templates"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1566, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}