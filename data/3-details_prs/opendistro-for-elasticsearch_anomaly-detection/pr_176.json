{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5NTgwOTg3", "number": 176, "title": "Queries data from the index when insufficient data in buffer to form a full shingle", "bodyText": "Issue #, if available:\nDescription of changes:\nWhen running an AD on an interval, data points from past consecutive intervals are required in the shingling process. Currently, the AD only checks data points from a buffer which only contains data points for intervals which were previously run. This means for the first several intervals which the AD runs on, or if there were previously missed intervals (for example, due to restarts), the AD is unable to form a shingle and will output no results, even if the data points for the missed intervals are in the data index.\nWith this change, instead of issuing a query which only retrieves the current data point, a single query to the index will be issued for the current data point and any missing data points from the buffer that are needed to form a full shingle. The results of the query are cached so that if the data point is missing from the index itself, it will not be re-queried later.\nTesting:\nA comprehensive set of unit tests have been added (8 new tests covering 25 test cases) to test the FeatureManager getCurrentFeatures method under various initial states and query responses.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-06-25T00:05:44Z", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176", "merged": true, "mergeCommit": {"oid": "44a8bcdccdf7f822c880690c7196e7d23d69fe4a"}, "closed": true, "closedAt": "2020-07-16T02:06:44Z", "author": {"login": "LiuJoyceC"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuj0POAFqTQzNzA5MzQ4Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1TAFAgFqTQ0OTQwNDE5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDkzNDg2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-437093486", "createdAt": "2020-06-25T00:30:34Z", "commit": {"oid": "e8b0d2acba8e1f05bf1af60ad678f0fca2518779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMDozMDozNFrOGonhNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMDozMDozNFrOGonhNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0MzcwMQ==", "bodyText": "is this branch still correct?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r445243701", "createdAt": "2020-06-25T00:30:34Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,40 +119,59 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n \n         Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n             .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+\n+        Map<Long, double[]> featuresMap = shingle.stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                for (int i = 0; i < missingRanges.size(); i++) {\n+                    Optional<double[]> point = points.get(i);\n+                    if (point.isPresent()) {\n+                        featuresMap.put(missingRanges.get(i).getValue(), point.get());\n+                    }\n+                }\n+                updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+            }, listener::onFailure));\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8b0d2acba8e1f05bf1af60ad678f0fca2518779"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8b0d2acba8e1f05bf1af60ad678f0fca2518779", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/e8b0d2acba8e1f05bf1af60ad678f0fca2518779", "committedDate": "2020-06-25T00:01:23Z", "message": "Queries data from the index when insufficient data in buffer to form a full shingle."}, "afterCommit": {"oid": "84d4a200a14e3fed987946facf1ae7d140dc088c", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/84d4a200a14e3fed987946facf1ae7d140dc088c", "committedDate": "2020-06-30T18:45:15Z", "message": "Queries data from the index when insufficient data in buffer to form a full shingle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/f87ee3d547dc0ce3cce26dfe3918a584c291c4c7", "committedDate": "2020-06-30T19:17:38Z", "message": "Queries data from the index when insufficient data in buffer to form a full shingle."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84d4a200a14e3fed987946facf1ae7d140dc088c", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/84d4a200a14e3fed987946facf1ae7d140dc088c", "committedDate": "2020-06-30T18:45:15Z", "message": "Queries data from the index when insufficient data in buffer to form a full shingle."}, "afterCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/f87ee3d547dc0ce3cce26dfe3918a584c291c4c7", "committedDate": "2020-06-30T19:17:38Z", "message": "Queries data from the index when insufficient data in buffer to form a full shingle."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzUzODUz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-440353853", "createdAt": "2020-06-30T20:17:27Z", "commit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDoxNzoyOFrOGrM6Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozMjo0NlrOGrNZww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MzQ5OQ==", "bodyText": "this method should be private to the class.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r447953499", "createdAt": "2020-06-30T20:17:28Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);\n+    }\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+    /**\n+     * Returns to listener unprocessed features and processed features (such as shingle) for the current data point.\n+     *\n+     * @param detector anomaly detector for which the features are returned\n+     * @param startTime start time of the data point in epoch milliseconds\n+     * @param endTime end time of the data point in epoch milliseconds\n+     * @param cacheMissingDataPoints if set to true, missing data points are remembered and not re-queried later\n+     * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n+     */\n+    public void getCurrentFeatures(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1OTQ1OQ==", "bodyText": "note the timestamps might not have exactly the same interval. there can be some jittering around each interval. for example, the timestamps from requests can be 59 sec, 1 min 58 sec, 2 min 03 sec, etc. if the data point already exists, the range can be skipped for query.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r447959459", "createdAt": "2020-06-30T20:28:49Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);\n+    }\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+    /**\n+     * Returns to listener unprocessed features and processed features (such as shingle) for the current data point.\n+     *\n+     * @param detector anomaly detector for which the features are returned\n+     * @param startTime start time of the data point in epoch milliseconds\n+     * @param endTime end time of the data point in epoch milliseconds\n+     * @param cacheMissingDataPoints if set to true, missing data points are remembered and not re-queried later\n+     * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n+     */\n+    public void getCurrentFeatures(\n+        AnomalyDetector detector,\n+        long startTime,\n+        long endTime,\n+        boolean cacheMissingDataPoints,\n+        ActionListener<SinglePointFeatures> listener\n+    ) throws IOException {\n+\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, Optional<double[]>>>(shingleSize));\n+\n+        Map<Long, Optional<double[]>> featuresMap = shingle.stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                for (int i = 0; i < points.size(); i++) {\n+                    Optional<double[]> point = points.get(i);\n+                    if (cacheMissingDataPoints || point.isPresent()) {\n+                        featuresMap.put(missingRanges.get(i).getValue(), point);\n+                    }\n+                }\n+                updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+            }, listener::onFailure));\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }\n     }\n \n+    private List<Entry<Long, Long>> getMissingRangesInShingle(\n+        AnomalyDetector detector,\n+        Map<Long, Optional<double[]>> featuresMap,\n+        long endTime\n+    ) {\n+        long intervalMilli = getDetectorIntervalInMilliseconds(detector);\n+\n+        return getFullShingleEndTimes(endTime, intervalMilli)\n+            .filter(time -> !featuresMap.containsKey(time))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MTUzOQ==", "bodyText": "minor. the query is from both the input and the system. if that happens, there will be no recovery for caller. usually those exceptions are caught and wrapped (abstracted) in unchecked exceptions for high-level callers, like in many other programming languages.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r447961539", "createdAt": "2020-06-30T20:32:46Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);\n+    }\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+    /**\n+     * Returns to listener unprocessed features and processed features (such as shingle) for the current data point.\n+     *\n+     * @param detector anomaly detector for which the features are returned\n+     * @param startTime start time of the data point in epoch milliseconds\n+     * @param endTime end time of the data point in epoch milliseconds\n+     * @param cacheMissingDataPoints if set to true, missing data points are remembered and not re-queried later\n+     * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjY2MDIw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-443266020", "createdAt": "2020-07-06T17:14:58Z", "commit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzoxNDo1OFrOGtgN6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzoyMjo0N1rOGtgeCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2Njk1Mw==", "bodyText": "Why do we have another method with the same signature?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r450366953", "createdAt": "2020-07-06T17:14:58Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2ODc2NA==", "bodyText": "What's the use case of always looking for missing data in the shingle besides starting detector running?  @wnbts", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r450368764", "createdAt": "2020-07-06T17:18:26Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);\n+    }\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+    /**\n+     * Returns to listener unprocessed features and processed features (such as shingle) for the current data point.\n+     *\n+     * @param detector anomaly detector for which the features are returned\n+     * @param startTime start time of the data point in epoch milliseconds\n+     * @param endTime end time of the data point in epoch milliseconds\n+     * @param cacheMissingDataPoints if set to true, missing data points are remembered and not re-queried later\n+     * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n+     */\n+    public void getCurrentFeatures(\n+        AnomalyDetector detector,\n+        long startTime,\n+        long endTime,\n+        boolean cacheMissingDataPoints,\n+        ActionListener<SinglePointFeatures> listener\n+    ) throws IOException {\n+\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, Optional<double[]>>>(shingleSize));\n+\n+        Map<Long, Optional<double[]>> featuresMap = shingle.stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MTA4Mg==", "bodyText": "Please make sure AnomalyResultTransportAction.onFeatureResponse can handle the exception you throw.  The IOException sounds like sth you should rethrow EndRunException in AnomalyResultTransportAction and let user know.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r450371082", "createdAt": "2020-07-06T17:22:47Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -118,67 +119,114 @@ public FeatureManager(\n      * @param startTime start time of the data point in epoch milliseconds\n      * @param endTime end time of the data point in epoch milliseconds\n      * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector\n      */\n-    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n+    public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener)\n+        throws IOException {\n+        getCurrentFeatures(detector, startTime, endTime, true, listener);\n+    }\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+    /**\n+     * Returns to listener unprocessed features and processed features (such as shingle) for the current data point.\n+     *\n+     * @param detector anomaly detector for which the features are returned\n+     * @param startTime start time of the data point in epoch milliseconds\n+     * @param endTime end time of the data point in epoch milliseconds\n+     * @param cacheMissingDataPoints if set to true, missing data points are remembered and not re-queried later\n+     * @param listener onResponse is called with unprocessed features and processed features for the current data point\n+     * @throws IOException if a user gives wrong query input when defining a detector", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MTUzOQ=="}, "originalCommit": {"oid": "f87ee3d547dc0ce3cce26dfe3918a584c291c4c7"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5793db2cf153da06c59ab70f230805771aeaa98d", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5793db2cf153da06c59ab70f230805771aeaa98d", "committedDate": "2020-07-06T18:49:05Z", "message": "Changes from previous commit:\n1) Allows time jitter up to half an interval.\n2) getCurrentFeatures returns all errors to the listener instead of throwing when searchFeatureDao throws.\n3) Modified unit tests to not require a public getCurrentFeatures interface that allows for not caching."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a071b67bfd756fa0ab4de19a319cdcfa56663fb", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2a071b67bfd756fa0ab4de19a319cdcfa56663fb", "committedDate": "2020-07-06T18:54:14Z", "message": "Merge branch 'master' of https://github.com/opendistro-for-elasticsearch/anomaly-detection into fill-shingle-with-history"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDY3OTY5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-443467969", "createdAt": "2020-07-06T23:29:00Z", "commit": {"oid": "2a071b67bfd756fa0ab4de19a319cdcfa56663fb"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoyOTowMFrOGtqL3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDowMjowOFrOGtqw7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzMDI2OQ==", "bodyText": "minor. this data should still be final.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r450530269", "createdAt": "2020-07-06T23:29:00Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -53,7 +54,7 @@\n     private static final Logger logger = LogManager.getLogger(FeatureManager.class);\n \n     // Each anomaly detector has a queue of data points with timestamps (in epoch milliseconds).\n-    private final Map<String, ArrayDeque<Entry<Long, double[]>>> detectorIdsToTimeShingles;\n+    private Map<String, ArrayDeque<Entry<Long, Optional<double[]>>>> detectorIdsToTimeShingles;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a071b67bfd756fa0ab4de19a319cdcfa56663fb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzOTc1OQ==", "bodyText": "minor. the second condition shingle.getLast().getKey() < endTime might need some relaxation. if the existing buffer is [1min, 2min,..., 8min] and endTime is 8min1sec, the last data point would still be valid for the endTime.\nalso, this if branch may be merged with the else branch, starting with optional current point and if current point is present, then optional current shingle.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r450539759", "createdAt": "2020-07-07T00:02:08Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -121,81 +122,133 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }\n     }\n \n+    private List<Entry<Long, Long>> getMissingRangesInShingle(\n+        AnomalyDetector detector,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n+        long endTime\n+    ) {\n+        long intervalMilli = getDetectorIntervalInMilliseconds(detector);\n+\n+        return getFullShingleEndTimes(endTime, intervalMilli)\n+            .filter(time -> !featuresMap.containsKey(time))\n+            .mapToObj(time -> new SimpleImmutableEntry<>(time - intervalMilli, time))\n+            .collect(Collectors.toList());\n+    }\n+\n     private void updateUnprocessedFeatures(\n-        Optional<double[]> point,\n-        Deque<Entry<Long, double[]>> shingle,\n         AnomalyDetector detector,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (point.isPresent()) {\n-            if (shingle.size() == shingleSize) {\n-                shingle.remove();\n-            }\n-            shingle.add(new SimpleImmutableEntry<>(endTime, point.get()));\n-            getProcessedFeatures(shingle, detector, endTime, listener);\n-        } else {\n-            listener.onResponse(new SinglePointFeatures(Optional.empty(), Optional.empty()));\n-        }\n+        shingle.clear();\n+        getFullShingleEndTimes(endTime, getDetectorIntervalInMilliseconds(detector))\n+            .filter(time -> featuresMap.containsKey(time))\n+            .mapToObj(time -> featuresMap.get(time))\n+            .forEach(e -> shingle.add(e));\n+\n+        getProcessedFeatures(shingle, detector, endTime, listener);\n     }\n \n     private void getProcessedFeatures(\n-        Deque<Entry<Long, double[]>> shingle,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n         AnomalyDetector detector,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-\n-        double[][] currentPoints = filterAndFill(shingle, endTime, detector);\n-        Optional<double[]> currentPoint = Optional.ofNullable(shingle.peekLast()).map(Entry::getValue);\n-        listener\n-            .onResponse(\n-                Optional\n-                    .ofNullable(currentPoints)\n-                    .map(points -> new SinglePointFeatures(currentPoint, Optional.of(batchShingle(points, shingleSize)[0])))\n-                    .orElse(new SinglePointFeatures(currentPoint, Optional.empty()))\n-            );\n+        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime || !shingle.getLast().getValue().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a071b67bfd756fa0ab4de19a319cdcfa56663fb"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d052f0566e71c93bd3ac09faad3c7aa934ecd7a0", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/d052f0566e71c93bd3ac09faad3c7aa934ecd7a0", "committedDate": "2020-07-09T22:41:52Z", "message": "Addresses minor comments from PR."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb13815a6fa0acda22512a4d932ff369da5f2663", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/cb13815a6fa0acda22512a4d932ff369da5f2663", "committedDate": "2020-07-09T22:44:18Z", "message": "Merge branch 'master' of https://github.com/opendistro-for-elasticsearch/anomaly-detection into fill-shingle-with-history"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MDM3Njg1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-446037685", "createdAt": "2020-07-09T23:43:00Z", "commit": {"oid": "cb13815a6fa0acda22512a4d932ff369da5f2663"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo0MzowMFrOGvlVpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMzo1MzozNFrOGvlhqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0ODAwNQ==", "bodyText": "minor. error handling can change to as kaituo suggested.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r452548005", "createdAt": "2020-07-09T23:43:00Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -121,81 +122,132 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb13815a6fa0acda22512a4d932ff369da5f2663"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0OTQzMw==", "bodyText": "getProcessedFeatures should be able to handle both branches.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r452549433", "createdAt": "2020-07-09T23:47:46Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -121,81 +122,132 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }\n     }\n \n+    private List<Entry<Long, Long>> getMissingRangesInShingle(\n+        AnomalyDetector detector,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n+        long endTime\n+    ) {\n+        long intervalMilli = getDetectorIntervalInMilliseconds(detector);\n+\n+        return getFullShingleEndTimes(endTime, intervalMilli)\n+            .filter(time -> !featuresMap.containsKey(time))\n+            .mapToObj(time -> new SimpleImmutableEntry<>(time - intervalMilli, time))\n+            .collect(Collectors.toList());\n+    }\n+\n     private void updateUnprocessedFeatures(\n-        Optional<double[]> point,\n-        Deque<Entry<Long, double[]>> shingle,\n         AnomalyDetector detector,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (point.isPresent()) {\n-            if (shingle.size() == shingleSize) {\n-                shingle.remove();\n-            }\n-            shingle.add(new SimpleImmutableEntry<>(endTime, point.get()));\n+        shingle.clear();\n+        getFullShingleEndTimes(endTime, getDetectorIntervalInMilliseconds(detector))\n+            .filter(time -> featuresMap.containsKey(time))\n+            .mapToObj(time -> featuresMap.get(time))\n+            .forEach(e -> shingle.add(e));\n+\n+        if (featuresMap.containsKey(endTime)) {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         } else {\n             listener.onResponse(new SinglePointFeatures(Optional.empty(), Optional.empty()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb13815a6fa0acda22512a4d932ff369da5f2663"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU1MTA4MQ==", "bodyText": "minor. this first filter might not be needed since the map should contains results for all interval, present or absent. to be safe in the unlikely case that map is incomplete, the second get can return an empty if the key is absent using getOrDefault.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r452551081", "createdAt": "2020-07-09T23:53:34Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -121,81 +122,132 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }\n     }\n \n+    private List<Entry<Long, Long>> getMissingRangesInShingle(\n+        AnomalyDetector detector,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n+        long endTime\n+    ) {\n+        long intervalMilli = getDetectorIntervalInMilliseconds(detector);\n+\n+        return getFullShingleEndTimes(endTime, intervalMilli)\n+            .filter(time -> !featuresMap.containsKey(time))\n+            .mapToObj(time -> new SimpleImmutableEntry<>(time - intervalMilli, time))\n+            .collect(Collectors.toList());\n+    }\n+\n     private void updateUnprocessedFeatures(\n-        Optional<double[]> point,\n-        Deque<Entry<Long, double[]>> shingle,\n         AnomalyDetector detector,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (point.isPresent()) {\n-            if (shingle.size() == shingleSize) {\n-                shingle.remove();\n-            }\n-            shingle.add(new SimpleImmutableEntry<>(endTime, point.get()));\n+        shingle.clear();\n+        getFullShingleEndTimes(endTime, getDetectorIntervalInMilliseconds(detector))\n+            .filter(time -> featuresMap.containsKey(time))\n+            .mapToObj(time -> featuresMap.get(time))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb13815a6fa0acda22512a4d932ff369da5f2663"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTU0ODAw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-446554800", "createdAt": "2020-07-10T16:56:58Z", "commit": {"oid": "d052f0566e71c93bd3ac09faad3c7aa934ecd7a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1Njo1OFrOGv-mPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1Njo1OFrOGv-mPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2MTg1Mg==", "bodyText": "The original code is easier to read.  Also, you do \"currentPoint.map(point -> filterAndFill(shingle, endTime, detector))\" without using currentPoint in filterAndFill, which looks strange.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r452961852", "createdAt": "2020-07-10T16:56:58Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -184,19 +188,14 @@ private void getProcessedFeatures(\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime || !shingle.getLast().getValue().isPresent()) {\n-            listener.onResponse(new SinglePointFeatures(Optional.empty(), Optional.empty()));\n-        } else {\n-            double[][] currentPoints = filterAndFill(shingle, endTime, detector);\n-            Optional<double[]> currentPoint = shingle.peekLast().getValue();\n-            listener\n-                .onResponse(\n-                    Optional\n-                        .ofNullable(currentPoints)\n-                        .map(points -> new SinglePointFeatures(currentPoint, Optional.of(batchShingle(points, shingleSize)[0])))\n-                        .orElse(new SinglePointFeatures(currentPoint, Optional.empty()))\n-                );\n-        }\n+        Optional<double[]> currentPoint = shingle.peekLast().getValue();\n+        listener\n+            .onResponse(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d052f0566e71c93bd3ac09faad3c7aa934ecd7a0"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1680fcc0a007d167ffc1a0ddc4e72e3546a4ed0e", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/1680fcc0a007d167ffc1a0ddc4e72e3546a4ed0e", "committedDate": "2020-07-10T23:57:08Z", "message": "Wraps IOException in EndRunException and caches an empty list from search response."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e1b4fad02d8d77b39fb00d126709b16793e305d", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8e1b4fad02d8d77b39fb00d126709b16793e305d", "committedDate": "2020-07-11T00:01:04Z", "message": "Merge branch 'master' of https://github.com/opendistro-for-elasticsearch/anomaly-detection into fill-shingle-with-history"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "843ac796bd5372d57f01697b371c19a2485640c3", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/843ac796bd5372d57f01697b371c19a2485640c3", "committedDate": "2020-07-11T02:30:24Z", "message": "Wraps IOException in EndRunException and removes unused use of \"point\" in Optional map function."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NDYxMjcy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-447461272", "createdAt": "2020-07-13T17:37:30Z", "commit": {"oid": "1680fcc0a007d167ffc1a0ddc4e72e3546a4ed0e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzo0MzozNlrOGwzBjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxODo0NjozOVrOGw1Rpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMDgxNA==", "bodyText": "add a function-level comment (e.g., \n  \n    \n      anomaly-detection/src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java\n    \n    \n         Line 243\n      in\n      cd3bdae\n    \n    \n    \n    \n\n        \n          \n                *                 onFailure is called with EndRunException on feature query creation errors \n        \n    \n  \n\n) to say you are gonna throw this exception when certain condition is true?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r453820814", "createdAt": "2020-07-13T17:43:36Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -132,81 +133,129 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(new EndRunException(detector.getDetectorId(), CommonErrorMessages.INVALID_SEARCH_QUERY_MSG, e, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843ac796bd5372d57f01697b371c19a2485640c3"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNTE5NQ==", "bodyText": "Have some documentation of this method since the return value is nested and not easy to understand?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r453835195", "createdAt": "2020-07-13T18:07:57Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -132,81 +133,129 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {\n \n-        Deque<Entry<Long, double[]>> shingle = detectorIdsToTimeShingles\n-            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<Entry<Long, double[]>>(shingleSize));\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime) {\n-            searchFeatureDao\n-                .getFeaturesForPeriod(\n-                    detector,\n-                    startTime,\n-                    endTime,\n-                    ActionListener\n-                        .wrap(point -> updateUnprocessedFeatures(point, shingle, detector, endTime, listener), listener::onFailure)\n-                );\n+        Deque<Entry<Long, Optional<double[]>>> shingle = detectorIdsToTimeShingles\n+            .computeIfAbsent(detector.getDetectorId(), id -> new ArrayDeque<>(shingleSize));\n+\n+        long maxTimeDifference = getDetectorIntervalInMilliseconds(detector) / 2;\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap = getNearbyPointsForShingle(detector, shingle, endTime, maxTimeDifference)\n+            .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n+\n+        List<Entry<Long, Long>> missingRanges = getMissingRangesInShingle(detector, featuresMap, endTime);\n+\n+        if (missingRanges.size() > 0) {\n+            try {\n+                searchFeatureDao.getFeatureSamplesForPeriods(detector, missingRanges, ActionListener.wrap(points -> {\n+                    for (int i = 0; i < points.size(); i++) {\n+                        Optional<double[]> point = points.get(i);\n+                        long rangeEndTime = missingRanges.get(i).getValue();\n+                        featuresMap.put(rangeEndTime, new SimpleImmutableEntry<>(rangeEndTime, point));\n+                    }\n+                    updateUnprocessedFeatures(detector, shingle, featuresMap, endTime, listener);\n+                }, listener::onFailure));\n+            } catch (IOException e) {\n+                listener.onFailure(new EndRunException(detector.getDetectorId(), CommonErrorMessages.INVALID_SEARCH_QUERY_MSG, e, true));\n+            }\n         } else {\n             getProcessedFeatures(shingle, detector, endTime, listener);\n         }\n     }\n \n+    private List<Entry<Long, Long>> getMissingRangesInShingle(\n+        AnomalyDetector detector,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n+        long endTime\n+    ) {\n+        long intervalMilli = getDetectorIntervalInMilliseconds(detector);\n+\n+        return getFullShingleEndTimes(endTime, intervalMilli)\n+            .filter(time -> !featuresMap.containsKey(time))\n+            .mapToObj(time -> new SimpleImmutableEntry<>(time - intervalMilli, time))\n+            .collect(Collectors.toList());\n+    }\n+\n     private void updateUnprocessedFeatures(\n-        Optional<double[]> point,\n-        Deque<Entry<Long, double[]>> shingle,\n         AnomalyDetector detector,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n+        Map<Long, Entry<Long, Optional<double[]>>> featuresMap,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (point.isPresent()) {\n-            if (shingle.size() == shingleSize) {\n-                shingle.remove();\n-            }\n-            shingle.add(new SimpleImmutableEntry<>(endTime, point.get()));\n-            getProcessedFeatures(shingle, detector, endTime, listener);\n-        } else {\n-            listener.onResponse(new SinglePointFeatures(Optional.empty(), Optional.empty()));\n-        }\n+        shingle.clear();\n+        getFullShingleEndTimes(endTime, getDetectorIntervalInMilliseconds(detector))\n+            .mapToObj(time -> featuresMap.getOrDefault(time, new SimpleImmutableEntry<>(time, Optional.empty())))\n+            .forEach(e -> shingle.add(e));\n+\n+        getProcessedFeatures(shingle, detector, endTime, listener);\n     }\n \n     private void getProcessedFeatures(\n-        Deque<Entry<Long, double[]>> shingle,\n+        Deque<Entry<Long, Optional<double[]>>> shingle,\n         AnomalyDetector detector,\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-\n-        double[][] currentPoints = filterAndFill(shingle, endTime, detector);\n-        Optional<double[]> currentPoint = Optional.ofNullable(shingle.peekLast()).map(Entry::getValue);\n+        Optional<double[]> currentPoint = shingle.peekLast().getValue();\n         listener\n             .onResponse(\n-                Optional\n-                    .ofNullable(currentPoints)\n-                    .map(points -> new SinglePointFeatures(currentPoint, Optional.of(batchShingle(points, shingleSize)[0])))\n-                    .orElse(new SinglePointFeatures(currentPoint, Optional.empty()))\n+                new SinglePointFeatures(\n+                    currentPoint,\n+                    Optional\n+                        .ofNullable(currentPoint.isPresent() ? filterAndFill(shingle, endTime, detector) : null)\n+                        .map(points -> batchShingle(points, shingleSize)[0])\n+                )\n             );\n     }\n \n-    private double[][] filterAndFill(Deque<Entry<Long, double[]>> shingle, long endTime, AnomalyDetector detector) {\n-        long intervalMilli = ((IntervalTimeConfiguration) detector.getDetectionInterval()).toDuration().toMillis();\n+    private double[][] filterAndFill(Deque<Entry<Long, Optional<double[]>>> shingle, long endTime, AnomalyDetector detector) {\n+        Deque<Entry<Long, Optional<double[]>>> filteredShingle = shingle\n+            .stream()\n+            .filter(e -> e.getValue().isPresent())\n+            .collect(Collectors.toCollection(ArrayDeque::new));\n         double[][] result = null;\n-        if (shingle.size() >= shingleSize - maxMissingPoints) {\n-            TreeMap<Long, double[]> search = new TreeMap<>(shingle.stream().collect(Collectors.toMap(Entry::getKey, Entry::getValue)));\n-            result = IntStream.rangeClosed(1, shingleSize).mapToLong(i -> endTime - (shingleSize - i) * intervalMilli).mapToObj(t -> {\n-                Optional<Entry<Long, double[]>> after = Optional.ofNullable(search.ceilingEntry(t));\n-                Optional<Entry<Long, double[]>> before = Optional.ofNullable(search.floorEntry(t));\n-                return after\n-                    .filter(a -> Math.abs(t - a.getKey()) <= before.map(b -> Math.abs(t - b.getKey())).orElse(Long.MAX_VALUE))\n-                    .map(Optional::of)\n-                    .orElse(before)\n-                    .filter(e -> Math.abs(t - e.getKey()) < intervalMilli * maxNeighborDistance)\n-                    .map(Entry::getValue)\n-                    .orElse(null);\n-            }).filter(d -> d != null).toArray(double[][]::new);\n+        if (filteredShingle.size() >= shingleSize - maxMissingPoints) {\n+            long maxMillisecondsDifference = maxNeighborDistance * getDetectorIntervalInMilliseconds(detector);\n+            result = getNearbyPointsForShingle(detector, filteredShingle, endTime, maxMillisecondsDifference)\n+                .map(e -> e.getValue().getValue().orElse(null))\n+                .filter(d -> d != null)\n+                .toArray(double[][]::new);\n+\n             if (result.length < shingleSize) {\n                 result = null;\n             }\n         }\n         return result;\n     }\n \n+    private Stream<Entry<Long, Entry<Long, Optional<double[]>>>> getNearbyPointsForShingle(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843ac796bd5372d57f01697b371c19a2485640c3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NDAxMw==", "bodyText": "Add comments on your workflow?  Is the following understanding correct?\nFirst, you interpolate using nearest points.\nThen, query for missing points.\nFinally, do another round of interpolation using nearest points.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r453854013", "createdAt": "2020-07-13T18:40:12Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -132,81 +133,129 @@ public FeatureManager(\n      */\n     public void getCurrentFeatures(AnomalyDetector detector, long startTime, long endTime, ActionListener<SinglePointFeatures> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843ac796bd5372d57f01697b371c19a2485640c3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NzcwMg==", "bodyText": "yes, thanks for the change.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#discussion_r453857702", "createdAt": "2020-07-13T18:46:39Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -184,19 +188,14 @@ private void getProcessedFeatures(\n         long endTime,\n         ActionListener<SinglePointFeatures> listener\n     ) {\n-        if (shingle.isEmpty() || shingle.getLast().getKey() < endTime || !shingle.getLast().getValue().isPresent()) {\n-            listener.onResponse(new SinglePointFeatures(Optional.empty(), Optional.empty()));\n-        } else {\n-            double[][] currentPoints = filterAndFill(shingle, endTime, detector);\n-            Optional<double[]> currentPoint = shingle.peekLast().getValue();\n-            listener\n-                .onResponse(\n-                    Optional\n-                        .ofNullable(currentPoints)\n-                        .map(points -> new SinglePointFeatures(currentPoint, Optional.of(batchShingle(points, shingleSize)[0])))\n-                        .orElse(new SinglePointFeatures(currentPoint, Optional.empty()))\n-                );\n-        }\n+        Optional<double[]> currentPoint = shingle.peekLast().getValue();\n+        listener\n+            .onResponse(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2MTg1Mg=="}, "originalCommit": {"oid": "d052f0566e71c93bd3ac09faad3c7aa934ecd7a0"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf9efebefca5df7902075907f162469f61b86edd", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/cf9efebefca5df7902075907f162469f61b86edd", "committedDate": "2020-07-15T01:00:34Z", "message": "Adds comments/function documents for clarification."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "636f293713837599b2eddc56fea398892102b3dd", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/636f293713837599b2eddc56fea398892102b3dd", "committedDate": "2020-07-15T01:00:46Z", "message": "Merge branch 'master' of https://github.com/opendistro-for-elasticsearch/anomaly-detection into fill-shingle-with-history"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "484df6819cade756bd4dd5e0817cf7fbdd7e87a1", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/484df6819cade756bd4dd5e0817cf7fbdd7e87a1", "committedDate": "2020-07-14T02:04:28Z", "message": "Adds comments/function documents for clarification."}, "afterCommit": {"oid": "636f293713837599b2eddc56fea398892102b3dd", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/636f293713837599b2eddc56fea398892102b3dd", "committedDate": "2020-07-15T01:00:46Z", "message": "Merge branch 'master' of https://github.com/opendistro-for-elasticsearch/anomaly-detection into fill-shingle-with-history"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937a74223305c615e40d6fe7f337aebe903dd220", "author": {"user": {"login": "LiuJoyceC", "name": "Joyce Liu"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/937a74223305c615e40d6fe7f337aebe903dd220", "committedDate": "2020-07-15T20:54:32Z", "message": "Updates line in documentation causing build to fail."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDA0MTky", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/176#pullrequestreview-449404192", "createdAt": "2020-07-15T23:12:21Z", "commit": {"oid": "937a74223305c615e40d6fe7f337aebe903dd220"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1492, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}