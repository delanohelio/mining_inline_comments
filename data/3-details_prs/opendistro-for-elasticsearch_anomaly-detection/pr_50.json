{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNjUzMjg1", "number": 50, "title": "support return AD job when get detector", "bodyText": "Add job disabled time\nSupport return AD job when get detector if set ?job=true\nTune start job logic:\n1). If job not exists, create new job.\n2). If job exists: a). if job state is enabled, return warning message; b). if job state is disabled, enable job.\nTune stop job logic:\n1). If job not exists, return error message\n2). If job exists: a).if job state is disabled, return warning message; b).if job state is enabled, disable job and stop AD model.\nTune delete detector logic:\n1). If no AD job index or AD job not found or AD job is disabled, delete detector directly\n2). If AD job state is enabled, return warning message, not delete detector", "createdAt": "2020-02-29T00:03:13Z", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50", "merged": true, "mergeCommit": {"oid": "6b265d4e757f3d14f25a31c98eca93e864ac2d9d"}, "closed": true, "closedAt": "2020-03-06T04:51:29Z", "author": {"login": "ylwu-amzn"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI42U9AH2gAyMzgxNjUzMjg1OmVmMmY3ZDk1MTEzZTEzM2I1MDE0NGQ1NDY3OGQ1NTAyYWY2MzI5ZGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcK4k32gFqTM3MDA3ODY2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db", "author": {"user": {"login": "ylwu-amzn", "name": "Yaliang"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/ef2f7d95113e133b50144d54678d5502af6329db", "committedDate": "2020-02-28T23:51:30Z", "message": "support return AD job when get detector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjgwMTM3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#pullrequestreview-367680137", "createdAt": "2020-03-03T03:22:10Z", "commit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzoyMjoxMFrOFw3JBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNToyMzo0MlrOFw4tTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3OTM5OQ==", "bodyText": "What does disabledTime != null and isEnabled = true mean?  It means the job has been disabled before and enabled after that? So does\neanbledTime > disabledTime => isEnabled = true\neanbledTime < disabledTime => isEnabled = false\neanbledTime = disabledTime => isEnabled = undefined\n?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386779399", "createdAt": "2020-03-03T03:22:10Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "diffHunk": "@@ -85,6 +92,7 @@ public static AnomalyDetectorJob parse(XContentParser parser) throws IOException\n         Schedule schedule = null;\n         Boolean isEnabled = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ==", "bodyText": "What if response.getShardInfo() return null or response is null?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386780355", "createdAt": "2020-03-03T03:26:22Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NjkzNA==", "bodyText": "return after sending response?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386796934", "createdAt": "2020-03-03T04:45:37Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ==", "bodyText": "so function does not send back response using channel?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386797075", "createdAt": "2020-03-03T04:46:14Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwNTA2OA==", "bodyText": "Why not using response.getResult() != DocWriteResponse.Result.CREATED && response.getResult() != DocWriteResponse.Result.UPDATED?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386805068", "createdAt": "2020-03-03T05:23:42Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjMwOTY5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#pullrequestreview-368230969", "createdAt": "2020-03-03T18:44:52Z", "commit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODo0NDo1MlrOFxSAGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODo0NDo1MlrOFxSAGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQ4Mg==", "bodyText": "It looks like deleteAnomalyDetectorJobDoc is only executed when given specific detector_id, no AD job is found. I think we may directly delete AD, or delete it if AD job is found but disabled.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387219482", "createdAt": "2020-03-03T18:44:52Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "diffHunk": "@@ -69,10 +74,40 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n         return channel -> {\n             logger.info(\"Delete anomaly detector {}\", detectorId);\n             handler\n-                .getDetectorJob(clusterService, client, detectorId, channel, () -> deleteAnomalyDetectorDoc(client, detectorId, channel));\n+                .getDetectorJob(\n+                    clusterService,\n+                    client,\n+                    detectorId,\n+                    channel,\n+                    () -> deleteAnomalyDetectorJobDoc(client, detectorId, channel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjY2OTEw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#pullrequestreview-368266910", "createdAt": "2020-03-03T19:37:15Z", "commit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxOTozNzoxNVrOFxTwFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxOTozNzoxNVrOFxTwFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODE1MA==", "bodyText": "Can we skip this if returnJob is false?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387248150", "createdAt": "2020-03-03T19:37:15Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -103,33 +104,44 @@ public RestResponse buildResponse(MultiGetResponse multiGetResponse) throws Exce\n                             .field(RestHandlerUtils._PRIMARY_TERM, response.getResponse().getPrimaryTerm())\n                             .field(RestHandlerUtils._SEQ_NO, response.getResponse().getSeqNo());\n                         if (!response.getResponse().isSourceEmpty()) {\n-                            XContentParser parser = XContentHelper\n-                                .createParser(\n-                                    channel.request().getXContentRegistry(),\n-                                    LoggingDeprecationHandler.INSTANCE,\n-                                    response.getResponse().getSourceAsBytesRef(),\n-                                    XContentType.JSON\n-                                );\n-                            try {\n+                            try (\n+                                XContentParser parser = RestHandlerUtils\n+                                    .createXContentParser(channel, response.getResponse().getSourceAsBytesRef())\n+                            ) {\n                                 ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n                                 detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n                             } catch (Throwable t) {\n                                 logger.error(\"Fail to parse detector\", t);\n-                                throw t;\n-                            } finally {\n-                                parser.close();\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector with id: \" + detectorId\n+                                );\n                             }\n                         }\n                     }\n \n                     if (ANOMALY_DETECTOR_JOB_INDEX.equals(response.getIndex())) {\n-                        if (!response.isFailed() && response.getResponse().isExists()) {\n-                            adJobEnabled = true;\n+                        if (response.getResponse() != null\n+                            && response.getResponse().isExists()\n+                            && !response.getResponse().isSourceEmpty()) {\n+                            try (XContentParser parser = createXContentParser(channel, response.getResponse().getSourceAsBytesRef())) {\n+                                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                                adJob = AnomalyDetectorJob.parse(parser);\n+                            } catch (Throwable t) {\n+                                logger.error(\"Fail to parse detector job \", t);\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector job with id: \" + detectorId\n+                                );\n+                            }\n                         }\n                     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7090b9e96ef11b27a19158ab2aa4c9d62e8a4a68", "author": {"user": {"login": "ylwu-amzn", "name": "Yaliang"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/7090b9e96ef11b27a19158ab2aa4c9d62e8a4a68", "committedDate": "2020-03-04T02:11:06Z", "message": "fix comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a50ffd8f43893f7880a2d18ee5c9975afdd92f2", "author": {"user": {"login": "ylwu-amzn", "name": "Yaliang"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8a50ffd8f43893f7880a2d18ee5c9975afdd92f2", "committedDate": "2020-03-04T23:30:35Z", "message": "handle null index response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MjQ4ODU3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#pullrequestreview-369248857", "createdAt": "2020-03-05T01:55:48Z", "commit": {"oid": "8a50ffd8f43893f7880a2d18ee5c9975afdd92f2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5e8396af18f44519f877abb35b9b71757dffe16", "author": {"user": {"login": "ylwu-amzn", "name": "Yaliang"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b5e8396af18f44519f877abb35b9b71757dffe16", "committedDate": "2020-03-06T04:27:00Z", "message": "add comment on ad function interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDc4NjYx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#pullrequestreview-370078661", "createdAt": "2020-03-06T04:40:11Z", "commit": {"oid": "b5e8396af18f44519f877abb35b9b71757dffe16"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0MDoxMVrOFys-yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0MDoxMVrOFys-yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDA5MQ==", "bodyText": "response -> responds", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r388710091", "createdAt": "2020-03-06T04:40:11Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/AnomalyDetectorFunction.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n     /**\n      * Performs this operation.\n+     *\n+     * Notes: don't forget to send back response via channel if you process response with this method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e8396af18f44519f877abb35b9b71757dffe16"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1625, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}