{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDk3MTgx", "number": 298, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1MzoyNlrOEznYWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTozOToxMlrOEzqDrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTU4MDQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1MzoyNlrOHq9DFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozMTowMlrOHq_NZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ1Mw==", "bodyText": "minor: can we combine these 2 if into single one?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514802453", "createdAt": "2020-10-30T03:53:26Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -70,82 +71,112 @@\n import com.amazon.opendistroforelasticsearch.ad.util.ExceptionUtil;\n import com.amazon.opendistroforelasticsearch.ad.util.MultiResponsesDelegateActionListener;\n \n-public class AnomalyDetectorProfileRunner {\n+public class AnomalyDetectorProfileRunner extends AbstractProfileRunner {\n     private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n     private Client client;\n     private NamedXContentRegistry xContentRegistry;\n     private DiscoveryNodeFilterer nodeFilter;\n-    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n-    static String FAIL_TO_GET_PROFILE_MSG = \"Fail to get profile for detector \";\n-    static String FAIL_TO_GET_TOTAL_ENTITIES = \"Failed to get total entities for detector \";\n-    private long requiredSamples;\n \n     public AnomalyDetectorProfileRunner(\n         Client client,\n         NamedXContentRegistry xContentRegistry,\n         DiscoveryNodeFilterer nodeFilter,\n         long requiredSamples\n     ) {\n+        super(requiredSamples);\n         this.client = client;\n         this.xContentRegistry = xContentRegistry;\n         this.nodeFilter = nodeFilter;\n         if (requiredSamples <= 0) {\n             throw new IllegalArgumentException(\"required samples should be a positive number, but was \" + requiredSamples);\n         }\n-        this.requiredSamples = requiredSamples;\n     }\n \n-    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<ProfileName> profilesToCollect) {\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<DetectorProfileName> profilesToCollect) {\n \n         if (profilesToCollect.isEmpty()) {\n             listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n             return;\n         }\n \n-        // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide when to consolidate results\n-        // and return to users\n-        int totalListener = 0;\n-\n-        if (profilesToCollect.contains(ProfileName.STATE)) {\n-            totalListener++;\n-        }\n-\n-        if (profilesToCollect.contains(ProfileName.ERROR)) {\n-            totalListener++;\n-        }\n+        calculateTotalResponsesToWait(detectorId, profilesToCollect, listener);\n+    }\n \n-        if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n-            totalListener++;\n-        }\n+    private void calculateTotalResponsesToWait(\n+        String detectorId,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ActionListener<DetectorProfile> listener\n+    ) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, ActionListener.wrap(getDetectorResponse -> {\n+            if (getDetectorResponse != null && getDetectorResponse.isExists()) {\n+                try (\n+                    XContentParser xContentParser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getDetectorResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, xContentParser.nextToken(), xContentParser::getTokenLocation);\n+                    AnomalyDetector detector = AnomalyDetector.parse(xContentParser, detectorId);\n+                    boolean isMultiEntityDetector = detector.isMultientityDetector();\n \n-        if (profilesToCollect.contains(ProfileName.COORDINATING_NODE)\n-            || profilesToCollect.contains(ProfileName.SHINGLE_SIZE)\n-            || profilesToCollect.contains(ProfileName.TOTAL_SIZE_IN_BYTES)\n-            || profilesToCollect.contains(ProfileName.MODELS)\n-            || profilesToCollect.contains(ProfileName.ACTIVE_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    int totalResponsesToWait = 0;\n \n-        if (profilesToCollect.contains(ProfileName.TOTAL_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    if (profilesToCollect.contains(DetectorProfileName.ERROR)) {\n+                        totalResponsesToWait++;\n+                    }\n \n-        MultiResponsesDelegateActionListener<DetectorProfile> delegateListener = new MultiResponsesDelegateActionListener<DetectorProfile>(\n-            listener,\n-            totalListener,\n-            \"Fail to fetch profile for \" + detectorId,\n-            false\n-        );\n+                    // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide\n+                    // when to consolidate results and return to users\n+                    if (isMultiEntityDetector) {\n+                        if (profilesToCollect.contains(DetectorProfileName.TOTAL_ENTITIES)) {\n+                            totalResponsesToWait++;\n+                        }\n+                        if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)\n+                            || profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)\n+                            || profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)\n+                            || profilesToCollect.contains(DetectorProfileName.MODELS)\n+                            || profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)\n+                            || profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                            || profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                            totalResponsesToWait++;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgzNzg2MQ==", "bodyText": "I separate them on purpose.  Each group will cost MultiResponsesDelegateActionListener one response.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514837861", "createdAt": "2020-10-30T04:31:02Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -70,82 +71,112 @@\n import com.amazon.opendistroforelasticsearch.ad.util.ExceptionUtil;\n import com.amazon.opendistroforelasticsearch.ad.util.MultiResponsesDelegateActionListener;\n \n-public class AnomalyDetectorProfileRunner {\n+public class AnomalyDetectorProfileRunner extends AbstractProfileRunner {\n     private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n     private Client client;\n     private NamedXContentRegistry xContentRegistry;\n     private DiscoveryNodeFilterer nodeFilter;\n-    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n-    static String FAIL_TO_GET_PROFILE_MSG = \"Fail to get profile for detector \";\n-    static String FAIL_TO_GET_TOTAL_ENTITIES = \"Failed to get total entities for detector \";\n-    private long requiredSamples;\n \n     public AnomalyDetectorProfileRunner(\n         Client client,\n         NamedXContentRegistry xContentRegistry,\n         DiscoveryNodeFilterer nodeFilter,\n         long requiredSamples\n     ) {\n+        super(requiredSamples);\n         this.client = client;\n         this.xContentRegistry = xContentRegistry;\n         this.nodeFilter = nodeFilter;\n         if (requiredSamples <= 0) {\n             throw new IllegalArgumentException(\"required samples should be a positive number, but was \" + requiredSamples);\n         }\n-        this.requiredSamples = requiredSamples;\n     }\n \n-    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<ProfileName> profilesToCollect) {\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<DetectorProfileName> profilesToCollect) {\n \n         if (profilesToCollect.isEmpty()) {\n             listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n             return;\n         }\n \n-        // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide when to consolidate results\n-        // and return to users\n-        int totalListener = 0;\n-\n-        if (profilesToCollect.contains(ProfileName.STATE)) {\n-            totalListener++;\n-        }\n-\n-        if (profilesToCollect.contains(ProfileName.ERROR)) {\n-            totalListener++;\n-        }\n+        calculateTotalResponsesToWait(detectorId, profilesToCollect, listener);\n+    }\n \n-        if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n-            totalListener++;\n-        }\n+    private void calculateTotalResponsesToWait(\n+        String detectorId,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ActionListener<DetectorProfile> listener\n+    ) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, ActionListener.wrap(getDetectorResponse -> {\n+            if (getDetectorResponse != null && getDetectorResponse.isExists()) {\n+                try (\n+                    XContentParser xContentParser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getDetectorResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, xContentParser.nextToken(), xContentParser::getTokenLocation);\n+                    AnomalyDetector detector = AnomalyDetector.parse(xContentParser, detectorId);\n+                    boolean isMultiEntityDetector = detector.isMultientityDetector();\n \n-        if (profilesToCollect.contains(ProfileName.COORDINATING_NODE)\n-            || profilesToCollect.contains(ProfileName.SHINGLE_SIZE)\n-            || profilesToCollect.contains(ProfileName.TOTAL_SIZE_IN_BYTES)\n-            || profilesToCollect.contains(ProfileName.MODELS)\n-            || profilesToCollect.contains(ProfileName.ACTIVE_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    int totalResponsesToWait = 0;\n \n-        if (profilesToCollect.contains(ProfileName.TOTAL_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    if (profilesToCollect.contains(DetectorProfileName.ERROR)) {\n+                        totalResponsesToWait++;\n+                    }\n \n-        MultiResponsesDelegateActionListener<DetectorProfile> delegateListener = new MultiResponsesDelegateActionListener<DetectorProfile>(\n-            listener,\n-            totalListener,\n-            \"Fail to fetch profile for \" + detectorId,\n-            false\n-        );\n+                    // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide\n+                    // when to consolidate results and return to users\n+                    if (isMultiEntityDetector) {\n+                        if (profilesToCollect.contains(DetectorProfileName.TOTAL_ENTITIES)) {\n+                            totalResponsesToWait++;\n+                        }\n+                        if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)\n+                            || profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)\n+                            || profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)\n+                            || profilesToCollect.contains(DetectorProfileName.MODELS)\n+                            || profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)\n+                            || profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                            || profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                            totalResponsesToWait++;\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ1Mw=="}, "originalCommit": {"oid": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTYzNDQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/caching/EntityCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDowMzo0NVrOHq9prQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozMjoxM1rOHq_Rfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgxMjMzMw==", "bodyText": "just name it getLastActiveModels", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514812333", "createdAt": "2020-10-30T04:03:45Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/caching/EntityCache.java", "diffHunk": "@@ -81,4 +83,19 @@\n      * @return list of modelStates\n      */\n     List<ModelState<?>> getAllModels();\n+\n+    /**\n+     * Return when the last active time of an entity's state.\n+     *\n+     * If the entity's state is active in the cache, the value indicates when the cache\n+     * is lastly accessed (get/put).  If the entity's state is inactive in the cache,\n+     * the value indicates when the cache state is created or when the entity is evicted\n+     * from active entity cache.\n+     *\n+     * @param detectorId The Id of the detector that an entity belongs to\n+     * @param entityModelId Entity's Model Id\n+     * @return if the entity is in the cache, return the timestamp in epoch\n+     * milliseconds when the entity's state is lastly used.  Otherwise, return -1.\n+     */\n+    long getLastActiveMs(String detectorId, String entityModelId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgzODkxMQ==", "bodyText": "For \"Ms\", I meant milliseconds.  Please see https://en.wikipedia.org/wiki/Millisecond.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514838911", "createdAt": "2020-10-30T04:32:13Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/caching/EntityCache.java", "diffHunk": "@@ -81,4 +83,19 @@\n      * @return list of modelStates\n      */\n     List<ModelState<?>> getAllModels();\n+\n+    /**\n+     * Return when the last active time of an entity's state.\n+     *\n+     * If the entity's state is active in the cache, the value indicates when the cache\n+     * is lastly accessed (get/put).  If the entity's state is inactive in the cache,\n+     * the value indicates when the cache state is created or when the entity is evicted\n+     * from active entity cache.\n+     *\n+     * @param detectorId The Id of the detector that an entity belongs to\n+     * @param entityModelId Entity's Model Id\n+     * @return if the entity is in the cache, return the timestamp in epoch\n+     * milliseconds when the entity's state is lastly used.  Otherwise, return -1.\n+     */\n+    long getLastActiveMs(String detectorId, String entityModelId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgxMjMzMw=="}, "originalCommit": {"oid": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjAxOTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNTozOToxMlrOHrB5PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjoxODo0MFrOHrChEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw==", "bodyText": "If a running detector stopped, then restart but not pass initialization yet. We can find anomaly results with anomaly score > 0 as the detector was running before. We can't tell the detector is at running status exactly for this case.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514881853", "createdAt": "2020-10-30T05:39:12Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -409,76 +358,126 @@ private void profileStateRelated(\n         });\n     }\n \n-    private InitProgressProfile computeInitProgressProfile(long totalUpdates, long intervalMins) {\n-        float percent = Math.min((100.0f * totalUpdates) / requiredSamples, 100.0f);\n-        int neededPoints = (int) (requiredSamples - totalUpdates);\n-        return new InitProgressProfile(\n-            // rounding: 93.456 => 93%, 93.556 => 94%\n-            String.format(\"%.0f%%\", percent),\n-            intervalMins * neededPoints,\n-            neededPoints\n-        );\n-    }\n-\n     private void profileModels(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profiles,\n+        AnomalyDetectorJob job,\n+        boolean forMultiEntityDetector,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n         DiscoveryNode[] dataNodes = nodeFilter.getEligibleDataNodes();\n-        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, dataNodes);\n-        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, enabled, listener));\n-    }\n-\n-    private boolean isHCDetector(AnomalyDetector detector) {\n-        return detector != null && detector.getCategoryField() != null && detector.getCategoryField().size() > 0;\n+        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, forMultiEntityDetector, dataNodes);\n+        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, job, listener));\n     }\n \n     private ActionListener<ProfileResponse> onModelResponse(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetectorJob job,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n-        boolean isHCDetector = isHCDetector(detector);\n+        boolean isMultientityDetector = detector.isMultientityDetector();\n         return ActionListener.wrap(profileResponse -> {\n             DetectorProfile.Builder profile = new DetectorProfile.Builder();\n-            if (profiles.contains(ProfileName.COORDINATING_NODE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)) {\n                 profile.coordinatingNode(profileResponse.getCoordinatingNode());\n             }\n-            if (profiles.contains(ProfileName.SHINGLE_SIZE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)) {\n                 profile.shingleSize(profileResponse.getShingleSize());\n             }\n-            if (profiles.contains(ProfileName.TOTAL_SIZE_IN_BYTES)) {\n+            if (profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)) {\n                 profile.totalSizeInBytes(profileResponse.getTotalSizeInBytes());\n             }\n-            if (profiles.contains(ProfileName.MODELS)) {\n+            if (profilesToCollect.contains(DetectorProfileName.MODELS)) {\n                 profile.modelProfile(profileResponse.getModelProfile());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.ACTIVE_ENTITIES)) {\n+            if (isMultientityDetector && profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)) {\n                 profile.activeEntities(profileResponse.getActiveEntities());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.INIT_PROGRESS)) {\n-                long totalUpdates = profileResponse.getTotalUpdates();\n-                long intervalMins = totalUpdates == 0\n-                    ? 0\n-                    : ((IntervalTimeConfiguration) detector.getDetectionInterval()).toDuration().toMinutes();\n-                InitProgressProfile initProgress = computeInitProgressProfile(totalUpdates, intervalMins);\n-                profile.initProgress(initProgress);\n+\n+            if (isMultientityDetector\n+                && (profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                    || profilesToCollect.contains(DetectorProfileName.STATE))) {\n+                profileMultiEntityDetectorStateRelated(job, profilesToCollect, profileResponse, profile, detector, listener);\n+            } else {\n+                listener.onResponse(profile.build());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.STATE)) {\n-                DetectorState state;\n-                if (enabled) {\n-                    state = profileResponse.getTotalUpdates() < requiredSamples ? DetectorState.INIT : DetectorState.RUNNING;\n-                } else {\n-                    state = DetectorState.DISABLED;\n-                }\n-                listener.onResponse(new DetectorProfile.Builder().state(state).build());\n+        }, listener::onFailure);\n+    }\n+\n+    private void profileMultiEntityDetectorStateRelated(\n+        AnomalyDetectorJob job,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ProfileResponse profileResponse,\n+        DetectorProfile.Builder profileBuilder,\n+        AnomalyDetector detector,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        if (job.isEnabled()) {\n+            if (profileResponse.getTotalUpdates() < requiredSamples) {\n+                // need to double check since what ProfileResponse returns is the highest priority entity currently in memory, but\n+                // another entity might have already been initialized and sit somewhere else (in memory or on disk).\n+                confirmMultiEntityDetectorInitStatus(\n+                    detector,\n+                    job.getEnabledTime().toEpochMilli(),\n+                    profileBuilder,\n+                    profilesToCollect,\n+                    profileResponse.getTotalUpdates(),\n+                    listener\n+                );\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);\n+                listener.onResponse(profileBuilder.build());\n+            }\n+        } else {\n+            if (profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                profileBuilder.state(DetectorState.DISABLED);\n             }\n+            listener.onResponse(profileBuilder.build());\n+        }\n+    }\n \n-            listener.onResponse(profile.build());\n-        }, listener::onFailure);\n+    private void confirmMultiEntityDetectorInitStatus(\n+        AnomalyDetector detector,\n+        long enabledTime,\n+        DetectorProfile.Builder profile,\n+        Set<DetectorProfileName> profilesToCollect,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        SearchRequest searchLatestResult = createInittedEverRequest(detector.getDetectorId(), enabledTime);\n+        client.search(searchLatestResult, onInittedEver(enabledTime, profile, profilesToCollect, detector, totalUpdates, listener));\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        long lastUpdateTimeMs,\n+        DetectorProfile.Builder profileBuilder,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetector detector,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                processInitResponse(detector, profilesToCollect, totalUpdates, false, profileBuilder, listener);\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43af49703df31b4e723a726fdf9744145f47f97"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4NjAyNw==", "bodyText": "I am searching records older than the job's enabled time.  Does that cover the issue you mentioned?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514886027", "createdAt": "2020-10-30T05:55:56Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -409,76 +358,126 @@ private void profileStateRelated(\n         });\n     }\n \n-    private InitProgressProfile computeInitProgressProfile(long totalUpdates, long intervalMins) {\n-        float percent = Math.min((100.0f * totalUpdates) / requiredSamples, 100.0f);\n-        int neededPoints = (int) (requiredSamples - totalUpdates);\n-        return new InitProgressProfile(\n-            // rounding: 93.456 => 93%, 93.556 => 94%\n-            String.format(\"%.0f%%\", percent),\n-            intervalMins * neededPoints,\n-            neededPoints\n-        );\n-    }\n-\n     private void profileModels(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profiles,\n+        AnomalyDetectorJob job,\n+        boolean forMultiEntityDetector,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n         DiscoveryNode[] dataNodes = nodeFilter.getEligibleDataNodes();\n-        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, dataNodes);\n-        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, enabled, listener));\n-    }\n-\n-    private boolean isHCDetector(AnomalyDetector detector) {\n-        return detector != null && detector.getCategoryField() != null && detector.getCategoryField().size() > 0;\n+        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, forMultiEntityDetector, dataNodes);\n+        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, job, listener));\n     }\n \n     private ActionListener<ProfileResponse> onModelResponse(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetectorJob job,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n-        boolean isHCDetector = isHCDetector(detector);\n+        boolean isMultientityDetector = detector.isMultientityDetector();\n         return ActionListener.wrap(profileResponse -> {\n             DetectorProfile.Builder profile = new DetectorProfile.Builder();\n-            if (profiles.contains(ProfileName.COORDINATING_NODE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)) {\n                 profile.coordinatingNode(profileResponse.getCoordinatingNode());\n             }\n-            if (profiles.contains(ProfileName.SHINGLE_SIZE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)) {\n                 profile.shingleSize(profileResponse.getShingleSize());\n             }\n-            if (profiles.contains(ProfileName.TOTAL_SIZE_IN_BYTES)) {\n+            if (profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)) {\n                 profile.totalSizeInBytes(profileResponse.getTotalSizeInBytes());\n             }\n-            if (profiles.contains(ProfileName.MODELS)) {\n+            if (profilesToCollect.contains(DetectorProfileName.MODELS)) {\n                 profile.modelProfile(profileResponse.getModelProfile());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.ACTIVE_ENTITIES)) {\n+            if (isMultientityDetector && profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)) {\n                 profile.activeEntities(profileResponse.getActiveEntities());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.INIT_PROGRESS)) {\n-                long totalUpdates = profileResponse.getTotalUpdates();\n-                long intervalMins = totalUpdates == 0\n-                    ? 0\n-                    : ((IntervalTimeConfiguration) detector.getDetectionInterval()).toDuration().toMinutes();\n-                InitProgressProfile initProgress = computeInitProgressProfile(totalUpdates, intervalMins);\n-                profile.initProgress(initProgress);\n+\n+            if (isMultientityDetector\n+                && (profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                    || profilesToCollect.contains(DetectorProfileName.STATE))) {\n+                profileMultiEntityDetectorStateRelated(job, profilesToCollect, profileResponse, profile, detector, listener);\n+            } else {\n+                listener.onResponse(profile.build());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.STATE)) {\n-                DetectorState state;\n-                if (enabled) {\n-                    state = profileResponse.getTotalUpdates() < requiredSamples ? DetectorState.INIT : DetectorState.RUNNING;\n-                } else {\n-                    state = DetectorState.DISABLED;\n-                }\n-                listener.onResponse(new DetectorProfile.Builder().state(state).build());\n+        }, listener::onFailure);\n+    }\n+\n+    private void profileMultiEntityDetectorStateRelated(\n+        AnomalyDetectorJob job,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ProfileResponse profileResponse,\n+        DetectorProfile.Builder profileBuilder,\n+        AnomalyDetector detector,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        if (job.isEnabled()) {\n+            if (profileResponse.getTotalUpdates() < requiredSamples) {\n+                // need to double check since what ProfileResponse returns is the highest priority entity currently in memory, but\n+                // another entity might have already been initialized and sit somewhere else (in memory or on disk).\n+                confirmMultiEntityDetectorInitStatus(\n+                    detector,\n+                    job.getEnabledTime().toEpochMilli(),\n+                    profileBuilder,\n+                    profilesToCollect,\n+                    profileResponse.getTotalUpdates(),\n+                    listener\n+                );\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);\n+                listener.onResponse(profileBuilder.build());\n+            }\n+        } else {\n+            if (profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                profileBuilder.state(DetectorState.DISABLED);\n             }\n+            listener.onResponse(profileBuilder.build());\n+        }\n+    }\n \n-            listener.onResponse(profile.build());\n-        }, listener::onFailure);\n+    private void confirmMultiEntityDetectorInitStatus(\n+        AnomalyDetector detector,\n+        long enabledTime,\n+        DetectorProfile.Builder profile,\n+        Set<DetectorProfileName> profilesToCollect,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        SearchRequest searchLatestResult = createInittedEverRequest(detector.getDetectorId(), enabledTime);\n+        client.search(searchLatestResult, onInittedEver(enabledTime, profile, profilesToCollect, detector, totalUpdates, listener));\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        long lastUpdateTimeMs,\n+        DetectorProfile.Builder profileBuilder,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetector detector,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                processInitResponse(detector, profilesToCollect, totalUpdates, false, profileBuilder, listener);\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw=="}, "originalCommit": {"oid": "b43af49703df31b4e723a726fdf9744145f47f97"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5MjA0OQ==", "bodyText": "Cool, make sense.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514892049", "createdAt": "2020-10-30T06:18:40Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -409,76 +358,126 @@ private void profileStateRelated(\n         });\n     }\n \n-    private InitProgressProfile computeInitProgressProfile(long totalUpdates, long intervalMins) {\n-        float percent = Math.min((100.0f * totalUpdates) / requiredSamples, 100.0f);\n-        int neededPoints = (int) (requiredSamples - totalUpdates);\n-        return new InitProgressProfile(\n-            // rounding: 93.456 => 93%, 93.556 => 94%\n-            String.format(\"%.0f%%\", percent),\n-            intervalMins * neededPoints,\n-            neededPoints\n-        );\n-    }\n-\n     private void profileModels(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profiles,\n+        AnomalyDetectorJob job,\n+        boolean forMultiEntityDetector,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n         DiscoveryNode[] dataNodes = nodeFilter.getEligibleDataNodes();\n-        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, dataNodes);\n-        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, enabled, listener));\n-    }\n-\n-    private boolean isHCDetector(AnomalyDetector detector) {\n-        return detector != null && detector.getCategoryField() != null && detector.getCategoryField().size() > 0;\n+        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, forMultiEntityDetector, dataNodes);\n+        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, job, listener));\n     }\n \n     private ActionListener<ProfileResponse> onModelResponse(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetectorJob job,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n-        boolean isHCDetector = isHCDetector(detector);\n+        boolean isMultientityDetector = detector.isMultientityDetector();\n         return ActionListener.wrap(profileResponse -> {\n             DetectorProfile.Builder profile = new DetectorProfile.Builder();\n-            if (profiles.contains(ProfileName.COORDINATING_NODE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)) {\n                 profile.coordinatingNode(profileResponse.getCoordinatingNode());\n             }\n-            if (profiles.contains(ProfileName.SHINGLE_SIZE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)) {\n                 profile.shingleSize(profileResponse.getShingleSize());\n             }\n-            if (profiles.contains(ProfileName.TOTAL_SIZE_IN_BYTES)) {\n+            if (profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)) {\n                 profile.totalSizeInBytes(profileResponse.getTotalSizeInBytes());\n             }\n-            if (profiles.contains(ProfileName.MODELS)) {\n+            if (profilesToCollect.contains(DetectorProfileName.MODELS)) {\n                 profile.modelProfile(profileResponse.getModelProfile());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.ACTIVE_ENTITIES)) {\n+            if (isMultientityDetector && profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)) {\n                 profile.activeEntities(profileResponse.getActiveEntities());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.INIT_PROGRESS)) {\n-                long totalUpdates = profileResponse.getTotalUpdates();\n-                long intervalMins = totalUpdates == 0\n-                    ? 0\n-                    : ((IntervalTimeConfiguration) detector.getDetectionInterval()).toDuration().toMinutes();\n-                InitProgressProfile initProgress = computeInitProgressProfile(totalUpdates, intervalMins);\n-                profile.initProgress(initProgress);\n+\n+            if (isMultientityDetector\n+                && (profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                    || profilesToCollect.contains(DetectorProfileName.STATE))) {\n+                profileMultiEntityDetectorStateRelated(job, profilesToCollect, profileResponse, profile, detector, listener);\n+            } else {\n+                listener.onResponse(profile.build());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.STATE)) {\n-                DetectorState state;\n-                if (enabled) {\n-                    state = profileResponse.getTotalUpdates() < requiredSamples ? DetectorState.INIT : DetectorState.RUNNING;\n-                } else {\n-                    state = DetectorState.DISABLED;\n-                }\n-                listener.onResponse(new DetectorProfile.Builder().state(state).build());\n+        }, listener::onFailure);\n+    }\n+\n+    private void profileMultiEntityDetectorStateRelated(\n+        AnomalyDetectorJob job,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ProfileResponse profileResponse,\n+        DetectorProfile.Builder profileBuilder,\n+        AnomalyDetector detector,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        if (job.isEnabled()) {\n+            if (profileResponse.getTotalUpdates() < requiredSamples) {\n+                // need to double check since what ProfileResponse returns is the highest priority entity currently in memory, but\n+                // another entity might have already been initialized and sit somewhere else (in memory or on disk).\n+                confirmMultiEntityDetectorInitStatus(\n+                    detector,\n+                    job.getEnabledTime().toEpochMilli(),\n+                    profileBuilder,\n+                    profilesToCollect,\n+                    profileResponse.getTotalUpdates(),\n+                    listener\n+                );\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);\n+                listener.onResponse(profileBuilder.build());\n+            }\n+        } else {\n+            if (profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                profileBuilder.state(DetectorState.DISABLED);\n             }\n+            listener.onResponse(profileBuilder.build());\n+        }\n+    }\n \n-            listener.onResponse(profile.build());\n-        }, listener::onFailure);\n+    private void confirmMultiEntityDetectorInitStatus(\n+        AnomalyDetector detector,\n+        long enabledTime,\n+        DetectorProfile.Builder profile,\n+        Set<DetectorProfileName> profilesToCollect,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        SearchRequest searchLatestResult = createInittedEverRequest(detector.getDetectorId(), enabledTime);\n+        client.search(searchLatestResult, onInittedEver(enabledTime, profile, profilesToCollect, detector, totalUpdates, listener));\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        long lastUpdateTimeMs,\n+        DetectorProfile.Builder profileBuilder,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetector detector,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                processInitResponse(detector, profilesToCollect, totalUpdates, false, profileBuilder, listener);\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw=="}, "originalCommit": {"oid": "b43af49703df31b4e723a726fdf9744145f47f97"}, "originalPosition": 593}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2804, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}