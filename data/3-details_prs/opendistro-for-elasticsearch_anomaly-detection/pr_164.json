{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3Mjk3MzAz", "number": 164, "title": "Adds initialization progress to profile API", "bodyText": "Issue #, if available:\n#148\nDescription of changes:\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\nInitialization percentage measures how far away we can observe RCF models emitting scores.  The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\nInitialization percent is computed as x/128:\n\nif total updates > 128, x = 128. Otherwise, x is the total updates\n128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.  Estimated minutes to go is computed as needed shingles * detector interval\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\nTesting done:\n\nadds unit tests\nrun e2e tests to verify init_progress number makes sense.\n\nSample output:\nkaituo@dev-dsk-kaituo-2a-74e3f324.us-west-2: ~/code/github/anomaly-detection\n% curl -X GET \"localhost:9200/_opendistro/_anomaly_detection/detectors/eT6_yXIBegfEFVlvLSF3/_profile?_all=true&pretty\"\n{\n  \"state\" : \"INIT\",\n  \"models\" : [\n    {\n      \"model_id\" : \"eT6_yXIBegfEFVlvLSF3_model_rcf_2\",\n      \"model_size_in_bytes\" : 2228224,\n      \"node_id\" : \"4l_Pb26iRLWrFydpEhVBsA\"\n    },\n    {\n      \"model_id\" : \"eT6_yXIBegfEFVlvLSF3_model_rcf_1\",\n      \"model_size_in_bytes\" : 2228224,\n      \"node_id\" : \"09xMkHzuSqOEIyn__syHUQ\"\n    },\n    {\n      \"model_id\" : \"eT6_yXIBegfEFVlvLSF3_model_rcf_0\",\n      \"model_size_in_bytes\" : 2228224,\n      \"node_id\" : \"09xMkHzuSqOEIyn__syHUQ\"\n    },\n    {\n      \"model_id\" : \"eT6_yXIBegfEFVlvLSF3_model_threshold\",\n      \"node_id\" : \"09xMkHzuSqOEIyn__syHUQ\"\n    }\n  ],\n  \"shingle_size\" : 7,\n  \"coordinating_node\" : \"4l_Pb26iRLWrFydpEhVBsA\",\n  \"total_size_in_bytes\" : 6684672,\n  \"init_progress\" : {\n    \"percentage\" : \"70%\",\n    \"estimated_minutes_left\" : 77,\n    \"needed_shingles\" : 77\n  }\n}\n[2020-06-18 16:31:32 PDT] [2020-06-18 23:31:32 UTC]\nkaituo@dev-dsk-kaituo-2a-74e3f324.us-west-2: ~/code/github/anomaly-detection\n% curl -X GET \"localhost:9200/_opendistro/_anomaly_detection/detectors/eT6_yXIBegfEFVlvLSF3/_profile/init_progress,state,error\"\n{\"state\":\"INIT\",\"init_progress\":{\"percentage\":\"70%\",\"estimated_minutes_left\":77,\"needed_shingles\":77}}%\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-06-19T21:11:53Z", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164", "merged": true, "mergeCommit": {"oid": "3d2d420dcf7358004113407cf233ad42c3a915ce"}, "closed": true, "closedAt": "2020-07-14T20:43:24Z", "author": {"login": "kaituo"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABctzThEgBqjM0NjkxODc1MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0r73VgFqTQ0NzcyNjA4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aaed579e7dfcdfdb116f844f9b765b2100e6e433", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/aaed579e7dfcdfdb116f844f9b765b2100e6e433", "committedDate": "2020-06-19T21:10:16Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "committedDate": "2020-06-22T16:14:18Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTA1Njcx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-435105671", "createdAt": "2020-06-22T16:50:22Z", "commit": {"oid": "5f353a6665045b0c9bc75c31e00b356cbbf40bdd"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "committedDate": "2020-06-22T16:14:18Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "e33265c74543911afd775e26607a3b3b3563939b", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/e33265c74543911afd775e26607a3b3b3563939b", "committedDate": "2020-06-25T00:39:42Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e33265c74543911afd775e26607a3b3b3563939b", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/e33265c74543911afd775e26607a3b3b3563939b", "committedDate": "2020-06-25T00:39:42Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "committedDate": "2020-06-26T16:11:38Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NTY5Mjc2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-438569276", "createdAt": "2020-06-26T20:16:07Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMDoxNjowOFrOGpte-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMDo0MjowOFrOGpuHkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MDAwOQ==", "bodyText": "remark. the issue of checked exception is clear here. they bubble up from low levels and raise unhelpful concerns/threats to higher-level in the chain, which, in this case, choose to expose unnecessary implementation.\nwhen there is an unlikely checked exception due to lower-level implementation and the caller is unlikely to act or recover, it's likely a good place to wrap the checked exceptions early on.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446390009", "createdAt": "2020-06-26T20:16:08Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/indices/AnomalyDetectionIndices.java", "diffHunk": "@@ -229,6 +251,18 @@ public void initAnomalyDetectorJobIndex(ActionListener<CreateIndexResponse> acti\n         adminClient.indices().create(request, actionListener);\n     }\n \n+    /**\n+     * Create an index.\n+     *\n+     * @param actionListener action called after create index\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA==", "bodyText": "issue. what happens to a completed but not hosted model (maybe after detector is stopped)?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446398980", "createdAt": "2020-06-26T20:38:35Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).\n+      * @param modelId model id\n+      */\n+    public long getTotalUpdates(String modelId) {\n+        ModelState<RandomCutForest> model = forests.get(modelId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDI2Ng==", "bodyText": "minor. unneeded annotation.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446400266", "createdAt": "2020-06-26T20:41:49Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.\n+ * @author kaituo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDQwMg==", "bodyText": "minor. indentation is off.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446400402", "createdAt": "2020-06-26T20:42:08Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjMxMjE3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-438631217", "createdAt": "2020-06-26T22:36:36Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMjozNjozNlrOGpwfLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMDozNTowNlrOGpx2aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA==", "bodyText": "minor. the comments do not apply to the method.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446439214", "createdAt": "2020-06-26T22:36:36Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjUyMw==", "bodyText": "this case should error out.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446452523", "createdAt": "2020-06-26T23:38:55Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";\n+\n+    public static final String RCF_UPDATES_FIELD = \"rcf_updates\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String ERROR_FIELD = \"error\";\n+\n+    private long rcfUpdates = -1L;\n+    private Instant lastUpdateTime = null;\n+    private String error = null;\n+\n+    private DetectorInternalState() {}\n+\n+    public static class Builder {\n+        private long rcfUpdates = -1;\n+        private Instant lastUpdateTime = null;\n+        private String error = null;\n+\n+        public Builder() {}\n+\n+        public Builder rcfUpdates(long rcfUpdates) {\n+            this.rcfUpdates = rcfUpdates;\n+            return this;\n+        }\n+\n+        public Builder lastUpdateTime(Instant lastUpdateTime) {\n+            this.lastUpdateTime = lastUpdateTime;\n+            return this;\n+        }\n+\n+        public Builder error(String error) {\n+            this.error = error;\n+            return this;\n+        }\n+\n+        public DetectorInternalState build() {\n+            DetectorInternalState state = new DetectorInternalState();\n+            state.rcfUpdates = this.rcfUpdates;\n+            state.lastUpdateTime = this.lastUpdateTime;\n+            state.error = this.error;\n+\n+            return state;\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        XContentBuilder xContentBuilder = builder.startObject();\n+\n+        if (rcfUpdates >= 0) {\n+            xContentBuilder.field(RCF_UPDATES_FIELD, rcfUpdates);\n+        }\n+        if (lastUpdateTime != null) {\n+            xContentBuilder.field(LAST_UPDATE_TIME_FIELD, lastUpdateTime.toEpochMilli());\n+        }\n+        if (error != null) {\n+            xContentBuilder.field(ERROR_FIELD, error);\n+        }\n+        return xContentBuilder.endObject();\n+    }\n+\n+    public static DetectorInternalState parse(XContentParser parser) throws IOException {\n+        long rcfUpdates = -1L;\n+        Instant lastUpdateTime = null;\n+        String error = null;\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation);\n+        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+            String fieldName = parser.currentName();\n+            parser.nextToken();\n+\n+            switch (fieldName) {\n+                case RCF_UPDATES_FIELD:\n+                    rcfUpdates = parser.longValue();\n+                    break;\n+                case LAST_UPDATE_TIME_FIELD:\n+                    lastUpdateTime = ParseUtils.toInstant(parser);\n+                    break;\n+                case ERROR_FIELD:\n+                    error = parser.text();\n+                    break;\n+                default:\n+                    parser.skipChildren();\n+                    break;\n+            }\n+        }\n+        return new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();\n+    }\n+\n+    @Generated\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        DetectorInternalState that = (DetectorInternalState) o;\n+        return Objects.equal(getRcfUpdates(), that.getRcfUpdates())\n+            && Objects.equal(getLastUpdateTime(), that.getLastUpdateTime())\n+            && Objects.equal(getError(), that.getError());\n+    }\n+\n+    @Generated\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(rcfUpdates, lastUpdateTime, error);\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        DetectorInternalState state = null;\n+        try {\n+            state = (DetectorInternalState) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            state = new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ==", "bodyText": "are these maps all keyed by the same detector ids?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454069", "createdAt": "2020-06-26T23:47:57Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -52,6 +53,7 @@\n     private static final Logger LOG = LogManager.getLogger(ADStateManager.class);\n     private ConcurrentHashMap<String, Entry<AnomalyDetector, Instant>> currentDetectors;\n     private ConcurrentHashMap<String, Entry<Integer, Instant>> partitionNumber;\n+    private ConcurrentHashMap<String, Instant> currentCheckpoints;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg==", "bodyText": "doc for this method is missing.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454712", "createdAt": "2020-06-26T23:51:07Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -140,6 +143,30 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw==", "bodyText": "minor. this method should be private", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454947", "createdAt": "2020-06-26T23:52:48Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -176,6 +205,27 @@ public void maintenance() {\n         });\n     }\n \n+    /**\n+     * Clean states if it is older than our stateTtl. The input has to be a\n+     * ConcurrentHashMap otherwise we will have\n+     * java.util.ConcurrentModificationException.\n+     *\n+     * @param flags flags to be maintained\n+     */\n+    void maintenanceFlag(ConcurrentHashMap<String, Instant> flags) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw==", "bodyText": "in other cases, such as when feature is present but actions fail due to other reasons than no model, will model training process begin?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446455917", "createdAt": "2020-06-26T23:58:54Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -287,6 +291,20 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n             }\n \n             if (!featureOptional.getProcessedFeatures().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA==", "bodyText": "remark. if only checked exceptions are not allowed to bubble up in the first place", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446458804", "createdAt": "2020-06-27T00:17:08Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/ThrowingConsumerWrapper.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.function.Consumer;\n+\n+public class ThrowingConsumerWrapper {\n+    /**\n+     * Utility method to use a method throwing checked exception inside a function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDIzMA==", "bodyText": "if rcf has 256 updates, updates on this field are no longer necessary so unnecessary document updates can be skipped. it'd be an unnecessary workload for most data points.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446460230", "createdAt": "2020-06-27T00:26:43Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class TotalRcfUpdatesStrategy implements GetStateStrategy {\n+        private long totalRcfUpdates;\n+\n+        TotalRcfUpdatesStrategy(long totalRcfUpdates) {\n+            this.totalRcfUpdates = totalRcfUpdates;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().rcfUpdates(totalRcfUpdates).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setRcfUpdates(totalRcfUpdates);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+            return newState;\n+        }\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+    }\n+\n+    public void saveRcfUpdates(long totalRcfUpdates, String detectorId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw==", "bodyText": "is it desirable to update state for every result? doubling the indexing workload\none idea for consideration is to cache the state and only update when there is valuable updates such as model updates before 256, latest error if any.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446461547", "createdAt": "2020-06-27T00:35:06Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -436,7 +442,8 @@ private void indexAnomalyResult(\n                 Instant.now(),\n                 response.getError()\n             );\n-            anomalyResultHandler.indexAnomalyResult(anomalyResult);\n+            anomalyResultHandler.index(anomalyResult, detectorId);\n+            detectorStateHandler.saveError(response.getError(), detectorId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Mzk4MzU0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-439398354", "createdAt": "2020-06-29T18:30:30Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODozMDozMVrOGqdGrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOToyNjoyNFrOGqe_Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MDIyMw==", "bodyText": "This is for saving error, not init progress.  We have to call profile API for a detector's error.  Consider dashboard and detector list page, that's a lot of calls for one refresh.  Previously, we search for anomaly result index for each detector's error.  This can cause performance problem, especially after I increased the size of result index.  See #117 for details. Here I materialize the error so we don't need to search.\nCaching error for valuable update does not work as we don't know which error is valuable and when kibana would query for it. So it is desirable to update error for every result.\nAre you saying we should index total rcf updates less than 128?  If so, we don't need messaging you suggested before, right?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447170223", "createdAt": "2020-06-29T18:30:31Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -436,7 +442,8 @@ private void indexAnomalyResult(\n                 Instant.now(),\n                 response.getError()\n             );\n-            anomalyResultHandler.indexAnomalyResult(anomalyResult);\n+            anomalyResultHandler.index(anomalyResult, detectorId);\n+            detectorStateHandler.saveError(response.getError(), detectorId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4OTkwOA==", "bodyText": "I did it. See ThrowingConsumerWrapper.throwingConsumerWrapper.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447189908", "createdAt": "2020-06-29T19:05:11Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/indices/AnomalyDetectionIndices.java", "diffHunk": "@@ -229,6 +251,18 @@ public void initAnomalyDetectorJobIndex(ActionListener<CreateIndexResponse> acti\n         adminClient.indices().create(request, actionListener);\n     }\n \n+    /**\n+     * Create an index.\n+     *\n+     * @param actionListener action called after create index\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MDAwOQ=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MDk4Nw==", "bodyText": "good catch. Fixed.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447190987", "createdAt": "2020-06-29T19:07:10Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MTM1Ng==", "bodyText": "We return 0 in this case.  Any other better way?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447191356", "createdAt": "2020-06-29T19:07:52Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).\n+      * @param modelId model id\n+      */\n+    public long getTotalUpdates(String modelId) {\n+        ModelState<RandomCutForest> model = forests.get(modelId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MjU4MQ==", "bodyText": "fixed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192581", "createdAt": "2020-06-29T19:10:18Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";\n+\n+    public static final String RCF_UPDATES_FIELD = \"rcf_updates\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String ERROR_FIELD = \"error\";\n+\n+    private long rcfUpdates = -1L;\n+    private Instant lastUpdateTime = null;\n+    private String error = null;\n+\n+    private DetectorInternalState() {}\n+\n+    public static class Builder {\n+        private long rcfUpdates = -1;\n+        private Instant lastUpdateTime = null;\n+        private String error = null;\n+\n+        public Builder() {}\n+\n+        public Builder rcfUpdates(long rcfUpdates) {\n+            this.rcfUpdates = rcfUpdates;\n+            return this;\n+        }\n+\n+        public Builder lastUpdateTime(Instant lastUpdateTime) {\n+            this.lastUpdateTime = lastUpdateTime;\n+            return this;\n+        }\n+\n+        public Builder error(String error) {\n+            this.error = error;\n+            return this;\n+        }\n+\n+        public DetectorInternalState build() {\n+            DetectorInternalState state = new DetectorInternalState();\n+            state.rcfUpdates = this.rcfUpdates;\n+            state.lastUpdateTime = this.lastUpdateTime;\n+            state.error = this.error;\n+\n+            return state;\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        XContentBuilder xContentBuilder = builder.startObject();\n+\n+        if (rcfUpdates >= 0) {\n+            xContentBuilder.field(RCF_UPDATES_FIELD, rcfUpdates);\n+        }\n+        if (lastUpdateTime != null) {\n+            xContentBuilder.field(LAST_UPDATE_TIME_FIELD, lastUpdateTime.toEpochMilli());\n+        }\n+        if (error != null) {\n+            xContentBuilder.field(ERROR_FIELD, error);\n+        }\n+        return xContentBuilder.endObject();\n+    }\n+\n+    public static DetectorInternalState parse(XContentParser parser) throws IOException {\n+        long rcfUpdates = -1L;\n+        Instant lastUpdateTime = null;\n+        String error = null;\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation);\n+        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+            String fieldName = parser.currentName();\n+            parser.nextToken();\n+\n+            switch (fieldName) {\n+                case RCF_UPDATES_FIELD:\n+                    rcfUpdates = parser.longValue();\n+                    break;\n+                case LAST_UPDATE_TIME_FIELD:\n+                    lastUpdateTime = ParseUtils.toInstant(parser);\n+                    break;\n+                case ERROR_FIELD:\n+                    error = parser.text();\n+                    break;\n+                default:\n+                    parser.skipChildren();\n+                    break;\n+            }\n+        }\n+        return new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();\n+    }\n+\n+    @Generated\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        DetectorInternalState that = (DetectorInternalState) o;\n+        return Objects.equal(getRcfUpdates(), that.getRcfUpdates())\n+            && Objects.equal(getLastUpdateTime(), that.getLastUpdateTime())\n+            && Objects.equal(getError(), that.getError());\n+    }\n+\n+    @Generated\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(rcfUpdates, lastUpdateTime, error);\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        DetectorInternalState state = null;\n+        try {\n+            state = (DetectorInternalState) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            state = new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjUyMw=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MjkwMw==", "bodyText": "fixed.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192903", "createdAt": "2020-06-29T19:10:58Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDQwMg=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5Mjk1OA==", "bodyText": "removed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192958", "createdAt": "2020-06-29T19:11:05Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.\n+ * @author kaituo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDI2Ng=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NDA4OQ==", "bodyText": "Could you explain your question?\nThis is for starting cold start whenever there is missing checkpoint.  The key is detector id, while the value is the timestamp when we find a checkpoint.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447194089", "createdAt": "2020-06-29T19:13:20Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -52,6 +53,7 @@\n     private static final Logger LOG = LogManager.getLogger(ADStateManager.class);\n     private ConcurrentHashMap<String, Entry<AnomalyDetector, Instant>> currentDetectors;\n     private ConcurrentHashMap<String, Entry<Integer, Instant>> partitionNumber;\n+    private ConcurrentHashMap<String, Instant> currentCheckpoints;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NTI1Nw==", "bodyText": "doc is deprecated.  We should remove doc in checkpointdao.  Do you want me to do that?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447195257", "createdAt": "2020-06-29T19:15:26Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -140,6 +143,30 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NTUxMA==", "bodyText": "I wrote unit tests for it.  That's why I am not using private.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447195510", "createdAt": "2020-06-29T19:15:55Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -176,6 +205,27 @@ public void maintenance() {\n         });\n     }\n \n+    /**\n+     * Clean states if it is older than our stateTtl. The input has to be a\n+     * ConcurrentHashMap otherwise we will have\n+     * java.util.ConcurrentModificationException.\n+     *\n+     * @param flags flags to be maintained\n+     */\n+    void maintenanceFlag(ConcurrentHashMap<String, Instant> flags) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMDA3OQ==", "bodyText": "other reasons could be: circuit breaker is open, cluster is under read/write block, or AD is disabled.  We should not trigger cold start in those cases.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447200079", "createdAt": "2020-06-29T19:24:27Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -287,6 +291,20 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n             }\n \n             if (!featureOptional.getProcessedFeatures().isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMDY3Ng==", "bodyText": "make sense.  I'll modify when you answered my previous question on whether to continue to use on-demand messaging.  Also, we should use 128, right?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447200676", "createdAt": "2020-06-29T19:25:31Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class TotalRcfUpdatesStrategy implements GetStateStrategy {\n+        private long totalRcfUpdates;\n+\n+        TotalRcfUpdatesStrategy(long totalRcfUpdates) {\n+            this.totalRcfUpdates = totalRcfUpdates;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().rcfUpdates(totalRcfUpdates).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setRcfUpdates(totalRcfUpdates);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+            return newState;\n+        }\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+    }\n+\n+    public void saveRcfUpdates(long totalRcfUpdates, String detectorId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDIzMA=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMTEwNw==", "bodyText": "Could you explain your remark?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447201107", "createdAt": "2020-06-29T19:26:24Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/ThrowingConsumerWrapper.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.function.Consumer;\n+\n+public class ThrowingConsumerWrapper {\n+    /**\n+     * Utility method to use a method throwing checked exception inside a function", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA=="}, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzQyMzM2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440342336", "createdAt": "2020-06-30T20:00:07Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDowMDowOFrOGrMXdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDowMDowOFrOGrMXdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NDU2NQ==", "bodyText": "minor, can we rename anomalyResultHandler  as anomalyIndexHandler?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447944565", "createdAt": "2020-06-30T20:00:08Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -170,28 +175,34 @@ public AnomalyDetectorPlugin() {}\n         IndexNameExpressionResolver indexNameExpressionResolver,\n         Supplier<DiscoveryNodes> nodesInCluster\n     ) {\n-        AnomalyResultHandler anomalyResultHandler = new AnomalyResultHandler(\n+\n+        AnomalyIndexHandler<AnomalyResult> anomalyResultHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzUwMjEy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440350212", "createdAt": "2020-06-30T20:11:53Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDoxMTo1M1rOGrMvxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDoxMTo1M1rOGrMvxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MDc4OA==", "bodyText": "How about change to .opendistro-anomaly-detection-state?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447950788", "createdAt": "2020-06-30T20:11:53Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzUxNjY5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440351669", "createdAt": "2020-06-30T20:14:06Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDoxNDowN1rOGrMzzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDoxNDowN1rOGrMzzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MTgyMw==", "bodyText": "Any special consideration for using -1 as default value?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447951823", "createdAt": "2020-06-30T20:14:07Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";\n+\n+    public static final String RCF_UPDATES_FIELD = \"rcf_updates\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String ERROR_FIELD = \"error\";\n+\n+    private long rcfUpdates = -1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzc1MzU2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440375356", "createdAt": "2020-06-30T20:50:12Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1MDoxMlrOGrN8uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1MDoxMlrOGrN8uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ==", "bodyText": "Why need to periodically maintain the checkpoint flag?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447970489", "createdAt": "2020-06-30T20:50:12Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -148,11 +175,13 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n     public void clear(String adID) {\n         currentDetectors.remove(adID);\n         partitionNumber.remove(adID);\n+        currentCheckpoints.remove(adID);\n     }\n \n     public void maintenance() {\n         maintenance(currentDetectors);\n         maintenance(partitionNumber);\n+        maintenanceFlag(currentCheckpoints);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzc3MTQy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440377142", "createdAt": "2020-06-30T20:52:59Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1Mjo1OVrOGrOCRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1Mjo1OVrOGrOCRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTkxMQ==", "bodyText": "If not find checkpoint, we should remove it from currentCheckpoints .\nOne case is if user delete checkpoint manually, we should remove it from currentCheckpoints.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447971911", "createdAt": "2020-06-30T20:52:59Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -140,6 +143,30 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {\n+        Instant timeGettingCheckpoint = currentCheckpoints.get(adID);\n+        if (timeGettingCheckpoint != null) {\n+            currentCheckpoints.put(adID, clock.instant());\n+            listener.onResponse(Boolean.TRUE);\n+            return;\n+        }\n+\n+        GetRequest request = new GetRequest(CommonName.CHECKPOINT_INDEX_NAME, modelManager.getRcfModelId(adID, 0));\n+\n+        clientUtil.<GetRequest, GetResponse>asyncRequest(request, client::get, onGetCheckpointResponse(adID, listener));\n+    }\n+\n+    private ActionListener<GetResponse> onGetCheckpointResponse(String adID, ActionListener<Boolean> listener) {\n+        return ActionListener.wrap(response -> {\n+            if (response == null || !response.isExists()) {\n+                listener.onResponse(Boolean.FALSE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMzgyODQ0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440382844", "createdAt": "2020-06-30T21:01:52Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowMTo1MlrOGrOVJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowMTo1MlrOGrOVJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ==", "bodyText": "For happy case(detector and feature present and circuit breaker not open, no read/write block, AD enabled), will every job run call getDetectorCheckpoint  method?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447976741", "createdAt": "2020-06-30T21:01:52Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -287,6 +291,20 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n             }\n \n             if (!featureOptional.getProcessedFeatures().isPresent()) {\n+                stateManager.getDetectorCheckpoint(adID, ActionListener.wrap(checkpointExists -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDAzMzkz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440403393", "createdAt": "2020-06-30T21:35:29Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTozNToyOVrOGrPU_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTozNToyOVrOGrPU_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MzA4NA==", "bodyText": "Add some comment doc for this class?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447993084", "createdAt": "2020-06-30T21:35:29Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/RCFPollingTransportAction.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+\n+import com.amazon.opendistroforelasticsearch.ad.cluster.HashRing;\n+import com.amazon.opendistroforelasticsearch.ad.common.exception.AnomalyDetectionException;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelManager;\n+import com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings;\n+\n+public class RCFPollingTransportAction extends HandledTransportAction<RCFPollingRequest, RCFPollingResponse> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDE2NTU2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-440416556", "createdAt": "2020-06-30T22:00:14Z", "commit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjowMDoxNFrOGrP_MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjowMDoxNFrOGrP_MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzg4OQ==", "bodyText": "We can save some memory for one detection interval if remove detector from currentCheckpoints, but needs another index query to get checkpoint as almost every detector run will try to get checkpoint. Can we just remove it when detector stopped/deleted?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448003889", "createdAt": "2020-06-30T22:00:14Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -176,6 +205,27 @@ public void maintenance() {\n         });\n     }\n \n+    /**\n+     * Clean states if it is older than our stateTtl. The input has to be a\n+     * ConcurrentHashMap otherwise we will have\n+     * java.util.ConcurrentModificationException.\n+     *\n+     * @param flags flags to be maintained\n+     */\n+    void maintenanceFlag(ConcurrentHashMap<String, Instant> flags) {\n+        flags.entrySet().stream().forEach(entry -> {\n+            String detectorId = entry.getKey();\n+            try {\n+                Instant time = entry.getValue();\n+                if (time.plus(stateTtl).isBefore(clock.instant())) {\n+                    flags.remove(detectorId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd"}, "originalPosition": 99}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "committedDate": "2020-06-26T16:11:38Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "committedDate": "2020-06-30T20:38:59Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "committedDate": "2020-06-30T20:38:59Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "ab8c592eb63ca0553f9a5ee21cee635764cf997c", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/ab8c592eb63ca0553f9a5ee21cee635764cf997c", "committedDate": "2020-07-07T15:58:34Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab8c592eb63ca0553f9a5ee21cee635764cf997c", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/ab8c592eb63ca0553f9a5ee21cee635764cf997c", "committedDate": "2020-07-07T15:58:34Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "9d018b900a75857f6345752429f374f4601f40c8", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9d018b900a75857f6345752429f374f4601f40c8", "committedDate": "2020-07-07T16:10:17Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/670d2a96142e0dff4ebe4d7be1ba165971595de4", "committedDate": "2020-07-07T16:24:48Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d018b900a75857f6345752429f374f4601f40c8", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9d018b900a75857f6345752429f374f4601f40c8", "committedDate": "2020-07-07T16:10:17Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}, "afterCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/670d2a96142e0dff4ebe4d7be1ba165971595de4", "committedDate": "2020-07-07T16:24:48Z", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MjQ2NzM3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-444246737", "createdAt": "2020-07-07T21:01:08Z", "commit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTowMTowOFrOGuPcNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowNjo0OVrOGuRTVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDY2MQ==", "bodyText": "the status will be incorrect for a stopped detector?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451140661", "createdAt": "2020-07-07T21:01:08Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -203,242 +190,120 @@ private void prepareProfile(\n     /**\n      * We expect three kinds of states:\n      *  -Disabled: if get ad job api says the job is disabled;\n-     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Init: if rcf model's total updates is less than required\n      *  -Running: if neither of the above applies and no exceptions.\n      * @param detectorId detector id\n-     * @param enabledTime the time when AD job is enabled in milliseconds\n      * @param listener listener to process the returned state or exception\n      * @param enabled whether the detector job is enabled or not\n+     * @param profilesToCollect target profiles to fetch\n      */\n-    private void profileState(\n+    private void profileStateRelated(\n         String detectorId,\n-        long enabledTime,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        boolean enabled\n+        boolean enabled,\n+        Set<ProfileName> profilesToCollect\n     ) {\n         if (enabled) {\n-            SearchRequest searchLatestResult = createInittedEverRequest(detectorId, enabledTime);\n-            client.search(searchLatestResult, onInittedEver(listener, detectorId, enabledTime));\n+            RCFPollingRequest request = new RCFPollingRequest(detectorId);\n+            client.execute(RCFPollingAction.INSTANCE, request, onPollRCFUpdates(detectorId, profilesToCollect, listener));\n         } else {\n-            DetectorProfile profile = new DetectorProfile();\n-            profile.setState(DetectorState.DISABLED);\n-            listener.onResponse(profile);\n-        }\n-    }\n-\n-    private ActionListener<SearchResponse> onInittedEver(\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        String detectorId,\n-        long lastUpdateTimeMs\n-    ) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            DetectorProfile profile = new DetectorProfile();\n-            if (hits.getHits().length == 0L) {\n-                profile.setState(DetectorState.INIT);\n-            } else {\n-                profile.setState(DetectorState.RUNNING);\n+            if (profilesToCollect.contains(ProfileName.STATE)) {\n+                listener.onResponse(new DetectorProfile.Builder().state(DetectorState.DISABLED).build());\n             }\n-\n-            listener.onResponse(profile);\n-\n-        }, exception -> {\n-            if (exception instanceof IndexNotFoundException) {\n-                DetectorProfile profile = new DetectorProfile();\n-                // anomaly result index is not created yet\n-                profile.setState(DetectorState.INIT);\n-                listener.onResponse(profile);\n-            } else {\n-                logger\n-                    .error(\n-                        \"Fail to find any anomaly result with anomaly score larger than 0 after AD job enabled time for detector {}\",\n-                        detectorId\n-                    );\n-                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n+                listener.onResponse(new DetectorProfile.Builder().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NTc5Ng==", "bodyText": "minor. i have difficulty in understanding this sentence.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451145796", "createdAt": "2020-07-07T21:11:35Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -203,242 +190,120 @@ private void prepareProfile(\n     /**\n      * We expect three kinds of states:\n      *  -Disabled: if get ad job api says the job is disabled;\n-     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Init: if rcf model's total updates is less than required\n      *  -Running: if neither of the above applies and no exceptions.\n      * @param detectorId detector id\n-     * @param enabledTime the time when AD job is enabled in milliseconds\n      * @param listener listener to process the returned state or exception\n      * @param enabled whether the detector job is enabled or not\n+     * @param profilesToCollect target profiles to fetch\n      */\n-    private void profileState(\n+    private void profileStateRelated(\n         String detectorId,\n-        long enabledTime,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        boolean enabled\n+        boolean enabled,\n+        Set<ProfileName> profilesToCollect\n     ) {\n         if (enabled) {\n-            SearchRequest searchLatestResult = createInittedEverRequest(detectorId, enabledTime);\n-            client.search(searchLatestResult, onInittedEver(listener, detectorId, enabledTime));\n+            RCFPollingRequest request = new RCFPollingRequest(detectorId);\n+            client.execute(RCFPollingAction.INSTANCE, request, onPollRCFUpdates(detectorId, profilesToCollect, listener));\n         } else {\n-            DetectorProfile profile = new DetectorProfile();\n-            profile.setState(DetectorState.DISABLED);\n-            listener.onResponse(profile);\n-        }\n-    }\n-\n-    private ActionListener<SearchResponse> onInittedEver(\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        String detectorId,\n-        long lastUpdateTimeMs\n-    ) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            DetectorProfile profile = new DetectorProfile();\n-            if (hits.getHits().length == 0L) {\n-                profile.setState(DetectorState.INIT);\n-            } else {\n-                profile.setState(DetectorState.RUNNING);\n+            if (profilesToCollect.contains(ProfileName.STATE)) {\n+                listener.onResponse(new DetectorProfile.Builder().state(DetectorState.DISABLED).build());\n             }\n-\n-            listener.onResponse(profile);\n-\n-        }, exception -> {\n-            if (exception instanceof IndexNotFoundException) {\n-                DetectorProfile profile = new DetectorProfile();\n-                // anomaly result index is not created yet\n-                profile.setState(DetectorState.INIT);\n-                listener.onResponse(profile);\n-            } else {\n-                logger\n-                    .error(\n-                        \"Fail to find any anomaly result with anomaly score larger than 0 after AD job enabled time for detector {}\",\n-                        detectorId\n-                    );\n-                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n+                listener.onResponse(new DetectorProfile.Builder().build());\n             }\n-        });\n+        }\n     }\n \n     /**\n-     * Precondition:\n-     * 1. Index are rotated with name pattern \".opendistro-anomaly-results-history-{now/d}-1\" and now is using UTC.\n-     * 2. Latest entry with error is recorded within enabled and disabled time.  Note disabled time can be null.\n-     *\n-     * Error is populated if error of the latest anomaly result is not empty.\n-     *\n-     * Two optimization to avoid scanning all anomaly result indices to get a detector's most recent error\n-     *\n-     * First, when a detector is running, we only need to scan the current index, not all of the rolled over ones\n-     *  since we are interested in the latest error.\n-     * Second, when a detector is disabled, we only need to scan the latest anomaly result indices created before the\n-     *  detector's enable time.\n-     *\n+     * Action listener for a detector in running or init state\n+     * @param listener listener to consolidate results and return a final response\n      * @param detectorId detector id\n-     * @param enabledTimeMillis the time when AD job is enabled in milliseconds\n-     * @param listener listener to process the returned error or exception\n+     * @param enabledTimeMs AD job enabled time\n+     * @return the listener for a detector in disabled state\n      */\n-    private void profileError(\n+    private ActionListener<GetResponse> onGetDetectorState(\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n         String detectorId,\n-        long enabledTimeMillis,\n-        Instant disabledTime,\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+        long enabledTimeMs\n     ) {\n-        String[] latestIndex = null;\n-\n-        long disabledTimeMillis = 0;\n-        if (disabledTime != null) {\n-            disabledTimeMillis = disabledTime.toEpochMilli();\n-        }\n-        if (enabledTimeMillis > disabledTimeMillis) {\n-            // detector is still running\n-            latestIndex = new String[1];\n-            latestIndex[0] = AnomalyResult.ANOMALY_RESULT_INDEX;\n-        } else {\n-            String[] concreteIndices = indexNameExpressionResolver\n-                .concreteIndexNames(\n-                    clusterService.state(),\n-                    IndicesOptions.lenientExpandOpen(),\n-                    AnomalyDetectionIndices.ALL_AD_RESULTS_INDEX_PATTERN\n-                );\n-\n-            // find the latest from result indices such as .opendistro-anomaly-results-history-2020.04.06-1 and\n-            // /.opendistro-anomaly-results-history-2020.04.07-000002\n-            long maxTimestamp = -1;\n-            TreeMap<Long, List<String>> candidateIndices = new TreeMap<>();\n-            for (String indexName : concreteIndices) {\n-                Matcher m = Pattern.compile(\"\\\\.opendistro-anomaly-results-history-(\\\\d{4})\\\\.(\\\\d{2})\\\\.(\\\\d{2})-\\\\d+\").matcher(indexName);\n-                if (m.matches()) {\n-                    int year = Integer.parseInt(m.group(1));\n-                    int month = Integer.parseInt(m.group(2));\n-                    int date = Integer.parseInt(m.group(3));\n-                    // month starts with 0\n-                    calendar.clear();\n-                    calendar.set(year, month - 1, date);\n-                    // 2020.05.08 is translated to 1588896000000\n-                    long timestamp = calendar.getTimeInMillis();\n-\n-                    // a candidate index can be created before or after enabled time, but the index is definitely created before disabled\n-                    // time\n-                    if (timestamp <= disabledTimeMillis && maxTimestamp <= timestamp) {\n-                        maxTimestamp = timestamp;\n-                        // we can have two rotations on the same day and we don't know which one has our data, so we keep all\n-                        List<String> indexList = candidateIndices.computeIfAbsent(timestamp, k -> new ArrayList<String>());\n-                        indexList.add(indexName);\n-                    }\n-                }\n-            }\n-            List<String> candidates = new ArrayList<String>();\n-            List<String> latestCandidate = candidateIndices.get(maxTimestamp);\n-\n-            if (latestCandidate != null) {\n-                candidates.addAll(latestCandidate);\n-            }\n-\n-            // look back one more index for an edge case:\n-            // Suppose detector interval is 1 minute. Detector last run is at 2020-05-07, 11:59:50 PM,\n-            // then AD result indices rolled over as .opendistro-anomaly-results-history-2020.05.07-001\n-            // Detector next run will be 2020-05-08, 00:00:50 AM. If a user stop the detector at\n-            // 2020-05-08 00:00:10 AM, detector will not have AD result on 2020-05-08.\n-            // We check AD result indices one day earlier to make sure we can always get AD result.\n-            Map.Entry<Long, List<String>> earlierCandidate = candidateIndices.lowerEntry(maxTimestamp);\n-            if (earlierCandidate != null) {\n-                candidates.addAll(earlierCandidate.getValue());\n-            }\n-            latestIndex = candidates.toArray(new String[0]);\n-        }\n-\n-        if (latestIndex == null || latestIndex.length == 0) {\n-            // no result index found: can be due to anomaly result is not created yet or result indices for the detector have been deleted.\n-            listener.onResponse(new DetectorProfile());\n-            return;\n-        }\n-        SearchRequest searchLatestResult = createLatestAnomalyResultRequest(detectorId, enabledTimeMillis, disabledTimeMillis, latestIndex);\n-        client.search(searchLatestResult, onGetLatestAnomalyResult(listener, detectorId));\n-    }\n-\n-    private ActionListener<SearchResponse> onGetLatestAnomalyResult(ActionListener<DetectorProfile> listener, String detectorId) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            if (hits.getHits().length == 0L) {\n-                listener.onResponse(new DetectorProfile());\n-            } else {\n-                SearchHit hit = hits.getAt(0);\n-\n+        return ActionListener.wrap(getResponse -> {\n+            DetectorProfile.Builder profileBuilder = new DetectorProfile.Builder();\n+            if (getResponse != null && getResponse.isExists()) {\n                 try (\n                     XContentParser parser = XContentType.JSON\n                         .xContent()\n-                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, hit.getSourceAsString())\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n                 ) {\n                     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-                    AnomalyResult result = parser.namedObject(AnomalyResult.class, AnomalyResult.PARSE_FIELD_NAME, null);\n-                    DetectorProfile profile = new DetectorProfile();\n-                    if (result.getError() != null) {\n-                        profile.setError(result.getError());\n+                    DetectorInternalState detectorState = DetectorInternalState.parse(parser);\n+                    long lastUpdateTimeMs = detectorState.getLastUpdateTime().toEpochMilli();\n+\n+                    // if state index hasn't been updated, we should not use the error field\n+                    // For example, before enabled, error is stopped due to, we should not show", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NjAzNA==", "bodyText": "this will retrieve the entire model checkpoints (w/ many data samples that are not used), recompuate all trees from samples, and only read one field. it would be more costly an operation than reading one field from the state. it's worth more consideration if this is scalable for the get profile requests.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451156034", "createdAt": "2020-07-07T21:32:41Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1045,4 +1067,24 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+     * Get a RCF model's total updates.\n+     * @param modelId the RCF model's id\n+     * @param detectorId detector Id\n+     * @param listener listener to return the result\n+     */\n+    public void getTotalUpdates(String modelId, String detectorId, ActionListener<Long> listener) {\n+        ModelState<RandomCutForest> model = forests.get(modelId);\n+        if (model != null) {\n+            listener.onResponse(model.getModel().getTotalUpdates());\n+        } else {\n+            checkpointDao\n+                .getModelCheckpoint(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1OTgzNA==", "bodyText": "this field is current not used in this version", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451159834", "createdAt": "2020-07-07T21:40:57Z", "author": {"login": "wnbts"}, "path": "src/main/resources/mappings/anomaly-state.json", "diffHunk": "@@ -0,0 +1,21 @@\n+{\n+  \"dynamic\": false,\n+  \"_meta\": {\n+    \"schema_version\": 1\n+  },\n+  \"properties\": {\n+    \"schema_version\": {\n+      \"type\": \"integer\"\n+    },\n+    \"rcf_updates\": {\n+      \"type\": \"integer\"\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NDkxNQ==", "bodyText": "minor. ConcurrentHashMap::computeIfAbsent is the api for this case.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451164915", "createdAt": "2020-07-07T21:52:09Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -91,31 +90,35 @@ public ADStateManager(\n      * @throws LimitExceededException when there is no sufficient resource available\n      */\n     public int getPartitionNumber(String adID, AnomalyDetector detector) {\n-        Entry<Integer, Instant> partitonAndTime = partitionNumber.get(adID);\n-        if (partitonAndTime != null) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getPartitonNumber() != null) {\n+            Entry<Integer, Instant> partitonAndTime = transportStates.get(adID).getPartitonNumber();\n             partitonAndTime.setValue(clock.instant());\n             return partitonAndTime.getKey();\n         }\n \n         int partitionNum = modelManager.getPartitionedForestSizes(detector).getKey();\n-        partitionNumber.putIfAbsent(adID, new SimpleEntry<>(partitionNum, clock.instant()));\n+        TransportState state = transportStates.get(adID);\n+        if (state == null) {\n+            state = new TransportState(adID);\n+            transportStates.put(adID, state);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjY4OA==", "bodyText": "which client is using this method?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451166688", "createdAt": "2020-07-07T21:56:11Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -140,35 +149,61 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    /**\n+     * Get a detector's checkpoint and save a flag if we find any so that next time we don't need to do it again\n+     * @param adID  the detector's ID\n+     * @param listener listener to handle get request\n+     */\n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODA3Mw==", "bodyText": "is it the same as Objects::equals ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451168073", "createdAt": "2020-07-07T21:59:17Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if ((state.getError() == null && error != null) || (state.getError() != null && !state.getError().equals(error))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng==", "bodyText": "can error be part of transport state and trigger indexing when updated? so a get can be saved for each run.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451171156", "createdAt": "2020-07-07T22:06:49Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if ((state.getError() == null && error != null) || (state.getError() != null && !state.getError().equals(error))) {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+    private NamedXContentRegistry xContentRegistry;\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService,\n+        NamedXContentRegistry xContentRegistry\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void saveError(String error, String detectorId, Instant jobEnabledTime) {\n+        update(detectorId, new ErrorStrategy(error), jobEnabledTime);\n+    }\n+\n+    /**\n+     * Updates a detector's state according to GetStateHandler\n+     * @param detectorId detector id\n+     * @param handler specify how to convert from existing state object to an object we want to save\n+     */\n+    private void update(String detectorId, GetStateStrategy handler, Instant jobEnabledTime) {\n+        try {\n+            GetRequest getRequest = new GetRequest(this.indexName).id(detectorId);\n+\n+            clientUtil.<GetRequest, GetResponse>asyncRequest(getRequest, client::get, ActionListener.wrap(response -> {\n+                DetectorInternalState newState = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzA4MTA4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-444308108", "createdAt": "2020-07-07T23:05:43Z", "commit": {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "575c9836d0c0639a58976489d1c5faf4741358d3", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/575c9836d0c0639a58976489d1c5faf4741358d3", "committedDate": "2020-07-07T23:11:32Z", "message": "refacotring and removing unused fields in state index schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c0cf04f5f4470b503bad983ce114685269f93906", "committedDate": "2020-07-09T15:59:53Z", "message": "Make error be part of transport state and trigger indexing when updated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTQ0NTYx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-445944561", "createdAt": "2020-07-09T20:27:37Z", "commit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDoyNzozN1rOGvgoLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToxMzozN1rOGviA6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA==", "bodyText": "are there any reasons not inverse the dependency, i.e., letting detector state handler be a dependency within state manager? there are for two benefits\n\nremoves the unnecessary dependency that state manager and job runner for the same detector are on the same node. if/when the two are run on separate nodes, error information doesn't need to be replicated.\nsince state manager already has the error, directly handing off/delegating to the handler is more natural than giving the info to job runner and let job runner give it to the handler.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452470828", "createdAt": "2020-07-09T20:27:37Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -436,7 +442,8 @@ private void indexAnomalyResult(\n                 Instant.now(),\n                 response.getError()\n             );\n-            anomalyResultHandler.indexAnomalyResult(anomalyResult);\n+            anomalyResultHandler.index(anomalyResult, detectorId);\n+            detectorStateHandler.saveError(response.getError(), detectorId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NTkzMA==", "bodyText": "is generic correct?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452485930", "createdAt": "2020-07-09T20:57:46Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/RCFPollingTransportAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+\n+import com.amazon.opendistroforelasticsearch.ad.cluster.HashRing;\n+import com.amazon.opendistroforelasticsearch.ad.common.exception.AnomalyDetectionException;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelManager;\n+import com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings;\n+\n+/**\n+ * Transport action to get total rcf updates from hosted models or checkpoint\n+ *\n+ */\n+public class RCFPollingTransportAction extends HandledTransportAction<RCFPollingRequest, RCFPollingResponse> {\n+\n+    private static final Logger LOG = LogManager.getLogger(RCFPollingTransportAction.class);\n+    static final String NO_NODE_FOUND_MSG = \"Cannot find model hosting node\";\n+    static final String FAIL_TO_GET_RCF_UPDATE_MSG = \"Cannot find hosted model or related checkpoint\";\n+\n+    private final TransportService transportService;\n+    private final ModelManager modelManager;\n+    private final HashRing hashRing;\n+    private final TransportRequestOptions option;\n+    private final ClusterService clusterService;\n+\n+    @Inject\n+    public RCFPollingTransportAction(\n+        ActionFilters actionFilters,\n+        TransportService transportService,\n+        Settings settings,\n+        ModelManager modelManager,\n+        HashRing hashRing,\n+        ClusterService clusterService\n+    ) {\n+        super(RCFPollingAction.NAME, transportService, actionFilters, RCFPollingRequest::new);\n+        this.transportService = transportService;\n+        this.modelManager = modelManager;\n+        this.hashRing = hashRing;\n+        this.option = TransportRequestOptions\n+            .builder()\n+            .withType(TransportRequestOptions.Type.REG)\n+            .withTimeout(AnomalyDetectorSettings.REQUEST_TIMEOUT.get(settings))\n+            .build();\n+        this.clusterService = clusterService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, RCFPollingRequest request, ActionListener<RCFPollingResponse> listener) {\n+\n+        String adID = request.getAdID();\n+\n+        String rcfModelID = modelManager.getRcfModelId(adID, 0);\n+\n+        Optional<DiscoveryNode> rcfNode = hashRing.getOwningNode(rcfModelID.toString());\n+        if (!rcfNode.isPresent()) {\n+            listener.onFailure(new AnomalyDetectionException(adID, NO_NODE_FOUND_MSG));\n+            return;\n+        }\n+\n+        String rcfNodeId = rcfNode.get().getId();\n+\n+        DiscoveryNode localNode = clusterService.localNode();\n+\n+        if (localNode.getId().equals(rcfNodeId)) {\n+            modelManager\n+                .getTotalUpdates(\n+                    rcfModelID,\n+                    adID,\n+                    ActionListener\n+                        .wrap(\n+                            totalUpdates -> listener.onResponse(new RCFPollingResponse(totalUpdates)),\n+                            e -> listener.onFailure(new AnomalyDetectionException(adID, FAIL_TO_GET_RCF_UPDATE_MSG, e))\n+                        )\n+                );\n+        } else {\n+            // redirect\n+            LOG.info(\"Sending RCF polling request to {} for model {}\", rcfNodeId, rcfModelID);\n+\n+            try {\n+                transportService\n+                    .sendRequest(rcfNode.get(), RCFPollingAction.NAME, request, option, new TransportResponseHandler<RCFPollingResponse>() {\n+\n+                        @Override\n+                        public RCFPollingResponse read(StreamInput in) throws IOException {\n+                            return new RCFPollingResponse(in);\n+                        }\n+\n+                        @Override\n+                        public void handleResponse(RCFPollingResponse response) {\n+                            listener.onResponse(response);\n+                        }\n+\n+                        @Override\n+                        public void handleException(TransportException exp) {\n+                            listener.onFailure(exp);\n+                        }\n+\n+                        @Override\n+                        public String executor() {\n+                            return ThreadPool.Names.GENERIC;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjA5MQ==", "bodyText": "minor. computeIfPresent is more concise", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452492091", "createdAt": "2020-07-09T21:10:33Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -91,31 +92,31 @@ public ADStateManager(\n      * @throws LimitExceededException when there is no sufficient resource available\n      */\n     public int getPartitionNumber(String adID, AnomalyDetector detector) {\n-        Entry<Integer, Instant> partitonAndTime = partitionNumber.get(adID);\n-        if (partitonAndTime != null) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getPartitonNumber() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjQxMA==", "bodyText": "minor. computeIfAbsent is more concise.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452492410", "createdAt": "2020-07-09T21:11:20Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -130,7 +131,13 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n             ) {\n                 ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n                 AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId());\n-                currentDetectors.put(adID, new SimpleEntry<>(detector, clock.instant()));\n+                TransportState state = transportStates.get(adID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MzU0NQ==", "bodyText": "minor. this seems more no_error.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452493545", "createdAt": "2020-07-09T21:13:37Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -204,4 +237,29 @@ public void resetBackpressureCounter(String nodeId) {\n     public boolean hasRunningQuery(AnomalyDetector detector) {\n         return clientUtil.hasRunningQuery(detector);\n     }\n+\n+    /**\n+     * Get last error of a detector\n+     * @param adID detector id\n+     * @return last error for the detector\n+     */\n+    public String getLastError(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastError() != null) {\n+            Entry<String, Instant> errorAndTime = transportStates.get(adID).getLastError();\n+            errorAndTime.setValue(clock.instant());\n+            return errorAndTime.getKey();\n+        }\n+\n+        return IMPOSSIBLE_ERROR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0cf04f5f4470b503bad983ce114685269f93906"}, "originalPosition": 197}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "committedDate": "2020-07-10T16:49:05Z", "message": "Use computeIfPresent to refactor code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Njk2ODM5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-446696839", "createdAt": "2020-07-10T20:57:50Z", "commit": {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1Nzo1MFrOGwFb4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1Nzo1MFrOGwFb4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Mzg5MQ==", "bodyText": "Should we update error to record the latest error time if the error message is the same?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453073891", "createdAt": "2020-07-10T20:57:50Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.transport.TransportStateManager;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+import com.google.common.base.Objects;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if (!Objects.equal(state.getError(), error)) {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+    private NamedXContentRegistry xContentRegistry;\n+    private TransportStateManager adStateManager;\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService,\n+        NamedXContentRegistry xContentRegistry,\n+        TransportStateManager adStateManager\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+        this.xContentRegistry = xContentRegistry;\n+        this.adStateManager = adStateManager;\n+    }\n+\n+    public void saveError(String error, String detectorId) {\n+        // trigger indexing if no error recorded (e.g., this detector got enabled just now)\n+        // or the recorded error is different than this one.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzU3NjMz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-446757633", "createdAt": "2020-07-11T00:14:55Z", "commit": {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwMDoxNDo1NVrOGwIyFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwMDoxNDo1NVrOGwIyFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyODcyNQ==", "bodyText": "Minor, how about rename  the json file as \"anomaly-detection-state.json\"? In AD workbench, we will introduce detection task, plan to put task execution state in this index \".opendistro-anomaly-detection-state\", will add more fields when design done.\nBTW, how about we rename ANOMALY_DETECTOR_STATE_INDEX_MAPPING_FILE as ANOMALY_DETECTION_STATE_INDEX_MAPPING_FILE, similar to ANOMALY_DETECTOR_STATE_INDEX.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453128725", "createdAt": "2020-07-11T00:14:55Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/settings/AnomalyDetectorSettings.java", "diffHunk": "@@ -141,6 +141,7 @@ private AnomalyDetectorSettings() {}\n     public static final String ANOMALY_DETECTORS_INDEX_MAPPING_FILE = \"mappings/anomaly-detectors.json\";\n     public static final String ANOMALY_DETECTOR_JOBS_INDEX_MAPPING_FILE = \"mappings/anomaly-detector-jobs.json\";\n     public static final String ANOMALY_RESULTS_INDEX_MAPPING_FILE = \"mappings/anomaly-results.json\";\n+    public static final String ANOMALY_DETECTOR_STATE_INDEX_MAPPING_FILE = \"mappings/anomaly-state.json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d6b5880ede89a998f1834d86ed4d2ec2d39ed13", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/4d6b5880ede89a998f1834d86ed4d2ec2d39ed13", "committedDate": "2020-07-13T23:34:18Z", "message": "Rename variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9285cd7bf708f2daaff6e072d8542dc3b359abfe", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9285cd7bf708f2daaff6e072d8542dc3b359abfe", "committedDate": "2020-07-13T23:54:43Z", "message": "Reorder import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Njk5NjU3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-447699657", "createdAt": "2020-07-14T00:18:56Z", "commit": {"oid": "9285cd7bf708f2daaff6e072d8542dc3b359abfe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDoxODo1NlrOGw_UOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwMDoxODo1NlrOGw_UOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyMjIwMg==", "bodyText": "minor, should we rename setDetectorStateHandler  as setDetectionStateHandler  ? Same question for other ...detectorState...", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r454022202", "createdAt": "2020-07-14T00:18:56Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -119,6 +121,10 @@ public void setSettings(Settings settings) {\n         this.maxRetryForEndRunException = AnomalyDetectorSettings.MAX_RETRY_FOR_END_RUN_EXCEPTION.get(settings);\n     }\n \n+    public void setDetectorStateHandler(DetectorStateHandler detectorStateHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9285cd7bf708f2daaff6e072d8542dc3b359abfe"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66d772f494636e79c0c3bdfa69d25870da37cea1", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/66d772f494636e79c0c3bdfa69d25870da37cea1", "committedDate": "2020-07-14T01:09:37Z", "message": "Rename variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzI2MDg5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#pullrequestreview-447726089", "createdAt": "2020-07-14T01:41:27Z", "commit": {"oid": "66d772f494636e79c0c3bdfa69d25870da37cea1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1473, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}