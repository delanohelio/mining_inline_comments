{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTk4NTg4", "number": 48, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjozOTo1NFrODlOpFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzo0MjoxMlrODl4mAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzYzNzk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjozOTo1NFrOFyAR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNjo1OFrOFyrADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NzY4MQ==", "bodyText": "Catch exception and log it ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r387977681", "createdAt": "2020-03-04T22:39:54Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -637,37 +572,130 @@ void saveDetectorResult(IndexRequest indexRequest, String context, Iterator<Time\n             );\n     }\n \n+    void handleExecuteException(Exception ex, ActionListener<AnomalyResultResponse> listener, String adID) {\n+        if (ex instanceof ClientException) {\n+            listener.onFailure(ex);\n+        } else if (ex instanceof AnomalyDetectionException) {\n+            listener.onFailure(new InternalFailure((AnomalyDetectionException) ex));\n+        } else {\n+            Throwable cause = ExceptionsHelper.unwrapCause(ex);\n+            listener.onFailure(new InternalFailure(adID, cause));\n+        }\n+    }\n+\n     class RCFActionListener implements ActionListener<RCFResultResponse> {\n         private List<RCFResultResponse> rcfResults;\n         private String modelID;\n         private AtomicReference<AnomalyDetectionException> failure;\n-        private String nodeID;\n+        private String rcfNodeID;\n+        private Optional<AnomalyDetector> detector;\n+        private ActionListener<AnomalyResultResponse> listener;\n+        private String thresholdModelID;\n+        private Optional<DiscoveryNode> thresholdNode;\n+        private List<FeatureData> featureInResponse;\n+        private long startTime;\n+        private long endTime;\n+        private int nodeCount;\n+        private final AtomicInteger responseCount;\n+        private final String adID;\n \n         RCFActionListener(\n             List<RCFResultResponse> rcfResults,\n             String modelID,\n             AtomicReference<AnomalyDetectionException> failure,\n-            String nodeID\n+            String rcfNodeID,\n+            Optional<AnomalyDetector> detector,\n+            ActionListener<AnomalyResultResponse> listener,\n+            String thresholdModelID,\n+            Optional<DiscoveryNode> thresholdNode,\n+            List<FeatureData> features,\n+            long startTime,\n+            long endTime,\n+            int nodeCount,\n+            AtomicInteger responseCount,\n+            String adID\n         ) {\n             this.rcfResults = rcfResults;\n             this.modelID = modelID;\n+            this.rcfNodeID = rcfNodeID;\n+            this.detector = detector;\n+            this.listener = listener;\n+            this.thresholdNode = thresholdNode;\n+            this.thresholdModelID = thresholdModelID;\n+            this.featureInResponse = features;\n             this.failure = failure;\n-            this.nodeID = nodeID;\n+            this.startTime = startTime;\n+            this.endTime = endTime;\n+            this.nodeCount = nodeCount;\n+            this.responseCount = responseCount;\n+            this.adID = adID;\n         }\n \n         @Override\n         public void onResponse(RCFResultResponse response) {\n-            stateManager.resetBackpressureCounter(nodeID);\n-            if (response != null) {\n-                rcfResults.add(response);\n-            } else {\n-                LOG.warn(NULL_RESPONSE + \" {} for {}\", modelID, nodeID);\n+            try {\n+                stateManager.resetBackpressureCounter(rcfNodeID);\n+                if (response != null) {\n+                    rcfResults.add(response);\n+                } else {\n+                    LOG.warn(NULL_RESPONSE + \" {} for {}\", modelID, rcfNodeID);\n+                }\n+            } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36683ddf7d0e2fc656304542b602426e1823d546"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzY0NQ==", "bodyText": "added", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r388677645", "createdAt": "2020-03-06T02:06:58Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -637,37 +572,130 @@ void saveDetectorResult(IndexRequest indexRequest, String context, Iterator<Time\n             );\n     }\n \n+    void handleExecuteException(Exception ex, ActionListener<AnomalyResultResponse> listener, String adID) {\n+        if (ex instanceof ClientException) {\n+            listener.onFailure(ex);\n+        } else if (ex instanceof AnomalyDetectionException) {\n+            listener.onFailure(new InternalFailure((AnomalyDetectionException) ex));\n+        } else {\n+            Throwable cause = ExceptionsHelper.unwrapCause(ex);\n+            listener.onFailure(new InternalFailure(adID, cause));\n+        }\n+    }\n+\n     class RCFActionListener implements ActionListener<RCFResultResponse> {\n         private List<RCFResultResponse> rcfResults;\n         private String modelID;\n         private AtomicReference<AnomalyDetectionException> failure;\n-        private String nodeID;\n+        private String rcfNodeID;\n+        private Optional<AnomalyDetector> detector;\n+        private ActionListener<AnomalyResultResponse> listener;\n+        private String thresholdModelID;\n+        private Optional<DiscoveryNode> thresholdNode;\n+        private List<FeatureData> featureInResponse;\n+        private long startTime;\n+        private long endTime;\n+        private int nodeCount;\n+        private final AtomicInteger responseCount;\n+        private final String adID;\n \n         RCFActionListener(\n             List<RCFResultResponse> rcfResults,\n             String modelID,\n             AtomicReference<AnomalyDetectionException> failure,\n-            String nodeID\n+            String rcfNodeID,\n+            Optional<AnomalyDetector> detector,\n+            ActionListener<AnomalyResultResponse> listener,\n+            String thresholdModelID,\n+            Optional<DiscoveryNode> thresholdNode,\n+            List<FeatureData> features,\n+            long startTime,\n+            long endTime,\n+            int nodeCount,\n+            AtomicInteger responseCount,\n+            String adID\n         ) {\n             this.rcfResults = rcfResults;\n             this.modelID = modelID;\n+            this.rcfNodeID = rcfNodeID;\n+            this.detector = detector;\n+            this.listener = listener;\n+            this.thresholdNode = thresholdNode;\n+            this.thresholdModelID = thresholdModelID;\n+            this.featureInResponse = features;\n             this.failure = failure;\n-            this.nodeID = nodeID;\n+            this.startTime = startTime;\n+            this.endTime = endTime;\n+            this.nodeCount = nodeCount;\n+            this.responseCount = responseCount;\n+            this.adID = adID;\n         }\n \n         @Override\n         public void onResponse(RCFResultResponse response) {\n-            stateManager.resetBackpressureCounter(nodeID);\n-            if (response != null) {\n-                rcfResults.add(response);\n-            } else {\n-                LOG.warn(NULL_RESPONSE + \" {} for {}\", modelID, nodeID);\n+            try {\n+                stateManager.resetBackpressureCounter(rcfNodeID);\n+                if (response != null) {\n+                    rcfResults.add(response);\n+                } else {\n+                    LOG.warn(NULL_RESPONSE + \" {} for {}\", modelID, rcfNodeID);\n+                }\n+            } finally {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NzY4MQ=="}, "originalCommit": {"oid": "36683ddf7d0e2fc656304542b602426e1823d546"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzYzODkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjo0MDoxM1rOFyASWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNjowOVrOFyq_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NzgxOA==", "bodyText": "onResponse will be called multiple times if send request to multiple nodes?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r387977818", "createdAt": "2020-03-04T22:40:13Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -637,37 +572,130 @@ void saveDetectorResult(IndexRequest indexRequest, String context, Iterator<Time\n             );\n     }\n \n+    void handleExecuteException(Exception ex, ActionListener<AnomalyResultResponse> listener, String adID) {\n+        if (ex instanceof ClientException) {\n+            listener.onFailure(ex);\n+        } else if (ex instanceof AnomalyDetectionException) {\n+            listener.onFailure(new InternalFailure((AnomalyDetectionException) ex));\n+        } else {\n+            Throwable cause = ExceptionsHelper.unwrapCause(ex);\n+            listener.onFailure(new InternalFailure(adID, cause));\n+        }\n+    }\n+\n     class RCFActionListener implements ActionListener<RCFResultResponse> {\n         private List<RCFResultResponse> rcfResults;\n         private String modelID;\n         private AtomicReference<AnomalyDetectionException> failure;\n-        private String nodeID;\n+        private String rcfNodeID;\n+        private Optional<AnomalyDetector> detector;\n+        private ActionListener<AnomalyResultResponse> listener;\n+        private String thresholdModelID;\n+        private Optional<DiscoveryNode> thresholdNode;\n+        private List<FeatureData> featureInResponse;\n+        private long startTime;\n+        private long endTime;\n+        private int nodeCount;\n+        private final AtomicInteger responseCount;\n+        private final String adID;\n \n         RCFActionListener(\n             List<RCFResultResponse> rcfResults,\n             String modelID,\n             AtomicReference<AnomalyDetectionException> failure,\n-            String nodeID\n+            String rcfNodeID,\n+            Optional<AnomalyDetector> detector,\n+            ActionListener<AnomalyResultResponse> listener,\n+            String thresholdModelID,\n+            Optional<DiscoveryNode> thresholdNode,\n+            List<FeatureData> features,\n+            long startTime,\n+            long endTime,\n+            int nodeCount,\n+            AtomicInteger responseCount,\n+            String adID\n         ) {\n             this.rcfResults = rcfResults;\n             this.modelID = modelID;\n+            this.rcfNodeID = rcfNodeID;\n+            this.detector = detector;\n+            this.listener = listener;\n+            this.thresholdNode = thresholdNode;\n+            this.thresholdModelID = thresholdModelID;\n+            this.featureInResponse = features;\n             this.failure = failure;\n-            this.nodeID = nodeID;\n+            this.startTime = startTime;\n+            this.endTime = endTime;\n+            this.nodeCount = nodeCount;\n+            this.responseCount = responseCount;\n+            this.adID = adID;\n         }\n \n         @Override\n         public void onResponse(RCFResultResponse response) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36683ddf7d0e2fc656304542b602426e1823d546"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzQ2NA==", "bodyText": "yes", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r388677464", "createdAt": "2020-03-06T02:06:09Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -637,37 +572,130 @@ void saveDetectorResult(IndexRequest indexRequest, String context, Iterator<Time\n             );\n     }\n \n+    void handleExecuteException(Exception ex, ActionListener<AnomalyResultResponse> listener, String adID) {\n+        if (ex instanceof ClientException) {\n+            listener.onFailure(ex);\n+        } else if (ex instanceof AnomalyDetectionException) {\n+            listener.onFailure(new InternalFailure((AnomalyDetectionException) ex));\n+        } else {\n+            Throwable cause = ExceptionsHelper.unwrapCause(ex);\n+            listener.onFailure(new InternalFailure(adID, cause));\n+        }\n+    }\n+\n     class RCFActionListener implements ActionListener<RCFResultResponse> {\n         private List<RCFResultResponse> rcfResults;\n         private String modelID;\n         private AtomicReference<AnomalyDetectionException> failure;\n-        private String nodeID;\n+        private String rcfNodeID;\n+        private Optional<AnomalyDetector> detector;\n+        private ActionListener<AnomalyResultResponse> listener;\n+        private String thresholdModelID;\n+        private Optional<DiscoveryNode> thresholdNode;\n+        private List<FeatureData> featureInResponse;\n+        private long startTime;\n+        private long endTime;\n+        private int nodeCount;\n+        private final AtomicInteger responseCount;\n+        private final String adID;\n \n         RCFActionListener(\n             List<RCFResultResponse> rcfResults,\n             String modelID,\n             AtomicReference<AnomalyDetectionException> failure,\n-            String nodeID\n+            String rcfNodeID,\n+            Optional<AnomalyDetector> detector,\n+            ActionListener<AnomalyResultResponse> listener,\n+            String thresholdModelID,\n+            Optional<DiscoveryNode> thresholdNode,\n+            List<FeatureData> features,\n+            long startTime,\n+            long endTime,\n+            int nodeCount,\n+            AtomicInteger responseCount,\n+            String adID\n         ) {\n             this.rcfResults = rcfResults;\n             this.modelID = modelID;\n+            this.rcfNodeID = rcfNodeID;\n+            this.detector = detector;\n+            this.listener = listener;\n+            this.thresholdNode = thresholdNode;\n+            this.thresholdModelID = thresholdModelID;\n+            this.featureInResponse = features;\n             this.failure = failure;\n-            this.nodeID = nodeID;\n+            this.startTime = startTime;\n+            this.endTime = endTime;\n+            this.nodeCount = nodeCount;\n+            this.responseCount = responseCount;\n+            this.adID = adID;\n         }\n \n         @Override\n         public void onResponse(RCFResultResponse response) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3NzgxOA=="}, "originalCommit": {"oid": "36683ddf7d0e2fc656304542b602426e1823d546"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDUxMTM2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunnerTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzo0MjoxMlrOFzBk2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo0MjowOFrOFzLzTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NzUxNA==", "bodyText": "typo", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r389047514", "createdAt": "2020-03-06T17:42:12Z", "author": {"login": "zhanghg08"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunnerTests.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.JobExecutionContext;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.LockModel;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.utils.LockService;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorJobRunnerTests extends AbstractADTest {\n+\n+    @Mock\n+    private Client client;\n+    @Mock\n+    private ClusterService clusterService;\n+\n+    private LockService lockService;\n+\n+    @Mock\n+    private AnomalyDetectorJob jobParameter;\n+\n+    @Mock\n+    private JobExecutionContext context;\n+\n+    private AnomalyDetectorJobRunner runner = AnomalyDetectorJobRunner.getJobRunnerInstance();\n+\n+    @Mock\n+    private ThreadPool threadPool;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        super.setUp();\n+        super.setUpLog4jForJUnit(AnomalyDetectorJobRunner.class);\n+        MockitoAnnotations.initMocks(this);\n+        ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(EsExecutors.threadName(\"node1\", \"test-ad\"));\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        executorService = EsExecutors.newFixed(\"test-ad\", 4, 100, threadFactory, threadContext);\n+        doReturn(executorService).when(threadPool).executor(anyString());\n+        runner.setThreadPool(threadPool);\n+        runner.setClient(client);\n+\n+        lockService = new LockService(client, clusterService);\n+        doReturn(lockService).when(context).getLockService();\n+    }\n+\n+    @Rule\n+    public ExpectedException expectedEx = ExpectedException.none();\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        super.tearDownLog4jForJUnit();\n+        executorService.shutdown();\n+    }\n+\n+    @Test\n+    public void testRunJobWithWrongParameterType() {\n+        expectedEx.expect(IllegalArgumentException.class);\n+        expectedEx.expectMessage(\"Job parameter is not instance of AnomalyDetectorJob, type: \");\n+\n+        ScheduledJobParameter parameter = mock(ScheduledJobParameter.class);\n+        when(jobParameter.getLockDurationSeconds()).thenReturn(null);\n+        runner.runJob(parameter, context);\n+    }\n+\n+    @Test\n+    public void testRunJobWithNullLockDuration() throws InterruptedException {\n+        when(jobParameter.getLockDurationSeconds()).thenReturn(null);\n+        runner.runJob(jobParameter, context);\n+        Thread.sleep(1000);\n+        assertTrue(testAppender.containsMessage(\"Can't get lock for AD job\"));\n+    }\n+\n+    @Test\n+    public void testRunJobWithLocakDuration() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57daff6dbf226777b10135b4bcfa491b86e619f5"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTA1Mg==", "bodyText": "That\u2019s actually from rebased code.  not the code meant to be reviewed.  I fixed it.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/48#discussion_r389215052", "createdAt": "2020-03-07T01:42:08Z", "author": {"login": "kaituo"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunnerTests.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.JobExecutionContext;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.LockModel;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.utils.LockService;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class AnomalyDetectorJobRunnerTests extends AbstractADTest {\n+\n+    @Mock\n+    private Client client;\n+    @Mock\n+    private ClusterService clusterService;\n+\n+    private LockService lockService;\n+\n+    @Mock\n+    private AnomalyDetectorJob jobParameter;\n+\n+    @Mock\n+    private JobExecutionContext context;\n+\n+    private AnomalyDetectorJobRunner runner = AnomalyDetectorJobRunner.getJobRunnerInstance();\n+\n+    @Mock\n+    private ThreadPool threadPool;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        super.setUp();\n+        super.setUpLog4jForJUnit(AnomalyDetectorJobRunner.class);\n+        MockitoAnnotations.initMocks(this);\n+        ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(EsExecutors.threadName(\"node1\", \"test-ad\"));\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        executorService = EsExecutors.newFixed(\"test-ad\", 4, 100, threadFactory, threadContext);\n+        doReturn(executorService).when(threadPool).executor(anyString());\n+        runner.setThreadPool(threadPool);\n+        runner.setClient(client);\n+\n+        lockService = new LockService(client, clusterService);\n+        doReturn(lockService).when(context).getLockService();\n+    }\n+\n+    @Rule\n+    public ExpectedException expectedEx = ExpectedException.none();\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        super.tearDownLog4jForJUnit();\n+        executorService.shutdown();\n+    }\n+\n+    @Test\n+    public void testRunJobWithWrongParameterType() {\n+        expectedEx.expect(IllegalArgumentException.class);\n+        expectedEx.expectMessage(\"Job parameter is not instance of AnomalyDetectorJob, type: \");\n+\n+        ScheduledJobParameter parameter = mock(ScheduledJobParameter.class);\n+        when(jobParameter.getLockDurationSeconds()).thenReturn(null);\n+        runner.runJob(parameter, context);\n+    }\n+\n+    @Test\n+    public void testRunJobWithNullLockDuration() throws InterruptedException {\n+        when(jobParameter.getLockDurationSeconds()).thenReturn(null);\n+        runner.runJob(jobParameter, context);\n+        Thread.sleep(1000);\n+        assertTrue(testAppender.containsMessage(\"Can't get lock for AD job\"));\n+    }\n+\n+    @Test\n+    public void testRunJobWithLocakDuration() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NzUxNA=="}, "originalCommit": {"oid": "57daff6dbf226777b10135b4bcfa491b86e619f5"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2981, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}