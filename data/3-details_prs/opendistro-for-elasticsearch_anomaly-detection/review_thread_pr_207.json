{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Nzk2ODg2", "number": 207, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDowMDoxNlrOEXXIUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMzozODo1N1rOEYpKZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTMxNjY1OnYy", "diffSide": "RIGHT", "path": "cli/internal/gateway/ad/ad.go", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDowMDoxNlrOG_HLFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozMzoyM1rOG_zo9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMDk5OA==", "bodyText": "remove?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468830998", "createdAt": "2020-08-11T20:00:16Z", "author": {"login": "kaituo"}, "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -59,6 +61,56 @@ func (g *gateway) buildCreateURL() (*url.URL, error) {\n \treturn endpoint, nil\n }\n \n+// CreateDetector Creates an anomaly detector job.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NTg4MA==", "bodyText": "Do you mean to remove this line? In go, if a method is exported, it is practice to write comment else linter will complain. At line 114, i  have a method CreateDetector, hence the comment.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468885880", "createdAt": "2020-08-11T21:52:44Z", "author": {"login": "VijayanB"}, "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -59,6 +61,56 @@ func (g *gateway) buildCreateURL() (*url.URL, error) {\n \treturn endpoint, nil\n }\n \n+// CreateDetector Creates an anomaly detector job.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMDk5OA=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTIyMw==", "bodyText": "my bad.  I thought the following is a commented out code block.  Does Go has block comment?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r469409223", "createdAt": "2020-08-12T17:04:30Z", "author": {"login": "kaituo"}, "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -59,6 +61,56 @@ func (g *gateway) buildCreateURL() (*url.URL, error) {\n \treturn endpoint, nil\n }\n \n+// CreateDetector Creates an anomaly detector job.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMDk5OA=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1OTU0MA==", "bodyText": "Yeah. I updated with block comments.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r469559540", "createdAt": "2020-08-12T21:33:23Z", "author": {"login": "VijayanB"}, "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -59,6 +61,56 @@ func (g *gateway) buildCreateURL() (*url.URL, error) {\n \treturn endpoint, nil\n }\n \n+// CreateDetector Creates an anomaly detector job.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMDk5OA=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTMyODIyOnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDowNDowNFrOG_HR_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozNDoxMVrOG_zqfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMjc2Ng==", "bodyText": "The code looks same as execyteByID.  Am I missing anything?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468832766", "createdAt": "2020-08-11T20:04:04Z", "author": {"login": "kaituo"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\tvar results []*entity.DetectorOutput\n+\t\tif idStatus {\n+\t\t\tresults = executeByID(commandHandler, args)\n+\t\t} else {\n+\t\t\tresults = executeByNames(commandHandler, args)\n+\t\t}\n+\t\tprintDetectors(results)\n+\t},\n+}\n+\n+//executeByNames gets detector output based on name as argument\n+func executeByNames(commandHandler *ad.Handler, args []string) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NzgxMA==", "bodyText": "yes.\nexecute by name calls method ad.GetAnomalyDetectorsByNamePattern which returns []*entity.DetectorOutput, while\nexecuteby id calls method ad.GetAnomalyDetectorsByID which returns *entity.DetectorOutput. Thats way i am not able to pass function as parameter. In go, type has to be matched.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468887810", "createdAt": "2020-08-11T21:57:22Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\tvar results []*entity.DetectorOutput\n+\t\tif idStatus {\n+\t\t\tresults = executeByID(commandHandler, args)\n+\t\t} else {\n+\t\t\tresults = executeByNames(commandHandler, args)\n+\t\t}\n+\t\tprintDetectors(results)\n+\t},\n+}\n+\n+//executeByNames gets detector output based on name as argument\n+func executeByNames(commandHandler *ad.Handler, args []string) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMjc2Ng=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDg0NA==", "bodyText": "Does it make sense to pass a boolean or enum say \"by field\".  And then you call different functions based on this by field?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r469410844", "createdAt": "2020-08-12T17:07:16Z", "author": {"login": "kaituo"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\tvar results []*entity.DetectorOutput\n+\t\tif idStatus {\n+\t\t\tresults = executeByID(commandHandler, args)\n+\t\t} else {\n+\t\t\tresults = executeByNames(commandHandler, args)\n+\t\t}\n+\t\tprintDetectors(results)\n+\t},\n+}\n+\n+//executeByNames gets detector output based on name as argument\n+func executeByNames(commandHandler *ad.Handler, args []string) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMjc2Ng=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1OTkzNQ==", "bodyText": "Sure. I wrapped the method for executeByID and used flags to differentiate action .", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r469559935", "createdAt": "2020-08-12T21:34:11Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\tvar results []*entity.DetectorOutput\n+\t\tif idStatus {\n+\t\t\tresults = executeByID(commandHandler, args)\n+\t\t} else {\n+\t\t\tresults = executeByNames(commandHandler, args)\n+\t\t}\n+\t\tprintDetectors(results)\n+\t},\n+}\n+\n+//executeByNames gets detector output based on name as argument\n+func executeByNames(commandHandler *ad.Handler, args []string) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMjc2Ng=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTQ5OTY5OnYy", "diffSide": "RIGHT", "path": "cli/internal/entity/ad/ad.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1NjoyMVrOG_I8Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1MzoxMVrOG_KiGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1OTk0Mw==", "bodyText": "If we add a field in the get detector API on the plugin side, would it break anything here?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468859943", "createdAt": "2020-08-11T20:56:21Z", "author": {"login": "kaituo"}, "path": "cli/internal/entity/ad/ad.go", "diffHunk": "@@ -143,3 +143,32 @@ type Container struct {\n type SearchResponse struct {\n \tHits Container `json:\"hits\"`\n }\n+\n+type Metadata CreateDetector\n+\n+type AnomalyDetector struct {\n+\tMetadata\n+\tSchemaVersion  int32  `json:\"schema_version\"`\n+\tLastUpdateTime uint64 `json:\"last_update_time\"`\n+}\n+\n+//DetectorResponse represents detector's setting\n+type DetectorResponse struct {\n+\tID              string          `json:\"_id\"`\n+\tAnomalyDetector AnomalyDetector `json:\"anomaly_detector\"`\n+}\n+\n+//DetectorOutput represents detector's setting displayed to user\n+type DetectorOutput struct {\n+\tID            string", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NjA0Mg==", "bodyText": "No, It won't break, just that it will not be deserialized.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r468886042", "createdAt": "2020-08-11T21:53:11Z", "author": {"login": "VijayanB"}, "path": "cli/internal/entity/ad/ad.go", "diffHunk": "@@ -143,3 +143,32 @@ type Container struct {\n type SearchResponse struct {\n \tHits Container `json:\"hits\"`\n }\n+\n+type Metadata CreateDetector\n+\n+type AnomalyDetector struct {\n+\tMetadata\n+\tSchemaVersion  int32  `json:\"schema_version\"`\n+\tLastUpdateTime uint64 `json:\"last_update_time\"`\n+}\n+\n+//DetectorResponse represents detector's setting\n+type DetectorResponse struct {\n+\tID              string          `json:\"_id\"`\n+\tAnomalyDetector AnomalyDetector `json:\"anomaly_detector\"`\n+}\n+\n+//DetectorOutput represents detector's setting displayed to user\n+type DetectorOutput struct {\n+\tID            string", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1OTk0Mw=="}, "originalCommit": {"oid": "092db6bc2199d8c9c28bad77fec58c425603f1cf"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjYzMzc0OnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoxNjo0MlrOHBEtHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoyOTowOFrOHBE5dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4NzcwOQ==", "bodyText": "This line seems very long. How about breaking it into two lines?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470887709", "createdAt": "2020-08-14T22:16:42Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MDg3MQ==", "bodyText": "Ack. Changed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470890871", "createdAt": "2020-08-14T22:29:08Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4NzcwOQ=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjYzNjgyOnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoxODozOVrOHBEu7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoyODo1OVrOHBE5QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4ODE3Mg==", "bodyText": "This method is not to execute a detector by ID. How about rename it as \"getDetectorByID\"", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470888172", "createdAt": "2020-08-14T22:18:39Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//executeByID gets detector output based on ID as argument\n+func executeByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MDgxNw==", "bodyText": "Ack. Changed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470890817", "createdAt": "2020-08-14T22:28:59Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//executeByID gets detector output based on ID as argument\n+func executeByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4ODE3Mg=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjY0MzM2OnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoyMjoxMFrOHBEyuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMzozNTozNlrOHBFxPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4OTE0NQ==", "bodyText": "If results is nil, what message will user see?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470889145", "createdAt": "2020-08-14T22:22:10Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MjU3NQ==", "bodyText": "So only possibility getDetectors can get nil is if there is an error from GET method. In that case it will display the error message ( why get failed ). This was handled inside getDetectors. I refactored now to return err and print outside now.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470892575", "createdAt": "2020-08-14T22:35:39Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4OTE0NQ=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MzUyOQ==", "bodyText": "only possibility getDetectors can get nil is if there is an error from GET method\n\nIf user input an invalid detector id, will throw an error or return empty results ?  In print method for _, d := range results {, if results is empty, will not print anything?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470893529", "createdAt": "2020-08-14T22:39:48Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4OTE0NQ=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTE1MQ==", "bodyText": "There is will be either json output or error message per detector.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470905151", "createdAt": "2020-08-14T23:35:36Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4OTE0NQ=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjY1MDA0OnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjoyNjoxMVrOHBE2nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjo0MToxN1rOHBFFOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MDE0MA==", "bodyText": "Is it best practice to use single-letter variable name in Go? How about replace d with detector ? That will be easier to read the code.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470890140", "createdAt": "2020-08-14T22:26:11Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//executeByID gets detector output based on ID as argument\n+func executeByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {\n+\n+\toutput, err := ad.GetAnomalyDetectorByID(commandHandler, ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn []*entity.DetectorOutput{output}, nil\n+}\n+\n+//printDetectors displays the list of output. Since this is json format, use indent function to\n+// pretty print before printing on console\n+func printDetectors(results []*entity.DetectorOutput) {\n+\tif results == nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range results {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5Mzg4MA==", "bodyText": "https://github.com/golang/go/wiki/CodeReviewComments#variable-names\nThe convention is you only need more descriptive if it is used far away from declaration. Especially for iterators, single variable name is preferred.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470893880", "createdAt": "2020-08-14T22:41:17Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = executeByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(commandHandler *ad.Handler, args []string, get func(*ad.Handler, string) ([]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//executeByID gets detector output based on ID as argument\n+func executeByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {\n+\n+\toutput, err := ad.GetAnomalyDetectorByID(commandHandler, ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn []*entity.DetectorOutput{output}, nil\n+}\n+\n+//printDetectors displays the list of output. Since this is json format, use indent function to\n+// pretty print before printing on console\n+func printDetectors(results []*entity.DetectorOutput) {\n+\tif results == nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range results {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MDE0MA=="}, "originalCommit": {"oid": "88e686962380288f1129ec3924a14f40adf8328d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjY2ODE0OnYy", "diffSide": "RIGHT", "path": "cli/cmd/cat.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMjozNjo0MVrOHBFBFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDozODo0OVrOHCrUSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MjgyMQ==", "bodyText": "The message \"Input is name or pattern\" is visible to user? Have you confirmed the wording with tech writer? I feel we should say Input is detector name or name pattern, Input is detector id", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470892821", "createdAt": "2020-08-14T22:36:41Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = getDetectorsByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(\n+\tcommandHandler *ad.Handler, args []string, get func(*ad.Handler, string) (\n+\t\t[]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//getDetectorsByID gets detector output based on ID as argument\n+func getDetectorsByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {\n+\n+\toutput, err := ad.GetAnomalyDetectorByID(commandHandler, ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn []*entity.DetectorOutput{output}, nil\n+}\n+\n+//printDetectors displays the list of output. Since this is json format, use indent function to\n+// pretty print before printing on console\n+func printDetectors(results []*entity.DetectorOutput) {\n+\tif results == nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range results {\n+\t\tformattedOutput, err := json.MarshalIndent(d, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Println(string(formattedOutput))\n+\t}\n+}\n+\n+func init() {\n+\tesadCmd.AddCommand(catCmd)\n+\tcatCmd.Flags().BoolP(\"name\", \"\", true, \"Input is name or pattern\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98101f2bd833d452535bc8967cdd6dec7cef43ba"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTAyMQ==", "bodyText": "As discussed offline, i will fix this accordingly.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470905021", "createdAt": "2020-08-14T23:34:55Z", "author": {"login": "VijayanB"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = getDetectorsByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(\n+\tcommandHandler *ad.Handler, args []string, get func(*ad.Handler, string) (\n+\t\t[]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//getDetectorsByID gets detector output based on ID as argument\n+func getDetectorsByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {\n+\n+\toutput, err := ad.GetAnomalyDetectorByID(commandHandler, ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn []*entity.DetectorOutput{output}, nil\n+}\n+\n+//printDetectors displays the list of output. Since this is json format, use indent function to\n+// pretty print before printing on console\n+func printDetectors(results []*entity.DetectorOutput) {\n+\tif results == nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range results {\n+\t\tformattedOutput, err := json.MarshalIndent(d, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Println(string(formattedOutput))\n+\t}\n+}\n+\n+func init() {\n+\tesadCmd.AddCommand(catCmd)\n+\tcatCmd.Flags().BoolP(\"name\", \"\", true, \"Input is name or pattern\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MjgyMQ=="}, "originalCommit": {"oid": "98101f2bd833d452535bc8967cdd6dec7cef43ba"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2ODkwNg==", "bodyText": "Sure, will approve this PR. Please fix this in another PR.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r472568906", "createdAt": "2020-08-19T00:38:49Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/cat.go", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"encoding/json\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCat = \"cat\"\n+)\n+\n+//catCmd prints detectors configuration based on id and name pattern.\n+var catCmd = &cobra.Command{\n+\tUse:   commandCat + \" [flags] [list of detectors]\",\n+\tShort: \"Concatenate and print detectors based on id or name pattern\",\n+\tLong:  `concatenate and print detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\tcommandHandler, err := getCommandHandler()\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t}\n+\t\t// default is name\n+\t\taction := ad.GetAnomalyDetectorsByNamePattern\n+\t\tif idStatus {\n+\t\t\taction = getDetectorsByID\n+\t\t}\n+\t\tif results := getDetectors(commandHandler, args, action); results != nil {\n+\t\t\tprintDetectors(results)\n+\t\t}\n+\t},\n+}\n+\n+func getDetectors(\n+\tcommandHandler *ad.Handler, args []string, get func(*ad.Handler, string) (\n+\t\t[]*entity.DetectorOutput, error)) []*entity.DetectorOutput {\n+\tvar results []*entity.DetectorOutput\n+\tfor _, detector := range args {\n+\t\toutput, err := get(commandHandler, detector)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tresults = append(results, output...)\n+\t}\n+\treturn results\n+}\n+\n+//getDetectorsByID gets detector output based on ID as argument\n+func getDetectorsByID(commandHandler *ad.Handler, ID string) ([]*entity.DetectorOutput, error) {\n+\n+\toutput, err := ad.GetAnomalyDetectorByID(commandHandler, ID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn []*entity.DetectorOutput{output}, nil\n+}\n+\n+//printDetectors displays the list of output. Since this is json format, use indent function to\n+// pretty print before printing on console\n+func printDetectors(results []*entity.DetectorOutput) {\n+\tif results == nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range results {\n+\t\tformattedOutput, err := json.MarshalIndent(d, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\tfmt.Println(err)\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Println(string(formattedOutput))\n+\t}\n+}\n+\n+func init() {\n+\tesadCmd.AddCommand(catCmd)\n+\tcatCmd.Flags().BoolP(\"name\", \"\", true, \"Input is name or pattern\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MjgyMQ=="}, "originalCommit": {"oid": "98101f2bd833d452535bc8967cdd6dec7cef43ba"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjc1Njg0OnYy", "diffSide": "RIGHT", "path": "cli/internal/controller/ad/ad.go", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMzozODo1N1rOHBFzww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODoyOTo0NVrOHEOKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTc5NQ==", "bodyText": "What use cases have you tested for the name pattern?  SearchDetectorByName method is using match query. Why not use regexp ?\n\tpayload := entity.SearchRequest{\n\t\tQuery: entity.SearchQuery{\n\t\t\tMatch: entity.Match{\n\t\t\t\tName: name,\n\t\t\t},\n\t\t},\n\t}", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470905795", "createdAt": "2020-08-14T23:38:57Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -467,5 +487,35 @@ func (c controller) DeleteDetectorByName(ctx context.Context, name string, force\n \t\t}\n \t}\n \treturn nil\n+}\n \n+//GetDetectorsByName get detector based on name pattern. It first calls SearchDetectorByName and then\n+// gets lists of detectorId and call GetDetector to get individual detector configuration\n+func (c controller) GetDetectorsByName(ctx context.Context, pattern string, display bool) ([]*entity.DetectorOutput, error) {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"fetch\", pattern)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37f4e4c7157e94158cf25bae3b9d20c4aaeeb1dd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNjEyNA==", "bodyText": "I followed this from documentation:\nhttps://opendistro.github.io/for-elasticsearch-docs/docs/ad/api/#search-detector", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r470906124", "createdAt": "2020-08-14T23:40:42Z", "author": {"login": "VijayanB"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -467,5 +487,35 @@ func (c controller) DeleteDetectorByName(ctx context.Context, name string, force\n \t\t}\n \t}\n \treturn nil\n+}\n \n+//GetDetectorsByName get detector based on name pattern. It first calls SearchDetectorByName and then\n+// gets lists of detectorId and call GetDetector to get individual detector configuration\n+func (c controller) GetDetectorsByName(ctx context.Context, pattern string, display bool) ([]*entity.DetectorOutput, error) {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"fetch\", pattern)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTc5NQ=="}, "originalCommit": {"oid": "37f4e4c7157e94158cf25bae3b9d20c4aaeeb1dd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU4MTM4MA==", "bodyText": "Can you do some test for different regex use cases? Like \"test.*\", \"test[0-9]\" etc.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r471581380", "createdAt": "2020-08-17T16:03:07Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -467,5 +487,35 @@ func (c controller) DeleteDetectorByName(ctx context.Context, name string, force\n \t\t}\n \t}\n \treturn nil\n+}\n \n+//GetDetectorsByName get detector based on name pattern. It first calls SearchDetectorByName and then\n+// gets lists of detectorId and call GetDetector to get individual detector configuration\n+func (c controller) GetDetectorsByName(ctx context.Context, pattern string, display bool) ([]*entity.DetectorOutput, error) {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"fetch\", pattern)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTc5NQ=="}, "originalCommit": {"oid": "37f4e4c7157e94158cf25bae3b9d20c4aaeeb1dd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NTg2Nw==", "bodyText": "I will create an issue to update search detecter using regex and will submit new PR with test cases.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r474185867", "createdAt": "2020-08-20T18:25:18Z", "author": {"login": "VijayanB"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -467,5 +487,35 @@ func (c controller) DeleteDetectorByName(ctx context.Context, name string, force\n \t\t}\n \t}\n \treturn nil\n+}\n \n+//GetDetectorsByName get detector based on name pattern. It first calls SearchDetectorByName and then\n+// gets lists of detectorId and call GetDetector to get individual detector configuration\n+func (c controller) GetDetectorsByName(ctx context.Context, pattern string, display bool) ([]*entity.DetectorOutput, error) {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"fetch\", pattern)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTc5NQ=="}, "originalCommit": {"oid": "37f4e4c7157e94158cf25bae3b9d20c4aaeeb1dd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4ODQyNg==", "bodyText": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/issues/213", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/207#discussion_r474188426", "createdAt": "2020-08-20T18:29:45Z", "author": {"login": "VijayanB"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -467,5 +487,35 @@ func (c controller) DeleteDetectorByName(ctx context.Context, name string, force\n \t\t}\n \t}\n \treturn nil\n+}\n \n+//GetDetectorsByName get detector based on name pattern. It first calls SearchDetectorByName and then\n+// gets lists of detectorId and call GetDetector to get individual detector configuration\n+func (c controller) GetDetectorsByName(ctx context.Context, pattern string, display bool) ([]*entity.DetectorOutput, error) {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"fetch\", pattern)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTc5NQ=="}, "originalCommit": {"oid": "37f4e4c7157e94158cf25bae3b9d20c4aaeeb1dd"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2910, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}