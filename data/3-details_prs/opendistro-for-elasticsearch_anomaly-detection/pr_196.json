{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3Mzg4MTcy", "number": 196, "title": "AD CLI", "bodyText": "Merged esad from private repo to anomaly detection plugin.\nIssue #, if available:\nDescription of changes:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-07-27T20:35:03Z", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196", "merged": true, "mergeCommit": {"oid": "d6dd8ab594bbd466b5270ed194f54dada91ba7ee"}, "closed": true, "closedAt": "2020-08-05T17:33:27Z", "author": {"login": "VijayanB"}, "timelineItems": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5H9vIAH2gAyNDU3Mzg4MTcyOjA0ODdhNDVmZjhlMGRkZjNhMTBjNzFmMTZkN2UyNjgxZDhmZGMzNmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7vxxbgH2gAyNDU3Mzg4MTcyOjdiZWEzZTY4MmM0ZGRlMWEwNTQ3ZDE3OGVjZDdjZjZlYWFhNmEzMmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "committedDate": "2020-07-27T20:36:32Z", "message": "Merge ESAD CLI into anomaly-detection\n\nMerged esad from private repo to anomaly detection plugin."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7599562e6ed5640e6a13441c76fa0311a40dbf86", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/7599562e6ed5640e6a13441c76fa0311a40dbf86", "committedDate": "2020-07-27T20:23:20Z", "message": "Merge ESAD CLI into anomaly-detection\n\nMerged esad from private repo to anomaly detection plugin."}, "afterCommit": {"oid": "0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0487a45ff8e0ddf3a10c71f16d7e2681d8fdc36d", "committedDate": "2020-07-27T20:36:32Z", "message": "Merge ESAD CLI into anomaly-detection\n\nMerged esad from private repo to anomaly detection plugin."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e49d94a3242f2da3b6d469e3ebef04215164a05", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2e49d94a3242f2da3b6d469e3ebef04215164a05", "committedDate": "2020-07-28T22:15:50Z", "message": "Include gitignore file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8e314549b060963e7846cfc333273d40c93273e2", "committedDate": "2020-07-28T22:55:44Z", "message": "Add workflow\n\nAdded build and publish artifacts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33a505e797214f6e428b4d8be09e8317faf607e0", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/33a505e797214f6e428b4d8be09e8317faf607e0", "committedDate": "2020-07-28T22:20:39Z", "message": "Add workflow\n\nAdded build and publish artifacts"}, "afterCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8e314549b060963e7846cfc333273d40c93273e2", "committedDate": "2020-07-28T22:55:44Z", "message": "Add workflow\n\nAdded build and publish artifacts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTE0MTg1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-457114185", "createdAt": "2020-07-29T00:20:11Z", "commit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMDoyMDoxMVrOG4kNeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMTowNzoxOVrOG4k-Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjcxNA==", "bodyText": "minor. is this expected?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461966714", "createdAt": "2020-07-29T00:20:11Z", "author": {"login": "wnbts"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjkyOA==", "bodyText": "minor. his should be This", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461966928", "createdAt": "2020-07-29T00:20:49Z", "author": {"login": "wnbts"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)\n+\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+his CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NzczOA==", "bodyText": "minor. AN should be An", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461967738", "createdAt": "2020-07-29T00:23:49Z", "author": {"login": "wnbts"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,97 @@\n+![Test Workflow](https://github.com/VijayanB/esad/workflows/Build%20and%20Test%20Anomaly%20detection%20commandline%20tool/badge.svg)\n+\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+his CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+AN ESAD CLI has following structure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MjEwNw==", "bodyText": "suggestion. for readability, refrain from using single letters for variable names.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461972107", "createdAt": "2020-07-29T00:40:06Z", "author": {"login": "wnbts"}, "path": "cli/cmd/create.go", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\thandler \"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCreate = \"create\"\n+\tinteractive   = \"interactive\"\n+\tgenerate      = \"generate-skeleton\"\n+)\n+\n+// createCmd represents the create command\n+var createCmd = &cobra.Command{\n+\tUse:   commandCreate + \" [list of file-path] [flags]\",\n+\tShort: \"Creates detectors based on configurations\",\n+\tLong:  `Creates detectors based on configurations specified by file path`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tstatus, _ := cmd.Flags().GetBool(interactive)\n+\t\tgenerate, _ := cmd.Flags().GetBool(generate)\n+\t\tif generate {\n+\t\t\terr := generateFile()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\terr := createDetectors(args, status)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+func generateFile() error {\n+\tdetector, _ := handler.GenerateAnomalyDetector()\n+\tfmt.Println(string(detector))\n+\treturn nil\n+}\n+\n+func init() {\n+\tesadCmd.AddCommand(createCmd)\n+\tcreateCmd.Flags().BoolP(interactive, \"i\", false, \"Create Detectors in an interactive way\")\n+\tcreateCmd.Flags().BoolP(generate, \"g\", false, \"Outputs Detector's configuration\")\n+\n+}\n+\n+func createDetectors(fileNames []string, status bool) error {\n+\th, err := getCommandHandler()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3MzUxNQ==", "bodyText": "minor. unused code can be deleted in multiple places.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461973515", "createdAt": "2020-07-29T00:45:27Z", "author": {"login": "wnbts"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3NTM1Ng==", "bodyText": "minor. the name should be existingprofilename as existing name is not valid for creation.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461975356", "createdAt": "2020-07-29T00:52:22Z", "author": {"login": "wnbts"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3ODcwNg==", "bodyText": "minor. retrieving profiles is repeated and can use refactoring.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461978706", "createdAt": "2020-07-29T01:05:31Z", "author": {"login": "wnbts"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func userInput(name string, mask bool, allowBlank bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getMaskedText()\n+\t} else {\n+\t\tresponse = getText()\n+\t}\n+\tif !allowBlank && len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn userInput(name, mask, allowBlank)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar validProfiles []string\n+\tfor _, name := range names {\n+\t\tif !validProfileName(name) {\n+\t\t\tfmt.Println(\"profile\", name, \"doesn't exists.\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalidProfiles = append(validProfiles, name)\n+\t}\n+\n+\tvar safeProfiles []entity.Profile\n+\tprofiles := getProfiles()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk3OTE1OA==", "bodyText": "question. does go have libraries for data structures other than array?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r461979158", "createdAt": "2020-07-29T01:07:19Z", "author": {"login": "wnbts"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+)\n+\n+// profilesCmd represents the profiles command\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+\t//Run: func(cmd *cobra.Command, args []string) {\n+\t//\tv, _ := cmd.Flags().GetBool(\"nameonly\")\n+\t//\tdisplayProfiles(!v)\n+\t//},\n+}\n+\n+// createProfilesCmd represents add profiles command\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+// deleteProfileCmd represents deleting profiles\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+// listProfilesCmd represents lists profiles\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+// profilesCmd represents the profiles command\n+//var updateProfileCmd = &cobra.Command{\n+//\tUse:   \"edit\",\n+//\tShort: \"edit profile\",\n+//\tLong: `A longer description that spans multiple lines and likely contains examples\n+//and usage of using your command. For example:\n+//\n+//Cobra is a CLI library for Go that empowers applications.\n+//This application is a tool to generate the needed files\n+//to quickly create a Cobra application.`,\n+//\tRun: func(cmd *cobra.Command, args []string) {\n+//\t\tupdateProfiles(args[0])\n+//\t},\n+//}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\t//profilesCmd.AddCommand(updateProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = userInput(\"profile's name\", false, false)\n+\t\tif !validProfileName(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := userInput(\"endpoint\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := userInput(\"user\", false, false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := userInput(\"password\", true, false)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func validProfileName(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func userInput(name string, mask bool, allowBlank bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getMaskedText()\n+\t} else {\n+\t\tresponse = getText()\n+\t}\n+\tif !allowBlank && len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn userInput(name, mask, allowBlank)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar validProfiles []string\n+\tfor _, name := range names {\n+\t\tif !validProfileName(name) {\n+\t\t\tfmt.Println(\"profile\", name, \"doesn't exists.\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalidProfiles = append(validProfiles, name)\n+\t}\n+\n+\tvar safeProfiles []entity.Profile\n+\tprofiles := getProfiles()\n+\tfor _, p := range profiles {\n+\t\tsafe := true\n+\t\tfor _, name := range validProfiles {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e314549b060963e7846cfc333273d40c93273e2"}, "originalPosition": 228}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34dea763b42fce6a1d6a4f331990dc80271450c3", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/34dea763b42fce6a1d6a4f331990dc80271450c3", "committedDate": "2020-07-29T01:32:24Z", "message": "test 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12659cebb8e1e3344e8c8126f2937c342dd54c4d", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/12659cebb8e1e3344e8c8126f2937c342dd54c4d", "committedDate": "2020-07-29T01:49:55Z", "message": "fixed workflow paths to cli directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0f363df560c5276f9d0c41ebd778c11492b092e", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/a0f363df560c5276f9d0c41ebd778c11492b092e", "committedDate": "2020-07-29T17:43:52Z", "message": "Refactored profiles\n\nFixed Code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb9dfc61c6749f253cbc807f385e10dab3f7bd2c", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/fb9dfc61c6749f253cbc807f385e10dab3f7bd2c", "committedDate": "2020-07-29T18:35:49Z", "message": "Update workflow name\n\nUpdate publish only tags are created."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1ccf8c740ade6e50861fc854c828d087259e619", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/f1ccf8c740ade6e50861fc854c828d087259e619", "committedDate": "2020-07-29T20:23:46Z", "message": "Temporarily allow publish artifact on push/pull"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDE5MDAx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-458019001", "createdAt": "2020-07-30T01:53:42Z", "commit": {"oid": "f1ccf8c740ade6e50861fc854c828d087259e619"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1Mzo0MlrOG5QPRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1Mzo0MlrOG5QPRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4ODA2OA==", "bodyText": "question. is it also a go convention to not have a separate directory/module for test code & data?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r462688068", "createdAt": "2020-07-30T01:53:42Z", "author": {"login": "wnbts"}, "path": "cli/internal/controller/ad/ad_test.go", "diffHunk": "@@ -0,0 +1,726 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\tesmockctrl \"esad/internal/controller/es/mocks\"\n+\tentity \"esad/internal/entity/ad\"\n+\tadgateway \"esad/internal/gateway/ad/mocks\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"github.com/golang/mock/gomock\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+const mockDetectorID = \"m4ccEnIBTXsGi3mvMt9p\"\n+const mockDetectorName = \"detector\"\n+\n+func helperLoadBytes(t *testing.T, name string) []byte {\n+\tpath := filepath.Join(\"testdata\", name) // relative path", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1ccf8c740ade6e50861fc854c828d087259e619"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9332f7d16104de9d6b7a59378986550b0da5af55", "committedDate": "2020-07-30T02:21:11Z", "message": "Upload code coverage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODM5NDQ0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-458839444", "createdAt": "2020-07-31T00:01:00Z", "commit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDowMTowMFrOG53vpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMToxMTozNlrOG5444Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNTMzMw==", "bodyText": "minor. MacOS and Linux and Windows", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463335333", "createdAt": "2020-07-31T00:01:00Z", "author": {"login": "wnbts"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NDg3Ng==", "bodyText": "question. why execute is not needed here but needed in start?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463344876", "createdAt": "2020-07-31T00:36:38Z", "author": {"login": "wnbts"}, "path": "cli/cmd/stop.go", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const commandStop = \"stop\"\n+\n+var stopCmd = &cobra.Command{\n+\tUse:   commandStop + \" [flags] [list of detectors]\",\n+\tShort: \"Stop detectors\",\n+\tLong:  `Stops detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StopAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StopAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NzM1Mg==", "bodyText": "minor. should increment be done after an operation is finished?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463347352", "createdAt": "2020-07-31T00:46:31Z", "author": {"login": "wnbts"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDU1MA==", "bodyText": "issue. the error looks like not ignored.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463350550", "createdAt": "2020-07-31T00:57:28Z", "author": {"login": "wnbts"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTkwMA==", "bodyText": "issue. is it safe to continue with a fatal error?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463351900", "createdAt": "2020-07-31T01:02:50Z", "author": {"login": "wnbts"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif interactive {\n+\t\t\tfmt.Println(*res)\n+\t\t}\n+\n+\t}\n+\terr := c.gateway.DeleteDetector(ctx, id)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) askForConfirmation(message *string) bool {\n+\n+\tif message == nil {\n+\t\treturn true\n+\t}\n+\tif len(*message) > 0 {\n+\t\tfmt.Print(*message)\n+\t}\n+\n+\tvar response string\n+\t_, err := fmt.Fscanln(c.reader, &response)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NDA4MQ==", "bodyText": "minor. this name should be undeleted.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r463354081", "createdAt": "2020-07-31T01:11:36Z", "author": {"login": "wnbts"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/gosuri/uiprogress\"\n+\t\"io\"\n+\t\"log\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector\n+func (c controller) DeleteDetector(ctx context.Context, id string, interactive bool, force bool) error {\n+\tif len(id) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id cannot be empty\")\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will delete detector: %s . Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tid,\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil\n+\t}\n+\tif force {\n+\t\tres, err := c.gateway.StopDetector(ctx, id) // ignore error\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif interactive {\n+\t\t\tfmt.Println(*res)\n+\t\t}\n+\n+\t}\n+\terr := c.gateway.DeleteDetector(ctx, id)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) askForConfirmation(message *string) bool {\n+\n+\tif message == nil {\n+\t\treturn true\n+\t}\n+\tif len(*message) > 0 {\n+\t\tfmt.Print(*message)\n+\t}\n+\n+\tvar response string\n+\t_, err := fmt.Fscanln(c.reader, &response)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tswitch strings.ToLower(response) {\n+\tcase \"y\", \"yes\":\n+\t\treturn true\n+\tcase \"n\", \"no\":\n+\t\treturn false\n+\tdefault:\n+\t\tfmt.Printf(\"I'm sorry but I didn't get what you meant, please type (y)es or (n)o and then press enter:\")\n+\t\treturn c.askForConfirmation(cmapper.StringToStringPtr(\"\"))\n+\t}\n+}\n+\n+//CreateMultiEntityAnomalyDetector creates multiple detector per entity\n+func (c controller) CreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error) {\n+\tif request.PartitionField == nil || len(*request.PartitionField) < 1 {\n+\t\tresult, err := c.CreateAnomalyDetector(ctx, request)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn []string{*result}, err\n+\t}\n+\tfilterValues, err := getFilterValues(ctx, request, c)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(filterValues) < 1 {\n+\t\treturn nil, fmt.Errorf(\n+\t\t\t\"failed to get values for partition field: %s, check whether any data is available in index %s\",\n+\t\t\t*request.PartitionField,\n+\t\t\trequest.Index,\n+\t\t)\n+\t}\n+\tproceed := true\n+\tif interactive {\n+\t\tproceed = c.askForConfirmation(\n+\t\t\tcmapper.StringToStringPtr(\n+\t\t\t\tfmt.Sprintf(\n+\t\t\t\t\t\"esad will create %d detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\",\n+\t\t\t\t\tlen(filterValues),\n+\t\t\t\t),\n+\t\t\t),\n+\t\t)\n+\t}\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\tvar bar *uiprogress.Bar\n+\tif display {\n+\t\tbar = createProgressBar(len(filterValues))\n+\t}\n+\tvar detectors []string\n+\tname := request.Name\n+\tfilter := request.Filter\n+\tvar createdDetectors []entity.Detector\n+\tfor _, value := range filterValues {\n+\t\tif bar != nil {\n+\t\t\tbar.Incr()\n+\t\t}\n+\t\trequest.Filter = buildCompoundQuery(*request.PartitionField, value, filter)\n+\t\trequest.Name = fmt.Sprintf(\"%s-%s\", name, value)\n+\t\tresult, err := c.CreateAnomalyDetector(ctx, request)\n+\t\tif err != nil {\n+\t\t\tc.cleanupCreatedDetectors(ctx, createdDetectors)\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tcreatedDetectors = append(createdDetectors, entity.Detector{\n+\t\t\tID:   *result,\n+\t\t\tName: request.Name,\n+\t\t})\n+\t\tdetectors = append(detectors, request.Name)\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func createProgressBar(total int) *uiprogress.Bar {\n+\tif total < 2 {\n+\t\treturn nil\n+\t}\n+\tuiprogress.Start()\n+\tbar := uiprogress.AddBar(total).PrependCompleted()\n+\tbar.Width = 50\n+\tbar.AppendFunc(func(b *uiprogress.Bar) string {\n+\t\treturn fmt.Sprintf(\"(%d / %d)\", b.Current(), total)\n+\t})\n+\treturn bar\n+}\n+\n+func buildCompoundQuery(field string, value interface{}, userFilter json.RawMessage) json.RawMessage {\n+\n+\tleaf1 := []byte(fmt.Sprintf(`{\n+    \t\t\t\"bool\": {\n+      \t\t\t\t\"filter\": {\n+          \t\t\t\t\"term\": {\n+\t\t\t\t\t\t\t\"%s\" : \"%v\"\n+         \t\t\t \t}\n+        \t\t\t}\n+\t\t\t\t}\n+  \t\t\t}`, field, value))\n+\tif userFilter == nil {\n+\t\treturn leaf1\n+\t}\n+\tmarshal, _ := json.Marshal(entity.Query{\n+\t\tBool: entity.Bool{\n+\t\t\tMust: []json.RawMessage{\n+\t\t\t\tleaf1, userFilter,\n+\t\t\t},\n+\t\t},\n+\t})\n+\treturn marshal\n+}\n+\n+func getFilterValues(ctx context.Context, request entity.CreateDetectorRequest, c controller) ([]interface{}, error) {\n+\tvar filterValues []interface{}\n+\tfor _, index := range request.Index {\n+\t\tv, err := c.esCtrl.GetDistinctValues(ctx, index, *request.PartitionField)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfilterValues = append(filterValues, v...)\n+\t}\n+\treturn filterValues, nil\n+}\n+\n+func (c controller) StopDetector(ctx context.Context, ID string) error {\n+\tif len(ID) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id: %s cannot be empty\", ID)\n+\t}\n+\t_, err := c.gateway.StopDetector(ctx, ID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StartDetector(ctx context.Context, ID string) error {\n+\tif len(ID) < 1 {\n+\t\treturn fmt.Errorf(\"detector Id: %s cannot be empty\", ID)\n+\t}\n+\terr := c.gateway.StartDetector(ctx, ID)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) CreateAnomalyDetector(ctx context.Context, r entity.CreateDetectorRequest) (*string, error) {\n+\n+\tif err := validateCreateRequest(r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tpayload, err := mapper.MapToCreateDetector(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse, err := c.gateway.CreateDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, processEntityError(err)\n+\t}\n+\tvar data map[string]interface{}\n+\t_ = json.Unmarshal(response, &data)\n+\n+\tdetectorID := fmt.Sprintf(\"%s\", data[\"_id\"])\n+\tif !r.Start {\n+\t\treturn cmapper.StringToStringPtr(detectorID), nil\n+\t}\n+\n+\terr = c.StartDetector(ctx, detectorID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"detector is created with id: %s, but failed to start due to %v\", detectorID, err)\n+\t}\n+\treturn cmapper.StringToStringPtr(detectorID), nil\n+}\n+\n+func processEntityError(err error) error {\n+\tvar c entity.CreateError\n+\tdata := fmt.Sprintf(\"%v\", err)\n+\tresponseErr := json.Unmarshal([]byte(data), &c)\n+\tif responseErr != nil {\n+\t\treturn err\n+\t}\n+\tif len(c.Error.Reason) > 0 {\n+\t\treturn errors.New(c.Error.Reason)\n+\t}\n+\treturn err\n+}\n+\n+func (c controller) cleanupCreatedDetectors(ctx context.Context, detectors []entity.Detector) {\n+\n+\tif len(detectors) < 1 {\n+\t\treturn\n+\t}\n+\tvar deleted []entity.Detector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9332f7d16104de9d6b7a59378986550b0da5af55"}, "originalPosition": 440}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98ca1f1f18aba01b288a3b554be3d634a327c501", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/98ca1f1f18aba01b288a3b554be3d634a327c501", "committedDate": "2020-07-31T20:47:21Z", "message": "Fixed code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a00bc59dc4d1f4ba1b5e6d0a83c165ecad4e6dc6", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/a00bc59dc4d1f4ba1b5e6d0a83c165ecad4e6dc6", "committedDate": "2020-08-03T18:24:15Z", "message": "Don't print error on root command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/924511ec3e08835237986e7550c3e0d23d0e135e", "committedDate": "2020-08-03T18:42:25Z", "message": "fix lint issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDIxMzI1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460421325", "createdAt": "2020-08-04T00:33:34Z", "commit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozMzozNFrOG7NBRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozMzozNFrOG7NBRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjQ4Ng==", "bodyText": "What will happen if I use same name for two profiles. Will throw error or override the prior one?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464732486", "createdAt": "2020-08-04T00:33:34Z", "author": {"login": "ylwu-amzn"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDIyNTE4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460422518", "createdAt": "2020-08-04T00:37:55Z", "commit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozNzo1NlrOG7NFyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozNzo1NlrOG7NFyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMzY0MA==", "bodyText": "Seems the commands not follow same name convention. esad profile create  looks like esad <resource> <action>, but here esad start [detector-name-pattern] looks like esad <action> <resource>. Is it possible to follow same name convention? Maybe consult Carlos to confirm.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464733640", "createdAt": "2020-08-04T00:37:56Z", "author": {"login": "ylwu-amzn"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+An ESAD CLI has following structure\n+```\n+$ esad <command> <subcommand> [flags and parameters]\n+```\n+For example to start detector:\n+```\n+$ esad start [detector-name-pattern]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDIzMDc3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460423077", "createdAt": "2020-08-04T00:39:50Z", "commit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozOTo1MFrOG7NHyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozOTo1MFrOG7NHyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDE1NA==", "bodyText": "How about adding version compatibility table in the help doc and read-me doc?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464734154", "createdAt": "2020-08-04T00:39:50Z", "author": {"login": "ylwu-amzn"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,96 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS and Linux, and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/\n+    ```\n+\n+## Configure\n+\n+Before using the AWS CLI, you need to configure your AWS credentials. You can do this in several ways:\n+\n+* Configuration command\n+* Config file\n+\n+The quickest way to get started is to run the `esad profile create`\n+\n+```\n+$ esad profile create\n+Enter profile's name: dev\n+ES Anomaly Detection Endpoint: https://localhost:9200\n+ES Anomaly Detection User: admin\n+ES Anomaly Detection Password:\n+```\n+\n+To use a config file, create a YAML file like this\n+```\n+profiles:\n+- endpoint: https://localhost:9200\n+  username: admin\n+  password: foobar\n+  name: default\n+- endpoint: https://odfe-node1:9200\n+  username: admin\n+  password: foobar\n+  name: dev\n+```\n+and place it on ~/.esad/config.yaml. if you wish to place the shared credentials file in a different location than the one specified above, you need to tell aws-cli where to find it. Do this by setting the appropriate environment variable:\n+\n+```\n+export ESAD_CONFIG_FILE=/path/to/config_file\n+```\n+You can have multiple profiles defined in the configuration file. You can then specify which profile to use by using the --profile option. If no profile is specified the `default` profile is used.\n+\n+\n+\n+## Basic Commands\n+\n+An ESAD CLI has following structure\n+```\n+$ esad <command> <subcommand> [flags and parameters]\n+```\n+For example to start detector:\n+```\n+$ esad start [detector-name-pattern]\n+```\n+To view help documentation, use one of the following:\n+```\n+$ esad --help\n+$ esad <command> --help\n+$ esad <command> <subcommand> --help\n+```\n+To get the version of the ESAD CLI:\n+```\n+$ esad --version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDMxNzcy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460431772", "createdAt": "2020-08-04T01:10:43Z", "commit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMToxMDo0M1rOG7Nl2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMToxMDo0M1rOG7Nl2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MTg1MA==", "bodyText": "What if user set both generate and create?  How about add some comments here about difference of create/generate, so don't need to go to handler.GenerateAnomalyDetector to learn more what generate does ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r464741850", "createdAt": "2020-08-04T01:10:43Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/create.go", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\thandler \"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandCreate = \"create\"\n+\tinteractive   = \"interactive\"\n+\tgenerate      = \"generate-skeleton\"\n+)\n+\n+var createCmd = &cobra.Command{\n+\tUse:   commandCreate + \" [list of file-path] [flags]\",\n+\tShort: \"Creates detectors based on configurations\",\n+\tLong:  `Creates detectors based on configurations specified by file path`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tstatus, _ := cmd.Flags().GetBool(interactive)\n+\t\tgenerate, _ := cmd.Flags().GetBool(generate)\n+\t\tif generate {\n+\t\t\terr := generateFile()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Println(commandCreate, \"command failed\")\n+\t\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\terr := createDetectors(args, status)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "924511ec3e08835237986e7550c3e0d23d0e135e"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "749fdfd91402bfa5569fc31dd680fe477ec39177", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/749fdfd91402bfa5569fc31dd680fe477ec39177", "committedDate": "2020-08-04T03:16:05Z", "message": "Update Readme\n\nFixed typo and added extra description about profile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635", "committedDate": "2020-08-04T03:29:57Z", "message": "Display usage if no args is specified"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTg3ODAy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460987802", "createdAt": "2020-08-04T16:42:15Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjo0MjoxNVrOG7ormg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjo0MjoxNVrOG7ormg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NTY5MA==", "bodyText": "This method is to get distinct value of one field. How about we rename this method as \"SearchDistinctValue\"? So I don't need to read the method implementation to learn this.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465185690", "createdAt": "2020-08-04T16:42:15Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/gateway/es/es.go", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package es\n+\n+import (\n+\t\"context\"\n+\t\"esad/internal/client\"\n+\telasticsearch \"esad/internal/entity/es\"\n+\tgw \"esad/internal/gateway\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+const search = \"_search\"\n+\n+//go:generate mockgen -destination=mocks/mock_es.go -package=mocks . Gateway\n+\n+//Gateway interface to call ES\n+type Gateway interface {\n+\tSearch(ctx context.Context, index string, field string) ([]byte, error)\n+}\n+\n+type gateway struct {\n+\tgw.HTTPGateway\n+}\n+\n+// NewESGateway returns new Gateway instance\n+func NewESGateway(c *client.Client, u *client.UserConfig) Gateway {\n+\treturn &gateway{\n+\t\t*gw.NewHTTPGateway(c, u),\n+\t}\n+}\n+func buildPayload(field string) *elasticsearch.SearchRequest {\n+\treturn &elasticsearch.SearchRequest{\n+\t\tSize: 0, // This will skip data in the response\n+\t\tAgg: elasticsearch.Aggregate{\n+\t\t\tGroup: elasticsearch.DistinctGroups{\n+\t\t\t\tTerm: elasticsearch.Terms{\n+\t\t\t\t\tField: field,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func (g *gateway) buildSearchURL(index string) (*url.URL, error) {\n+\tendpoint, err := gw.GetValidEndpoint(g.UserConfig)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint.Path = fmt.Sprintf(\"%s/%s\", index, search)\n+\treturn endpoint, nil\n+}\n+\n+func (g *gateway) Search(ctx context.Context, index string, field string) ([]byte, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTk3ODE3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-460997817", "createdAt": "2020-08-04T16:55:12Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjo1NToxMlrOG7pKMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjo1NToxMlrOG7pKMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzUyMg==", "bodyText": "What's the name convention for the file name? I see this ES controller named as \"controller.go\", but AD controller named as \"ad.go\". And I see five \"ad.go\" files in these folders: entity, mapper, gateway, handler, controller. Is it common practice in Go to use same file name and differentiate them with package path?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465193522", "createdAt": "2020-08-04T16:55:12Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/es/controller.go", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDAyNjE3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461002617", "createdAt": "2020-08-04T17:01:15Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowMToxNlrOG7pY1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowMToxNlrOG7pY1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NzI2OA==", "bodyText": "Add comments for public methods ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465197268", "createdAt": "2020-08-04T17:01:16Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDA2OTg1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461006985", "createdAt": "2020-08-04T17:07:33Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowNzozNFrOG7pmYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowNzozNFrOG7pmYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDczOA==", "bodyText": "minor: how about move StartDetectorByName method before StopDetectorByName ? This can improve a little bit code readability.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465200738", "createdAt": "2020-08-04T17:07:34Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 202}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/adfe6dd467f0c3d282b75a7eff43c575631a0ed6", "committedDate": "2020-08-04T17:08:40Z", "message": "Update Readme"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDA4NjE3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461008617", "createdAt": "2020-08-04T17:09:52Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowOTo1MlrOG7prVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowOTo1MlrOG7prVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMjAwNA==", "bodyText": "minor: this simple comment looks like some duplicate of the method name \"DeleteDetector\".  How about add more details like what we will do for force is true/false? Suggest to check other places too.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465202004", "createdAt": "2020-08-04T17:09:52Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/ad/ad.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"esad/internal/controller/es\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"esad/internal/gateway/ad\"\n+\tcmapper \"esad/internal/mapper\"\n+\tmapper \"esad/internal/mapper/ad\"\n+\t\"fmt\"\n+\t\"github.com/cheggaaa/pb/v3\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . AnomalyDetectorController\n+\n+//AnomalyDetectorController is an interface for the AD plugin controllers\n+type AnomalyDetectorController interface {\n+\tCreateAnomalyDetector(context.Context, entity.CreateDetectorRequest) (*string, error)\n+\tCreateMultiEntityAnomalyDetector(ctx context.Context, request entity.CreateDetectorRequest, interactive bool, display bool) ([]string, error)\n+\tStartDetector(context.Context, string) error\n+\tStopDetector(context.Context, string) error\n+\tDeleteDetector(context.Context, string, bool, bool) error\n+\tDeleteDetectorByName(context.Context, string, bool, bool) error\n+\tStartDetectorByName(context.Context, string, bool) error\n+\tStopDetectorByName(context.Context, string, bool) error\n+\tSearchDetectorByName(context.Context, string) ([]entity.Detector, error)\n+}\n+\n+type controller struct {\n+\treader  io.Reader\n+\tgateway ad.Gateway\n+\tesCtrl  es.Controller\n+}\n+\n+func validateCreateRequest(r entity.CreateDetectorRequest) error {\n+\tif len(r.Name) < 1 {\n+\t\treturn fmt.Errorf(\"name field cannot be empty\")\n+\t}\n+\tif len(r.Features) < 1 {\n+\t\treturn fmt.Errorf(\"features cannot be empty\")\n+\t}\n+\tif len(r.Index) < 1 || len(r.Index[0]) < 1 {\n+\t\treturn fmt.Errorf(\"index field cannot be empty and it should have at least one valid index\")\n+\t}\n+\tif len(r.Interval) < 1 {\n+\t\treturn fmt.Errorf(\"interval field cannot be empty\")\n+\t}\n+\treturn nil\n+}\n+func (c controller) DeleteDetectorByName(ctx context.Context, name string, force bool, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, \"delete\", name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := c.DeleteDetector(ctx, detector.ID, false, force)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"failed to delete %d following detector(s)\\n\", len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+\n+}\n+\n+//NewADController returns new ADController instance\n+func NewADController(reader io.Reader, esCtrl es.Controller, gateway ad.Gateway) AnomalyDetectorController {\n+\treturn &controller{\n+\t\treader,\n+\t\tgateway,\n+\t\tesCtrl,\n+\t}\n+}\n+\n+func (c controller) SearchDetectorByName(ctx context.Context, name string) ([]entity.Detector, error) {\n+\tif len(name) < 1 {\n+\t\treturn nil, fmt.Errorf(\"detector name cannot be empty\")\n+\t}\n+\tpayload := entity.SearchRequest{\n+\t\tQuery: entity.SearchQuery{\n+\t\t\tMatch: entity.Match{\n+\t\t\t\tName: name,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tresponse, err := c.gateway.SearchDetector(ctx, payload)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdetectors, err := mapper.MapToDetectors(response, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn detectors, nil\n+}\n+\n+func (c controller) StartDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"start\", c.StartDetector, display)\n+}\n+\n+func (c controller) getDetectorsToProcess(ctx context.Context, method string, pattern string) ([]entity.Detector, error) {\n+\tif len(pattern) < 1 {\n+\t\treturn nil, fmt.Errorf(\"name cannot be empty\")\n+\t}\n+\t//Search Detector By Name to get ID\n+\tmatchedDetectors, err := c.SearchDetectorByName(ctx, pattern)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(matchedDetectors) < 1 {\n+\t\tfmt.Printf(\"no detectors matched by name %s\\n\", pattern)\n+\t\treturn nil, nil\n+\t}\n+\tfmt.Printf(\"%d detectors matched by name %s\\n\", len(matchedDetectors), pattern)\n+\tfor _, detector := range matchedDetectors {\n+\t\tfmt.Println(detector.Name)\n+\t}\n+\n+\tproceed := c.askForConfirmation(\n+\t\tcmapper.StringToStringPtr(\n+\t\t\tfmt.Sprintf(\"esad will %s above matched detector(s). Do you want to proceed? please type (y)es or (n)o and then press enter:\", method),\n+\t\t),\n+\t)\n+\tif !proceed {\n+\t\treturn nil, nil\n+\t}\n+\treturn matchedDetectors, nil\n+}\n+\n+func (c controller) processDetectorByAction(ctx context.Context, pattern string, action string, f func(c context.Context, s string) error, display bool) error {\n+\tmatchedDetectors, err := c.getDetectorsToProcess(ctx, action, pattern)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif matchedDetectors == nil {\n+\t\treturn nil\n+\t}\n+\tvar bar *pb.ProgressBar\n+\tif display {\n+\t\tbar = createProgressBar(len(matchedDetectors))\n+\t}\n+\tvar failedDetectors []string\n+\tfor _, detector := range matchedDetectors {\n+\t\terr := f(ctx, detector.ID)\n+\t\tif err != nil {\n+\t\t\tfailedDetectors = append(failedDetectors, fmt.Sprintf(\"%s \\t Reason: %s\", detector.Name, err))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bar != nil {\n+\t\t\tbar.Increment()\n+\t\t}\n+\t}\n+\tif bar != nil {\n+\t\tbar.Finish()\n+\t}\n+\tif len(failedDetectors) > 0 {\n+\t\tfmt.Printf(\"\\nfailed to %s %d following detector(s)\\n\", action, len(failedDetectors))\n+\t\tfor _, detector := range failedDetectors {\n+\t\t\tfmt.Println(detector)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c controller) StopDetectorByName(ctx context.Context, pattern string, display bool) error {\n+\treturn c.processDetectorByAction(ctx, pattern, \"stop\", c.StopDetector, display)\n+}\n+\n+//DeleteDetector deletes detector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDEzODAx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461013801", "createdAt": "2020-08-04T17:16:44Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoxNjo0NVrOG7p7BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoxNjo0NVrOG7p7BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjAyMQ==", "bodyText": "Rename it as EsController considering we have AnomalyDetectorController?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465206021", "createdAt": "2020-08-04T17:16:45Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/controller/es/controller.go", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package es\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/es\"\n+\t\"esad/internal/gateway/es\"\n+\t\"fmt\"\n+)\n+\n+//go:generate mockgen -destination=mocks/mock_ad.go -package=mocks . Controller\n+\n+//Controller is an interface for ES Cluster to get distinct values\n+type Controller interface {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDE2Mjc2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461016276", "createdAt": "2020-08-04T17:20:14Z", "commit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyMDoxNFrOG7qC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyMDoxNFrOG7qC7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODA0NQ==", "bodyText": "I think we should write const in uppercase letters.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465208045", "createdAt": "2020-08-04T17:20:14Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/gateway/ad/ad.go", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"esad/internal/client\"\n+\tgw \"esad/internal/gateway\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+const (\n+\tbaseURL           = \"_opendistro/_anomaly_detection/detectors\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a7c1a6d9dc4cdc1a9e0f518722ffe5182fb635"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDIxNTg5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461021589", "createdAt": "2020-08-04T17:27:39Z", "commit": {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyNzo0MFrOG7qT0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyNzo0MFrOG7qT0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMjM3MA==", "bodyText": "Should we change the repo ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465212370", "createdAt": "2020-08-04T17:27:40Z", "author": {"login": "ylwu-amzn"}, "path": "cli/README.md", "diffHunk": "@@ -0,0 +1,105 @@\n+![AD CLI Test and Build](https://github.com/opendistro-for-elasticsearch/anomaly-detection/workflows/AD%20CLI%20Test%20and%20Build/badge.svg)\n+# Open Distro for Elasticsearch AD CLI\n+\n+The AD CLI component in Open Distro for Elasticsearch (ODFE) is a command line interface for ODFE AD plugin.\n+This CLI provides greater flexibility of use. User can use CLI to easily do things that are difficult or sometimes impossible to do with kibana UI. This doesn\u2019t use any additional  system resources to load any of graphical part, thus making it simpler and faster than UI. \n+\n+It only supports [Open Distro for Elasticsearch (ODFE) AD Plugin](https://opendistro.github.io/for-elasticsearch-docs/docs/ad/)\n+You must have the ODFE AD plugin installed to your Elasticsearch instance to connect. \n+Users can run this CLI from MacOS, Windows, Linux and connect to any valid Elasticsearch end-point such as Amazon Elasticsearch Service (AES).The ESAD CLI implements AD APIs.\n+\n+## Version Compatibility Matrix\n+\n+| ESAD Version  | ODFE Version        |\n+| ------------- |:-------------------:|\n+| 0.1           | 1.7.X, 1.8.X, 1.9.X |\n+\n+## Features\n+\n+* Create Detectors\n+* Start, Stop, Delete Detectors\n+* Create named profiles to connect to ES cluster\n+\n+## Install\n+\n+Launch your local Elasticsearch instance and make sure you have the Open Distro for Elasticsearch AD plugin installed.\n+\n+To install the AD CLI:\n+\n+\n+1. Install from source:\n+\n+    ```\n+    $ go get github.com/VijayanB/esad/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDI5MTkx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461029191", "createdAt": "2020-08-04T17:38:27Z", "commit": {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzozODoyN1rOG7qrzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzozODoyN1rOG7qrzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxODUxMA==", "bodyText": "Wrong comments?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465218510", "createdAt": "2020-08-04T17:38:27Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/handler/ad/ad.go", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\tcontroller \"esad/internal/controller/ad\"\n+\tentity \"esad/internal/entity/ad\"\n+\tmapper2 \"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+)\n+\n+//Handler is facade for controller\n+type Handler struct {\n+\tcontroller.AnomalyDetectorController\n+}\n+\n+// New returns new Handler instance\n+func New(controller controller.AnomalyDetectorController) *Handler {\n+\treturn &Handler{\n+\t\tcontroller,\n+\t}\n+}\n+\n+//CreateAnomalyDetector creates detector based on file configurations\n+func CreateAnomalyDetector(h *Handler, fileName string, interactive bool) error {\n+\treturn h.CreateAnomalyDetector(fileName, interactive)\n+}\n+\n+//GenerateAnomalyDetector creates detector based on file configurations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe6dd467f0c3d282b75a7eff43c575631a0ed6"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b32a33abde85620b09bc2097a08d343d84b344b0", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b32a33abde85620b09bc2097a08d343d84b344b0", "committedDate": "2020-08-04T17:56:02Z", "message": "Rename Search to SearchDistinctValues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d65eb8a39828520049ae568845a45dfdbf87303f", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/d65eb8a39828520049ae568845a45dfdbf87303f", "committedDate": "2020-08-04T17:59:16Z", "message": "rename controller to es"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9b805da939d62fb7243a4a9ee01792ed48b4a50f", "committedDate": "2020-08-04T18:51:32Z", "message": "Fixed following review comments\n\n1) Move methods close to help readability\n2) Add comments to exported methods\n3) Fix typo and copied comments\n4) Rename file name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTE2NTc5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461116579", "createdAt": "2020-08-04T19:38:05Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTozODowNVrOG7uydA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTozODowNVrOG7uydA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NTc0OA==", "bodyText": "How about print all existing profile names as well? So user don't need to guess which name is not used.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465285748", "createdAt": "2020-08-04T19:38:05Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTE5NjU0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461119654", "createdAt": "2020-08-04T19:42:49Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0Mjo0OVrOG7u7yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0Mjo0OVrOG7u7yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4ODEzNg==", "bodyText": "How about we abstract this as validate func and pass it into getUserInput ? So it's flexible to support more parameter's validation logic in future. As currently we have only one simple validation, don't need to make it too complicated currently. Add some todo is fine. It's up to you.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465288136", "createdAt": "2020-08-04T19:42:49Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := getUserInput(\"endpoint\", false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := getUserInput(\"user\", false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := getUserInput(\"password\", true)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func isProfileExists(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getUserInputAsText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getUserInputAsMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func getUserInput(name string, mask bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getUserInputAsMaskedText()\n+\t} else {\n+\t\tresponse = getUserInputAsText()\n+\t}\n+\tif len(response) < 1 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTIyNzE0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461122714", "createdAt": "2020-08-04T19:47:44Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0Nzo0NVrOG7vFYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0Nzo0NVrOG7vFYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MDU5NQ==", "bodyText": "Not so efficient to run isProfileExists  for every profile name, which will getProfile and do iteration to check if name exists. How about read all profiles, construct map (key: profile name, value: profile), then remove deleted profiles ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465290595", "createdAt": "2020-08-04T19:47:45Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/profile.go", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"esad/internal/client\"\n+\tentity \"esad/internal/entity/ad\"\n+\t\"fmt\"\n+\t\"github.com/mitchellh/mapstructure\"\n+\t\"github.com/spf13/cobra\"\n+\t\"github.com/spf13/viper\"\n+\t\"golang.org/x/crypto/ssh/terminal\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/tabwriter\"\n+)\n+\n+const (\n+\tprofileBaseCmdName      = \"profile\"\n+\tcreateNewProfileCmdName = \"create\"\n+\tdeleteNewProfileCmdName = \"delete\"\n+\tlistProfileCmdName      = \"list\"\n+\tesadProfile             = \"ESAD_PROFILE\"\n+)\n+\n+var profilesCmd = &cobra.Command{\n+\tUse:   profileBaseCmdName + \" [flags] [command] [sub command]\",\n+\tShort: \"profile is a collection of settings and credentials that you can apply to an esad command\",\n+\tLong: `\t   A named profile is a collection of settings and credentials that you can apply to an ESAD command. \n+           When you specify a profile to run a command, the settings and credentials are used to run that command. \n+           You can specify a profile in an environment variable (ESAD_PROFILE) which essentially acts as the default profile for commands if default doesn't exists.\n+           The ESAD CLI supports using any of multiple named profiles that are stored in the config and credentials files.`,\n+}\n+\n+var createProfilesCmd = &cobra.Command{\n+\tUse:   createNewProfileCmdName,\n+\tShort: \"Create new named profile\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tcreateProfile()\n+\t},\n+}\n+\n+var deleteProfileCmd = &cobra.Command{\n+\tUse:   deleteNewProfileCmdName + \" [list of profile names to be deleted]\",\n+\tShort: \"Delete named profiles\",\n+\tLong:  `Delete profile permanently from configuration files`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tdeleteProfiles(args)\n+\t},\n+}\n+\n+var listProfilesCmd = &cobra.Command{\n+\tUse:   listProfileCmdName,\n+\tShort: \"lists named profiles\",\n+\tLong:  `A named profile is a collection of settings and credentials that you can apply to an ESAD command.`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tdisplayProfiles()\n+\t},\n+}\n+\n+func displayProfiles() {\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load config due to \", err)\n+\t\treturn\n+\t}\n+\tconst padding = 3\n+\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.AlignRight)\n+\tfmt.Fprintln(w, \"Name\\t\\tUserName\\t\\tEndpoint-url\\t\")\n+\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", \"----\", \"--------\", \"------------\")\n+\tfor _, profile := range config.Profiles {\n+\t\tfmt.Fprintf(w, \"%s\\t\\t%s\\t\\t%s\\t\\n\", profile.Name, profile.Username, profile.Endpoint)\n+\t}\n+\tw.Flush()\n+\n+}\n+\n+func init() {\n+\tprofilesCmd.AddCommand(createProfilesCmd)\n+\tprofilesCmd.AddCommand(deleteProfileCmd)\n+\tesadCmd.AddCommand(profilesCmd)\n+\tprofilesCmd.AddCommand(listProfilesCmd)\n+\n+}\n+\n+func createProfile() {\n+\tvar name string\n+\tfor {\n+\t\tfmt.Printf(\"Enter profile's name: \")\n+\t\tname = getUserInput(\"profile's name\", false)\n+\t\tif !isProfileExists(name) {\n+\t\t\tbreak\n+\t\t}\n+\t\tfmt.Println(\"profile\", name, \"already exists.\")\n+\t}\n+\tfmt.Printf(\"ES Anomaly Detection Endpoint: \")\n+\tendpoint := getUserInput(\"endpoint\", false)\n+\tfmt.Printf(\"ES Anomaly Detection User: \")\n+\tuser := getUserInput(\"user\", false)\n+\tfmt.Printf(\"ES Anomaly Detection Password: \")\n+\tpassword := getUserInput(\"password\", true)\n+\tprofile := entity.Profile{\n+\t\tName:     name,\n+\t\tEndpoint: endpoint,\n+\t\tUsername: user,\n+\t\tPassword: password,\n+\t}\n+\tconfig := &entity.Configuration{\n+\t\tProfiles: []entity.Profile{},\n+\t}\n+\terr := mapstructure.Decode(viper.AllSettings(), config)\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to load profiles due to \", err)\n+\t}\n+\tconfig.Profiles = append(config.Profiles, profile)\n+\tsaveProfiles(config.Profiles)\n+}\n+\n+func saveProfiles(profiles []entity.Profile) {\n+\tviper.Set(\"profiles\", profiles)\n+\terr := viper.WriteConfig()\n+\tif err == nil {\n+\t\treturn\n+\t}\n+\terr = viper.SafeWriteConfig()\n+\tif err != nil {\n+\t\tfmt.Println(\"failed to save profile due to \", err)\n+\t}\n+}\n+\n+func isProfileExists(name string) bool {\n+\tprofiles := getProfiles()\n+\tfor _, profile := range profiles {\n+\t\tif profile.Name == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func getUserInputAsText() string {\n+\tvar response string\n+\t_, err := fmt.Scanln(&response)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\treturn strings.TrimSpace(response)\n+}\n+\n+func getUserInputAsMaskedText() string {\n+\tmaskedValue, err := terminal.ReadPassword(0)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\tos.Exit(1)\n+\t}\n+\tfmt.Println()\n+\treturn fmt.Sprintf(\"%s\", maskedValue)\n+}\n+\n+func getUserInput(name string, mask bool) string {\n+\n+\tvar response string\n+\tif mask {\n+\t\tresponse = getUserInputAsMaskedText()\n+\t} else {\n+\t\tresponse = getUserInputAsText()\n+\t}\n+\tif len(response) < 1 {\n+\t\tfmt.Printf(\"value cannot be empty. Please enter non-empty value for %s: \", name)\n+\t\treturn getUserInput(name, mask)\n+\t}\n+\treturn response\n+}\n+\n+func deleteProfiles(names []string) {\n+\n+\tvar existingProfileNames []string\n+\tfor _, name := range names {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTI1MDQ1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461125045", "createdAt": "2020-08-04T19:51:24Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1MToyNFrOG7vMYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1MToyNFrOG7vMYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjM4Nw==", "bodyText": "Wrong comment?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465292387", "createdAt": "2020-08-04T19:51:24Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+// createCmd represents the create command", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTI1Njgz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461125683", "createdAt": "2020-08-04T19:52:25Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1MjoyNVrOG7vOkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1MjoyNVrOG7vOkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mjk0NA==", "bodyText": "Missing comment ? How about add comments for every command?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465292944", "createdAt": "2020-08-04T19:52:25Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+// createCmd represents the create command\n+var startCmd = &cobra.Command{\n+\tUse:   commandStart + \" [flags] [list of detectors]\",\n+\tShort: \"Start detectors\",\n+\tLong:  `Start detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StartAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StartAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandStart, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+var stopCmd = &cobra.Command{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTI5NTcy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461129572", "createdAt": "2020-08-04T19:58:34Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1ODozNVrOG7vatg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1ODozNVrOG7vatg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjA1NA==", "bodyText": "We only support minutes on AD Kibana. Should we support more unit options in AD CLI? If user use \"Hours\" to create index with CLI, then AD Kibana may not show it correctly.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465296054", "createdAt": "2020-08-04T19:58:35Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/mapper/ad/ad.go", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/ad\"\n+\t\"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+const featureCountLimit = 5\n+\n+func getFeatureAggregationQuery(name string, agg string, field string) ([]byte, error) {\n+\n+\tuserTypeToESType := make(map[string]string)\n+\tuserTypeToESType[\"average\"] = \"avg\"\n+\tuserTypeToESType[\"count\"] = \"value_count\"\n+\tuserTypeToESType[\"sum\"] = \"sum\"\n+\tuserTypeToESType[\"min\"] = \"min\"\n+\tuserTypeToESType[\"max\"] = \"max\"\n+\tval, ok := userTypeToESType[strings.ToLower(agg)]\n+\tif !ok {\n+\t\tvar allowedTypes []string\n+\t\tfor key := range userTypeToESType {\n+\t\t\tallowedTypes = append(allowedTypes, key)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invlaid aggeration type: '%s', only allowed types are: %s \", agg, strings.Join(allowedTypes, \",\"))\n+\t}\n+\tagg = val\n+\treturn []byte(fmt.Sprintf(`{\n+        \t\t\t\"%s\": {\n+          \t\t\t\t\"%s\": {\n+            \t\t\t\t\"field\": \"%s\"\n+\t\t\t\t\t\t}\n+        \t\t\t}\n+      \t\t\t}`, name, agg, field)), nil\n+}\n+func mapToFeature(r ad.FeatureRequest) ([]ad.Feature, error) {\n+\tvar features []ad.Feature\n+\tfor _, t := range r.AggregationType {\n+\t\tfor _, f := range r.Field {\n+\t\t\tname := fmt.Sprintf(\"%s_%s\", t, f)\n+\t\t\tquery, err := getFeatureAggregationQuery(name, t, f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfeatures = append(features, ad.Feature{\n+\t\t\t\tName:             name,\n+\t\t\t\tEnabled:          r.Enabled,\n+\t\t\t\tAggregationQuery: query,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn features, nil\n+}\n+\n+func getUnit(request string) (*string, error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTMwMzY5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461130369", "createdAt": "2020-08-04T19:59:50Z", "commit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1OTo1MFrOG7vdUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1OTo1MFrOG7vdUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjcyMg==", "bodyText": "minor: typo, feautes  -> features", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465296722", "createdAt": "2020-08-04T19:59:50Z", "author": {"login": "ylwu-amzn"}, "path": "cli/internal/mapper/ad/ad.go", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package ad\n+\n+import (\n+\t\"encoding/json\"\n+\t\"esad/internal/entity/ad\"\n+\t\"esad/internal/mapper\"\n+\t\"fmt\"\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+const featureCountLimit = 5\n+\n+func getFeatureAggregationQuery(name string, agg string, field string) ([]byte, error) {\n+\n+\tuserTypeToESType := make(map[string]string)\n+\tuserTypeToESType[\"average\"] = \"avg\"\n+\tuserTypeToESType[\"count\"] = \"value_count\"\n+\tuserTypeToESType[\"sum\"] = \"sum\"\n+\tuserTypeToESType[\"min\"] = \"min\"\n+\tuserTypeToESType[\"max\"] = \"max\"\n+\tval, ok := userTypeToESType[strings.ToLower(agg)]\n+\tif !ok {\n+\t\tvar allowedTypes []string\n+\t\tfor key := range userTypeToESType {\n+\t\t\tallowedTypes = append(allowedTypes, key)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invlaid aggeration type: '%s', only allowed types are: %s \", agg, strings.Join(allowedTypes, \",\"))\n+\t}\n+\tagg = val\n+\treturn []byte(fmt.Sprintf(`{\n+        \t\t\t\"%s\": {\n+          \t\t\t\t\"%s\": {\n+            \t\t\t\t\"field\": \"%s\"\n+\t\t\t\t\t\t}\n+        \t\t\t}\n+      \t\t\t}`, name, agg, field)), nil\n+}\n+func mapToFeature(r ad.FeatureRequest) ([]ad.Feature, error) {\n+\tvar features []ad.Feature\n+\tfor _, t := range r.AggregationType {\n+\t\tfor _, f := range r.Field {\n+\t\t\tname := fmt.Sprintf(\"%s_%s\", t, f)\n+\t\t\tquery, err := getFeatureAggregationQuery(name, t, f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfeatures = append(features, ad.Feature{\n+\t\t\t\tName:             name,\n+\t\t\t\tEnabled:          r.Enabled,\n+\t\t\t\tAggregationQuery: query,\n+\t\t\t})\n+\t\t}\n+\t}\n+\treturn features, nil\n+}\n+\n+func getUnit(request string) (*string, error) {\n+\n+\t//extract last character\n+\tunit := strings.ToLower(request[len(request)-1:])\n+\tstringToUnitMap := make(map[string]string)\n+\tstringToUnitMap[\"s\"] = \"Seconds\"\n+\tstringToUnitMap[\"m\"] = \"Minutes\"\n+\tstringToUnitMap[\"h\"] = \"Hours\"\n+\tstringToUnitMap[\"w\"] = \"Weeks\"\n+\tstringToUnitMap[\"d\"] = \"Days\"\n+\tif val, ok := stringToUnitMap[unit]; ok {\n+\t\treturn mapper.StringToStringPtr(val), nil\n+\t}\n+\treturn nil, fmt.Errorf(\"invlaid unit: '%v' in %v\", unit, request)\n+}\n+\n+func getDuration(request string) (*int32, error) {\n+\t//extract last but one character\n+\tduration, err := strconv.Atoi(request[:len(request)-1])\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invlaid duration: %v, due to {%v}\", request, err)\n+\t}\n+\tif duration < 0 {\n+\t\treturn nil, fmt.Errorf(\"duration must be positive integer\")\n+\t}\n+\treturn mapper.IntToInt32Ptr(duration)\n+}\n+\n+func mapToInterval(request string) (*ad.Interval, error) {\n+\tif len(request) < 2 {\n+\t\treturn nil, fmt.Errorf(\"invalid format: %s\", request)\n+\t}\n+\tduration, err := getDuration(request)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tunit, err := getUnit(request)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &ad.Interval{\n+\t\tPeriod: ad.Period{\n+\t\t\tDuration: mapper.Int32PtrToInt32(duration),\n+\t\t\tUnit:     mapper.StringPtrToString(unit),\n+\t\t},\n+\t}, nil\n+}\n+\n+//MapToCreateDetector maps to CreateDetector\n+func MapToCreateDetector(request ad.CreateDetectorRequest) (*ad.CreateDetector, error) {\n+\n+\tvar features []ad.Feature\n+\terr := validateFeatureLimit(request.Features)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, f := range request.Features {\n+\t\tftr, err := mapToFeature(f)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfeatures = append(features, ftr...)\n+\t}\n+\n+\tinterval, err := mapToInterval(request.Interval)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdelay, err := mapToInterval(request.Delay)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &ad.CreateDetector{\n+\t\tName:        request.Name,\n+\t\tDescription: request.Description,\n+\t\tTimeField:   request.TimeField,\n+\t\tIndex:       request.Index,\n+\t\tFeatures:    features,\n+\t\tFilter:      request.Filter,\n+\t\tInterval:    *interval,\n+\t\tDelay:       *delay,\n+\t}, nil\n+}\n+\n+func validateFeatureLimit(features []ad.FeatureRequest) error {\n+\tfeatureCount := 0\n+\tfor _, f := range features {\n+\t\tfeatureCount += len(f.AggregationType) * len(f.Field)\n+\t}\n+\tif featureCount == 0 || featureCount > featureCountLimit {\n+\t\treturn fmt.Errorf(\"trying to create %d feautes, only upto %d features are allowed\", featureCount, featureCountLimit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b805da939d62fb7243a4a9ee01792ed48b4a50f"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9659ac6502ff88e96c46337b7cf09f9a140bd46d", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9659ac6502ff88e96c46337b7cf09f9a140bd46d", "committedDate": "2020-08-04T21:22:15Z", "message": "use map for get profiles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bec3bd904b8e43a1edc4bea9624893f800e5572", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2bec3bd904b8e43a1edc4bea9624893f800e5572", "committedDate": "2020-08-04T21:30:32Z", "message": "Fixed typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjAzMjM2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#pullrequestreview-461203236", "createdAt": "2020-08-04T21:58:30Z", "commit": {"oid": "2bec3bd904b8e43a1edc4bea9624893f800e5572"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTo1ODozMFrOG7y76Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMTo1ODozMFrOG7y76Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MzcwNQ==", "bodyText": "How about rename as \"StopAnomalyDetectorByNamePattern\" considering this method \"StopAnomalyDetectorByID\"", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/196#discussion_r465353705", "createdAt": "2020-08-04T21:58:30Z", "author": {"login": "ylwu-amzn"}, "path": "cli/cmd/start_stop.go", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package cmd\n+\n+import (\n+\t\"esad/internal/client\"\n+\t\"esad/internal/handler/ad\"\n+\t\"fmt\"\n+\t\"github.com/spf13/cobra\"\n+)\n+\n+const (\n+\tcommandStart = \"start\"\n+\tcommandStop  = \"stop\"\n+)\n+\n+var startCmd = &cobra.Command{\n+\tUse:   commandStart + \" [flags] [list of detectors]\",\n+\tShort: \"Start detectors\",\n+\tLong:  `Start detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StartAnomalyDetector\n+\t\tif idStatus {\n+\t\t\taction = ad.StartAnomalyDetectorByID\n+\t\t}\n+\t\terr := execute(action, args)\n+\t\tif err != nil {\n+\t\t\tfmt.Println(commandStart, \"command failed\")\n+\t\t\tfmt.Println(\"Reason:\", err)\n+\t\t}\n+\t},\n+}\n+\n+var stopCmd = &cobra.Command{\n+\tUse:   commandStop + \" [flags] [list of detectors]\",\n+\tShort: \"Stop detectors\",\n+\tLong:  `Stops detectors based on pattern, use \"\" to make sure the name is not matched with pwd lists'`,\n+\tRun: func(cmd *cobra.Command, args []string) {\n+\t\t//If no args, display usage\n+\t\tif len(args) < 1 {\n+\t\t\tif err := cmd.Usage(); err != nil {\n+\t\t\t\tfmt.Println(err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tidStatus, _ := cmd.Flags().GetBool(\"id\")\n+\t\taction := ad.StopAnomalyDetector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bec3bd904b8e43a1edc4bea9624893f800e5572"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e7336d943debc0fb9f445a0dfdbacfe6c85b895", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5e7336d943debc0fb9f445a0dfdbacfe6c85b895", "committedDate": "2020-08-04T22:03:26Z", "message": "Move validation as method argument"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d92e26323c2b583d564c82941fdaae3b1460df97", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/d92e26323c2b583d564c82941fdaae3b1460df97", "committedDate": "2020-08-04T23:08:45Z", "message": "Fixed Review comments\n\nRename Method name to include byNamePattern\nSupport only minutes for interval\nAdded extra comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bea3e682c4dde1a0547d178ecd7cf6eaaa6a32a", "author": {"user": {"login": "VijayanB", "name": "Vijayan Balasubramanian"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/7bea3e682c4dde1a0547d178ecd7cf6eaaa6a32a", "committedDate": "2020-08-05T00:07:31Z", "message": "Renamed gateway"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1506, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}