{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNjQwMDg1", "number": 184, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzo0MDoxNlrOELyHDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo1OTozOFrOEL13QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzkwNzk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzo0MDoxNlrOGthBYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMToxMjoxMFrOGuUs_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ==", "bodyText": "add some interpolation if you miss less than 25% of points?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450380129", "createdAt": "2020-07-06T17:40:16Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5ODExNg==", "bodyText": "no, since the results from search are known to be missing. that truth should not be manipulated. interpolation is for when the data is unknown.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450498116", "createdAt": "2020-07-06T21:50:19Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzNTc4NQ==", "bodyText": "Interpolation is for robust results.  I don't agree with truth should not be manipulated assertion.  Say samples are always 6 points, you are gonna drop them all and start with 0 shingles.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450535785", "createdAt": "2020-07-06T23:47:59Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0NTYxMw==", "bodyText": "yes, the behavior in the example is expected. when data is sparse and shingle is required, the conflict will persist throughout the detector run. even training data were to be populated by introducing non-existent data, real-time prediciton will still fail for lack of data. there will need to be a different solution for solving this problem. let's start with the right solution and see the feedback.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450545613", "createdAt": "2020-07-07T00:24:17Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMDAyOA==", "bodyText": "We had this conversation before: once in your initial cold start CR where you dropped all samples if you encounter a hole, once for missing data inside the shingle.  We agree to use limited interpolation and not dropping samples.  What's the difference this time?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r451000028", "createdAt": "2020-07-07T16:40:45Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyOTcwMQ==", "bodyText": "Before this change, due to the few number of samples (a few dozens), interpolation has to be used or there is no training data at all.\nWith exhaustive search, there are more samples for training and knowingly inserting data that is known not to exist becomes unnecessary given its downsides.\n\ninterpolated data affects model accuracy.\nit's highly controversial and idiosyncratic when to/not to fake data, how, and even why and therefore there is unlikely a solution satisfactory to all. Think person A thinks 20% is ok for interpolation. person B thinks 60% is better. person C thinks a different interpolation is the best. and yet person D says even 10% is bad. Using data as-it-is is the most agreeable approach.\n\nThis pr is adding improvements from standard data processing over the existing one, serving as the least controversial foundation yet not a one-way door. In case someone has a strong personal preference, they can always raise a new pr based on this one for everyone to see and take/reject.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r451129701", "createdAt": "2020-07-07T20:39:46Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3NzkzMw==", "bodyText": "About your downside points:\n\nno doubt\nInterpolation is basic in machine learning.  I am not sure about the high controversial part.  We don't want to put users on such delicate choice of the percentage of fake data.  We want to guide users  reasonable choice.\n\nI feel the PR can be better by considering data imputation.  I don't want a half-done solution.  We have already gone this far by running much more queries than we planned.  It's better to make it worthwhile and not trivially throw away points.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r451177933", "createdAt": "2020-07-07T22:24:28Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNjg3OA==", "bodyText": "the controversies are as follows.\n\nwhen to interpolate/not to interpolate. with 1% data, can anyone \"interpolate\" the rest 99%? 10% to 90%? what's the boundary? who makes the rules on what authority? even with interpolation, how many more data points are expected to be produced? no one can guarantee those arbitrary rules will produce more data points. if there is still no enough samples, then what? keep beating this dead horse?\nhow to interpolate/impute. there are many options. for example, why not just filter out gaps and shingle the remaining? again, any proposal will be unfair to some and attract challenges and who is the judge.\n\nit should be clear now that on this topic, the matters are not what everyone, or even we, can agree on, and they may continue forever due to their flexible/ill-defined targets and lack of a legal means/authority to resolve. What in one's opinion is completely-done can be considered further wrong in another's.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r451226878", "createdAt": "2020-07-08T01:12:10Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );\n+            } catch (IOException e) {\n+                listener.onFailure(e);\n+            }\n         } else {\n             listener.onResponse(Optional.empty());\n         }\n     }\n \n-    private void processColdStartSamples(Optional<Entry<double[][], Integer>> samples, ActionListener<Optional<double[][]>> listener) {\n-        listener\n-            .onResponse(\n-                samples\n-                    .map(\n-                        results -> transpose(\n-                            interpolator.interpolate(transpose(results.getKey()), results.getValue() * (results.getKey().length - 1) + 1)\n-                        )\n-                    )\n-                    .map(points -> batchShingle(points, shingleSize))\n-            );\n+    private void processColdStartSamples(List<Optional<double[]>> samples, ActionListener<Optional<double[][]>> listener) {\n+        List<double[]> shingles = new ArrayList<>();\n+        Optional<double[]> previous = Optional.empty();\n+        List<double[]> currentBlock = new ArrayList<>();\n+        for (Optional<double[]> sample : samples) {\n+            if (sample.isPresent()) {\n+                currentBlock.add(sample.get());\n+            } else {\n+                if (previous.isPresent()) {\n+                    batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+                    currentBlock.clear();\n+                }\n+            }\n+            previous = sample;\n+        }\n+        batchShingle(currentBlock, this.shingleSize).ifPresent(batch -> Arrays.stream(batch).forEach(shingles::add));\n+        listener.onResponse(Optional.of(shingles.toArray(new double[0][0])).filter(results -> results.length > 0));\n+    }\n+\n+    private Optional<double[][]> batchShingle(List<double[]> points, int shingleSize) {\n+        return Optional\n+            .ofNullable(points)\n+            .filter(p -> p.size() >= shingleSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyOQ=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODUyMjg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo1OTozOFrOGtm7ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo0NzoxNFrOGtoJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3Njk4Ng==", "bodyText": "Is checking for latest.isPresent() (or even passing in latest as a param) still needed, since latest is not used by searchFeatureDao.getFeatureSamplesForPeriods or anywhere else in this function anymore?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450476986", "createdAt": "2020-07-06T20:59:38Z", "author": {"login": "LiuJoyceC"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5Njg2MQ==", "bodyText": "it's now used in line 253.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/184#discussion_r450496861", "createdAt": "2020-07-06T21:47:14Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -241,30 +250,59 @@ public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<d\n \n     private void getColdStartSamples(Optional<Long> latest, AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n         if (latest.isPresent()) {\n-            searchFeatureDao\n-                .getFeaturesForSampledPeriods(\n-                    detector,\n-                    maxTrainSamples,\n-                    maxSampleStride,\n-                    latest.get(),\n-                    ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n-                );\n+            List<Entry<Long, Long>> sampleRanges = getColdStartSampleRanges(detector, latest.get());\n+            try {\n+                searchFeatureDao\n+                    .getFeatureSamplesForPeriods(\n+                        detector,\n+                        sampleRanges,\n+                        ActionListener.wrap(samples -> processColdStartSamples(samples, listener), listener::onFailure)\n+                    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3Njk4Ng=="}, "originalCommit": {"oid": "976a225a275d724b0f8775b8136e0327b47ba3c3"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2894, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}