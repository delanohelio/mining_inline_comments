{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMDk5NTU5", "number": 84, "title": "Add state and error to profile API", "bodyText": "Issue #, if available:\nDescription of changes:\nWe want to make it easy for customers and oncalls to identify a detector\u2019s state and error if any. This PR adds such information to our new profile API.\nWe expect three kinds of states:\n-Disabled: if get ad job api says the job is disabled;\n-Init: if anomaly score after the last update time of the detector is larger than 0\n-Running: if neither of the above applies and no exceptions.\nError is populated if error of the latest anomaly result is not empty.\nExample:\ncurl -X GET \"localhost:9200/_opendistro/_anomaly_detection/detectors/t6gGRXEBNjeafFFiEvhk/_profile\"\n{\"state\":\"INIT\",\"error\":\"No full shingle in current detection window\"}\n\ncurl -X GET \"localhost:9200/_opendistro/_anomaly_detection/detectors/t6gGRXEBNjeafFFiEvhk/_profile/state\"\n{\"state\":\"INIT\"}\n\nTesting done:\n-manual testing during a detector\u2019s life cycle: not created, created but not started, started, during initialization, after initialization, stopped, restarted\n-added unit tests to cover above scenario\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-10T23:08:07Z", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84", "merged": true, "mergeCommit": {"oid": "e5b6ce5f47590e9c451c02a2b81d1c40a5f2b6d6"}, "closed": true, "closedAt": "2020-04-15T22:45:14Z", "author": {"login": "kaituo"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWZW4TAH2gAyNDAyMDk5NTU5OjdlZDFmZWMyMDViYTk5ODk2ODg4MGE3ZjU0MTVjZjIxYjQxYzJiMTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX-rzdAH2gAyNDAyMDk5NTU5OjNkNmU5YmJhMTljMGJiOWE5NzU5MTE1NmZmYmVhZDhkZTk1ODgwNDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/7ed1fec205ba998968880a7f5415cf21b41c2b19", "committedDate": "2020-04-10T23:05:02Z", "message": "Add state and error to profile API\n\nWe want to make it easy for customers and oncalls to identify a detector\u2019s state and error if any. This PR adds such information to our new profile API.\n\nWe expect three kinds of states:\n-Disabled: if get ad job api says the job is disabled;\n-Init: if anomaly score after the last update time of the detector is larger than 0\n-Running: if neither of the above applies and no exceptions.\n\nError is populated if error of the latest anomaly result is not empty.\n\nTesting done:\n-manual testing during a detector\u2019s life cycle: not created, created but not started, started, during initialization, after initialization, stopped, restarted\n-added unit tests to cover above scenario"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjI1MDY4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392625068", "createdAt": "2020-04-14T06:04:16Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjowNDoxNlrOGE_bqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjowNDoxNlrOGE_bqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4Njc2MA==", "bodyText": "Use job enabled_time here, think of the case : detector last update time not changed, but we disabled and restarted job multiple times. So we may get some AD result with non-zero anomaly score which generated before latest job enabled time, but actually the latest AD job is still initializing.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407886760", "createdAt": "2020-04-14T06:04:16Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);\n+                    listener.onFailure(new RuntimeException(error, e));\n+                }\n+            } else {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            }\n+        }, exception -> {\n+            logger.warn(exception);\n+            // detector job index does not exist\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to get detector state for \" + detectorId);\n+                listener.onFailure(exception);\n+            }\n+        }));\n+\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        long lastUpdateTimeMs\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            DetectorProfile profile = new DetectorProfile();\n+            if (hits.getTotalHits().value == 0L) {\n+                profile.setState(DetectorState.INIT);\n+            } else {\n+                profile.setState(DetectorState.RUNNING);\n+            }\n+\n+            listener.onResponse(profile);\n+\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                // anomaly result index is not created yet\n+                profile.setState(DetectorState.INIT);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Error is populated if error of the latest anomaly result is not empty.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned error or exception\n+     */\n+    private void profileError(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        SearchRequest searchLatestResult = createLatestAnomalyResultRequest(detectorId, lastUpdateTimeMs);\n+        client.search(searchLatestResult, onGetLatestAnomalyResult(listener, detectorId));\n+    }\n+\n+    private ActionListener<SearchResponse> onGetLatestAnomalyResult(ActionListener<DetectorProfile> listener, String detectorId) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                logger.error(\"We should not get empty result: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Unexpected error while looking for detector state:  \" + detectorId));\n+            } else {\n+                SearchHit hit = hits.getAt(0);\n+\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, hit.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyResult result = parser.namedObject(AnomalyResult.class, AnomalyResult.PARSE_FIELD_NAME, null);\n+\n+                    DetectorProfile profile = new DetectorProfile();\n+                    if (result.getError() != null) {\n+                        profile.setError(result.getError());\n+                    }\n+                    listener.onResponse(profile);\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(\"Fail to parse anomaly result with \" + hit.toString());\n+                    listener.onFailure(new RuntimeException(\"Fail to find detector error: \" + detectorId, e));\n+                }\n+            }\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                listener.onResponse(new DetectorProfile());\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: \" + detectorId);\n+                listener.onFailure(new RuntimeException(\"Fail to find detector error: \" + detectorId, exception));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create search request to check if we have at least 1 anomaly score larger than 0 after last update time\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeEpochMs last update time in milliseconds\n+     * @return the search request\n+     */\n+    private SearchRequest createInittedEverRequest(String detectorId, long lastUpdateTimeEpochMs) {\n+        BoolQueryBuilder filterQuery = new BoolQueryBuilder();\n+        filterQuery.filter(QueryBuilders.termQuery(AnomalyResult.DETECTOR_ID_FIELD, detectorId));\n+        filterQuery.filter(QueryBuilders.rangeQuery(AnomalyResult.EXECUTION_END_TIME_FIELD).gte(lastUpdateTimeEpochMs));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjI2MTA3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392626107", "createdAt": "2020-04-14T06:07:07Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjowNzowN1rOGE_fOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjowNzowN1rOGE_fOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4NzY3Mg==", "bodyText": "Similar as line 260, we should use AD job \"enabled_time\"", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407887672", "createdAt": "2020-04-14T06:07:07Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);\n+                    listener.onFailure(new RuntimeException(error, e));\n+                }\n+            } else {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            }\n+        }, exception -> {\n+            logger.warn(exception);\n+            // detector job index does not exist\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to get detector state for \" + detectorId);\n+                listener.onFailure(exception);\n+            }\n+        }));\n+\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        long lastUpdateTimeMs\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            DetectorProfile profile = new DetectorProfile();\n+            if (hits.getTotalHits().value == 0L) {\n+                profile.setState(DetectorState.INIT);\n+            } else {\n+                profile.setState(DetectorState.RUNNING);\n+            }\n+\n+            listener.onResponse(profile);\n+\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                // anomaly result index is not created yet\n+                profile.setState(DetectorState.INIT);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Error is populated if error of the latest anomaly result is not empty.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned error or exception\n+     */\n+    private void profileError(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        SearchRequest searchLatestResult = createLatestAnomalyResultRequest(detectorId, lastUpdateTimeMs);\n+        client.search(searchLatestResult, onGetLatestAnomalyResult(listener, detectorId));\n+    }\n+\n+    private ActionListener<SearchResponse> onGetLatestAnomalyResult(ActionListener<DetectorProfile> listener, String detectorId) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                logger.error(\"We should not get empty result: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Unexpected error while looking for detector state:  \" + detectorId));\n+            } else {\n+                SearchHit hit = hits.getAt(0);\n+\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, hit.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyResult result = parser.namedObject(AnomalyResult.class, AnomalyResult.PARSE_FIELD_NAME, null);\n+\n+                    DetectorProfile profile = new DetectorProfile();\n+                    if (result.getError() != null) {\n+                        profile.setError(result.getError());\n+                    }\n+                    listener.onResponse(profile);\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(\"Fail to parse anomaly result with \" + hit.toString());\n+                    listener.onFailure(new RuntimeException(\"Fail to find detector error: \" + detectorId, e));\n+                }\n+            }\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                listener.onResponse(new DetectorProfile());\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: \" + detectorId);\n+                listener.onFailure(new RuntimeException(\"Fail to find detector error: \" + detectorId, exception));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create search request to check if we have at least 1 anomaly score larger than 0 after last update time\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeEpochMs last update time in milliseconds\n+     * @return the search request\n+     */\n+    private SearchRequest createInittedEverRequest(String detectorId, long lastUpdateTimeEpochMs) {\n+        BoolQueryBuilder filterQuery = new BoolQueryBuilder();\n+        filterQuery.filter(QueryBuilders.termQuery(AnomalyResult.DETECTOR_ID_FIELD, detectorId));\n+        filterQuery.filter(QueryBuilders.rangeQuery(AnomalyResult.EXECUTION_END_TIME_FIELD).gte(lastUpdateTimeEpochMs));\n+        filterQuery.filter(QueryBuilders.rangeQuery(AnomalyResult.ANOMALY_SCORE_FIELD).gt(0));\n+\n+        SearchSourceBuilder source = new SearchSourceBuilder().query(filterQuery).size(1);\n+\n+        SearchRequest request = new SearchRequest(AnomalyResult.ANOMALY_RESULT_INDEX);\n+        request.source(source);\n+        return request;\n+    }\n+\n+    private SearchRequest createLatestAnomalyResultRequest(String detectorId, long lastUpdateTimeEpochMs) {\n+        BoolQueryBuilder filterQuery = new BoolQueryBuilder();\n+        filterQuery.filter(QueryBuilders.termQuery(AnomalyResult.DETECTOR_ID_FIELD, detectorId));\n+        filterQuery.filter(QueryBuilders.rangeQuery(AnomalyResult.EXECUTION_END_TIME_FIELD).gte(lastUpdateTimeEpochMs));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 273}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjI3Nzcy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392627772", "createdAt": "2020-04-14T06:11:01Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjoxMTowMVrOGE_lDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjoxMTowMVrOGE_lDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg4OTE2Ng==", "bodyText": "log exception stack trace to make operation easier? Similar to other places", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407889166", "createdAt": "2020-04-14T06:11:01Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjQyOTQz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392642943", "createdAt": "2020-04-14T06:45:26Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo0NToyNlrOGFAWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo0NToyNlrOGFAWbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMTgwNg==", "bodyText": "saved means the responses are from some saved result from ES indices ? Or means we cache these response ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407901806", "createdAt": "2020-04-14T06:45:26Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/DelegateActionListener.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+public class DelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(DelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    private final List<T> savedResponses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjQ4MTIy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392648122", "createdAt": "2020-04-14T06:55:36Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo1NTozNlrOGFAnLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo1NTozNlrOGFAnLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNjA5Mg==", "bodyText": "How about we add some comments about what TYPE means and the supported value?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407906092", "createdAt": "2020-04-14T06:55:36Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -55,11 +65,32 @@\n \n     private static final String GET_ANOMALY_DETECTOR_ACTION = \"get_anomaly_detector\";\n     private static final Logger logger = LogManager.getLogger(RestGetAnomalyDetectorAction.class);\n+    private final AnomalyDetectorProfileRunner profileRunner;\n+    private final Set<String> allProfileTypeStrs;\n+\n+    public RestGetAnomalyDetectorAction(\n+        RestController controller,\n+        AnomalyDetectorProfileRunner profileRunner,\n+        Set<String> allProfileTypeStrs\n+    ) {\n+        this.profileRunner = profileRunner;\n+        this.allProfileTypeStrs = allProfileTypeStrs;\n \n-    public RestGetAnomalyDetectorAction(RestController controller) {\n         String path = String.format(Locale.ROOT, \"%s/{%s}\", AnomalyDetectorPlugin.AD_BASE_DETECTORS_URI, DETECTOR_ID);\n         controller.registerHandler(RestRequest.Method.GET, path, this);\n         controller.registerHandler(RestRequest.Method.HEAD, path, this);\n+        controller\n+            .registerHandler(\n+                RestRequest.Method.GET,\n+                String.format(Locale.ROOT, \"%s/{%s}/%s\", AnomalyDetectorPlugin.AD_BASE_DETECTORS_URI, DETECTOR_ID, PROFILE),\n+                this\n+            );\n+        controller\n+            .registerHandler(\n+                RestRequest.Method.GET,\n+                String.format(Locale.ROOT, \"%s/{%s}/%s/{%s}\", AnomalyDetectorPlugin.AD_BASE_DETECTORS_URI, DETECTOR_ID, PROFILE, TYPE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjQ4NjUx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392648651", "createdAt": "2020-04-14T06:56:38Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo1NjozOFrOGFAozA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjo1NjozOFrOGFAozA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNjUwOA==", "bodyText": "How about we validate type here and return Set<ProfileName>?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407906508", "createdAt": "2020-04-14T06:56:38Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -148,4 +178,25 @@ public RestResponse buildResponse(MultiGetResponse multiGetResponse) throws Exce\n         };\n     }\n \n+    private ActionListener<DetectorProfile> getProfileActionListener(RestChannel channel, String detectorId) {\n+        return ActionListener\n+            .wrap(\n+                profile -> { channel.sendResponse(new BytesRestResponse(RestStatus.OK, profile.toXContent(channel.newBuilder()))); },\n+                exception -> { channel.sendResponse(buildInternalServerErrorResponse(exception, exception.getMessage())); }\n+            );\n+    }\n+\n+    private RestResponse buildInternalServerErrorResponse(Exception e, String errorMsg) {\n+        logger.error(errorMsg, e);\n+        return new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, errorMsg);\n+    }\n+\n+    private Set<String> getProfilesToCollect(String typesStr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjU2NzY5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392656769", "createdAt": "2020-04-14T07:11:31Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoxMTozMVrOGFBDVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoxMTozMVrOGFBDVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxMzMwMQ==", "bodyText": "Seems you design this general delegate listener not only for profile API. Can you add more comments? Suggest to use a more specific name like MultiResponsesDelegateActionListener ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407913301", "createdAt": "2020-04-14T07:11:31Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/DelegateActionListener.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+public class DelegateActionListener<T extends Mergeable> implements ActionListener<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjU5ODAx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392659801", "createdAt": "2020-04-14T07:16:25Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoxNjoyNVrOGFBM9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoxNjoyNVrOGFBM9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxNTc2NQ==", "bodyText": "If expectedResponseCount==0 , collectedResponseCount.incrementAndGet() will always greater than expectedResponseCount , please add some validation for expectedResponseCount, or change to collectedResponseCount.incrementAndGet() >= expectedResponseCount", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407915765", "createdAt": "2020-04-14T07:16:25Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/DelegateActionListener.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+public class DelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(DelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public DelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        ;\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() == expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        LOG.info(e);\n+        try {\n+            this.exceptions.add(e.getMessage());\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() == expectedResponseCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjYyMDc1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392662075", "createdAt": "2020-04-14T07:20:11Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoyMDoxMVrOGFBUuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoyMDoxMVrOGFBUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkxNzc1NQ==", "bodyText": "Why log response0 here? Similar for line 84.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407917755", "createdAt": "2020-04-14T07:20:11Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/DelegateActionListener.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+public class DelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(DelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public DelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        ;\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() == expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        LOG.info(e);\n+        try {\n+            this.exceptions.add(e.getMessage());\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() == expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+    }\n+\n+    private void finish() {\n+        if (this.exceptions.size() == 0) {\n+            if (savedResponses.size() == 0) {\n+                this.delegate.onFailure(new RuntimeException(String.format(\"Unexpected exceptions\")));\n+            } else {\n+                T response0 = savedResponses.get(0);\n+                LOG.info(response0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjY3NTg0", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392667584", "createdAt": "2020-04-14T07:28:42Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoyODo0MlrOGFBmzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzoyODo0MlrOGFBmzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkyMjM4MQ==", "bodyText": "Here, the finalErrorMsg is \"Fail to fetch profile for \" + detectorId.\nFrom line89 of class DelegateActionListener: this.delegate.onFailure(new RuntimeException(String.format(Locale.ROOT, finalErrorMsg, exceptions)));,  String.format(...) will not include exceptions, is this by design?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407922381", "createdAt": "2020-04-14T07:28:42Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjcxOTI2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392671926", "createdAt": "2020-04-14T07:35:21Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzozNToyMVrOGFB0-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzozNToyMVrOGFB0-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkyNjAxMA==", "bodyText": "How about we change to \"Must set at least one profile type\" to avoid confusion between empty profile types and wrong profile types which we don't support?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407926010", "createdAt": "2020-04-14T07:35:21Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjc3Mzgw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392677380", "createdAt": "2020-04-14T07:43:24Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo0MzoyNFrOGFCGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo0MzoyNFrOGFCGkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzMDUxNQ==", "bodyText": "minor: can use this method: listener.failImmediately(String errMsg, Exception e)", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407930515", "createdAt": "2020-04-14T07:43:24Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjgzNjcw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392683670", "createdAt": "2020-04-14T07:52:33Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo1MjozM1rOGFCaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo1MjozM1rOGFCaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzNTU1NQ==", "bodyText": "If some uncatched exception, will not execute listener.onFailure method, collectedResponseCount will not increase, so will never execute finish.\nSuggest to catch Exception here to avoid some uncatched exceptions. Similar to line 236", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407935555", "createdAt": "2020-04-14T07:52:33Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjkwMTA3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392690107", "createdAt": "2020-04-14T08:01:11Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODowMToxMVrOGFCvKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODowMToxMVrOGFCvKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk0MDkwNw==", "bodyText": "Can we add custom error message here?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407940907", "createdAt": "2020-04-14T08:01:11Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);\n+                    listener.onFailure(new RuntimeException(error, e));\n+                }\n+            } else {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            }\n+        }, exception -> {\n+            logger.warn(exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 160}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjk2MDkz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392696093", "createdAt": "2020-04-14T08:09:27Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODowOToyN1rOGFDB7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODowOToyN1rOGFDB7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk0NTcxMA==", "bodyText": "minor: make the error message more accurate, like Fail to find latest anomaly result with anomalyScore>0 from XXX for detector XXX", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407945710", "createdAt": "2020-04-14T08:09:27Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);\n+                    listener.onFailure(new RuntimeException(error, e));\n+                }\n+            } else {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            }\n+        }, exception -> {\n+            logger.warn(exception);\n+            // detector job index does not exist\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to get detector state for \" + detectorId);\n+                listener.onFailure(exception);\n+            }\n+        }));\n+\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        long lastUpdateTimeMs\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            DetectorProfile profile = new DetectorProfile();\n+            if (hits.getTotalHits().value == 0L) {\n+                profile.setState(DetectorState.INIT);\n+            } else {\n+                profile.setState(DetectorState.RUNNING);\n+            }\n+\n+            listener.onResponse(profile);\n+\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                // anomaly result index is not created yet\n+                profile.setState(DetectorState.INIT);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: {}\", detectorId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 197}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzAwODA4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-392700808", "createdAt": "2020-04-14T08:15:44Z", "commit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoxNTo0NFrOGFDQ9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODoxNTo0NFrOGFDQ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk0OTU1OA==", "bodyText": "Why throw exception if we can't find AD result ? If not AD result, that means AD job is initializing and no error. But from DelegateActionListener  line 89, if any exception occurs, will execute this.delegate.onFailure(...) rather than return Init state and null error.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r407949558", "createdAt": "2020-04-14T08:15:44Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.DelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        DelegateActionListener<DetectorProfile> delegateListener = new DelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE.getName()) || profiles.contains(ProfileName.ERROR.getName())) {\n+            prepareProfileStateNError(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfileStateNError(String detectorId, DelegateActionListener<DetectorProfile> listener, Set<String> profiles) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+    }\n+\n+    private ActionListener<GetResponse> onGetDetectorResponse(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        Set<String> profiles\n+    ) {\n+        return ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                    long lastUpdateTimeMs = detector.getLastUpdateTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE.getName())) {\n+                        profileState(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR.getName())) {\n+                        profileError(detectorId, lastUpdateTimeMs, listener);\n+                    }\n+\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(new RuntimeException(FAIL_TO_FIND_DETECTOR_MSG + detectorId, e));\n+                }\n+            } else {\n+                listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId);\n+            }\n+        }, exception -> { listener.failImmediately(FAIL_TO_FIND_DETECTOR_MSG + detectorId, exception); });\n+    }\n+\n+    /**\n+     * We expect three kinds of states:\n+     *  -Disabled: if get ad job api says the job is disabled;\n+     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Running: if neither of the above applies and no exceptions.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned state or exception\n+     */\n+    private void profileState(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    if (job.isEnabled()) {\n+                        SearchRequest searchLatestResult = createInittedEverRequest(detectorId, lastUpdateTimeMs);\n+                        client.search(searchLatestResult, onInittedEver(listener, detectorId, lastUpdateTimeMs));\n+                    } else {\n+                        DetectorProfile profile = new DetectorProfile();\n+                        profile.setState(DetectorState.DISABLED);\n+                        listener.onResponse(profile);\n+                    }\n+                } catch (IOException | XContentParseException e) {\n+                    String error = \"Fail to parse detector with id: \" + detectorId;\n+                    logger.error(error);\n+                    listener.onFailure(new RuntimeException(error, e));\n+                }\n+            } else {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            }\n+        }, exception -> {\n+            logger.warn(exception);\n+            // detector job index does not exist\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                profile.setState(DetectorState.DISABLED);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to get detector state for \" + detectorId);\n+                listener.onFailure(exception);\n+            }\n+        }));\n+\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        DelegateActionListener<DetectorProfile> listener,\n+        String detectorId,\n+        long lastUpdateTimeMs\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            DetectorProfile profile = new DetectorProfile();\n+            if (hits.getTotalHits().value == 0L) {\n+                profile.setState(DetectorState.INIT);\n+            } else {\n+                profile.setState(DetectorState.RUNNING);\n+            }\n+\n+            listener.onResponse(profile);\n+\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {\n+                DetectorProfile profile = new DetectorProfile();\n+                // anomaly result index is not created yet\n+                profile.setState(DetectorState.INIT);\n+                listener.onResponse(profile);\n+            } else {\n+                logger.error(\"Fail to find latest anomaly result of id: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Error is populated if error of the latest anomaly result is not empty.\n+     * @param detectorId detector id\n+     * @param lastUpdateTimeMs last update time of the detector in milliseconds\n+     * @param listener listener to process the returned error or exception\n+     */\n+    private void profileError(String detectorId, long lastUpdateTimeMs, DelegateActionListener<DetectorProfile> listener) {\n+        SearchRequest searchLatestResult = createLatestAnomalyResultRequest(detectorId, lastUpdateTimeMs);\n+        client.search(searchLatestResult, onGetLatestAnomalyResult(listener, detectorId));\n+    }\n+\n+    private ActionListener<SearchResponse> onGetLatestAnomalyResult(ActionListener<DetectorProfile> listener, String detectorId) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                logger.error(\"We should not get empty result: {}\", detectorId);\n+                listener.onFailure(new RuntimeException(\"Unexpected error while looking for detector state:  \" + detectorId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ed1fec205ba998968880a7f5415cf21b41c2b19"}, "originalPosition": 219}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a1a304ab1d71841a2dac7c226560f06cb66825a", "author": {"user": {"login": "amirmuminovic", "name": "Amir Muminovi\u0107"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/6a1a304ab1d71841a2dac7c226560f06cb66825a", "committedDate": "2020-04-15T01:37:39Z", "message": "Added URL for jb_scheduler-plugin_zip instead of local file path (#82)\n\n* Added URL for jb_scheduler-plugin_zip instead of local file path\r\n\r\n* Fixed windows path by adding additional /"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c04e836c03069617bac4fd2c5bda648f2464d890", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c04e836c03069617bac4fd2c5bda648f2464d890", "committedDate": "2020-04-15T01:38:26Z", "message": "Use callbacks and bug fix (#83)\n\n* Use callbacks and bug fix\r\n\r\nThis PR includes the following changes:\r\n\r\n1. remove classes that are not needed in jacocoExclusions since we have enough coverage for those classes.\r\n2. Use ClientUtil instead of Elasticsearch\u2019s client in AD job runner\r\n3. Use one function to get the number of partitioned forests. Previously, we have redundant code in both ModelManager and ADStateManager.\r\n4. Change ADStateManager.getAnomalyDetector to use callback.\r\n5. Change AnomalyResultTransportAction to use callback to get features.\r\n6. Add in AnomalyResultTransportAction to handle the case where all features have been disabled, and users' index does not exist.\r\n7. Change get RCF and threshold result methods to use callback and add exception handling of IndexNotFoundException due to the change. Previously, getting RCF and threshold result methods won\u2019t throw IndexNotFoundException.\r\n8. Remove unused fields in StopDetectorTransportAction and AnomalyResultTransportAction\r\n9. Unwrap EsRejectedExecutionException as it can be nested inside RemoteTransportException. Previously, we would not recognize EsRejectedExecutionException and thus miss anomaly results write retrying.\r\n10. Add error in anomaly result schema.11. Fix broken tests due to my changes.\r\n\r\nTesting done:\r\n1. unit/integration tests pass\r\n2. do end-to-end testing and make sure my fix achieves the purpose\u00a0\r\n   * timeout issue is gone\u00a0\r\n   * when all features have been disabled or index does not exist, we will retry a few more times and disable AD jobs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db4543ca46c21320cbe9663e82e9d124caa2d068", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/db4543ca46c21320cbe9663e82e9d124caa2d068", "committedDate": "2020-04-15T01:38:26Z", "message": "Add state and error to profile API\n\nWe want to make it easy for customers and oncalls to identify a detector\u2019s state and error if any. This PR adds such information to our new profile API.\n\nWe expect three kinds of states:\n-Disabled: if get ad job api says the job is disabled;\n-Init: if anomaly score after the last update time of the detector is larger than 0\n-Running: if neither of the above applies and no exceptions.\n\nError is populated if error of the latest anomaly result is not empty.\n\nTesting done:\n-manual testing during a detector\u2019s life cycle: not created, created but not started, started, during initialization, after initialization, stopped, restarted\n-added unit tests to cover above scenario"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b445fb8e91640794c5bcd707054564b33d0a9716", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b445fb8e91640794c5bcd707054564b33d0a9716", "committedDate": "2020-04-15T01:38:27Z", "message": "Addresss various comments from Yaliang"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/a476ed48257ace99427189f7a0d53281b27245b2", "committedDate": "2020-04-15T02:47:04Z", "message": "Merge branch 'development' into profile3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTQwODQz", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-393940843", "createdAt": "2020-04-15T16:30:16Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTg2NzIw", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-393986720", "createdAt": "2020-04-15T17:30:21Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzozMDoyMlrOGGEMPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzozMDoyMlrOGGEMPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMzMwOA==", "bodyText": "not blocker: you can move this isEmpty() check to the entry of this method, aka line 67. And then you can skip the check on line 78", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409013308", "createdAt": "2020-04-15T17:30:22Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.MultiResponsesDelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+    static String FAIL_TO_GET_PROFILE_MSG = \"Fail to get profile for detector \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<ProfileName> profiles) {\n+        MultiResponsesDelegateActionListener<DetectorProfile> delegateListener = new MultiResponsesDelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTk2NDgy", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-393996482", "createdAt": "2020-04-15T17:43:47Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0Mzo0N1rOGGErqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0Mzo0N1rOGGErqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMTM1Mg==", "bodyText": "Unsupported profile", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409021352", "createdAt": "2020-04-15T17:43:47Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/ProfileName.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public enum ProfileName {\n+    STATE(\"state\"),\n+    ERROR(\"error\");\n+\n+    private String name;\n+\n+    ProfileName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Get profile name\n+     *\n+     * @return name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Get set of profile names\n+     *\n+     * @return set of profile names\n+     */\n+    public static Set<String> getNames() {\n+        Set<String> names = new HashSet<>();\n+\n+        for (ProfileName statName : ProfileName.values()) {\n+            names.add(statName.getName());\n+        }\n+        return names;\n+    }\n+\n+    public static ProfileName getName(String name) {\n+        switch (name) {\n+            case \"state\":\n+                return STATE;\n+            case \"error\":\n+                return ERROR;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported prof\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDAxMjg4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394001288", "createdAt": "2020-04-15T17:50:20Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1MDoyMFrOGGE66A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1MDoyMFrOGGE66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNTI1Ng==", "bodyText": "LOG.error()", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409025256", "createdAt": "2020-04-15T17:50:20Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/MultiResponsesDelegateActionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+/**\n+ * A listener wrapper to help send multiple requests asynchronously and return one final responses together\n+ */\n+public class MultiResponsesDelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(MultiResponsesDelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    // save responses from multiple requests\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public MultiResponsesDelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } catch (Exception e) {\n+            onFailure(e);\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        LOG.info(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDA0NTA2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394004506", "createdAt": "2020-04-15T17:54:46Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo0NlrOGGFFfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo0NlrOGGFFfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk2NQ==", "bodyText": "It looks like to be duplicate with above line 60. Can we remove the finally here? And also, the only potential scenario where exception can get thrown is that Exception e is null, but I don't think it is possible.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409027965", "createdAt": "2020-04-15T17:54:46Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/MultiResponsesDelegateActionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+/**\n+ * A listener wrapper to help send multiple requests asynchronously and return one final responses together\n+ */\n+public class MultiResponsesDelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(MultiResponsesDelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    // save responses from multiple requests\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public MultiResponsesDelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } catch (Exception e) {\n+            onFailure(e);\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        LOG.info(e);\n+        try {\n+            this.exceptions.add(e.getMessage());\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {\n+                finish();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDI1MTg1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394025185", "createdAt": "2020-04-15T18:23:35Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODoyMzozNVrOGGGGaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODoyMzozNVrOGGGGaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NDU4Nw==", "bodyText": "expected implies that the total collected count must be more than expectedResponseCount, otherwise it is a failure. Based on my understanding of use of this class, I guess maxResponseCount might be a better name.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409044587", "createdAt": "2020-04-15T18:23:35Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/MultiResponsesDelegateActionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+/**\n+ * A listener wrapper to help send multiple requests asynchronously and return one final responses together\n+ */\n+public class MultiResponsesDelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(MultiResponsesDelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    // save responses from multiple requests\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public MultiResponsesDelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } catch (Exception e) {\n+            onFailure(e);\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDMxMTcx", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394031171", "createdAt": "2020-04-15T18:32:04Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODozMjowNFrOGGGZUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODozMjowNFrOGGGZUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0OTQyNA==", "bodyText": "String.format may not be needed if only static string is there. Also, I think in case of empty exceptions and empty savedResponses, it may be better to throw exception with message like No response collected, which makes more sense to me.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409049424", "createdAt": "2020-04-15T18:32:04Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/MultiResponsesDelegateActionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.Mergeable;\n+\n+/**\n+ * A listener wrapper to help send multiple requests asynchronously and return one final responses together\n+ */\n+public class MultiResponsesDelegateActionListener<T extends Mergeable> implements ActionListener<T> {\n+    private static final Logger LOG = LogManager.getLogger(MultiResponsesDelegateActionListener.class);\n+    private final ActionListener<T> delegate;\n+    private final AtomicInteger collectedResponseCount;\n+    private final int expectedResponseCount;\n+    // save responses from multiple requests\n+    private final List<T> savedResponses;\n+    private List<String> exceptions;\n+    private String finalErrorMsg;\n+\n+    public MultiResponsesDelegateActionListener(ActionListener<T> delegate, int expectedResponseCount, String finalErrorMsg) {\n+        this.delegate = delegate;\n+        this.collectedResponseCount = new AtomicInteger(0);\n+        this.expectedResponseCount = expectedResponseCount;\n+        this.savedResponses = Collections.synchronizedList(new ArrayList<T>());\n+        this.exceptions = Collections.synchronizedList(new ArrayList<String>());\n+        this.finalErrorMsg = finalErrorMsg;\n+    }\n+\n+    @Override\n+    public void onResponse(T response) {\n+        try {\n+            if (response != null) {\n+                this.savedResponses.add(response);\n+            }\n+        } catch (Exception e) {\n+            onFailure(e);\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        LOG.info(e);\n+        try {\n+            this.exceptions.add(e.getMessage());\n+        } finally {\n+            if (collectedResponseCount.incrementAndGet() >= expectedResponseCount) {\n+                finish();\n+            }\n+        }\n+    }\n+\n+    private void finish() {\n+        if (this.exceptions.size() == 0) {\n+            if (savedResponses.size() == 0) {\n+                this.delegate.onFailure(new RuntimeException(String.format(\"Unexpected exceptions\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDQzMjI5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394043229", "createdAt": "2020-04-15T18:48:32Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODo0ODozMlrOGGG_8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODo0ODozMlrOGGG_8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1OTMxNA==", "bodyText": "can you log exception here as well?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#discussion_r409059314", "createdAt": "2020-04-15T18:48:32Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.search.sort.SortOrder;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyResult;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorProfile;\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorState;\n+import com.amazon.opendistroforelasticsearch.ad.model.ProfileName;\n+import com.amazon.opendistroforelasticsearch.ad.util.MultiResponsesDelegateActionListener;\n+\n+public class AnomalyDetectorProfileRunner {\n+    private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n+    private Client client;\n+    private NamedXContentRegistry xContentRegistry;\n+    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n+    static String FAIL_TO_GET_PROFILE_MSG = \"Fail to get profile for detector \";\n+\n+    public AnomalyDetectorProfileRunner(Client client, NamedXContentRegistry xContentRegistry) {\n+        this.client = client;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<ProfileName> profiles) {\n+        MultiResponsesDelegateActionListener<DetectorProfile> delegateListener = new MultiResponsesDelegateActionListener<DetectorProfile>(\n+            listener,\n+            profiles.size(),\n+            \"Fail to fetch profile for \" + detectorId\n+        );\n+\n+        if (profiles.isEmpty()) {\n+            listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n+            return;\n+        }\n+\n+        if (profiles.contains(ProfileName.STATE) || profiles.contains(ProfileName.ERROR)) {\n+            prepareProfile(detectorId, delegateListener, profiles);\n+        }\n+    }\n+\n+    private void prepareProfile(\n+        String detectorId,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n+        Set<ProfileName> profiles\n+    ) {\n+        GetRequest getRequest = new GetRequest(ANOMALY_DETECTOR_JOB_INDEX, detectorId);\n+        client.get(getRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetectorJob job = AnomalyDetectorJob.parse(parser);\n+                    long enabledTimeMs = job.getEnabledTime().toEpochMilli();\n+\n+                    if (profiles.contains(ProfileName.STATE)) {\n+                        profileState(detectorId, enabledTimeMs, listener, job.isEnabled());\n+                    }\n+                    if (profiles.contains(ProfileName.ERROR)) {\n+                        profileError(detectorId, enabledTimeMs, listener);\n+                    }\n+                } catch (IOException | XContentParseException | NullPointerException e) {\n+                    logger.error(e);\n+                    listener.failImmediately(FAIL_TO_GET_PROFILE_MSG, e);\n+                }\n+            } else {\n+                GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+                client.get(getDetectorRequest, onGetDetectorResponse(listener, detectorId, profiles));\n+            }\n+        }, exception -> {\n+            if (exception instanceof IndexNotFoundException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDQ3NDM2", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/84#pullrequestreview-394047436", "createdAt": "2020-04-15T18:54:22Z", "commit": {"oid": "a476ed48257ace99427189f7a0d53281b27245b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d6e9bba19c0bb9a97591156ffbead8de9588045", "author": {"user": {"login": "kaituo", "name": "Kaituo Li"}}, "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/3d6e9bba19c0bb9a97591156ffbead8de9588045", "committedDate": "2020-04-15T21:08:18Z", "message": "Address comments from Yizhe"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1657, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}