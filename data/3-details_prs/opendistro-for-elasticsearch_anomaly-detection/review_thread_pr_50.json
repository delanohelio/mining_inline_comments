{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNjUzMjg1", "number": 50, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzoyMjoxMFrODkgLJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0MDoxMVrODlrZBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjAyNDcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzoyMjoxMFrOFw3JBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjoyMzoxN1rOFxYzyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3OTM5OQ==", "bodyText": "What does disabledTime != null and isEnabled = true mean?  It means the job has been disabled before and enabled after that? So does\neanbledTime > disabledTime => isEnabled = true\neanbledTime < disabledTime => isEnabled = false\neanbledTime = disabledTime => isEnabled = undefined\n?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386779399", "createdAt": "2020-03-03T03:22:10Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "diffHunk": "@@ -85,6 +92,7 @@ public static AnomalyDetectorJob parse(XContentParser parser) throws IOException\n         Schedule schedule = null;\n         Boolean isEnabled = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTAxOA==", "bodyText": "1.What does disabledTime != null and isEnabled = true mean? It means the job has been disabled before and enabled after that?\nCorrect, that means job disabled before and enabled later.\n\nSo does\neanbledTime > disabledTime => isEnabled = true\neanbledTime < disabledTime => isEnabled = false\neanbledTime = disabledTime => isEnabled = undefined?\n\nIf isEnabled=true, we know job is enabled currently, and show enabledTime, if need to show last disabledTime, we can still show last disabledTime. Impossible for enabledTime=disabledTime.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387331018", "createdAt": "2020-03-03T22:23:17Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "diffHunk": "@@ -85,6 +92,7 @@ public static AnomalyDetectorJob parse(XContentParser parser) throws IOException\n         Schedule schedule = null;\n         Boolean isEnabled = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3OTM5OQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjAzMTI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzoyNjoyMlrOFw3Mww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzoxMjowN1rOFyBCRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ==", "bodyText": "What if response.getShardInfo() return null or response is null?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386780355", "createdAt": "2020-03-03T03:26:22Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwNTA2OA==", "bodyText": "Why not using response.getResult() != DocWriteResponse.Result.CREATED && response.getResult() != DocWriteResponse.Result.UPDATED?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386805068", "createdAt": "2020-03-03T05:23:42Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MDU3Ng==", "bodyText": "1.What if response.getShardInfo() return null or response is null?\nIs it possible return null IndexResponse?\n\nWhy not using response.getResult() != DocWriteResponse.Result.CREATED && response.getResult() != DocWriteResponse.Result.UPDATED?\n\nThis method is used for both created and updated(stop AD job will updated current AD job).", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387340576", "createdAt": "2020-03-03T22:45:44Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyMDIyMQ==", "bodyText": "1.What if response.getShardInfo() return null or response is null?\nIs it possible return null IndexResponse?\nYes, it is possible.  I get that before (different kinds of response though).", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387520221", "createdAt": "2020-03-04T08:46:14Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyMjAxOQ==", "bodyText": "Why not using response.getResult() != DocWriteResponse.Result.CREATED && response.getResult() != DocWriteResponse.Result.UPDATED?\n\n\n\nThis method is used for both created and updated(stop AD job will updated current AD job).\n\n\nWhat I want to ask is: does \"response.getShardInfo().getSuccessful() >= 1\" mean the create/update is successful?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387522019", "createdAt": "2020-03-04T08:50:01Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MDA4NQ==", "bodyText": "1.What if response.getShardInfo() return null or response is null?\nIs it possible return null IndexResponse?\nYes, it is possible. I get that before (different kinds of response though).\n\nOk, to be safe, will add null check.\n\"response.getShardInfo().getSuccessful() >= 1\" means there is at least one shard written successfully, that means created/updated successfully.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387990085", "createdAt": "2020-03-04T23:12:07Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4MDM1NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjEzOTI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNDo0NTozN1rOFw4Nhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo0OToyNFrOFxZfPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NjkzNA==", "bodyText": "return after sending response?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386796934", "createdAt": "2020-03-03T04:45:37Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MjE0MA==", "bodyText": "Good catch. Will add it", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387342140", "createdAt": "2020-03-03T22:49:24Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NjkzNA=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjE0MDIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNDo0NjoxNFrOFw4OEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNzowN1rOFyrAKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ==", "bodyText": "so function does not send back response using channel?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r386797075", "createdAt": "2020-03-03T04:46:14Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0Mzc2MA==", "bodyText": "Function will send back response.\nCheck line 287 of file IndexAnomalyDetectorJobActionHandler\nstopAdDetectorListener(channel, detectorId)", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387343760", "createdAt": "2020-03-03T22:53:04Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyODE4Mg==", "bodyText": "Any way to enforce sending back response? It is easy for function implementor to forget to add a channel.sendResponse.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387528182", "createdAt": "2020-03-04T09:02:08Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MzUzOA==", "bodyText": "This is a private function and it doesn't implicitly require to send response to channel here. Depends on how developer implements the logic.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387993538", "createdAt": "2020-03-04T23:21:45Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NjQzNw==", "bodyText": "AnomalyDetectorFunction is too general and can be anything.  We want to make an interface specific for a specific thing.  I would suggest:\n\nrename AnomalyDetectorFunction to ListenerWithChannel or sth that is more specific\nmake execute take channel as a parameter\nadd a comment before channel indicating user should send channel response.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r388676437", "createdAt": "2020-03-06T02:01:35Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzY3NA==", "bodyText": "We can do that. How about we split such refactoring work into another issue. So we can make this PR more focusing. Thanks for the suggestion.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r388677674", "createdAt": "2020-03-06T02:07:07Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -140,147 +148,154 @@ private void onGetAnomalyDetectorResponse(GetResponse response) throws IOExcepti\n             channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n             return;\n         }\n-        XContentParser parser = XContentType.JSON\n-            .xContent()\n-            .createParser(\n-                channel.request().getXContentRegistry(),\n-                LoggingDeprecationHandler.INSTANCE,\n-                response.getSourceAsBytesRef().streamInput()\n-            );\n+        try (XContentParser parser = RestHandlerUtils.createXContentParser(channel, response.getSourceAsBytesRef())) {\n+            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+            AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n \n-        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+            IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+            Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+            Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n \n-        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n-        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n-        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n-        AnomalyDetectorJob job = new AnomalyDetectorJob(\n-            detector.getDetectorId(),\n-            schedule,\n-            true,\n-            Instant.now(),\n-            Instant.now(),\n-            duration.getSeconds()\n-        );\n+            AnomalyDetectorJob job = new AnomalyDetectorJob(\n+                detector.getDetectorId(),\n+                schedule,\n+                true,\n+                Instant.now(),\n+                null,\n+                Instant.now(),\n+                duration.getSeconds()\n+            );\n \n-        getAnomalyDetectorJob(job);\n+            getAnomalyDetectorJobForWrite(job);\n+        } catch (IOException e) {\n+            String message = \"Failed to parse anomaly detector job \" + detectorId;\n+            logger.error(message, e);\n+            channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+        }\n     }\n \n-    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+    private void getAnomalyDetectorJobForWrite(AnomalyDetectorJob job) {\n         GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n \n-        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener.wrap(response -> onGetAnomalyDetectorJobForWrite(response, job), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+    private void onGetAnomalyDetectorJobForWrite(GetResponse response, AnomalyDetectorJob job) throws IOException {\n         if (response.isExists()) {\n-            XContentBuilder builder = channel\n-                .newErrorBuilder()\n-                .startObject()\n-                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n-                .endObject();\n-            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n-            return;\n+            try (XContentParser parser = createXContentParser(channel, response.getSourceAsBytesRef())) {\n+                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                AnomalyDetectorJob currentAdJob = AnomalyDetectorJob.parse(parser);\n+                if (currentAdJob.isEnabled()) {\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Anomaly detector job is already running: \" + detectorId));\n+                    return;\n+                } else {\n+                    AnomalyDetectorJob newJob = new AnomalyDetectorJob(\n+                        job.getName(),\n+                        job.getSchedule(),\n+                        job.isEnabled(),\n+                        Instant.now(),\n+                        currentAdJob.getDisabledTime(),\n+                        Instant.now(),\n+                        job.getLockDurationSeconds()\n+                    );\n+                    indexAnomalyDetectorJob(newJob, null);\n+                }\n+            } catch (IOException e) {\n+                String message = \"Failed to parse anomaly detector job \" + job.getName();\n+                logger.error(message, e);\n+                channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, message));\n+            }\n+        } else {\n+            indexAnomalyDetectorJob(job, null);\n         }\n-\n-        indexAnomalyDetectorJob(job);\n     }\n \n-    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job, AnomalyDetectorFunction function) throws IOException {\n         IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n-            .setRefreshPolicy(refreshPolicy)\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n             .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n             .setIfSeqNo(seqNo)\n             .setIfPrimaryTerm(primaryTerm)\n             .timeout(requestTimeout)\n             .id(detectorId);\n-        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n-    }\n-\n-    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n-        return new RestResponseListener<IndexResponse>(channel) {\n-            @Override\n-            public RestResponse buildResponse(IndexResponse response) throws Exception {\n-                if (response.getShardInfo().getSuccessful() < 1) {\n-                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n-                }\n-\n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .endObject();\n-\n-                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n-                if (response.status() == RestStatus.CREATED) {\n-                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n-                    restResponse.addHeader(\"Location\", location);\n-                }\n-                return restResponse;\n-            }\n-        };\n+        client\n+            .index(\n+                indexRequest,\n+                ActionListener.wrap(response -> onIndexAnomalyDetectorJobResponse(response, function), exception -> onFailure(exception))\n+            );\n     }\n \n-    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n-        if (response.isAcknowledged()) {\n-            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n-            prepareAnomalyDetectorJobIndexing();\n+    private void onIndexAnomalyDetectorJobResponse(IndexResponse response, AnomalyDetectorFunction function) throws IOException {\n+        if (response.getShardInfo().getSuccessful() < 1) {\n+            channel.sendResponse(new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS)));\n+        }\n+        if (function != null) {\n+            function.execute();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NzA3NQ=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODg0MzY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODo0NDo1MlrOFxSAGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjo1ODoxMVrOFxZt2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQ4Mg==", "bodyText": "It looks like deleteAnomalyDetectorJobDoc is only executed when given specific detector_id, no AD job is found. I think we may directly delete AD, or delete it if AD job is found but disabled.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387219482", "createdAt": "2020-03-03T18:44:52Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "diffHunk": "@@ -69,10 +74,40 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n         return channel -> {\n             logger.info(\"Delete anomaly detector {}\", detectorId);\n             handler\n-                .getDetectorJob(clusterService, client, detectorId, channel, () -> deleteAnomalyDetectorDoc(client, detectorId, channel));\n+                .getDetectorJob(\n+                    clusterService,\n+                    client,\n+                    detectorId,\n+                    channel,\n+                    () -> deleteAnomalyDetectorJobDoc(client, detectorId, channel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NTg4MQ==", "bodyText": "deleteAnomalyDetectorJobDoc will be executed if\n1.AD job index not found\n2.AD job is not found\n3.AD job found and is disabled\nYou can find more in method AnomalyDetectorActionHandler#getDetectorJob", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387345881", "createdAt": "2020-03-03T22:58:11Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "diffHunk": "@@ -69,10 +74,40 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n         return channel -> {\n             logger.info(\"Delete anomaly detector {}\", detectorId);\n             handler\n-                .getDetectorJob(clusterService, client, detectorId, channel, () -> deleteAnomalyDetectorDoc(client, detectorId, channel));\n+                .getDetectorJob(\n+                    clusterService,\n+                    client,\n+                    detectorId,\n+                    channel,\n+                    () -> deleteAnomalyDetectorJobDoc(client, detectorId, channel)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTQ4Mg=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5OTAyMTQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxOTozNzoxNVrOFxTwFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMzowMTo0MlrOFxZzZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODE1MA==", "bodyText": "Can we skip this if returnJob is false?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387248150", "createdAt": "2020-03-03T19:37:15Z", "author": {"login": "yizheliu-amazon"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -103,33 +104,44 @@ public RestResponse buildResponse(MultiGetResponse multiGetResponse) throws Exce\n                             .field(RestHandlerUtils._PRIMARY_TERM, response.getResponse().getPrimaryTerm())\n                             .field(RestHandlerUtils._SEQ_NO, response.getResponse().getSeqNo());\n                         if (!response.getResponse().isSourceEmpty()) {\n-                            XContentParser parser = XContentHelper\n-                                .createParser(\n-                                    channel.request().getXContentRegistry(),\n-                                    LoggingDeprecationHandler.INSTANCE,\n-                                    response.getResponse().getSourceAsBytesRef(),\n-                                    XContentType.JSON\n-                                );\n-                            try {\n+                            try (\n+                                XContentParser parser = RestHandlerUtils\n+                                    .createXContentParser(channel, response.getResponse().getSourceAsBytesRef())\n+                            ) {\n                                 ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n                                 detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n                             } catch (Throwable t) {\n                                 logger.error(\"Fail to parse detector\", t);\n-                                throw t;\n-                            } finally {\n-                                parser.close();\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector with id: \" + detectorId\n+                                );\n                             }\n                         }\n                     }\n \n                     if (ANOMALY_DETECTOR_JOB_INDEX.equals(response.getIndex())) {\n-                        if (!response.isFailed() && response.getResponse().isExists()) {\n-                            adJobEnabled = true;\n+                        if (response.getResponse() != null\n+                            && response.getResponse().isExists()\n+                            && !response.getResponse().isSourceEmpty()) {\n+                            try (XContentParser parser = createXContentParser(channel, response.getResponse().getSourceAsBytesRef())) {\n+                                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                                adJob = AnomalyDetectorJob.parse(parser);\n+                            } catch (Throwable t) {\n+                                logger.error(\"Fail to parse detector job \", t);\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector job with id: \" + detectorId\n+                                );\n+                            }\n                         }\n                     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NzMwMg==", "bodyText": "Yes, current logic will skip this if block.\nIf returnJob is false, the response will not have ANOMALY_DETECTOR_JOB_INDEX, so will skip this block of if (ANOMALY_DETECTOR_JOB_INDEX.equals(response.getIndex())) {.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r387347302", "createdAt": "2020-03-03T23:01:42Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -103,33 +104,44 @@ public RestResponse buildResponse(MultiGetResponse multiGetResponse) throws Exce\n                             .field(RestHandlerUtils._PRIMARY_TERM, response.getResponse().getPrimaryTerm())\n                             .field(RestHandlerUtils._SEQ_NO, response.getResponse().getSeqNo());\n                         if (!response.getResponse().isSourceEmpty()) {\n-                            XContentParser parser = XContentHelper\n-                                .createParser(\n-                                    channel.request().getXContentRegistry(),\n-                                    LoggingDeprecationHandler.INSTANCE,\n-                                    response.getResponse().getSourceAsBytesRef(),\n-                                    XContentType.JSON\n-                                );\n-                            try {\n+                            try (\n+                                XContentParser parser = RestHandlerUtils\n+                                    .createXContentParser(channel, response.getResponse().getSourceAsBytesRef())\n+                            ) {\n                                 ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n                                 detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n                             } catch (Throwable t) {\n                                 logger.error(\"Fail to parse detector\", t);\n-                                throw t;\n-                            } finally {\n-                                parser.close();\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector with id: \" + detectorId\n+                                );\n                             }\n                         }\n                     }\n \n                     if (ANOMALY_DETECTOR_JOB_INDEX.equals(response.getIndex())) {\n-                        if (!response.isFailed() && response.getResponse().isExists()) {\n-                            adJobEnabled = true;\n+                        if (response.getResponse() != null\n+                            && response.getResponse().isExists()\n+                            && !response.getResponse().isSourceEmpty()) {\n+                            try (XContentParser parser = createXContentParser(channel, response.getResponse().getSourceAsBytesRef())) {\n+                                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                                adJob = AnomalyDetectorJob.parse(parser);\n+                            } catch (Throwable t) {\n+                                logger.error(\"Fail to parse detector job \", t);\n+                                return new BytesRestResponse(\n+                                    RestStatus.INTERNAL_SERVER_ERROR,\n+                                    \"Failed to parse detector job with id: \" + detectorId\n+                                );\n+                            }\n                         }\n                     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODE1MA=="}, "originalCommit": {"oid": "ef2f7d95113e133b50144d54678d5502af6329db"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODM0ODIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/AnomalyDetectorFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0MDoxMVrOFys-yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNDo0OToxOVrOFytFWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDA5MQ==", "bodyText": "response -> responds", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r388710091", "createdAt": "2020-03-06T04:40:11Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/AnomalyDetectorFunction.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n     /**\n      * Performs this operation.\n+     *\n+     * Notes: don't forget to send back response via channel if you process response with this method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5e8396af18f44519f877abb35b9b71757dffe16"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTc3MQ==", "bodyText": "thanks, will fix", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/50#discussion_r388711771", "createdAt": "2020-03-06T04:49:19Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/AnomalyDetectorFunction.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n     /**\n      * Performs this operation.\n+     *\n+     * Notes: don't forget to send back response via channel if you process response with this method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDA5MQ=="}, "originalCommit": {"oid": "b5e8396af18f44519f877abb35b9b71757dffe16"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2985, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}