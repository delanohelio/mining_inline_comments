{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1ODEwNjM5", "number": 208, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1NDozNFrOEXUcQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDoyMDo1MlrOEZtEtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODg3NjE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1NDozNFrOG_C6ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOTo1NDo0MlrOG_G_yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MTE5NA==", "bodyText": "minor: Shall we add this as last constant? ( constants arranged alphabetically )", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468761194", "createdAt": "2020-08-11T17:54:34Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -142,6 +141,7 @@\n     public static final String AD_BASE_URI = \"/_opendistro/_anomaly_detection\";\n     public static final String AD_BASE_DETECTORS_URI = AD_BASE_URI + \"/detectors\";\n     public static final String AD_THREAD_POOL_NAME = \"ad-threadpool\";\n+    public static final String COLD_START_THREAD_POOL_NAME = \"ad-cold-start-threadpool\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyODEwNA==", "bodyText": "changed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468828104", "createdAt": "2020-08-11T19:54:42Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -142,6 +141,7 @@\n     public static final String AD_BASE_URI = \"/_opendistro/_anomaly_detection\";\n     public static final String AD_BASE_DETECTORS_URI = AD_BASE_URI + \"/detectors\";\n     public static final String AD_THREAD_POOL_NAME = \"ad-threadpool\";\n+    public static final String COLD_START_THREAD_POOL_NAME = \"ad-cold-start-threadpool\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MTE5NA=="}, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODg5NTI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1OTo0MlrOG_DGcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOTo1NTo0MFrOG_HB1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDI3Mg==", "bodyText": "Question: Is it possible to have both (lastDetectionError and lastColdStartException) to be not null ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468764272", "createdAt": "2020-08-11T17:59:42Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -88,8 +99,11 @@ public boolean expired(Duration stateTtl, Instant now) {\n         if (checkpoint != null) {\n             ans = ans && expired(stateTtl, now, checkpoint);\n         }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n+        if (lastDetectionError != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyODYyOQ==", "bodyText": "yes, it is possible.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468828629", "createdAt": "2020-08-11T19:55:40Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -88,8 +99,11 @@ public boolean expired(Duration stateTtl, Instant now) {\n         if (checkpoint != null) {\n             ans = ans && expired(stateTtl, now, checkpoint);\n         }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n+        if (lastDetectionError != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDI3Mg=="}, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODkyMTE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODowNzoxM1rOG_DWuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTozODoyM1rOG_KJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw==", "bodyText": "Question: Where is this used?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468768443", "createdAt": "2020-08-11T18:07:13Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyOTAyMQ==", "bodyText": "It is used in AnomalyResultTransportAction.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468829021", "createdAt": "2020-08-11T19:56:23Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw=="}, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTY2Nw==", "bodyText": "Got it. For some reason AnomalyResultTransportAction was not loaded .", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468879667", "createdAt": "2020-08-11T21:38:23Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw=="}, "originalCommit": {"oid": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTYyMjc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTozNzozNlrOG_KH8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNjo1Njo1N1rOG_qMKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTM0NQ==", "bodyText": "since detectorId is already extracted, can we reuse it here and other places like 811, 802 ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468879345", "createdAt": "2020-08-11T21:37:36Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +775,122 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detector.getDetectorId(), \"Invalid training data\", exception, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwNDcxNQ==", "bodyText": "Nice catch.  Changed.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469404715", "createdAt": "2020-08-12T16:56:57Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +775,122 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detector.getDetectorId(), \"Invalid training data\", exception, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTM0NQ=="}, "originalCommit": {"oid": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTY1NDcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0OTowOFrOG_KbHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzowMDoxM1rOG_qUJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NDI1Mw==", "bodyText": "Shall we do short circuit like below?\nif ( exp == null )\nreturn null\nand then...\nif !(exp instanceof  ResourceNotFoundException)\nthrow exp\nString adID = detector.getDetectorID();\n......\nUsually it is hard to read if there is nested scope and else .\nAlso it increases Cyclomatic complexity .", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468884253", "createdAt": "2020-08-11T21:49:08Z", "author": {"login": "VijayanB"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,44 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwNjc1OQ==", "bodyText": "changed.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469406759", "createdAt": "2020-08-12T17:00:13Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,44 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NDI1Mw=="}, "originalCommit": {"oid": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDA4ODYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjowOTowMlrOG_0jQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMTo1NzoxN1rOHAfG2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NDQ2Ng==", "bodyText": "why keep the overhead of an additional thread pool constantly when model training is at best occasional?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469574466", "createdAt": "2020-08-12T22:09:02Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -400,14 +399,21 @@ private static Void initGson() {\n \n     @Override\n     public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {\n-        return Collections\n-            .singletonList(\n+        return Arrays\n+            .asList(\n                 new FixedExecutorBuilder(\n                     settings,\n                     AD_THREAD_POOL_NAME,\n                     Math.max(1, EsExecutors.allocatedProcessors(settings) / 4),\n                     AnomalyDetectorSettings.AD_THEAD_POOL_QUEUE_SIZE,\n                     \"opendistro.ad.\" + AD_THREAD_POOL_NAME\n+                ),\n+                new FixedExecutorBuilder(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTcwNg==", "bodyText": "removed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470271706", "createdAt": "2020-08-13T21:57:17Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -400,14 +399,21 @@ private static Void initGson() {\n \n     @Override\n     public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {\n-        return Collections\n-            .singletonList(\n+        return Arrays\n+            .asList(\n                 new FixedExecutorBuilder(\n                     settings,\n                     AD_THREAD_POOL_NAME,\n                     Math.max(1, EsExecutors.allocatedProcessors(settings) / 4),\n                     AnomalyDetectorSettings.AD_THEAD_POOL_QUEUE_SIZE,\n                     \"opendistro.ad.\" + AD_THREAD_POOL_NAME\n+                ),\n+                new FixedExecutorBuilder(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NDQ2Ng=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDExMzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjoxOTowNFrOG_0yVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODowOToyM1rOHB0d9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw==", "bodyText": "why should this query call back be run separately?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469578327", "createdAt": "2020-08-12T22:19:04Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTk3Mw==", "bodyText": "Ideally, all AD code should run inside AD threadpool.  This is long overdue.  I am starting with cold start code.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470271973", "createdAt": "2020-08-13T21:58:00Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NjkwMQ==", "bodyText": "does it mean every callback needs to run this way? can this be simplified at a higher level?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470296901", "createdAt": "2020-08-13T23:08:20Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTE3Mw==", "bodyText": "yes. I don't know how to simplify this.  Any suggestion?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851173", "createdAt": "2020-08-14T20:29:47Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjc4NQ==", "bodyText": "TransportNodesAction seems to take thread pool name.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470916785", "createdAt": "2020-08-15T00:49:15Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MDI2Mw==", "bodyText": "You meant the threadpool name in TransportResponseHandler?  Our case is not just transport thread.  Also, the threadpool name is good for one callback.  It does not cover nested call backs.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471670263", "createdAt": "2020-08-17T18:09:23Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDE2NzU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjo0MDo0OVrOG_1S5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDozMDozMFrOHBCfjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw==", "bodyText": "what does a null exception mean? is that an exception or no exception? why not using optional?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469586663", "createdAt": "2020-08-12T22:40:49Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzA2Nw==", "bodyText": "null means there is no error, so no exception.  I know you are passionate about optional.  Here it is unnecessary.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470273067", "createdAt": "2020-08-13T22:00:43Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5ODQwNA==", "bodyText": "if it's no error, would it suffice to leave the entire record to null? <exception, time> is null seems simpler.\noptional question. why optional is unnecessary ? clearly this variable can be present or absent and the need seems to exist.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470298404", "createdAt": "2020-08-13T23:13:33Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTQ3MA==", "bodyText": "changed to optional", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851470", "createdAt": "2020-08-14T20:30:30Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDE4MDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjo0NjoxOVrOG_1adg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDozMDo1NVrOHBCgNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA==", "bodyText": "why getting the exception status involves updating the timestamp?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469588598", "createdAt": "2020-08-12T22:46:19Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastColdStartException() != null) {\n+            Entry<Exception, Instant> errorAndTime = transportStates.get(adID).getLastColdStartException();\n+            errorAndTime.setValue(clock.instant());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzU5Mg==", "bodyText": "It is the same as other transport state.  We are gonna clear these states if they are not accessed within one hour.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470273592", "createdAt": "2020-08-13T22:01:58Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastColdStartException() != null) {\n+            Entry<Exception, Instant> errorAndTime = transportStates.get(adID).getLastColdStartException();\n+            errorAndTime.setValue(clock.instant());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwMDUzMw==", "bodyText": "Would one last access time for one entire statue be sufficient? instead of keeping one timestamp for each field and still using the latest one", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470300533", "createdAt": "2020-08-13T23:20:26Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastColdStartException() != null) {\n+            Entry<Exception, Instant> errorAndTime = transportStates.get(adID).getLastColdStartException();\n+            errorAndTime.setValue(clock.instant());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTYzNw==", "bodyText": "changed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851637", "createdAt": "2020-08-14T20:30:55Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastColdStartException() != null) {\n+            Entry<Exception, Instant> errorAndTime = transportStates.get(adID).getLastColdStartException();\n+            errorAndTime.setValue(clock.instant());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDIxOTA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMzowMzozMFrOG_1xRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNDowNVrOHAfRbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5NDQzNg==", "bodyText": "the two cases are different", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469594436", "createdAt": "2020-08-12T23:03:30Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,115 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDQxMw==", "bodyText": "LimitExceededException is a subtype of AnomalyDetectionException.  I am commenting on one example here.  Updated comment to make it more clear.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470274413", "createdAt": "2020-08-13T22:04:05Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,115 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5NDQzNg=="}, "originalCommit": {"oid": "7e3065fc68a4841f4a3713390ac7acb07721e1c2"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgyODU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo0MDozOVrOHBGa1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDoxMjoxOVrOHB-6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA==", "bodyText": "Why use () -> detectorId?  detectorId should work.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470915798", "createdAt": "2020-08-15T00:40:39Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MTQwMQ==", "bodyText": "See https://www.baeldung.com/log4j-2-lazy-logging", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471671401", "createdAt": "2020-08-17T18:11:25Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4ODc5OQ==", "bodyText": "From the document you shared ,\n\nThe lambda expression is only evaluated if the corresponding log level is enabled. This is referred to as lazy logging.\n\nI think error log level is always enabled, so the lambda () -> detectorId will always be executed?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471788799", "createdAt": "2020-08-17T21:36:56Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0MTQxNQ==", "bodyText": "you are right.  Changed.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471841415", "createdAt": "2020-08-18T00:12:19Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgzNDc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo0ODoxNVrOHBGeNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODoxMzozNlrOHB0mog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjY2Mw==", "bodyText": "If it's EndRunException  and  isEndNow() is true, JobRunner will stop detector job. Will the previousException be cleaned when stop detector job? Why need to check previous exception ? If user wait for some time and restart detector, cluster state may change, and user may not get previous exception any more.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470916663", "createdAt": "2020-08-15T00:48:15Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MjQ4Mg==", "bodyText": "Yes, it will be cleared.  We need to check previous exception because cold start is asynchronous.  We don't know cold start error instantly.\nIf transport state gets cleared up, next few runs would trigger the same error.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471672482", "createdAt": "2020-08-17T18:13:36Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjY2Mw=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 365}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgzNzU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo1MToyNFrOHBGfuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozOTo1MlrOHCqTDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ==", "bodyText": "Should we throw exception ? Why not record this exception as previousException ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917051", "createdAt": "2020-08-15T00:51:24Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            }\n+        }, exception -> {\n+            Throwable cause = ExceptionsHelper.unwrapCause(exception);\n+            if (cause instanceof IndexNotFoundException) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            } else {\n+                LOG.error(String.format(\"Fail to get checkpoint state for %s\", detectorId), exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3NzY2OA==", "bodyText": "This is in callback.  We cannot throw exception directly as it is asynchronous and won't be caught by AD job.  What do we expect the job runner to do here?  For example, we can reach here if cold start does not happen before and the system is under extreme heavy load and get request gets rejected.  We can log the error and retry later.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471677668", "createdAt": "2020-08-17T18:23:45Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            }\n+        }, exception -> {\n+            Throwable cause = ExceptionsHelper.unwrapCause(exception);\n+            if (cause instanceof IndexNotFoundException) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            } else {\n+                LOG.error(String.format(\"Fail to get checkpoint state for %s\", detectorId), exception);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ1ODYyMg==", "bodyText": "Job runner will end detector job if getsEndRunException and isEndNow is true.  If isEndNow is false, will still stop detector job if the count of EndRunException exceeds MAX_RETRY_FOR_END_RUN_EXCEPTION(default 6 currently). For other exceptions except for EndRunException, job runner will record it in AD result.\nHow about we return this exception to JobRunner so it can be logged into AD result ?\nIn this change, cold start is put into another thread pool and run asynchronously; will check previousException if no checkpoint or no model.  How about we check EndRunException which isEndNow is false and return it to JobRunner, so JobRunner can stop detector job if find too many EndRunExceptions ? That can avoid endlessly run cold start.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472458622", "createdAt": "2020-08-18T20:15:07Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            }\n+        }, exception -> {\n+            Throwable cause = ExceptionsHelper.unwrapCause(exception);\n+            if (cause instanceof IndexNotFoundException) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            } else {\n+                LOG.error(String.format(\"Fail to get checkpoint state for %s\", detectorId), exception);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MjIwNQ==", "bodyText": "changed as we discussed offline", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472552205", "createdAt": "2020-08-18T23:39:52Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            }\n+        }, exception -> {\n+            Throwable cause = ExceptionsHelper.unwrapCause(exception);\n+            if (cause instanceof IndexNotFoundException) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            } else {\n+                LOG.error(String.format(\"Fail to get checkpoint state for %s\", detectorId), exception);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg0MTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo1NToyMVrOHBGhmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODoyNDoxNVrOHB09fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzUzMQ==", "bodyText": "cold error  means cold start error?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917531", "createdAt": "2020-08-15T00:55:21Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -29,16 +29,19 @@\n     private Entry<Integer, Instant> partitonNumber;\n     // checkpoint fetch time\n     private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n+    private Entry<String, Instant> lastDetectionError;\n+    // last training error. Used to save cold error by a concurrent cold start thread.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3ODMzNA==", "bodyText": "Good catch.  Fixed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471678334", "createdAt": "2020-08-17T18:24:15Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -29,16 +29,19 @@\n     private Entry<Integer, Instant> partitonNumber;\n     // checkpoint fetch time\n     private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n+    private Entry<String, Instant> lastDetectionError;\n+    // last training error. Used to save cold error by a concurrent cold start thread.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzUzMQ=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg0NDI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo1OToyNFrOHBGjKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxODoxNTozM1rOHB0qqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzkzMQ==", "bodyText": "Why not return this exception ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917931", "createdAt": "2020-08-15T00:59:24Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,45 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MzUxMg==", "bodyText": "The returned exception is for cold start related failure only.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471673512", "createdAt": "2020-08-17T18:15:33Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,45 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzkzMQ=="}, "originalCommit": {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM2NjAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTowNjo1MFrOHB_zQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjo0MToxMVrOHCpImw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw==", "bodyText": "minor. why not using configured executor name instead of hardcoding it in all places?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471855937", "createdAt": "2020-08-18T01:06:50Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDY2Mg==", "bodyText": "I don't understand.  Could you explain more?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472334662", "createdAt": "2020-08-18T16:42:46Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4OTE1NA==", "bodyText": "AnomalyDetectorPlugin.AD_THREAD_POOL_NAME is the name.\nwhy not using a configured name like threadpool in configuration? instead of hardcoding it.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472389154", "createdAt": "2020-08-18T18:12:57Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxNjg5OQ==", "bodyText": "What do you mean by configuration?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472416899", "createdAt": "2020-08-18T19:04:21Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0NDA3Ng==", "bodyText": "the value is configurable using constructor.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472444076", "createdAt": "2020-08-18T19:56:11Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2ODY5Nw==", "bodyText": "The benefit to make it configurable is to make testing easy.\nMy concern is we may not have just one threadpool to use in this class.  For example, I want to add a dedicated cold start threadpool for high cardinality.  So we should add threadpool_ad, threadpool_coldStart for this?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472468697", "createdAt": "2020-08-18T20:26:06Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMzE0Nw==", "bodyText": "if there are additional dependency configuration (threadpool and executor names), they can also be passed via constructor and the implementation just needs to pick the corresponding configuration (threadpool and executor name combination)", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472533147", "createdAt": "2020-08-18T22:41:11Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM3NTI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxMTo1NVrOHB_4gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDoyOTowMVrOHCrJ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA==", "bodyText": "minor. documentation is missing for the interface of this class.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471857280", "createdAt": "2020-08-18T01:11:55Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNjgxMw==", "bodyText": "added", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472336813", "createdAt": "2020-08-18T16:46:23Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NjI1Mw==", "bodyText": "also all the public methods (interface)", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472566253", "createdAt": "2020-08-19T00:29:01Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTM3OTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToxNDoxNVrOHB_6_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOTozMzo0N1rOHCjAXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg==", "bodyText": "minor. the input can be simplified to one parameter as the expiration time.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471857916", "createdAt": "2020-08-18T01:14:15Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {\n     private String detectorId;\n-    // detector definition and the definition fetch time\n-    private Entry<AnomalyDetector, Instant> detectorDef;\n-    // number of partitions and the number's fetch time\n-    private Entry<Integer, Instant> partitonNumber;\n+    // detector definition\n+    private AnomalyDetector detectorDef;\n+    // number of partitions\n+    private int partitonNumber;\n     // checkpoint fetch time\n-    private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    private Instant lastAccessTime;\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n-\n-    public TransportState(String detectorId) {\n+    private Optional<String> lastDetectionError;\n+    // last training error. Used to save cold start error by a concurrent cold start thread.\n+    private Optional<Exception> lastColdStartException;\n+    // flag indicating whether checkpoint for the detector exists\n+    private boolean checkPointExists;\n+    // clock to get current time\n+    private final Clock clock;\n+\n+    public TransportState(String detectorId, Clock clock) {\n         this.detectorId = detectorId;\n-        detectorDef = null;\n-        partitonNumber = null;\n-        checkpoint = null;\n-        lastError = null;\n+        this.detectorDef = null;\n+        this.partitonNumber = -1;\n+        this.lastAccessTime = clock.instant();\n+        this.lastDetectionError = Optional.empty();\n+        this.lastColdStartException = Optional.empty();\n+        this.checkPointExists = false;\n+        this.clock = clock;\n     }\n \n     public String getDetectorId() {\n         return detectorId;\n     }\n \n-    public Entry<AnomalyDetector, Instant> getDetectorDef() {\n+    public AnomalyDetector getDetectorDef() {\n+        refreshLastUpdateTime();\n         return detectorDef;\n     }\n \n-    public void setDetectorDef(Entry<AnomalyDetector, Instant> detectorDef) {\n+    public void setDetectorDef(AnomalyDetector detectorDef) {\n         this.detectorDef = detectorDef;\n+        refreshLastUpdateTime();\n     }\n \n-    public Entry<Integer, Instant> getPartitonNumber() {\n+    public int getPartitonNumber() {\n+        refreshLastUpdateTime();\n         return partitonNumber;\n     }\n \n-    public void setPartitonNumber(Entry<Integer, Instant> partitonNumber) {\n+    public void setPartitonNumber(int partitonNumber) {\n         this.partitonNumber = partitonNumber;\n+        refreshLastUpdateTime();\n     }\n \n-    public Instant getCheckpoint() {\n-        return checkpoint;\n+    public boolean doesCheckpointExists() {\n+        refreshLastUpdateTime();\n+        return checkPointExists;\n     }\n \n-    public void setCheckpoint(Instant checkpoint) {\n-        this.checkpoint = checkpoint;\n+    public void setCheckpointExists(boolean checkpointExists) {\n+        refreshLastUpdateTime();\n+        this.checkPointExists = checkpointExists;\n     };\n \n-    public Entry<String, Instant> getLastError() {\n-        return lastError;\n+    public Optional<String> getLastDetectionError() {\n+        refreshLastUpdateTime();\n+        return lastDetectionError;\n     }\n \n-    public void setLastError(Entry<String, Instant> lastError) {\n-        this.lastError = lastError;\n+    public void setLastDetectionError(String lastError) {\n+        this.lastDetectionError = Optional.ofNullable(lastError);\n+        refreshLastUpdateTime();\n     }\n \n-    public boolean expired(Duration stateTtl, Instant now) {\n-        boolean ans = true;\n-        if (detectorDef != null) {\n-            ans = ans && expired(stateTtl, now, detectorDef.getValue());\n-        }\n-        if (partitonNumber != null) {\n-            ans = ans && expired(stateTtl, now, partitonNumber.getValue());\n-        }\n-        if (checkpoint != null) {\n-            ans = ans && expired(stateTtl, now, checkpoint);\n-        }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n-        }\n-        return ans;\n+    public Optional<Exception> getLastColdStartException() {\n+        refreshLastUpdateTime();\n+        return lastColdStartException;\n+    }\n+\n+    public void setLastColdStartException(Exception lastColdStartError) {\n+        this.lastColdStartException = Optional.ofNullable(lastColdStartError);\n+        refreshLastUpdateTime();\n     }\n \n-    private boolean expired(Duration stateTtl, Instant now, Instant toCheck) {\n-        return toCheck.plus(stateTtl).isBefore(now);\n+    private void refreshLastUpdateTime() {\n+        lastAccessTime = clock.instant();\n+    }\n+\n+    public boolean expired(Duration stateTtl, Instant now) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNzYzNw==", "bodyText": "I don't understand.  Could you explain?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472337637", "createdAt": "2020-08-18T16:47:45Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {\n     private String detectorId;\n-    // detector definition and the definition fetch time\n-    private Entry<AnomalyDetector, Instant> detectorDef;\n-    // number of partitions and the number's fetch time\n-    private Entry<Integer, Instant> partitonNumber;\n+    // detector definition\n+    private AnomalyDetector detectorDef;\n+    // number of partitions\n+    private int partitonNumber;\n     // checkpoint fetch time\n-    private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    private Instant lastAccessTime;\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n-\n-    public TransportState(String detectorId) {\n+    private Optional<String> lastDetectionError;\n+    // last training error. Used to save cold start error by a concurrent cold start thread.\n+    private Optional<Exception> lastColdStartException;\n+    // flag indicating whether checkpoint for the detector exists\n+    private boolean checkPointExists;\n+    // clock to get current time\n+    private final Clock clock;\n+\n+    public TransportState(String detectorId, Clock clock) {\n         this.detectorId = detectorId;\n-        detectorDef = null;\n-        partitonNumber = null;\n-        checkpoint = null;\n-        lastError = null;\n+        this.detectorDef = null;\n+        this.partitonNumber = -1;\n+        this.lastAccessTime = clock.instant();\n+        this.lastDetectionError = Optional.empty();\n+        this.lastColdStartException = Optional.empty();\n+        this.checkPointExists = false;\n+        this.clock = clock;\n     }\n \n     public String getDetectorId() {\n         return detectorId;\n     }\n \n-    public Entry<AnomalyDetector, Instant> getDetectorDef() {\n+    public AnomalyDetector getDetectorDef() {\n+        refreshLastUpdateTime();\n         return detectorDef;\n     }\n \n-    public void setDetectorDef(Entry<AnomalyDetector, Instant> detectorDef) {\n+    public void setDetectorDef(AnomalyDetector detectorDef) {\n         this.detectorDef = detectorDef;\n+        refreshLastUpdateTime();\n     }\n \n-    public Entry<Integer, Instant> getPartitonNumber() {\n+    public int getPartitonNumber() {\n+        refreshLastUpdateTime();\n         return partitonNumber;\n     }\n \n-    public void setPartitonNumber(Entry<Integer, Instant> partitonNumber) {\n+    public void setPartitonNumber(int partitonNumber) {\n         this.partitonNumber = partitonNumber;\n+        refreshLastUpdateTime();\n     }\n \n-    public Instant getCheckpoint() {\n-        return checkpoint;\n+    public boolean doesCheckpointExists() {\n+        refreshLastUpdateTime();\n+        return checkPointExists;\n     }\n \n-    public void setCheckpoint(Instant checkpoint) {\n-        this.checkpoint = checkpoint;\n+    public void setCheckpointExists(boolean checkpointExists) {\n+        refreshLastUpdateTime();\n+        this.checkPointExists = checkpointExists;\n     };\n \n-    public Entry<String, Instant> getLastError() {\n-        return lastError;\n+    public Optional<String> getLastDetectionError() {\n+        refreshLastUpdateTime();\n+        return lastDetectionError;\n     }\n \n-    public void setLastError(Entry<String, Instant> lastError) {\n-        this.lastError = lastError;\n+    public void setLastDetectionError(String lastError) {\n+        this.lastDetectionError = Optional.ofNullable(lastError);\n+        refreshLastUpdateTime();\n     }\n \n-    public boolean expired(Duration stateTtl, Instant now) {\n-        boolean ans = true;\n-        if (detectorDef != null) {\n-            ans = ans && expired(stateTtl, now, detectorDef.getValue());\n-        }\n-        if (partitonNumber != null) {\n-            ans = ans && expired(stateTtl, now, partitonNumber.getValue());\n-        }\n-        if (checkpoint != null) {\n-            ans = ans && expired(stateTtl, now, checkpoint);\n-        }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n-        }\n-        return ans;\n+    public Optional<Exception> getLastColdStartException() {\n+        refreshLastUpdateTime();\n+        return lastColdStartException;\n+    }\n+\n+    public void setLastColdStartException(Exception lastColdStartError) {\n+        this.lastColdStartException = Optional.ofNullable(lastColdStartError);\n+        refreshLastUpdateTime();\n     }\n \n-    private boolean expired(Duration stateTtl, Instant now, Instant toCheck) {\n-        return toCheck.plus(stateTtl).isBefore(now);\n+    private void refreshLastUpdateTime() {\n+        lastAccessTime = clock.instant();\n+    }\n+\n+    public boolean expired(Duration stateTtl, Instant now) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4OTgzMQ==", "bodyText": "why using two input parameters for this method when one parameter such as expiration time is sufficient?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472389831", "createdAt": "2020-08-18T18:14:15Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {\n     private String detectorId;\n-    // detector definition and the definition fetch time\n-    private Entry<AnomalyDetector, Instant> detectorDef;\n-    // number of partitions and the number's fetch time\n-    private Entry<Integer, Instant> partitonNumber;\n+    // detector definition\n+    private AnomalyDetector detectorDef;\n+    // number of partitions\n+    private int partitonNumber;\n     // checkpoint fetch time\n-    private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    private Instant lastAccessTime;\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n-\n-    public TransportState(String detectorId) {\n+    private Optional<String> lastDetectionError;\n+    // last training error. Used to save cold start error by a concurrent cold start thread.\n+    private Optional<Exception> lastColdStartException;\n+    // flag indicating whether checkpoint for the detector exists\n+    private boolean checkPointExists;\n+    // clock to get current time\n+    private final Clock clock;\n+\n+    public TransportState(String detectorId, Clock clock) {\n         this.detectorId = detectorId;\n-        detectorDef = null;\n-        partitonNumber = null;\n-        checkpoint = null;\n-        lastError = null;\n+        this.detectorDef = null;\n+        this.partitonNumber = -1;\n+        this.lastAccessTime = clock.instant();\n+        this.lastDetectionError = Optional.empty();\n+        this.lastColdStartException = Optional.empty();\n+        this.checkPointExists = false;\n+        this.clock = clock;\n     }\n \n     public String getDetectorId() {\n         return detectorId;\n     }\n \n-    public Entry<AnomalyDetector, Instant> getDetectorDef() {\n+    public AnomalyDetector getDetectorDef() {\n+        refreshLastUpdateTime();\n         return detectorDef;\n     }\n \n-    public void setDetectorDef(Entry<AnomalyDetector, Instant> detectorDef) {\n+    public void setDetectorDef(AnomalyDetector detectorDef) {\n         this.detectorDef = detectorDef;\n+        refreshLastUpdateTime();\n     }\n \n-    public Entry<Integer, Instant> getPartitonNumber() {\n+    public int getPartitonNumber() {\n+        refreshLastUpdateTime();\n         return partitonNumber;\n     }\n \n-    public void setPartitonNumber(Entry<Integer, Instant> partitonNumber) {\n+    public void setPartitonNumber(int partitonNumber) {\n         this.partitonNumber = partitonNumber;\n+        refreshLastUpdateTime();\n     }\n \n-    public Instant getCheckpoint() {\n-        return checkpoint;\n+    public boolean doesCheckpointExists() {\n+        refreshLastUpdateTime();\n+        return checkPointExists;\n     }\n \n-    public void setCheckpoint(Instant checkpoint) {\n-        this.checkpoint = checkpoint;\n+    public void setCheckpointExists(boolean checkpointExists) {\n+        refreshLastUpdateTime();\n+        this.checkPointExists = checkpointExists;\n     };\n \n-    public Entry<String, Instant> getLastError() {\n-        return lastError;\n+    public Optional<String> getLastDetectionError() {\n+        refreshLastUpdateTime();\n+        return lastDetectionError;\n     }\n \n-    public void setLastError(Entry<String, Instant> lastError) {\n-        this.lastError = lastError;\n+    public void setLastDetectionError(String lastError) {\n+        this.lastDetectionError = Optional.ofNullable(lastError);\n+        refreshLastUpdateTime();\n     }\n \n-    public boolean expired(Duration stateTtl, Instant now) {\n-        boolean ans = true;\n-        if (detectorDef != null) {\n-            ans = ans && expired(stateTtl, now, detectorDef.getValue());\n-        }\n-        if (partitonNumber != null) {\n-            ans = ans && expired(stateTtl, now, partitonNumber.getValue());\n-        }\n-        if (checkpoint != null) {\n-            ans = ans && expired(stateTtl, now, checkpoint);\n-        }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n-        }\n-        return ans;\n+    public Optional<Exception> getLastColdStartException() {\n+        refreshLastUpdateTime();\n+        return lastColdStartException;\n+    }\n+\n+    public void setLastColdStartException(Exception lastColdStartError) {\n+        this.lastColdStartException = Optional.ofNullable(lastColdStartError);\n+        refreshLastUpdateTime();\n     }\n \n-    private boolean expired(Duration stateTtl, Instant now, Instant toCheck) {\n-        return toCheck.plus(stateTtl).isBefore(now);\n+    private void refreshLastUpdateTime() {\n+        lastAccessTime = clock.instant();\n+    }\n+\n+    public boolean expired(Duration stateTtl, Instant now) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQzMjczMg==", "bodyText": "changed", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472432732", "createdAt": "2020-08-18T19:33:47Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {\n     private String detectorId;\n-    // detector definition and the definition fetch time\n-    private Entry<AnomalyDetector, Instant> detectorDef;\n-    // number of partitions and the number's fetch time\n-    private Entry<Integer, Instant> partitonNumber;\n+    // detector definition\n+    private AnomalyDetector detectorDef;\n+    // number of partitions\n+    private int partitonNumber;\n     // checkpoint fetch time\n-    private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    private Instant lastAccessTime;\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n-\n-    public TransportState(String detectorId) {\n+    private Optional<String> lastDetectionError;\n+    // last training error. Used to save cold start error by a concurrent cold start thread.\n+    private Optional<Exception> lastColdStartException;\n+    // flag indicating whether checkpoint for the detector exists\n+    private boolean checkPointExists;\n+    // clock to get current time\n+    private final Clock clock;\n+\n+    public TransportState(String detectorId, Clock clock) {\n         this.detectorId = detectorId;\n-        detectorDef = null;\n-        partitonNumber = null;\n-        checkpoint = null;\n-        lastError = null;\n+        this.detectorDef = null;\n+        this.partitonNumber = -1;\n+        this.lastAccessTime = clock.instant();\n+        this.lastDetectionError = Optional.empty();\n+        this.lastColdStartException = Optional.empty();\n+        this.checkPointExists = false;\n+        this.clock = clock;\n     }\n \n     public String getDetectorId() {\n         return detectorId;\n     }\n \n-    public Entry<AnomalyDetector, Instant> getDetectorDef() {\n+    public AnomalyDetector getDetectorDef() {\n+        refreshLastUpdateTime();\n         return detectorDef;\n     }\n \n-    public void setDetectorDef(Entry<AnomalyDetector, Instant> detectorDef) {\n+    public void setDetectorDef(AnomalyDetector detectorDef) {\n         this.detectorDef = detectorDef;\n+        refreshLastUpdateTime();\n     }\n \n-    public Entry<Integer, Instant> getPartitonNumber() {\n+    public int getPartitonNumber() {\n+        refreshLastUpdateTime();\n         return partitonNumber;\n     }\n \n-    public void setPartitonNumber(Entry<Integer, Instant> partitonNumber) {\n+    public void setPartitonNumber(int partitonNumber) {\n         this.partitonNumber = partitonNumber;\n+        refreshLastUpdateTime();\n     }\n \n-    public Instant getCheckpoint() {\n-        return checkpoint;\n+    public boolean doesCheckpointExists() {\n+        refreshLastUpdateTime();\n+        return checkPointExists;\n     }\n \n-    public void setCheckpoint(Instant checkpoint) {\n-        this.checkpoint = checkpoint;\n+    public void setCheckpointExists(boolean checkpointExists) {\n+        refreshLastUpdateTime();\n+        this.checkPointExists = checkpointExists;\n     };\n \n-    public Entry<String, Instant> getLastError() {\n-        return lastError;\n+    public Optional<String> getLastDetectionError() {\n+        refreshLastUpdateTime();\n+        return lastDetectionError;\n     }\n \n-    public void setLastError(Entry<String, Instant> lastError) {\n-        this.lastError = lastError;\n+    public void setLastDetectionError(String lastError) {\n+        this.lastDetectionError = Optional.ofNullable(lastError);\n+        refreshLastUpdateTime();\n     }\n \n-    public boolean expired(Duration stateTtl, Instant now) {\n-        boolean ans = true;\n-        if (detectorDef != null) {\n-            ans = ans && expired(stateTtl, now, detectorDef.getValue());\n-        }\n-        if (partitonNumber != null) {\n-            ans = ans && expired(stateTtl, now, partitonNumber.getValue());\n-        }\n-        if (checkpoint != null) {\n-            ans = ans && expired(stateTtl, now, checkpoint);\n-        }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n-        }\n-        return ans;\n+    public Optional<Exception> getLastColdStartException() {\n+        refreshLastUpdateTime();\n+        return lastColdStartException;\n+    }\n+\n+    public void setLastColdStartException(Exception lastColdStartError) {\n+        this.lastColdStartException = Optional.ofNullable(lastColdStartError);\n+        refreshLastUpdateTime();\n     }\n \n-    private boolean expired(Duration stateTtl, Instant now, Instant toCheck) {\n-        return toCheck.plus(stateTtl).isBefore(now);\n+    private void refreshLastUpdateTime() {\n+        lastAccessTime = clock.instant();\n+    }\n+\n+    public boolean expired(Duration stateTtl, Instant now) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTQwMzY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMToyNzoxMVrOHCAITw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzo0ODozNlrOHCqdGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw==", "bodyText": "minor.\nwhen resource is not found, what exception does this method return? why the general exception instead of the more specific one? if other exceptions occur, what does this method return?\nalso who is we? does it refer to the reader of the doc? the client of the interface? the developer of the implementation? or the software implementation? please avoid incorrect/ambiguous use of we when the referee is software.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471861327", "createdAt": "2020-08-18T01:27:11Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTgxMQ==", "bodyText": "Changed to new AnomalyDetectionException.\nIs there any place saying we cannot use we?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472371811", "createdAt": "2020-08-18T17:42:34Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ1MzczNg==", "bodyText": "it was the question about who we refers to. https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472453736", "createdAt": "2020-08-18T20:09:37Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyODM3NA==", "bodyText": "Which part of the doc do you want me to read?  Any particular part related?\nAnyway, I changed to \"AD job execution\".", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472528374", "createdAt": "2020-08-18T22:27:39Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMzI5OQ==", "bodyText": "See Use 3rd person (descriptive) not 2nd person (prescriptive).", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472533299", "createdAt": "2020-08-18T22:41:40Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1NDc3OA==", "bodyText": "good to know", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472554778", "createdAt": "2020-08-18T23:48:36Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTQzMDk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTo0MjowN1rOHCAXyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzo0MzozMVrOHCfUeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NTI5MQ==", "bodyText": "question. what should be returned when the checkpoint exists?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471865291", "createdAt": "2020-08-18T01:42:07Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", detectorId, exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 373}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjM0NQ==", "bodyText": "This is a callback.  We don't need to return anything.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472372345", "createdAt": "2020-08-18T17:43:31Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", detectorId, exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NTI5MQ=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 373}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTQ1MDgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMTo1NDowNVrOHCAjWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOTozNDo1MVrOHCjCXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ==", "bodyText": "question. why should exception be cleared only when data point is missing?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471868249", "createdAt": "2020-08-18T01:54:05Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3Mjc3OQ==", "bodyText": "What do you mean by \"data point is missing\"?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472372779", "createdAt": "2020-08-18T17:44:12Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MjEyOQ==", "bodyText": "look at when the method coldStartIfNoCheckPoint gets called", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472392129", "createdAt": "2020-08-18T18:18:03Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQzMzI0NA==", "bodyText": "There is another method calling fetchColdStartException: coldStartIfNoModel", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472433244", "createdAt": "2020-08-18T19:34:51Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzA5Nzk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOTo1MTo0MVrOHCjjgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyOTowN1rOHClYTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MTczMQ==", "bodyText": "Is it possible that last cold start still not finished when execute coldStart ? Should we check the state of last cold start ?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472441731", "createdAt": "2020-08-18T19:51:41Z", "author": {"login": "ylwu-amzn"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;\n+        }\n+\n+        // fetch previous cold start exception\n+        String adID = detector.getDetectorId();\n+        final Optional<Exception> previousException = stateManager.fetchColdStartException(adID);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", () -> adID, () -> exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return exception;\n             }\n         }\n-        return false;\n+        LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n+        coldStart(detector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MTYzMA==", "bodyText": "It is possible.  Let me add a check.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472471630", "createdAt": "2020-08-18T20:29:07Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;\n+        }\n+\n+        // fetch previous cold start exception\n+        String adID = detector.getDetectorId();\n+        final Optional<Exception> previousException = stateManager.fetchColdStartException(adID);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", () -> adID, () -> exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return exception;\n             }\n         }\n-        return false;\n+        LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n+        coldStart(detector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MTczMQ=="}, "originalCommit": {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Mzg4MzQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMDoyMDo1MlrOHCrBMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo0NjowNVrOHE0KIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg==", "bodyText": "minor. why not do expired(expirationdate=now-ttl)? ttl is an odd parameter.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472564016", "createdAt": "2020-08-19T00:20:52Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NDg3Nw==", "bodyText": "expirationdate is a date, while ttl is a duration.  ttl means time to leave.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473194877", "createdAt": "2020-08-19T17:13:09Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI4NjEwOA==", "bodyText": "the method can just take one input parameter as the final expiration time, which can be calculated by the client however they want. in this case, it is now-tll. the method is easier to understand and use and more reusable.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473286108", "createdAt": "2020-08-19T20:02:17Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwMjA5OQ==", "bodyText": "I don't understand.  Expiration date = last access time + ttl.  Why is it now-ttl?", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473302099", "createdAt": "2020-08-19T20:33:53Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNTExMA==", "bodyText": "so this method takes one parameter that is the expiration time. if the last access time is before it, the method returns true, otherwise it returns false.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473305110", "createdAt": "2020-08-19T20:39:56Z", "author": {"login": "wnbts"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMDkxMw==", "bodyText": "In that case, all the caller has to compute the expiration time.  Current implementation looks easier that encapsulate the logic inside.", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r474810913", "createdAt": "2020-08-21T16:46:05Z", "author": {"login": "kaituo"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, "originalCommit": {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2914, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}