{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxOTI5MjUx", "number": 805, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTo0MzoxMFrOEm18BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNzowMDoyMlrOEnIvCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTY1MDYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTo0MzoxMFrOHXGzeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMTo0MzoxMFrOHXGzeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk5MDc3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (supportedLocales != null && !supportedLocales.isEmpty()) {\n          \n          \n            \n                                    if (!supportedLocales.isEmpty()) {", "url": "https://github.com/vmware/singleton/pull/805#discussion_r493990777", "createdAt": "2020-09-24T01:43:10Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "diffHunk": "@@ -49,19 +52,44 @@ public RemoteProductOpt(BaseDTO dto) {\n      * get supported locales from vip(non-Javadoc)\n      *\n      */\n-    public List<String> getSupportedLocales() {\n-        JSONArray msgObject = new JSONArray();\n-        String responseStr = \"\";\n+    public MessageCacheItem getSupportedLocales(MessageCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+            headers.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+\n         Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(\n-                dto, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()), ConstantsKeys.GET, null);\n-        responseStr = (String) response.get(URLUtils.BODY);\n-        if (null != responseStr && !responseStr.equals(\"\")) {\n-            Object dataObj = this.getMessagesFromResponse(responseStr,\n-                    ConstantsKeys.LOCALES);\n-            if (dataObj != null) {\n-                msgObject = (JSONArray) dataObj;\n+                dto, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()), ConstantsKeys.GET, null, headers);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+\n+            long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n+                    System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+\n+            String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+\n+            Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                String responseStr = (String) response.get(URLUtils.BODY);\n+                if (responseStr != null && !responseStr.isEmpty()) {\n+                    Object dataObj = this.getMessagesFromResponse(responseStr, ConstantsKeys.LOCALES);\n+                    if (dataObj != null) {\n+                        List<String> supportedLocales = (JSONArray) dataObj;\n+                        Map<String, String> languageTags = new HashMap<>();\n+                        if (supportedLocales != null && !supportedLocales.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2763fb1c581e8c6b5bfabd3dfa53b2cfb326b0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDcwODY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/ProductOpt.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjo1NDozNFrOHXkBbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjo1NDozNFrOHXkBbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ2OTQ4Nw==", "bodyText": "Since MessageCacheItem is passed as a parameter, so the method's return type can be void.", "url": "https://github.com/vmware/singleton/pull/805#discussion_r494469487", "createdAt": "2020-09-24T16:54:34Z", "author": {"login": "huihuiw01"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/ProductOpt.java", "diffHunk": "@@ -6,7 +6,9 @@\n \n import java.util.List;\n \n+import com.vmware.vipclient.i18n.base.cache.MessageCacheItem;\n+\n public interface ProductOpt {\n-\tpublic List<String> getSupportedLocales();\n+\tpublic MessageCacheItem getSupportedLocales(MessageCacheItem cacheItem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2763fb1c581e8c6b5bfabd3dfa53b2cfb326b0"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDczMDM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNzowMDoyMlrOHXkPcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMDo1ODo1N1rOHXxcpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MzA3NQ==", "bodyText": "I think this judgement is not needed. No matter the locale list is empty or not, it should be cached, or it will always try to fetch locale list from data source if last fetch fails, which may impact the performance.", "url": "https://github.com/vmware/singleton/pull/805#discussion_r494473075", "createdAt": "2020-09-24T17:00:22Z", "author": {"login": "huihuiw01"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -71,28 +75,81 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @return list of locales of the product specified in the dto object\n+     * @return list of locales of the product specified in the dto object, or an empty list in case of failure to retrieve from any data source.\n      */\n     public Set<Locale> getSupportedLocales() {\n-        Set<Locale> locales = new HashSet<>();\n+        return langTagtoLocaleSet(getSupportedLanguageTags());\n+    }\n+\n+    public Set<String> getSupportedLanguageTags() {\n         Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            for (String languageTag : opt.getSupportedLocales()) {\n-                locales.add(Locale.forLanguageTag(languageTag));\n-            }\n-            // If failed to get locales from the data source, log the error.\n-            if (locales == null || locales.isEmpty()) {\n-                logger.error(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString());\n-            }\n+        Set<String> supportedLangTags = new HashSet<>();\n+        while(msgSourceQueueIter.hasNext() && supportedLangTags.isEmpty()) {\n+            supportedLangTags = getSupportedLanguageTags(msgSourceQueueIter.next());\n+        }\n+        return supportedLangTags;\n+    }\n+\n+    public Set<String> getSupportedLanguageTags(DataSourceEnum dataSource) {\n+        CacheService cs = new CacheService(new MessagesDTO(dto));\n+        MessageCacheItem cacheItem = cs.getCacheOfLocales(dataSource);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired())\n+                refreshCacheItemTask(cacheItem, dataSource);\n+            return cacheItem.getCachedData().keySet();\n+        } else {\n+            cacheItem = createCacheItem(dataSource);\n+            if (cacheItem == null)\n+                return new HashSet<>();\n+            return cacheItem.getCachedData().keySet();\n         }\n-        return locales;\n     }\n \n     public boolean isSupportedLocale(Locale locale) {\n         return getSupportedLocales().contains(LocaleUtility.fmtToMappedLocale(locale));\n     }\n \n+    private void refreshCacheItem(final MessageCacheItem cacheItem, DataSourceEnum dataSource) {\n+        long timestampOld = cacheItem.getTimestamp();\n+        dataSource.createProductOpt(dto).getSupportedLocales(cacheItem);\n+        long timestamp = cacheItem.getTimestamp();\n+        if (timestampOld == timestamp) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+        }\n+    }\n+\n+    private void refreshCacheItemTask(MessageCacheItem cacheItem, DataSourceEnum dataSource) {\n+        Callable<MessageCacheItem> callable = () -> {\n+            try {\n+                refreshCacheItem(cacheItem, dataSource);\n+                return cacheItem;\n+            } catch (Exception e) {\n+                return null;\n+            }\n+        };\n+        FutureTask<MessageCacheItem> task = new FutureTask<>(callable);\n+        Thread thread = new Thread(task);\n+        thread.start();\n+    }\n+\n+    private MessageCacheItem createCacheItem (DataSourceEnum dataSource) {\n+        CacheService cs = new CacheService(new MessagesDTO(dto));\n+        MessageCacheItem cacheItem = new MessageCacheItem();\n+        refreshCacheItem(cacheItem, dataSource);\n+        if (!cacheItem.getCachedData().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2763fb1c581e8c6b5bfabd3dfa53b2cfb326b0"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4OTQ0NQ==", "bodyText": "If cachedData is empty, that means the fetch actually failed. At least 1 language must be supported. Therefore, since it failed, it should actually try to fetch from data source again next time.\nAn empty data is useless. Don't add anything that is \"empty\" or null in the cache.", "url": "https://github.com/vmware/singleton/pull/805#discussion_r494689445", "createdAt": "2020-09-25T00:58:57Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -71,28 +75,81 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @return list of locales of the product specified in the dto object\n+     * @return list of locales of the product specified in the dto object, or an empty list in case of failure to retrieve from any data source.\n      */\n     public Set<Locale> getSupportedLocales() {\n-        Set<Locale> locales = new HashSet<>();\n+        return langTagtoLocaleSet(getSupportedLanguageTags());\n+    }\n+\n+    public Set<String> getSupportedLanguageTags() {\n         Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n-        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n-            DataSourceEnum dataSource = msgSourceQueueIter.next();\n-            ProductOpt opt = dataSource.createProductOpt(dto);\n-            for (String languageTag : opt.getSupportedLocales()) {\n-                locales.add(Locale.forLanguageTag(languageTag));\n-            }\n-            // If failed to get locales from the data source, log the error.\n-            if (locales == null || locales.isEmpty()) {\n-                logger.error(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString());\n-            }\n+        Set<String> supportedLangTags = new HashSet<>();\n+        while(msgSourceQueueIter.hasNext() && supportedLangTags.isEmpty()) {\n+            supportedLangTags = getSupportedLanguageTags(msgSourceQueueIter.next());\n+        }\n+        return supportedLangTags;\n+    }\n+\n+    public Set<String> getSupportedLanguageTags(DataSourceEnum dataSource) {\n+        CacheService cs = new CacheService(new MessagesDTO(dto));\n+        MessageCacheItem cacheItem = cs.getCacheOfLocales(dataSource);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired())\n+                refreshCacheItemTask(cacheItem, dataSource);\n+            return cacheItem.getCachedData().keySet();\n+        } else {\n+            cacheItem = createCacheItem(dataSource);\n+            if (cacheItem == null)\n+                return new HashSet<>();\n+            return cacheItem.getCachedData().keySet();\n         }\n-        return locales;\n     }\n \n     public boolean isSupportedLocale(Locale locale) {\n         return getSupportedLocales().contains(LocaleUtility.fmtToMappedLocale(locale));\n     }\n \n+    private void refreshCacheItem(final MessageCacheItem cacheItem, DataSourceEnum dataSource) {\n+        long timestampOld = cacheItem.getTimestamp();\n+        dataSource.createProductOpt(dto).getSupportedLocales(cacheItem);\n+        long timestamp = cacheItem.getTimestamp();\n+        if (timestampOld == timestamp) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));\n+        }\n+    }\n+\n+    private void refreshCacheItemTask(MessageCacheItem cacheItem, DataSourceEnum dataSource) {\n+        Callable<MessageCacheItem> callable = () -> {\n+            try {\n+                refreshCacheItem(cacheItem, dataSource);\n+                return cacheItem;\n+            } catch (Exception e) {\n+                return null;\n+            }\n+        };\n+        FutureTask<MessageCacheItem> task = new FutureTask<>(callable);\n+        Thread thread = new Thread(task);\n+        thread.start();\n+    }\n+\n+    private MessageCacheItem createCacheItem (DataSourceEnum dataSource) {\n+        CacheService cs = new CacheService(new MessagesDTO(dto));\n+        MessageCacheItem cacheItem = new MessageCacheItem();\n+        refreshCacheItem(cacheItem, dataSource);\n+        if (!cacheItem.getCachedData().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MzA3NQ=="}, "originalCommit": {"oid": "9a2763fb1c581e8c6b5bfabd3dfa53b2cfb326b0"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4332, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}