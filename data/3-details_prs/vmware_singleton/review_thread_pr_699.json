{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDE1NDg3", "number": 699, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMjozMjowOVrOEVPCBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNjoyNDozNFrOEX6XhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzAxODMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/MessageCacheItem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMjozMjowOVrOG739iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMjozMjowOVrOG739iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzNjA0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic synchronized void setCacheItem(String locale, Map<String, String> cachedData, String etag, long timestamp, Long maxAgeMillis) {\n          \n          \n            \n            \tpublic synchronized void setCacheItem(String locale, Map<String, String> dataToCache, String etag, long timestamp, Long maxAgeMillis) {", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465436040", "createdAt": "2020-08-05T02:32:09Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/MessageCacheItem.java", "diffHunk": "@@ -14,75 +14,58 @@\n \tpublic MessageCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic MessageCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n-\t\tthis.etag = etag;\n-\t\tthis.timestamp = timestamp;\n-\t\tthis.maxAgeMillis = maxAgeMillis;\n-\t}\n-\t\n-\tpublic MessageCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n+\n+\tpublic MessageCacheItem(Map<String, String> dataMap) {\n \t\tif (dataMap != null)\n-\t\t\tthis.addCachedData(dataMap);\n+\t\t\tthis.cachedData.putAll(dataMap);\n \t}\n \t\n-\t\n+\tpublic MessageCacheItem (String locale, Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.setCacheItem(locale, dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+\tprivate String locale;\n \tprivate String etag;\n \tprivate long timestamp;\n \tprivate Long maxAgeMillis = 86400000l;\n \t\n-\tprivate final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCacheData(String key, String value) {\n-\t\tthis.cachedData.put(key, value);\n-\t}\n-\t\n-\tpublic synchronized void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null) \n+\tprivate final Map<String, String> cachedData = new HashMap<>();\n+\n+\tpublic synchronized void setCacheItem(String locale, Map<String, String> cachedData, String etag, long timestamp, Long maxAgeMillis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA3ODY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzowODozOFrOG74hbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjo0OToxOVrOG_AkMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTIyOQ==", "bodyText": "Don't need to store time to cache because data from local will never expire.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465445229", "createdAt": "2020-08-05T03:08:38Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -67,9 +67,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n \t\t\t\tpath = Paths.get(uri);\n \t\t\t\tmessages = JSONBundleUtil.getMessages(path);\n \t\t\t}\n-\t\t\t\t\n-\t    \tcacheItem.addCachedData(messages);\n-\t    \tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\tcacheItem.setCacheItem(dto.getLocale(), messages, null, System.currentTimeMillis(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0ODM3Mg==", "bodyText": "Data from local must expire. Use case: If data from local was fetched as a fallback for when Singleton service is temporarily down. In this case, when the cached data from local expires, it should try to fetch from the service again.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r467148372", "createdAt": "2020-08-07T16:36:32Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -67,9 +67,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n \t\t\t\tpath = Paths.get(uri);\n \t\t\t\tmessages = JSONBundleUtil.getMessages(path);\n \t\t\t}\n-\t\t\t\t\n-\t    \tcacheItem.addCachedData(messages);\n-\t    \tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\tcacheItem.setCacheItem(dto.getLocale(), messages, null, System.currentTimeMillis(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTIyOQ=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNTM4OQ==", "bodyText": "It should be set the time in other place because here is Local Opt, it doesn't need to consider the time.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r468305389", "createdAt": "2020-08-11T03:29:12Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -67,9 +67,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n \t\t\t\tpath = Paths.get(uri);\n \t\t\t\tmessages = JSONBundleUtil.getMessages(path);\n \t\t\t}\n-\t\t\t\t\n-\t    \tcacheItem.addCachedData(messages);\n-\t    \tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\tcacheItem.setCacheItem(dto.getLocale(), messages, null, System.currentTimeMillis(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTIyOQ=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMjczOA==", "bodyText": "So where do you recommend to set the time? By the way,  there is nothing about expire time here, only timestamp of when the data was fetched from local bundles. And it has been there before this PR, just combined them into 1 call, so I do not want to make any change about that in this PR.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r468722738", "createdAt": "2020-08-11T16:49:19Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -67,9 +67,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n \t\t\t\tpath = Paths.get(uri);\n \t\t\t\tmessages = JSONBundleUtil.getMessages(path);\n \t\t\t}\n-\t\t\t\t\n-\t    \tcacheItem.addCachedData(messages);\n-\t    \tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\tcacheItem.setCacheItem(dto.getLocale(), messages, null, System.currentTimeMillis(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTIyOQ=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA4NTcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/MessageCacheItem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMjozOFrOG74ldw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMjozOFrOG74ldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjI2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic boolean isExpired() {\n          \n          \n            \n            \tpublic synchronized boolean isExpired() {", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465446263", "createdAt": "2020-08-05T03:12:38Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/MessageCacheItem.java", "diffHunk": "@@ -14,75 +14,58 @@\n \tpublic MessageCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic MessageCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n-\t\tthis.etag = etag;\n-\t\tthis.timestamp = timestamp;\n-\t\tthis.maxAgeMillis = maxAgeMillis;\n-\t}\n-\t\n-\tpublic MessageCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n+\n+\tpublic MessageCacheItem(Map<String, String> dataMap) {\n \t\tif (dataMap != null)\n-\t\t\tthis.addCachedData(dataMap);\n+\t\t\tthis.cachedData.putAll(dataMap);\n \t}\n \t\n-\t\n+\tpublic MessageCacheItem (String locale, Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.setCacheItem(locale, dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+\tprivate String locale;\n \tprivate String etag;\n \tprivate long timestamp;\n \tprivate Long maxAgeMillis = 86400000l;\n \t\n-\tprivate final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCacheData(String key, String value) {\n-\t\tthis.cachedData.put(key, value);\n-\t}\n-\t\n-\tpublic synchronized void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null) \n+\tprivate final Map<String, String> cachedData = new HashMap<>();\n+\n+\tpublic synchronized void setCacheItem(String locale, Map<String, String> cachedData, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tif (cachedData != null)\n \t\t\tthis.cachedData.putAll(cachedData);\n+\t\tthis.setCacheItem(locale, etag, timestamp, maxAgeMillis);\n \t}\n-\t\n+\tpublic synchronized void setCacheItem(String locale, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.locale = locale;\n+\t\tif (etag != null && !etag.isEmpty())\n+\t\t\tthis.etag = etag;\n+\t\tthis.timestamp = timestamp;\n+\t\tif (maxAgeMillis != null)\n+\t\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n \tpublic synchronized void setCacheItem (MessageCacheItem cacheItem) {\n-\t\t// Do not update cacheItem if timestamp is earlier than current. \n-\t\t// An older timestamp comes from an old thread that was blocked.\n-\t\tif (cacheItem.getTimestamp() < this.timestamp) \n-\t\t\treturn;\n-\t\tthis.addCachedData(cacheItem.getCachedData());\n-\t\tthis.etag = cacheItem.etag;\n-\t\tthis.timestamp = cacheItem.timestamp;\n-\t\tthis.maxAgeMillis = cacheItem.maxAgeMillis;\n+\t\tthis.setCacheItem(cacheItem.getLocale(), cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n \t}\n \t\t\n-\tpublic synchronized String getEtag() {\n+\tpublic String getEtag() {\n \t\treturn etag;\n \t}\n \n-\tpublic synchronized void setEtag(String etag) {\n-\t\tthis.etag = etag;\n-\t}\n-\n-\tpublic synchronized long getTimestamp() {\n+\tpublic long getTimestamp() {\n \t\treturn timestamp;\n \t}\n-\n-\tpublic synchronized void setTimestamp(long timestamp) {\n-\t\tthis.timestamp = timestamp;\n-\t}\n     \n     public Map<String, String> getCachedData() {\n \t\treturn cachedData;\n \t}\n \n-\tpublic synchronized Long getMaxAgeMillis() {\n+\tpublic Long getMaxAgeMillis() {\n \t\treturn maxAgeMillis;\n \t}\n \n-\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n-\t\tthis.maxAgeMillis = maxAgeMillis;\n-\t}\n+\tpublic String getLocale() { return locale; }\n \n \tpublic boolean isExpired() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA4OTc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ComponentBasedOpt.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxNToxNVrOG74n4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjozOTo0M1rOG9gkbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0Njg4MA==", "bodyText": "If it fails, still store these into cache?", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465446880", "createdAt": "2020-08-05T03:15:15Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ComponentBasedOpt.java", "diffHunk": "@@ -52,33 +50,32 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n         \n         if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n         \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n-        \t\n-        \t// If already in cache (timestamp > 0), always extend the timestamp.\n-        \tif (cacheItem.getTimestamp() != 0 && response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n-\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tlong timestamp = 0;\n+        \tString etag = null;\n+        \tLong maxAgeMillis = null;\n+\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+        \t    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n         \tif (response.get(URLUtils.HEADERS) != null)\n-\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+        \t    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n \t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n-\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n-\t\t\t      \n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n \t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n \t\t        JSONObject respObj = (JSONObject) JSONValue.parse((String) response.get(URLUtils.BODY));\n \t\t        try {\n-\t        \t\tif (getResponseCode(respObj) == 200){ \n-\t        \t\t\t// If not yet in cache (timestamp = 0), store the timestamp only when successful (business code 200).\n-\t        \t\t\tif (cacheItem.getTimestamp() == 0 && response.get(URLUtils.RESPONSE_TIMESTAMP) != null) {\n-\t        \t\t\t\tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n-\t        \t\t\t}\n+\t        \t\tif (getResponseCode(respObj) == 200) {\n \t\t\t\t        Map<String,String> messages = this.getMsgsJson(response);\n \t\t\t\t        if (messages != null) {\n-\t\t\t\t        \tcacheItem.addCachedData(messages);\n+\t\t\t\t        \tcacheItem.setCacheItem(this.dto.getLocale(), messages, etag, timestamp, maxAgeMillis);\n \t\t\t\t        }\n         \t\t\t}\n \t        \t} catch (Exception e) {\n \t        \t\tlogger.error(\"Failed to get messages\");\n \t        \t}\n-\t        }\n-\n+\t        } else {\n+                cacheItem.setCacheItem(this.dto.getLocale(), etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0OTkzNQ==", "bodyText": "The else is not for when it fails. It is for when status is 304 (HTTP_NOT_MODIFIED). See lines 51-52.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r467149935", "createdAt": "2020-08-07T16:39:43Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ComponentBasedOpt.java", "diffHunk": "@@ -52,33 +50,32 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n         \n         if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n         \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n-        \t\n-        \t// If already in cache (timestamp > 0), always extend the timestamp.\n-        \tif (cacheItem.getTimestamp() != 0 && response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n-\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tlong timestamp = 0;\n+        \tString etag = null;\n+        \tLong maxAgeMillis = null;\n+\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+        \t    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n         \tif (response.get(URLUtils.HEADERS) != null)\n-\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+        \t    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n \t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n-\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n-\t\t\t      \n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n \t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n \t\t        JSONObject respObj = (JSONObject) JSONValue.parse((String) response.get(URLUtils.BODY));\n \t\t        try {\n-\t        \t\tif (getResponseCode(respObj) == 200){ \n-\t        \t\t\t// If not yet in cache (timestamp = 0), store the timestamp only when successful (business code 200).\n-\t        \t\t\tif (cacheItem.getTimestamp() == 0 && response.get(URLUtils.RESPONSE_TIMESTAMP) != null) {\n-\t        \t\t\t\tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n-\t        \t\t\t}\n+\t        \t\tif (getResponseCode(respObj) == 200) {\n \t\t\t\t        Map<String,String> messages = this.getMsgsJson(response);\n \t\t\t\t        if (messages != null) {\n-\t\t\t\t        \tcacheItem.addCachedData(messages);\n+\t\t\t\t        \tcacheItem.setCacheItem(this.dto.getLocale(), messages, etag, timestamp, maxAgeMillis);\n \t\t\t\t        }\n         \t\t\t}\n \t        \t} catch (Exception e) {\n \t        \t\tlogger.error(\"Failed to get messages\");\n \t        \t}\n-\t        }\n-\n+\t        } else {\n+                cacheItem.setCacheItem(this.dto.getLocale(), etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0Njg4MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA5NTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxODo0M1rOG74rAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo0MjozM1rOG9gpug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzY4Mg==", "bodyText": "Here the etag is for all the components instead of a single component. so it's a wrong etag.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465447682", "createdAt": "2020-08-05T03:18:43Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentsService.java", "diffHunk": "@@ -96,7 +96,7 @@ public ComponentsService(final VIPCfg config) {\n             final MessagesDTO dto = new MessagesDTO();\n             dto.setComponent(comp);\n             dto.setLocale(locale);\n-            new CacheService(dto).addCacheOfComponent(new MessageCacheItem(messages, cacheItem.getEtag(), \n+            new CacheService(dto).addCacheOfComponent(new MessageCacheItem(locale, messages, cacheItem.getEtag(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MTI5MA==", "bodyText": "Right! Good catch. I'll set the etag to null for this one for now.\n#646", "url": "https://github.com/vmware/singleton/pull/699#discussion_r467151290", "createdAt": "2020-08-07T16:42:33Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentsService.java", "diffHunk": "@@ -96,7 +96,7 @@ public ComponentsService(final VIPCfg config) {\n             final MessagesDTO dto = new MessagesDTO();\n             dto.setComponent(comp);\n             dto.setLocale(locale);\n-            new CacheService(dto).addCacheOfComponent(new MessageCacheItem(messages, cacheItem.getEtag(), \n+            new CacheService(dto).addCacheOfComponent(new MessageCacheItem(locale, messages, cacheItem.getEtag(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzY4Mg=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzc2MTQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwODowNzoxMVrOG7-2oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTowODoxNlrOG_y7Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA==", "bodyText": "For some reasons, the requested locale failed last time. We still need to try the requested locale first, then fallback to default locale if failure.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r465548960", "createdAt": "2020-08-05T08:07:11Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NDM0NQ==", "bodyText": "I will update line 103 with this: if (cacheItem.isExpired() || !cacheItem.getLocale().equals(this.dto.getLocale())). It should resolve the issue.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r467154345", "createdAt": "2020-08-07T16:48:42Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNTk5Nw==", "bodyText": "I'm afraid it can't. If one locale gets the default locale's messages, it will always get the default locale's messages. It's wrong.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r468305997", "createdAt": "2020-08-11T03:31:40Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzODcwNA==", "bodyText": "Right! My mistake. See the changes please", "url": "https://github.com/vmware/singleton/pull/699#discussion_r468938704", "createdAt": "2020-08-12T00:33:05Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMyOTE4NA==", "bodyText": "I mean that the requested locale fails not because locale isn't supported but other reasons such as network error. So next time to update cache, still need to get the requested locale first.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469329184", "createdAt": "2020-08-12T15:05:37Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM5Mjg4OA==", "bodyText": "Yes, that is what is happening as I explained to Huihui.\nIn line 110, if the cache contains the fallback locale and not the requested locale, it will always try to fetch the requested locale first (line 113) and try to assign that to the requested locales cache key (line 116). Only if it fails again will it point to the fallback locale\u2019s cacheItem again (line 122).\npopulateCacheTask only refreshes the content of the object that is already in the cache (e.g. either the target or fallback locale cacheItem), but it will not change the mapping of the object to the cache key/s. So this line you commented on will not affect the existing mapping/s of the object to cache key/s. It will just update the contents (the insides) of cacheItem object itself.\nIf you still do not get it, let's connect over Zoom", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469392888", "createdAt": "2020-08-12T16:37:12Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0Nzg1OQ==", "bodyText": "I have also updated the code to make it easier to understand, but same logic.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469547859", "createdAt": "2020-08-12T21:08:16Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -125,12 +125,19 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n \tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n \t\tCallable<MessageCacheItem> callable = () -> {\n     \t\ttry {\n-    \t\t\t// Pass cacheItem to getMessages so that:\n-\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n-\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed \n-\t\t\t\t// \t with new properties from the next HTTP response.\n-\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-    \t\t\treturn cacheItem;\n+    \t\t\t/* Pass cacheItem to fetchMessages so that:\n+\t\t\t\t\t1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t\t2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t\t\twith new values from the next HTTP response.\n+\t\t\t\t*/\n+\t\t\t\tString cacheItemLocale = cacheItem.getLocale();\n+    \t\t\tif (cacheItemLocale.equals(this.dto.getLocale())) {\n+\t\t\t\t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+\t\t\t\t} else {  //If cacheItem's locale is not the requested locale, it means it is for a fallback locale. Hence, refresh the appropriate fallback locale's cache\n+\t\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), cacheItemLocale, dto.getProductID(), dto.getVersion());\n+\t\t\t\t\tnew ComponentService(fallbackLocaleDTO).fetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0ODk2MA=="}, "originalCommit": {"oid": "ff99a372495ad5f7c71e1daf39085f0b23389e0f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzA1NTU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoxNTo1NVrOG-xaTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoxNTo1NVrOG-xaTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NDQ0NA==", "bodyText": "With this condition !cacheItem.getLocale().equals(this.dto.getLocale()),\ncache default locale's content for requested locale may not take effect, because they never be equal.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r468474444", "createdAt": "2020-08-11T10:15:55Z", "author": {"login": "huihuiw01"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -99,7 +99,8 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tMessageCacheItem cacheItem = null;\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n-    \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n+\t\t\t// If the cacheItem is either expired or for a fallback locale\n+    \t\tif (cacheItem.isExpired() || !cacheItem.getLocale().equals(this.dto.getLocale())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "271ee08a424106a9cc38e874fe07c14535bd1d96"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDY4OTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMjo0MTozOVrOG_5_Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNToyMjozMVrOG_8aCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY2MzU1MA==", "bodyText": "How about moving this into above if block so it doesn't fetch every time.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469663550", "createdAt": "2020-08-13T02:41:39Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcwMzE3Ng==", "bodyText": "We actually want to always try to fetch for the requested locale every time in a separate thread, not just when the cacheItem has expired. This is because if the cacheItem is for a fallback locale, any other call for a non-supported locale can trigger a refresh of the fallback locale's cacheItem. If that happens, the requested locale may not satisfy the if(cacheItem.isExpired() because the fallback locale has been refreshed by some other request. In this case, we still want to try and fetch the data for the requested locale.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469703176", "createdAt": "2020-08-13T05:22:31Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY2MzU1MA=="}, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDc0Njk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMzoxNjo0OFrOG_6hDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNTozNToyOFrOG_8omQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY3MjIwNw==", "bodyText": "Need to judge if current fallback locale is same as the locale in DTO. If same, should skip it.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469672207", "createdAt": "2020-08-13T03:16:48Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}\n+    \t} else { // Item is not in cache. Create and store cacheItem for the requested locale\n+    \t\tcacheItem = createCacheItem(fallbackLocalesIter);\n     \t}\n     \treturn cacheItem;\n     }\n-    \n-\tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n+\n+\t/**\n+\t * Creates a new MessageCacheItem for the DTO and stores it in cache.\n+\t *\n+\t * @param fallbackLocalesIter The fallback locale queue to use in case of failure.\n+\t *\n+\t */\n+    private MessageCacheItem createCacheItem(Iterator<Locale> fallbackLocalesIter) {\n+\t\tCacheService cacheService = new CacheService(dto);\n+\t\t// Create a new cacheItem object to be stored in cache\n+\t\tMessageCacheItem cacheItem = new MessageCacheItem();\n+\t\trefreshCacheItem(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n+\n+\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n+\t\t\t// If failed to fetch message for the requetsed DTO, use MessageCacheItem of the next fallback locale.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcwNjkwNQ==", "bodyText": "If you follow the recursive logic, the locale in the dto will be the previous locale in the fallback locale queue.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469706905", "createdAt": "2020-08-13T05:35:28Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}\n+    \t} else { // Item is not in cache. Create and store cacheItem for the requested locale\n+    \t\tcacheItem = createCacheItem(fallbackLocalesIter);\n     \t}\n     \treturn cacheItem;\n     }\n-    \n-\tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n+\n+\t/**\n+\t * Creates a new MessageCacheItem for the DTO and stores it in cache.\n+\t *\n+\t * @param fallbackLocalesIter The fallback locale queue to use in case of failure.\n+\t *\n+\t */\n+    private MessageCacheItem createCacheItem(Iterator<Locale> fallbackLocalesIter) {\n+\t\tCacheService cacheService = new CacheService(dto);\n+\t\t// Create a new cacheItem object to be stored in cache\n+\t\tMessageCacheItem cacheItem = new MessageCacheItem();\n+\t\trefreshCacheItem(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n+\n+\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n+\t\t\t// If failed to fetch message for the requetsed DTO, use MessageCacheItem of the next fallback locale.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY3MjIwNw=="}, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDc1MzQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMzoyMDo1MlrOG_6k4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMzoyMDo1MlrOG_6k4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY3MzE4Ng==", "bodyText": "It seems here has a recursive call: getMessages(Iterator fallbackLocalesIter)  -> createCacheItem(Iterator fallbackLocalesIter)  -> new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter)\nIn my opinion, the hierarchical relation between methods are not clear.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469673186", "createdAt": "2020-08-13T03:20:52Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}\n+    \t} else { // Item is not in cache. Create and store cacheItem for the requested locale\n+    \t\tcacheItem = createCacheItem(fallbackLocalesIter);\n     \t}\n     \treturn cacheItem;\n     }\n-    \n-\tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n+\n+\t/**\n+\t * Creates a new MessageCacheItem for the DTO and stores it in cache.\n+\t *\n+\t * @param fallbackLocalesIter The fallback locale queue to use in case of failure.\n+\t *\n+\t */\n+    private MessageCacheItem createCacheItem(Iterator<Locale> fallbackLocalesIter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTA4OTk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNjoyNDozNFrOG_9n-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo0MzoxNFrOHARbUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcyMzEyOQ==", "bodyText": "Here only use the first fallback locale in the fallback locale chain, doesn't go through the whole fallback locale chain.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r469723129", "createdAt": "2020-08-13T06:24:34Z", "author": {"login": "huihuiw01"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}\n+    \t} else { // Item is not in cache. Create and store cacheItem for the requested locale\n+    \t\tcacheItem = createCacheItem(fallbackLocalesIter);\n     \t}\n     \treturn cacheItem;\n     }\n-    \n-\tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n+\n+\t/**\n+\t * Creates a new MessageCacheItem for the DTO and stores it in cache.\n+\t *\n+\t * @param fallbackLocalesIter The fallback locale queue to use in case of failure.\n+\t *\n+\t */\n+    private MessageCacheItem createCacheItem(Iterator<Locale> fallbackLocalesIter) {\n+\t\tCacheService cacheService = new CacheService(dto);\n+\t\t// Create a new cacheItem object to be stored in cache\n+\t\tMessageCacheItem cacheItem = new MessageCacheItem();\n+\t\trefreshCacheItem(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n+\n+\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n+\t\t\t// If failed to fetch message for the requetsed DTO, use MessageCacheItem of the next fallback locale.\n+\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n+\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n+\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzU2OQ==", "bodyText": "It actually does go through the whole cahin/queue. In line 138, you see fallbackLocalesIter.next(). By calling .next(), the current pointer of fallbackLocalesIter moves to the next item in the queue. When you pass fallbackLocalesIter to ComponentService.getMessages() in line139, the iterator holds the correct place (current pointer) in the queue.", "url": "https://github.com/vmware/singleton/pull/699#discussion_r470047569", "createdAt": "2020-08-13T15:43:14Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ComponentService.java", "diffHunk": "@@ -100,44 +106,78 @@ public MessageCacheItem getMessages(Iterator<Locale> fallbackLocalesIter) {\n     \tif (cacheService.isContainComponent()) { // Item is in cache\n     \t\tcacheItem = cacheService.getCacheOfComponent();\n     \t\tif (cacheItem.isExpired()) { // cacheItem has expired\n-    \t\t\t// Update the cache in a separate thread\n-    \t\t\tpopulateCacheTask(cacheItem);\n+    \t\t\t// Refresh the cacheItem in a separate thread\n+    \t\t\trefreshCacheItemTask(cacheItem);\n     \t\t}\n-    \t} else { // Item is not in cache\n-    \t\t// Create a new cacheItem object to be stored in cache\n-    \t\tcacheItem = new MessageCacheItem();\n-    \t\tfetchMessages(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-\n-\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n-    \t\t\t// If failed to fetch message, use MessageCacheItem of the next fallback locale.\n-\t\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n-\t\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n-\t\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n-\t\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n-\t\t\t\t}\n+\t\t\t// If the cacheItem is for a fallback locale, create and store cacheItem for the requested locale in a separate thread.\n+    \t\tif (!LocaleUtility.isSameLocale(cacheItem.getLocale(), this.dto.getLocale())) {\n+\t\t\t\tthis.createCacheItemTask(fallbackLocalesIter);\n \t\t\t}\n+    \t} else { // Item is not in cache. Create and store cacheItem for the requested locale\n+    \t\tcacheItem = createCacheItem(fallbackLocalesIter);\n     \t}\n     \treturn cacheItem;\n     }\n-    \n-\tprivate void populateCacheTask(MessageCacheItem cacheItem) {\n+\n+\t/**\n+\t * Creates a new MessageCacheItem for the DTO and stores it in cache.\n+\t *\n+\t * @param fallbackLocalesIter The fallback locale queue to use in case of failure.\n+\t *\n+\t */\n+    private MessageCacheItem createCacheItem(Iterator<Locale> fallbackLocalesIter) {\n+\t\tCacheService cacheService = new CacheService(dto);\n+\t\t// Create a new cacheItem object to be stored in cache\n+\t\tMessageCacheItem cacheItem = new MessageCacheItem();\n+\t\trefreshCacheItem(cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n+\n+\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t} else if (!dto.getLocale().equals(ConstantsKeys.SOURCE) && fallbackLocalesIter!=null && fallbackLocalesIter.hasNext()) {\n+\t\t\t// If failed to fetch message for the requetsed DTO, use MessageCacheItem of the next fallback locale.\n+\t\t\tMessagesDTO fallbackLocaleDTO = new MessagesDTO(dto.getComponent(), fallbackLocalesIter.next().toLanguageTag(), dto.getProductID(), dto.getVersion());\n+\t\t\tcacheItem = new ComponentService(fallbackLocaleDTO).getMessages(fallbackLocalesIter);\n+\t\t\tif (!cacheItem.getCachedData().isEmpty()) {\n+\t\t\t\tcacheService.addCacheOfComponent(cacheItem);\n+\t\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcyMzEyOQ=="}, "originalCommit": {"oid": "673b8fd1b44f9bc38fa3f4b366d702230dc3e1c7"}, "originalPosition": 130}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4501, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}