{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNjE2ODk0", "number": 742, "title": "add L2 cache expire logic", "bodyText": "", "createdAt": "2020-08-26T03:15:55Z", "url": "https://github.com/vmware/singleton/pull/742", "merged": true, "mergeCommit": {"oid": "b62f4389002e597d534c54748376182318772661"}, "closed": true, "closedAt": "2020-10-30T02:45:07Z", "author": {"login": "huihuiw01"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCjAyIgH2gAyNDczNjE2ODk0OjRlZGJjNGViZGUxNzE1Y2FkNjBkYzIxNzI1OWI1NDczOTFmMTVhODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVZtyYgFqTUxNTg1MzMzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/4edbc4ebde1715cad60dc217259b547391f15a81", "committedDate": "2020-08-26T03:12:37Z", "message": "add L2 cache expire logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTI3NjEy", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-475127612", "createdAt": "2020-08-26T03:36:48Z", "commit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMzozNjo0OFrOHG6lRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwNjowMzoxMVrOHG9Cjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzMxNg==", "bodyText": "Add synchronized keyword to this method, otherwise there will be a bug calculating expiration.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477013316", "createdAt": "2020-08-26T03:36:48Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDQyOQ==", "bodyText": "It seems responseTimeStamp won't be null in any case.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020429", "createdAt": "2020-08-26T04:04:34Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDY4MA==", "bodyText": "Why use two types of long?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020680", "createdAt": "2020-08-26T04:05:22Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDc3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn System.currentTimeMillis() - responseTimeStamp > maxAgeMillis;\n          \n          \n            \n            \t\treturn System.currentTimeMillis() - responseTimeStamp >= maxAgeMillis;", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477020770", "createdAt": "2020-08-26T04:05:46Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - responseTimeStamp > maxAgeMillis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNTEzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n          \n          \n            \n            \t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477025131", "createdAt": "2020-08-26T04:22:42Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ==", "bodyText": "This will never expire because it's from local.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477032085", "createdAt": "2020-08-26T04:49:55Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjkyNw==", "bodyText": "Set time stamp in service because it's common in different origins.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477032927", "createdAt": "2020-08-26T04:52:59Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzEwMA==", "bodyText": "same as above.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477033100", "createdAt": "2020-08-26T04:53:43Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) regionsData.get(PatternKeys.TERRITORIES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMzI2NA==", "bodyText": "I think this is unnecessary because this is in locale bundle.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477033264", "createdAt": "2020-08-26T04:54:24Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tif (!languagesNames.getCachedData().isEmpty()) {\n \t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n \t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n \t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n \t\t}\n-\t\treturn null;\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tcacheItem.addCachedData((Map<String, String>) regionsData.get(PatternKeys.TERRITORIES));\n+\t\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\treturn null;\n+\t}\n+\n+\tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n+\t\tCallable<LocaleCacheItem> callable = () -> {\n+\t\t\ttry {\n+\n+\t\t\t\t// Pass cacheItem to getMessages so that:\n+\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t// \t with new properties from the next HTTP response.\n+\t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n+\t\t\t\treturn cacheItem;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// To make sure that the thread will close\n+\t\t\t\t// even when an exception is thrown\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n+\t\tThread thread = new Thread(task);\n+\t\tthread.start();\n \t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0OTMxMQ==", "bodyText": "Should judge regionMap is null?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477049311", "createdAt": "2020-08-26T05:50:32Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MzU4Mw==", "bodyText": "The code is full of this kind of logic, could you think merging them?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r477053583", "createdAt": "2020-08-26T06:03:11Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/a5f740469d4fff8bb3734004e7c83c81a6dfcc86", "committedDate": "2020-08-27T14:03:25Z", "message": "fix CI reporting issue: update copyright year for new added files according to new CI checking rule"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NTg1MTMw", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-478585130", "createdAt": "2020-08-31T12:50:47Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NjUwODQ1", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-479650845", "createdAt": "2020-09-01T11:32:48Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMTozMjo0OFrOHKyK8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMjo0ODozNlrOHK0tEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA2OTgwOA==", "bodyText": "This is unnecessary because it has been save to cache at line 74.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481069808", "createdAt": "2020-09-01T11:32:48Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTExMTMxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n          \n          \n            \n            \t        \t\tif (respBody!=null && (getResponseCode(respBody) >= 200 && getResponseCode(respBody) < 300 || getResponseCode(respBody) >= 600 && getResponseCode(respBody) < 700) ){", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481111314", "createdAt": "2020-09-01T12:48:36Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTE0ODgz", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-480114883", "createdAt": "2020-09-01T21:05:18Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTowNToxOFrOHLINXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMToyMzo0OFrOHLN7ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzMDg3Nw==", "bodyText": "Do not add synchronized to this method. It will affect performance as many threads checking for expiration would have to do it one at a time.\nInstead, set all the factors that go together (etag, timestamp and maxAgeMillis, and cachedData) in only one synchronized setter method. Remove the individual setters from here. This is to prevent mismatched etag, timestamp and maxAgeMillis due to lack of thread safety.\nSince you created LocaleCacheItem and PatternCacheItem separately, then you should put the said setter method in those 2 classes.\nAdded note: I think we should remove synchronized from MessgaeCacheItem.isExpired as well.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481430877", "createdAt": "2020-09-01T21:05:18Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzMxNg=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNjA2NA==", "bodyText": "maxAgeMillis must be null if the VIP server does not send cache-control max-age. That is why this is a Long type, same as in MessageCacheItem.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481436064", "createdAt": "2020-09-01T21:15:24Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDY4MA=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MTMzMA==", "bodyText": "I agree with Xiaochao. Default value of long timestamp is 0, so if timestamp is not set, it effectively renders the cache item as expired.\nYou do not need to convert to Long responseTimestamp. You can remove lines 53-56.\nI think we should do the same for MessageCacheItem.isExpired.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481441330", "createdAt": "2020-09-01T21:26:12Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDQyOQ=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MzI2MQ==", "bodyText": "I agree, it should be >=. The prefix \"max\" in maxAgeMillis means that the value is the maximum acceptable age. This means = should return true.\nWe should do this for MessageCacheItem.isExpired too.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481443261", "createdAt": "2020-09-01T21:30:17Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n \tpublic FormatCacheItem() {\n \t\t\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n+\tpublic synchronized String getEtag() {\n+\t\treturn etag;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tpublic synchronized void setEtag(String etag) {\n+\t\tthis.etag = etag;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic synchronized long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tpublic synchronized void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n+\t}\n+\n+\tpublic synchronized Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n+\t}\n+\n+\tpublic synchronized void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n+\t}\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong responseTimeStamp = this.getTimestamp();\n+\t\tif (responseTimeStamp == null) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - responseTimeStamp > maxAgeMillis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDc3MA=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1Mjc0NQ==", "bodyText": "As I said in my comment in FormaCacheItem, you should not set the cachedData separately from the other properties (etag, timestamp and maxAgeMillis). Create a setter method here that will update all 4 of them together as a set.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481452745", "createdAt": "2020-09-01T21:52:06Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap) {\n+        super();\n+        this.addCachedData(dataMap);\n+    }\n+\n+    public final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public void addCachedData(Map<String, String> cachedData) {\n+        if (cachedData != null)\n+            this.cachedData.putAll(cachedData);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MjgzMg==", "bodyText": "As I said in my comment in FormaCacheItem, you should not set the cachedData separately from the other properties (etag, timestamp and maxAgeMillis). Create a setter method here that will update all 4 of them together as a set.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481452832", "createdAt": "2020-09-01T21:52:23Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\tpublic PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap) {\n+\t\tsuper();\n+\t\tthis.addCachedData(dataMap);\n+\t}\n+\t\n+\tpublic final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\t\n+\tpublic void addCachedData(Map<String, Object> cachedData) {\n+\t\tif (cachedData != null)\n+\t\t\tthis.cachedData.putAll(cachedData);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NjAzMg==", "bodyText": "Add isExpired in CacheItem interface", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481456032", "createdAt": "2020-09-01T21:59:58Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,62 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MDc5Mg==", "bodyText": "I think I accidentally deleted Xiaochao's comment to reuse L3 method here. This is my reply: I think it is better to separate because the 2 different VIP service URLs (L2 and L3) may have different response bodies and/or codes in the future, which we may also have to handle differently here.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481460792", "createdAt": "2020-09-01T22:11:44Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzUwNg==", "bodyText": "I want to remove the word \"base/d\" from the name of Opt classes because it does not help describe, so here is my suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class L2RemoteBaseOpt extends BaseOpt{\n          \n          \n            \n            public class RemoteL2Opt extends BaseOpt {", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481507506", "createdAt": "2020-09-02T00:38:28Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNTU3NA==", "bodyText": "Set timestamp, maxAgeMillis, etag and cachedData using 1 single synchronized setter for thread-safety. Please see my comment in FormatCacheItem. See recent changes in ComponentBasedOpt.getComponentMessages for reference.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481515574", "createdAt": "2020-09-02T00:55:33Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n+\t\t\t\t        return respBody.get(ConstantsKeys.DATA);\n+        \t\t\t}\n+\t        \t} catch (Exception e) {\n+\t        \t\tlogger.error(\"Failed to get L2 data from remote!\");\n+\t        \t}\n+\t        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjgyNw==", "bodyText": "This logic applies to L3. Does the VIP service also return either 200 or 304 successful response for all L2 service urls?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481516827", "createdAt": "2020-09-02T00:57:03Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNzUzMA==", "bodyText": "This logic applies to L3. Does this logic also apply to all L2 urls? In other words, what are the various \"business codes\" that the VIP service returns with http 200 response for each L2 url?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481517530", "createdAt": "2020-09-02T00:59:49Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/L2RemoteBaseOpt.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.server;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n+import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class L2RemoteBaseOpt extends BaseOpt{\n+    private final Logger      logger = LoggerFactory.getLogger(L2RemoteBaseOpt.class.getName());\n+\n+\n+    public L2RemoteBaseOpt() {\n+\n+    }\n+\n+    public Object getDataFromResponse(String url, String method, Object requestData, FormatCacheItem cacheItem) {\n+        Map<String, String> headers = new HashMap<String, String>();\n+        if (cacheItem.getEtag() != null)\n+        \theaders.put(URLUtils.IF_NONE_MATCH_HEADER, cacheItem.getEtag());\n+        \n+        Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n+        \t\t.request(url, method, requestData, headers);\n+        \n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+        \n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) || \n+        \t\tresponseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+        \t\n+        \tif (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+\t        \tcacheItem.setTimestamp((long) response.get(URLUtils.RESPONSE_TIMESTAMP) );\n+        \tif (response.get(URLUtils.HEADERS) != null)\n+\t        \tcacheItem.setEtag(URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS)));\n+\t        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+\t        \tcacheItem.setMaxAgeMillis((Long) response.get(URLUtils.MAX_AGE_MILLIS));\n+\t\t\t      \n+\t        if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+\t\t\t\ttry {\n+\t\t\t\t\tString responseStr = (String) response.get(URLUtils.BODY);\n+\t\t\t\t\tif (null == responseStr || responseStr.equals(\"\"))\n+\t\t\t\t\t\treturn null;\n+\t\t        \tJSONObject respBody = (JSONObject) JSONValue.parse(responseStr);\n+\t        \t\tif (respBody!=null && getResponseCode(respBody) == 200){\n+\t\t\t\t        return respBody.get(ConstantsKeys.DATA);\n+        \t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMTk4OQ==", "bodyText": "Set timestamp, maxAgeMillis, etag and cachedData using 1 single synchronized setter for thread-safety. Please see my comment in FormatCacheItem. See recent changes in ComponentBasedOpt.getComponentMessages for reference.\nSuggestion: Because you have 2 child classes RemoteLocaleOpt and RemotePatternOpt, call the new synchronized setter method that sets all 4 (timestamp, maxAgeMillis, etag and cachedData) in these child classes. Do not pass the original cacheItem object to getDataFromResponse anymore. Instead, inside getDataFromResponse, just return a map that holds the timestamp, etag, maxAgeMillis and responseBody object from the response from the service. Then in here (the child class), use the values in the  map to populate the original cacheItem object using the single synchronized setter method I mentioned above.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481521989", "createdAt": "2020-09-02T01:17:27Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+                if (territories != null) {\n+                    cacheItem.addCachedData(territories);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMjI5NA==", "bodyText": "See my comment in RemoteLocaleOpt.java line 40", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481522294", "createdAt": "2020-09-02T01:18:47Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +27,49 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            List<Map<String, Object>> dataNode = (List<Map<String, Object>>) getDataFromResponse(\n+                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode != null && !dataNode.isEmpty()) {\n+                Map<String, Object> regionMap = dataNode.get(0);\n+                Map<String, String> territories = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+                if (territories != null) {\n+                    cacheItem.addCachedData(territories);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> dataNode = (Map<String, Object>) getDataFromResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n+                        ConstantsKeys.GET, null, cacheItem);\n+            if (dataNode == null || dataNode.isEmpty()) {\n+                return;\n             }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+            List<Map<String, String>> languagesArray = (List<Map<String, String>>) dataNode.get(ConstantsKeys.LANGUAGES);\n+            if (languagesArray != null && !languagesArray.isEmpty()) {\n+                Map<String, String> dispMap = new HashMap<String, String>();\n+                for (int i = 0; i < languagesArray.size(); i++) {\n+                    Map<String, String> languageNode = languagesArray.get(i);\n+                    dispMap.put(languageNode.get(ConstantsKeys.LANGUAGE_TAG),\n+                            languageNode.get(ConstantsKeys.DISPLAY_NAME));\n                 }\n+                cacheItem.addCachedData(dispMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyMjM3MQ==", "bodyText": "See my comment in RemoteLocaleOpt.java line 40", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481522371", "createdAt": "2020-09-02T01:19:02Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,54 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+        Map<String, Object> data = (Map<String, Object>) getDataFromResponse(url, method, requestData, cacheItem);\n+        if (null != data && !data.isEmpty()) {\n+            Map<String, Object> categoriesData = this.getCategoriesFromData(data);\n+            if (categoriesData != null) {\n+                cacheItem.addCachedData(categoriesData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNDI4Mg==", "bodyText": "Remove addCachedData setter method. Set cachedData together with the other properties in a single synchronized setter method. See my comment in RemoteLocaleOpt.java line 40\nDo this sorting inside that setter, right before setting the cacheItem's cachedData.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481524282", "createdAt": "2020-09-02T01:23:20Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -20,56 +20,58 @@ public FormattingCacheService() {\n \n     }\n \n-    public void addPatterns(String locale, JSONObject o) {\n+    public void addPatterns(String locale, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addPatterns(String language, String region, JSONObject o) {\n+    public void addPatterns(String language, String region, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(language, region);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addSupportedLanguages(BaseDTO dto, String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUyNDU4MA==", "bodyText": "See comment in lines 34-35", "url": "https://github.com/vmware/singleton/pull/742#discussion_r481524580", "createdAt": "2020-09-02T01:23:48Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -20,56 +20,58 @@ public FormattingCacheService() {\n \n     }\n \n-    public void addPatterns(String locale, JSONObject o) {\n+    public void addPatterns(String locale, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addPatterns(String language, String region, JSONObject o) {\n+    public void addPatterns(String language, String region, PatternCacheItem o) {\n         String cacheKey = getPatternsCacheKey(language, region);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addSupportedLanguages(BaseDTO dto, String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);\n         String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addLanguagesNames(String locale, Map<String, String> o) {\n+    public void addLanguagesNames(String locale, LocaleCacheItem o) {\n         String cacheKey = getLanguagesNamesCacheKey(locale);\n         addFormattings(cacheKey, o);\n     }\n \n-    public void addRegions(String locale, Map<String, String> o) {\n-        o = JSONUtils.map2SortMap(o);\n+    public void addRegions(String locale, LocaleCacheItem o) {\n+        Map<String, String> map = JSONUtils.map2SortMap(o.getCachedData());\n+        o.addCachedData(map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwOTcxMjE1", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-480971215", "createdAt": "2020-09-02T15:59:44Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo1OTo0NFrOHL2PpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo0MjozMFrOHL35bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4NTEyNQ==", "bodyText": "This is erroneous for 2 reasons:\n\n\nThe cacheItem retrieved in line 63 may be that of a fallback locale, and not of the locale passed to getRegionsByLocale. In other words, fallback locale is previously mapped to the requested locale in line 49. If this is the case, populateRegionsCache in line 67, which calls getRegionsFromDS, will mistakenly populate the properties of fallback locale's cacheItem with data of the requested locale.\n\n\nMultiple locales may be using the cacheItem retrieved in line 63 as fallback. Any one of those locales can trigger populateRegionsCache. When this happens, all the other locales that are using this cacheItem will not enter the if block in line 65 and will just return the fallback locale's cacheItem in line 70. However, we want each requested locale to try and fetch its own data after some time. This means we want each of those locales to have its own timestamp, so that it will expire on its own. When it expires, it should try to fetch for its own data from data store.\n\n\nFor both #1 and #2, this is what I did:\nAdd a property in cacheItem called \"locale\" to describe what was actually cached. This will be the same as the requested locale if the requested locale was retrieved from DS. Otherwise, this will be the fallback locale (locale of the fallback cacheItem).\nFor #1, when refreshing expired cacheItem in populateRegionsCache, read the cacheItem.locale to see what the actual locale to be retrieved from data store. See ComponentService.refreshCacheItemTask for reference.\nFor #2, this is what I recently did in ComponentService :\nIf the requested locale is not available, the cacheItem to be stored will have the following properties (ComponentService line 146):\n\nlocale = fallback locale\netag = null;\nmaxAgeMillis = maxAgeMillis of the fallback locale's cacheItem\ncachedData = null (indicates that the fallback locale's cacheItem must be used)\ntimestamp = System.currentTimeMillis()\n\nWhen retrieving data from cache and you find that the cachedData is empty, retrieve and return the cacheItem of the fallback locale (cacheItem.locale) instead. See ComponentService lines 105-116", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482185125", "createdAt": "2020-09-02T15:59:44Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMDk0Ng==", "bodyText": "For locales that are not found in cache, we need to immediately return fallback locale's cacheItem first and do line 72-77 in a separate thread. Reason:\nFor some product applications, this slowness at the very first uncached request is not acceptable. So we give the option to initialize cache at application start up by setting initializeCache config to true. This will populate the cache for all supported locales. However, cache will not be populated for non-supported locales. Hence, for the very first uncached request for any locale (supported or not), we want to return the fallback locale's cacheItem, assuming that at the very least, the fallback locale's cacheItem is in cache.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482210946", "createdAt": "2020-09-02T16:40:26Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n+            formattingCacheService.addRegions(locale, cacheItem);\n             logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMjIwNg==", "bodyText": "See my comments for regions. They should apply to display names too.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482212206", "createdAt": "2020-09-02T16:42:30Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,177 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addRegions(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n+            formattingCacheService.addRegions(locale, cacheItem);\n             logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n         }\n-        return regionMap;\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n                         fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n             logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n         }\n-        return dispMap;\n+        return cacheItem;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private void getSupportedLanguagesFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);\n-            return dispMap;\n+            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString());\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getSupportedLanguages(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getSupportedLanguagesFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return dispMap;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDcyNjYx", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-481472661", "createdAt": "2020-09-03T03:50:17Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo1MDoxN1rOHMU3CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwMzo1MToyN1rOHMU4Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjcyOA==", "bodyText": "First get from service, then get from local. In this way, local L2 doesn't depend on local L3.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482686728", "createdAt": "2020-09-03T03:50:17Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzAyMw==", "bodyText": "Remove unused BUNDLE_PREFIX and BUNDLE_SUFFIX", "url": "https://github.com/vmware/singleton/pull/742#discussion_r482687023", "createdAt": "2020-09-03T03:51:27Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -7,19 +7,21 @@\n import com.vmware.i18n.PatternUtil;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Mjk5NTQy", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-484299542", "createdAt": "2020-09-08T16:17:45Z", "commit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjoxNzo0NVrOHOkqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjo1NjoxOFrOHOmC4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MjgwNQ==", "bodyText": "@Xiaochao8 , in line 74, the fallback locale's cache item was mapped to the fallback locale itself. In here, she is mapping the same fallback locale's cacheItem to the requested locale.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485042805", "createdAt": "2020-09-08T16:17:45Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA2OTgwOA=="}, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NDQwNA==", "bodyText": "This is erroneous. Same comment as in LocaleService.getRegionsByLocale", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485044404", "createdAt": "2020-09-08T16:20:22Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Njk3NA==", "bodyText": "Why do we need this method if we already have getPatterns(String locale, PatternCacheItem cacheItem) in line 23? I find that the 2 VIP service URLs are redundant. We can derive the 'language' and 'region' from the 'locale' and vice versa, correct?\nI suggest we only keep getPatterns(String locale, PatternCacheItem cacheItem). Compose/normalize the locale from language and region in PatternService.java. This locale is the used for the service URL's GET /i18n/api/v2/formatting/patterns/locales/{locale} so verify that this URL gives the exact same response as the service's GET /i18n/api/v2/formatting/patterns.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485056974", "createdAt": "2020-09-08T16:41:29Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,54 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NzMzNA==", "bodyText": "Why do we need this method if we already have getPatterns(String locale, PatternCacheItem cacheItem) in line 25? See my comment in RemotePatternOpt.java line 30", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485057334", "createdAt": "2020-09-08T16:42:08Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,35 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NzkyNw==", "bodyText": "Local should expire also to give a chance to try to fetch from service once it expires.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485057927", "createdAt": "2020-09-08T16:43:12Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2Mzg1OQ==", "bodyText": "We do not need getPatternByLanguageRegion. Just normalize/compose the locale here from the language and region, and then call getPatterns(String locale). See my comment in RemotePatternOpt.java line 30.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485063859", "createdAt": "2020-09-08T16:53:35Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDE1OA==", "bodyText": "We do not need this method. See comment above (lines 81-98)", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064158", "createdAt": "2020-09-08T16:54:07Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDQ3OA==", "bodyText": "We do not need this method. See comment above (lines 81-98)", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064478", "createdAt": "2020-09-08T16:54:41Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(language, region, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            formattingCacheService.addPatterns(language, region, patterns);\n+            formattingCacheService.addPatterns(language, region, cacheItem);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n-    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String locale, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(locale);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED, locale, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(locale, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL, locale));\n+            }\n         }\n-        return patterns;\n     }\n \n-    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String language, String region, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDc5NA==", "bodyText": "We do not need this method. See comment above (lines 81-98)", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485064794", "createdAt": "2020-09-08T16:55:16Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(language, region, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (!cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n             // and\n-            formattingCacheService.addPatterns(language, region, patterns);\n+            formattingCacheService.addPatterns(language, region, cacheItem);\n             logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n-    private JSONObject getPatternsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String locale, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(locale);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED, locale, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(locale, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL, locale));\n+            }\n         }\n-        return patterns;\n     }\n \n-    private JSONObject getPatternsFromDS(String language, String region, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        JSONObject patterns = null;\n+    private void getPatternsFromDS(String language, String region, PatternCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext())\n-            return patterns;\n+            return;\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        patterns = dataSource.createPatternOpt().getPatterns(language, region);\n-        if (patterns == null || patterns.isEmpty()) {\n-            patterns = getPatternsFromDS(language, region, msgSourceQueueIter);\n+        dataSource.createPatternOpt().getPatterns(language, region, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_1, language, region, dataSource.toString()));\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            if (msgSourceQueueIter.hasNext()) {\n+                getPatternsFromDS(language, region, cacheItem, msgSourceQueueIter);\n+            }else{\n+                logger.debug(FormatUtils.format(ConstantsMsg.GET_PATTERNS_FAILED_ALL_1, language, region));\n+            }\n         }\n-        return patterns;\n+    }\n+\n+    private void populateCacheTask(String locale, PatternCacheItem cacheItem) {\n+        Callable<PatternCacheItem> callable = () -> {\n+            try {\n+\n+                // Pass cacheItem to getMessages so that:\n+                // 1. A previously stored etag, if any, can be used for the next HTTP request.\n+                // 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+                // \t with new properties from the next HTTP response.\n+                getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+                return cacheItem;\n+            } catch (Exception e) {\n+                // To make sure that the thread will close\n+                // even when an exception is thrown\n+                return null;\n+            }\n+        };\n+        FutureTask<PatternCacheItem> task = new FutureTask<PatternCacheItem>(callable);\n+        Thread thread = new Thread(task);\n+        thread.start();\n+    }\n+\n+    private void populateCacheTask(String language, String region, PatternCacheItem cacheItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NTQ0MQ==", "bodyText": "This is erroneous. Same comment as in LocaleService.getRegionsByLocale", "url": "https://github.com/vmware/singleton/pull/742#discussion_r485065441", "createdAt": "2020-09-08T16:56:18Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,183 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(locale, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\");\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(locale);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(locale);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(locale, cacheItem);\n+            }\n             logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n-            return patterns;\n+            return cacheItem;\n         }\n-        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (patterns != null) {\n+        cacheItem = new PatternCacheItem();\n+        getPatternsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (cacheItem.getCachedData() != null && !cacheItem.getCachedData().isEmpty()) {\n             logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n-            formattingCacheService.addPatterns(locale, patterns);\n+            formattingCacheService.addPatterns(locale, cacheItem);\n             logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n-            return patterns;\n         }\n-        return null;\n+        return cacheItem;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n-        JSONObject patterns = getPatternsByLanguageRegion(language, region);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLanguageRegion(language, region);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(new Locale(language, region).toLanguageTag()))\n                 continue;\n             logger.info(\"Can't find pattern for language [{}] region [{}], look for fallback locale [{}] pattern as fallback!\", language, region, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(language, region, patterns);\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                new FormattingCacheService().addPatterns(language, region, cacheItem);\n                 logger.debug(\"Fallback locale [{}] pattern is cached for language [{}], region [{}]!\\n\\n\", fallbackLocale, language, region);\n-                return patterns;\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLanguageRegion(String language, String region) {\n+    public PatternCacheItem getPatternsByLanguageRegion(String language, String region) {\n         language = language.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+        PatternCacheItem cacheItem = null;\n         logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        patterns = (JSONObject) formattingCacheService.getPatterns(language, region);// key\n-        if (patterns != null) {\n+        cacheItem = formattingCacheService.getPatterns(language, region);// key\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateCacheTask(language, region, cacheItem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cd329d43a74dc04e36131c4c39cf89442102c32", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/2cd329d43a74dc04e36131c4c39cf89442102c32", "committedDate": "2020-09-21T06:51:13Z", "message": "fix review comment: set all the cache expiration related variables in one synchronized method to make them matched"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5f4b8ae7e481447096da4bfad880caa991c0cba", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/b5f4b8ae7e481447096da4bfad880caa991c0cba", "committedDate": "2020-09-18T06:43:44Z", "message": "fix review comment: set all the cache expiration related variables in one synchronized method to make them matched"}, "afterCommit": {"oid": "2cd329d43a74dc04e36131c4c39cf89442102c32", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/2cd329d43a74dc04e36131c4c39cf89442102c32", "committedDate": "2020-09-21T06:51:13Z", "message": "fix review comment: set all the cache expiration related variables in one synchronized method to make them matched"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c", "committedDate": "2020-09-23T16:04:34Z", "message": "fix review comments:\n1. mistakenly populate fallback locale's cacheItem with request locale's cacheItem\n2. CacheItem of locales that fallback at first fetch can't be updated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDU3OTg4", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-495057988", "createdAt": "2020-09-23T21:21:37Z", "commit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMToyMTozN1rOHXBbgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMTo1NjoxMlrOHXCYLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMjcyMQ==", "bodyText": "Remove all setter methods from FormatCacheItem so that only the synchronized set methods in LocaleCacheItem and PatternCacheItem will be used.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493902721", "createdAt": "2020-09-23T21:21:37Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTE3NQ==", "bodyText": "Let's remove this setter and only use the other synchronized setter methods. This is to avoid retrieving CacheItem from cache and then modifying CacheItem properties individually. I am planning to remove this from MessageCacheItem as well.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493905175", "createdAt": "2020-09-23T21:26:55Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+        this.set(dataMap, etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(LocaleCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNjQwMw==", "bodyText": "Please remove this. We want to use only the synchronized setter methods with multiple parameters so that the dataMap, timestamp, eTag and maxAgeMillis are updated as a set in a single thread. We want to avoid mismatched dataMap, etag, timestamp and/or maxAgeMillis due to conflicting threads.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493906403", "createdAt": "2020-09-23T21:29:37Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();\n+\n+    public LocaleCacheItem() {\n+\n+    }\n+\n+    public LocaleCacheItem (Map<String, String> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+        this.set(dataMap, etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, String> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(LocaleCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }\n+\n+    public synchronized void set(long timestamp) {\n+        setTimestamp(timestamp);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNzE5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tLong maxAgeResponse = this.getMaxAgeMillis();\n          \n          \n            \n            \t\tif (maxAgeResponse != null) {\n          \n          \n            \n            \t\t\tmaxAgeMillis = maxAgeResponse;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (maxAgeMillis == null) \n          \n          \n            \n            \t\t\treturn false;", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493917190", "createdAt": "2020-09-23T21:54:13Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODE4OQ==", "bodyText": "Same comment as above: \"Please remove this. We want to use only the synchronized setter methods with multiple parameters so that the dataMap, timestamp, eTag and maxAgeMillis are updated as a set in a single thread. We want to avoid mismatched dataMap, etag, timestamp and/or maxAgeMillis due to conflicting threads.\"", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493918189", "createdAt": "2020-09-23T21:56:01Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\n+    public PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.set(dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+    public synchronized void set(Map<String, Object> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, Object> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(PatternCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }\n+\n+    public synchronized void set(long timestamp) {\n+        setTimestamp(timestamp);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxODI1Mw==", "bodyText": "Same comment as above: \"Let's remove this setter and only use the other synchronized setter methods. This is to avoid retrieving CacheItem from cache and then modifying CacheItem properties individually. I am planning to remove this from MessageCacheItem as well.\"", "url": "https://github.com/vmware/singleton/pull/742#discussion_r493918253", "createdAt": "2020-09-23T21:56:12Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/PatternCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class PatternCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, Object> cachedData = new HashMap<String, Object>();\n+\n+    public PatternCacheItem() {\n+\n+\t}\n+\n+\tpublic PatternCacheItem(Map<String, Object> dataMap, String etag, long timestamp, Long maxAgeMillis) {\n+\t\tthis.set(dataMap, etag, timestamp, maxAgeMillis);\n+\t}\n+\n+    public synchronized void set(Map<String, Object> dataMap, long timestamp) {\n+        this.set(dataMap, null, timestamp, null);\n+    }\n+\n+    public synchronized void set(Map<String, Object> dataToCache, String etag, long timestamp, Long maxAgeMillis) {\n+        if (dataToCache != null)\n+            this.cachedData.putAll(dataToCache);\n+        this.set(etag, timestamp, maxAgeMillis);\n+    }\n+\n+    public synchronized void set(String etag, long timestamp, Long maxAgeMillis) {\n+        if (etag != null && !etag.isEmpty())\n+            setEtag(etag);\n+        setTimestamp(timestamp);\n+        if (maxAgeMillis != null)\n+            setMaxAgeMillis(maxAgeMillis);\n+    }\n+\n+    public synchronized void set(PatternCacheItem cacheItem) {\n+        this.set(cacheItem.getCachedData(), cacheItem.getEtag(), cacheItem.getTimestamp(), cacheItem.getMaxAgeMillis());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTc4NDA4", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-495178408", "createdAt": "2020-09-24T02:31:56Z", "commit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e59d2a75f4bce4122ffaad1a53c68095a13205b", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/3e59d2a75f4bce4122ffaad1a53c68095a13205b", "committedDate": "2020-09-24T03:53:15Z", "message": "fix some minor comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTgyMDQw", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-495182040", "createdAt": "2020-09-24T02:44:51Z", "commit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMjo0NDo1MVrOHXHvwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNDowNjowN1rOHXI8Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwNjIxMA==", "bodyText": "Suggest moving this to parent class CacheItem because they are common.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494006210", "createdAt": "2020-09-24T02:44:51Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAwOTg1OQ==", "bodyText": "It seems these lines do nothing because it assigns maxAgeMillis to itself.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494009859", "createdAt": "2020-09-24T02:59:55Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ==", "bodyText": "Put these lines into a synchronized block to make sure maxAgeMillis and timeStamp are matched.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494010181", "createdAt": "2020-09-24T03:01:13Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - this.getTimestamp() >= maxAgeMillis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMzQyOA==", "bodyText": "Suggest to move this into CacheItem because it's common, change the type to Object.\nThen all the logic about expiration can move into CacheItem.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494013428", "createdAt": "2020-09-24T03:15:10Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/LocaleCacheItem.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2019-2020 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.base.cache;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class LocaleCacheItem extends FormatCacheItem implements CacheItem {\n+\n+    private final Map<String, String> cachedData = new HashMap<String, String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNDYzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n            \t\t\tlogger.debug(\"Didn't find supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494014637", "createdAt": "2020-09-24T03:20:15Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNzY4OQ==", "bodyText": "Can remove all these from code? There are 6 in total.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494017689", "createdAt": "2020-09-24T03:33:15Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyMzIzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n          \n          \n            \n            \t\tCallable<LocaleCacheItem> callable = () -> {\n          \n          \n            \n            \t\t\ttry {\n          \n          \n            \n            \n          \n          \n            \n            \t\t\t\t// Pass cacheItem to getMessages so that:\n          \n          \n            \n            \t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n          \n          \n            \n            \t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n          \n          \n            \n            \t\t\t\t// \t with new properties from the next HTTP response.\n          \n          \n            \n            \t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n          \n          \n            \n            \t\t\t\treturn cacheItem;\n          \n          \n            \n            \t\t\t} catch (Exception e) {\n          \n          \n            \n            \t\t\t\t// To make sure that the thread will close\n          \n          \n            \n            \t\t\t\t// even when an exception is thrown\n          \n          \n            \n            \t\t\t\treturn null;\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t};\n          \n          \n            \n            \t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n          \n          \n            \n            \t\tThread thread = new Thread(task);\n          \n          \n            \n            \t\tthread.start();\n          \n          \n            \n            \t}\n          \n          \n            \n            \tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n          \n          \n            \n            \t\tRunnable runnable = () -> {\n          \n          \n            \n            \t\t\ttry {\n          \n          \n            \n            \t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n          \n          \n            \n            \t\t\t} catch (Exception e) {\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t};\n          \n          \n            \n            \t\tnew Thread(runnable).start();\n          \n          \n            \n            \t}", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494023238", "createdAt": "2020-09-24T03:56:16Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t\t}\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\treturn null;\n+\t}\n+\n+\tprivate void populateLanguagesCache(String locale, LocaleCacheItem cacheItem) {\n+\t\tCallable<LocaleCacheItem> callable = () -> {\n+\t\t\ttry {\n+\n+\t\t\t\t// Pass cacheItem to getMessages so that:\n+\t\t\t\t// 1. A previously stored etag, if any, can be used for the next HTTP request.\n+\t\t\t\t// 2. CacheItem properties such as etag, timestamp and maxAgeMillis can be refreshed\n+\t\t\t\t// \t with new properties from the next HTTP response.\n+\t\t\t\tgetLanguagesNamesFromBundle(locale, cacheItem);\n+\t\t\t\treturn cacheItem;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// To make sure that the thread will close\n+\t\t\t\t// even when an exception is thrown\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\tFutureTask<LocaleCacheItem> task = new FutureTask<LocaleCacheItem>(callable);\n+\t\tThread thread = new Thread(task);\n+\t\tthread.start();\n \t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNDU0NA==", "bodyText": "Remove all these comments, they are for translations.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494024544", "createdAt": "2020-09-24T04:01:15Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n+        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+        return cacheItem;\n     }\n \n \n-    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    private void getSupportedLanguagesFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);\n-            return dispMap;\n+            logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString());\n-            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getSupportedLanguages(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getSupportedLanguagesFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return dispMap;\n+    }\n+\n+    private void populateRegionsCache(String locale, LocaleCacheItem cacheItem) {\n+        Callable<LocaleCacheItem> callable = () -> {\n+            try {\n+\n+                // Pass cacheItem to getMessages so that:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNTc3MQ==", "bodyText": "May you call BaseOpt.getMessagesFromResponse to get the data?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494025771", "createdAt": "2020-09-24T04:06:07Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Failed to get pattern data from remote!\");\n+                }\n+            }else{\n+                logger.debug(\"There is no update on Singleton Service for the pattern of locale [{}].\\n\", locale);\n+                cacheItem.set(etag, timestamp, maxAgeMillis);\n             }\n-            return msgObject;\n         }\n     }\n \n-    private Object getCategoriesFromResponse(String responseStr, String node) {\n-        Object msgObject = null;\n-        try {\n-            JSONObject responseObj = (JSONObject) JSONValue.parseWithException(responseStr);\n-            if (responseObj != null) {\n-                Object dataObj = responseObj.get(ConstantsKeys.DATA);\n-                if (dataObj != null && dataObj instanceof JSONObject) {\n-                    msgObject = ((JSONObject) dataObj).get(node);\n-                }\n+    private Map<String, Object> getPatternsFromResponse(String responseBody) {\n+        Map<String, Object> categoriesObj = null;\n+        Map<String, Object> dataObj = (Map<String, Object>) getDataFromResponse(responseBody);\n+        if (dataObj != null && dataObj instanceof JSONObject) {\n+            Object obj = dataObj.get(PatternKeys.CATEGORIES);\n+            if (obj != null && obj instanceof JSONObject) {\n+                categoriesObj = (Map<String, Object>) obj;\n             }\n-        } catch (ParseException e) {\n-            // TODO Auto-generated catch block\n-            logger.error(e.getMessage());\n         }\n-        return msgObject;\n+        return categoriesObj;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/98e09fa956d7acfcedb65b34247965107188c808", "committedDate": "2020-09-24T04:18:55Z", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_L2CacheExpire"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzMzMjcz", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-495733273", "createdAt": "2020-09-24T16:10:12Z", "commit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "state": "COMMENTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjoxMDoxMlrOHXiTZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMToxNjoxM1rOHXxsuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0MTMxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long timestamp = 0;\n          \n          \n            \n                            String etag = null;\n          \n          \n            \n                            Long maxAgeMillis = null;\n          \n          \n            \n                            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                            if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                          long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                          String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494441317", "createdAt": "2020-09-24T16:10:12Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0Njc0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long timestamp = 0;\n          \n          \n            \n                            String etag = null;\n          \n          \n            \n                            Long maxAgeMillis = null;\n          \n          \n            \n                            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                            if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                          long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                          String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494446742", "createdAt": "2020-09-24T16:18:41Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0NzExOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                        logger.debug(\"Found the regions from Singleton Service for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494447118", "createdAt": "2020-09-24T16:19:14Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0NzQ0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                        logger.debug(\"Didn't find the regions from Singleton Service for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494447444", "createdAt": "2020-09-24T16:19:45Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                        \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494448357", "createdAt": "2020-09-24T16:21:08Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTMzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                                        logger.debug(\"Found the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449330", "createdAt": "2020-09-24T16:22:39Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTQzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                                        logger.debug(\"Didn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449435", "createdAt": "2020-09-24T16:22:51Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            languages = JSONUtils.map2SortMap(languages);\n+                            cacheItem.set(languages, etag, timestamp, maxAgeMillis);\n+                        }else{\n+                            logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                       \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494449661", "createdAt": "2020-09-24T16:23:15Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            languages = JSONUtils.map2SortMap(languages);\n+                            cacheItem.set(languages, etag, timestamp, maxAgeMillis);\n+                        }else{\n+                            logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU4ODE1NA==", "bodyText": "Let's discuss this after this PR. We need to revisit the design workflow for L2.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494588154", "createdAt": "2020-09-24T20:22:14Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,54 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Njk3NA=="}, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MDEzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        long timestamp = 0;\n          \n          \n            \n                        String etag = null;\n          \n          \n            \n                        Long maxAgeMillis = null;\n          \n          \n            \n            \n          \n          \n            \n                        if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n          \n          \n            \n                            timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                        if (response.get(URLUtils.HEADERS) != null)\n          \n          \n            \n                            etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                        if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n          \n          \n            \n                            maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n          \n          \n            \n                        long timestamp = response.get(URLUtils.RESPONSE_TIMESTAMP) == null ?\n          \n          \n            \n                                System.currentTimeMillis() : (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n          \n          \n            \n                         String etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n          \n          \n            \n                          Long maxAgeMillis = response.get(URLUtils.MAX_AGE_MILLIS) == null ? null : (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494590132", "createdAt": "2020-09-24T20:26:11Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTM2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                    logger.debug(\"Found the pattern from Singleton Service for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591361", "createdAt": "2020-09-24T20:28:31Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTQzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n          \n          \n            \n                                    logger.debug(\"Didn't find the pattern from Singleton Service for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591433", "createdAt": "2020-09-24T20:28:41Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    cacheItem.set(etag, timestamp, maxAgeMillis);\n          \n          \n            \n                                   \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem in any case of failure of fetch from service.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494591530", "createdAt": "2020-09-24T20:28:52Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NTc0Mg==", "bodyText": "In reply to Xiaochao's comment: I actually do not think we should put any parsing in BaseOpt. Each API will have a different json content, and therefore, must be parsed differently. Like here, Huihui is getting PatternKeys.CATEGORIES. In RemoteL2BaseOpt.getDataFromResponse, she is parsing the business code (although not handling anything other than 200. We can improve this in the future).\nThat being said, I do not understand the design pattern of having a BaseOpt.java with methods that are for very specific, not related cases. We should revisit and clean this up in the future.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494595742", "createdAt": "2020-09-24T20:36:49Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends L2RemoteBaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Failed to get pattern data from remote!\");\n+                }\n+            }else{\n+                logger.debug(\"There is no update on Singleton Service for the pattern of locale [{}].\\n\", locale);\n+                cacheItem.set(etag, timestamp, maxAgeMillis);\n             }\n-            return msgObject;\n         }\n     }\n \n-    private Object getCategoriesFromResponse(String responseStr, String node) {\n-        Object msgObject = null;\n-        try {\n-            JSONObject responseObj = (JSONObject) JSONValue.parseWithException(responseStr);\n-            if (responseObj != null) {\n-                Object dataObj = responseObj.get(ConstantsKeys.DATA);\n-                if (dataObj != null && dataObj instanceof JSONObject) {\n-                    msgObject = ((JSONObject) dataObj).get(node);\n-                }\n+    private Map<String, Object> getPatternsFromResponse(String responseBody) {\n+        Map<String, Object> categoriesObj = null;\n+        Map<String, Object> dataObj = (Map<String, Object>) getDataFromResponse(responseBody);\n+        if (dataObj != null && dataObj instanceof JSONObject) {\n+            Object obj = dataObj.get(PatternKeys.CATEGORIES);\n+            if (obj != null && obj instanceof JSONObject) {\n+                categoriesObj = (Map<String, Object>) obj;\n             }\n-        } catch (ParseException e) {\n-            // TODO Auto-generated catch block\n-            logger.error(e.getMessage());\n         }\n-        return msgObject;\n+        return categoriesObj;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNTc3MQ=="}, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDU4OA==", "bodyText": "In reply to Xiaochao's comment:  Yes, in LocaleService,  it will only use LocalLocaleOpt.getSupportedLanguages if RemoteLocaleOpt.getSupportedLanguages failed", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494614588", "createdAt": "2020-09-24T21:14:52Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NjcyOA=="}, "originalCommit": {"oid": "a5f740469d4fff8bb3734004e7c83c81a6dfcc86"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMTcxNw==", "bodyText": "In reply to Xiaochao's comment: Please log as a separate \"issue\" (or just directly create a separate PR if you have the time now) in GitHub.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494621717", "createdAt": "2020-09-24T21:30:13Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +40,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxNzY4OQ=="}, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMTE5MQ==", "bodyText": "After reviewing again, will the information in cache ever be updated either from service or from local?\n\nIt looks like formattingCacehService.addLanguageNames is only used for local data. If this is the case, then the cached data will never be refreshed from service.\nThe local data in jar is included at compile time. This means that there will never be any updated jar file unless application is restarted correct?\n\nIf the above 2 points are true, then we do not need an expire logic here...no need to check isExpired,  and no need for populateLanguagesCache, correct?\nDo we actually need to put this data in cache at all? I know that the content is a map of language tags and display names that is specific to a requested display language. The data is used for LocaleService.getSupportedDisplayNamesByLocale, which is already caching the supported languages and names per requested display language. I think the caching in  LocaleService.getSupportedDisplayNamesByLocale is enough so that no call to LocalLocaleOpt.getLanguagesNamesFromCLDR will be called for the same display language more than once. Hence, no need for caching in LocalLocaleOpt.\nAs a result, you may remove associated code:\n\nFormattingCacheItem.addLanguagesNames\nFormattingCacheItem.getLanguagesNames\nFormattingCacheItem.getLanguagesNamesCacheKey\nConstantsKeys.LANGUAGES_PREFIX", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494631191", "createdAt": "2020-09-24T21:51:53Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMTcyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n          \n          \n            \n            \t\t\tlogger.debug(\"Found languages' names from cache for locale [{}]!\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494631724", "createdAt": "2020-09-24T21:53:06Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMjcxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\t\tlogger.debug(\"Didn't find the regions from local bundle for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494632711", "createdAt": "2020-09-24T21:55:23Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzA3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to change anything in the cache item if fetch from bundle failed.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633073", "createdAt": "2020-09-24T21:56:15Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-        return null;\n \t}\n \n-\tpublic JSONObject getRegions(String locale) {\n+\tpublic void getRegions(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n-            return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> regionsData = (Map<String, Object>) new JSONParser().parse(regionsJsonStr);\n+\t\t\tif (regionsData != null) {\n+\t\t\t\tMap<String, String> territories = (Map<String, String>) regionsData.get(PatternKeys.TERRITORIES);\n+\t\t\t\tif(territories != null) {\n+\t\t\t\t\tlogger.debug(\"Find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tterritories = JSONUtils.map2SortMap(territories);\n+\t\t\t\t\tcacheItem.set(territories, System.currentTimeMillis());\n+\t\t\t\t}else{\n+\t\t\t\t\tlogger.debug(\"Doesn't find the regions from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\t\tcacheItem.set(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzIwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\tlogger.debug(\"Didn't find the languages' names from local bundle for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633209", "createdAt": "2020-09-24T21:56:39Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzI5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to change anything in the cache item if fetch from bundle failed.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633299", "createdAt": "2020-09-24T21:56:49Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set((Map<String, String>) languagesData.get(PatternKeys.LANGUAGES), System.currentTimeMillis());\n+\t\t\t}else{\n+\t\t\t\tlogger.debug(\"Doesn't find the languages' names from local bundle for locale [{}].\\n\", locale);\n+\t\t\t\tcacheItem.set(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMzM3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);\n          \n          \n            \n            \t\t\t\tlogger.debug(\"Found the languages' names from local bundle for locale [{}].\\n\", locale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494633378", "createdAt": "2020-09-24T21:57:01Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n-\t\t\treturn null;\n-        try {\n-            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\t\tJSONObject languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t\treturn;\n+\t\ttry {\n+\t\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\t\tMap<String, Object> languagesData = (Map<String, Object>) new JSONParser().parse(languagesJsonStr);\n+\t\t\tif (languagesData != null) {\n+\t\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNDYyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tcacheItem.set(System.currentTimeMillis());\n          \n          \n            \n            \t\t\t\n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cacheItem if fetch failed.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494634625", "createdAt": "2020-09-24T21:59:54Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzM3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n          \n          \n            \n                            logger.debug(\"Didn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693373", "createdAt": "2020-09-25T01:15:28Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set((Map<String, Object>) patterns.get(PatternKeys.CATEGORIES), System.currentTimeMillis());\n+            }else{\n+                logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzQwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n          \n          \n            \n                            logger.debug(\"Found the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693408", "createdAt": "2020-09-25T01:15:36Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MzU2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            cacheItem.set(System.currentTimeMillis());\n          \n          \n            \n                       \n          \n      \n    \n    \n  \n\nRemove this line. We do not want to update anything in the cache item if fetch failed.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494693563", "createdAt": "2020-09-25T01:16:13Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -22,33 +22,38 @@\n public class LocalPatternOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n         String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n         logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n     @Override\n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n         LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n         String normalizedLocale = resultData.getLocale();\n         logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n-        return getPatternsByLocale(normalizedLocale);\n+        getPatternsByLocale(normalizedLocale, cacheItem);\n     }\n \n-    private JSONObject getPatternsByLocale(String normalizedLocale) {\n+    private void getPatternsByLocale(String normalizedLocale, PatternCacheItem cacheItem) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n-            return null;\n+            return;\n         try {\n             String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n-            return (JSONObject) patterns.get(PatternKeys.CATEGORIES);\n+            if(patterns != null) {\n+                logger.debug(\"Find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set((Map<String, Object>) patterns.get(PatternKeys.CATEGORIES), System.currentTimeMillis());\n+            }else{\n+                logger.debug(\"Doesn't find the pattern from local bundle for locale [{}].\\n\", normalizedLocale);\n+                cacheItem.set(System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTA3Mjg0", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-496907284", "createdAt": "2020-09-25T23:07:55Z", "commit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMzowNzo0MlrOHYdD1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNjoxNDo1MlrOHYeIHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzk4OA==", "bodyText": "You should not add the cacheItem to the cache fetch if getRegionsFromDS failed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    formattingCacheService.addRegions(locale, cacheItem);\n          \n          \n            \n                    logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                    if (!cacheItem.getCachedData().isEmpty()) {\n          \n          \n            \n                        formattingCacheService.addRegions(locale, cacheItem);\n          \n          \n            \n                        logger.debug(\"Regions has been cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                    }", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495403988", "createdAt": "2020-09-26T03:07:42Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTgzMA==", "bodyText": "For next PR:\n\nCheck here if the requested locale is supported or not. If not supported, do not try to fetch from datastore anymore and just do the following:\n\n\nCheck if the requested locale matches a supported locale (e.g. fr_CA matches fr). If it matches, return fr regions.\nIf it does not match any supported locale, iterate over the fallback locales.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495409830", "createdAt": "2020-09-26T03:42:54Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMTQ3MQ==", "bodyText": "You should not add the cacheItem to the cache fetch if getSupportedLanguagesFromDS failed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n          \n          \n            \n                    logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    if (cacheItem.getCachedData().isEmpty() {\n          \n          \n            \n                        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n          \n          \n            \n                        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    }", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495421471", "createdAt": "2020-09-26T06:14:52Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n+        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Mjg3NTAz", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-495287503", "createdAt": "2020-09-24T07:25:33Z", "commit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNzoyNTozM1rOHXNJKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwMjo1Mjo1N1rOHYs9uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5NDYzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n          \n          \n            \n                private Map<String, String> getLanguagesNamesFromCache(String locale){", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494094632", "createdAt": "2020-09-24T07:25:33Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA5NDgzMw==", "bodyText": "Log an error message before return?", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494094833", "createdAt": "2020-09-24T07:26:00Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +38,115 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n-\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\tsupportedLanguageNames.put(language, languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tlogger.debug(\"Find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tsupportedLanguageNames = JSONUtils.map2SortMap(supportedLanguageNames);\n+\t\t\tcacheItem.set(supportedLanguageNames, System.currentTimeMillis());\n+\t\t}else{\n+\t\t\tlogger.debug(\"Doesn't find the supported languages from local bundle for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+\t\t\tcacheItem.set(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired\n+\t\t\t\t// Update the cache in a separate thread\n+\t\t\t\tpopulateLanguagesCache(locale, languagesNames);\n+\t\t\t}\n \t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n-\t\t\treturn languagesNames;\n+\t\t\treturn languagesNames.getCachedData();\n \t\t}\n-\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n-\t\tif (languagesNames != null) {\n-\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n-\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n-\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n-\t\t\treturn languagesNames;\n-\t\t}\n-\t\treturn null;\n+\t\tlanguagesNames = new LocaleCacheItem();\n+\t\tgetLanguagesNamesFromBundle(locale, languagesNames);\n+\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\treturn languagesNames.getCachedData();\n \t}\n \n-\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\tprivate void getLanguagesNamesFromBundle(String locale, LocaleCacheItem cacheItem) {\n \t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEwNDE2Nw==", "bodyText": "I don't agree, it redundant and unnecessary because local bundles aren't allow change. Here has nothing with service.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494104167", "createdAt": "2020-09-24T07:42:18Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyNzM3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PatternCacheItem getPatternsByLocale(String locale) {\n          \n          \n            \n                public PatternCacheItem getPatternsFromCache(String locale) {", "url": "https://github.com/vmware/singleton/pull/742#discussion_r494127379", "createdAt": "2020-09-24T08:20:19Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -22,115 +27,172 @@\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        JSONObject patterns = new JSONObject(cacheItem.getCachedData());\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n-        JSONObject patterns = getPatternsByLocale(locale);\n-        if (patterns != null) {\n-            return patterns;\n+        PatternCacheItem cacheItem = getPatternsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return new JSONObject(cacheItem.getCachedData());\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find pattern for locale [{}], look for fallback locale [{}] pattern as fallback!\", locale, fallbackLocale);\n-            patterns = getPatternsByLocale(fallbackLocale);\n-            if (patterns != null) {\n-                new FormattingCacheService().addPatterns(locale, patterns);\n-                logger.debug(\"Fallback locale [{}] pattern is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n-                return patterns;\n+            cacheItem = getPatternsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n+                return new JSONObject(cacheItem.getCachedData());\n             }\n         }\n         return null;\n     }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        if(locale != null && !locale.isEmpty())\n-            locale = locale.replace(\"_\", \"-\");\n-        JSONObject patterns = null;\n+    public PatternCacheItem getPatternsByLocale(String locale) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2MTQ1NQ==", "bodyText": "Without synchronized keyword, how can you make sure the 2 variables are matched?\nAfter this.getMaxAgeMillis() but before this.getTimestamp() , other thread may have changed timestamp, they are not matched in this case.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495661455", "createdAt": "2020-09-28T02:36:54Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/base/cache/FormatCacheItem.java", "diffHunk": "@@ -4,28 +4,58 @@\n  */\n package com.vmware.vipclient.i18n.base.cache;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import com.vmware.vipclient.i18n.VIPCfg;\n \n public class FormatCacheItem implements CacheItem {\n+\n+\tprivate String etag;\n+\tprivate long timestamp;\n+\tprivate Long maxAgeMillis = 86400000l;\n+\n \tpublic FormatCacheItem() {\n-\t\t\n+\n+\t}\n+\n+\tpublic String getEtag() {\n+\t\treturn etag;\n+\t}\n+\n+\tprotected void setEtag(String etag) {\n+\t\tthis.etag = etag;\n+\t}\n+\n+\tpublic long getTimestamp() {\n+\t\treturn timestamp;\n+\t}\n+\n+\tprotected void setTimestamp(long timestamp) {\n+\t\tthis.timestamp = timestamp;\n \t}\n-\t\n-\tpublic FormatCacheItem (Map<String, String> dataMap) {\n-\t\tsuper();\n-\t\tthis.addCachedData(dataMap);\n+\n+\tpublic Long getMaxAgeMillis() {\n+\t\treturn maxAgeMillis;\n \t}\n-\t\n-\tpublic final Map<String, String> cachedData = new HashMap<String, String>();\n-\t\n-\tpublic void addCachedData(Map<String, String> cachedData) {\n-\t\tif (cachedData != null)\n-\t\t\tthis.cachedData.putAll(cachedData);\n+\n+\tprotected void setMaxAgeMillis(Long maxAgeMillis) {\n+\t\tthis.maxAgeMillis = maxAgeMillis;\n \t}\n-\t\t\n-    public Map<String, String> getCachedData() {\n-\t\treturn cachedData;\n+\n+\tpublic boolean isExpired() {\n+\t\t// If offline mode only, cache never expires.\n+\t\tif (VIPCfg.getInstance().getVipServer() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// If maxAgeFromConfig is present, it means it is using the old way\n+\t\t// of caching expiration, so do not expire individual CacheItem object\n+\t\tif (VIPCfg.getInstance().getCacheExpiredTime() != 0) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tLong maxAgeResponse = this.getMaxAgeMillis();\n+\t\tif (maxAgeResponse != null) {\n+\t\t\tmaxAgeMillis = maxAgeResponse;\n+\t\t}\n+\n+\t\treturn System.currentTimeMillis() - this.getTimestamp() >= maxAgeMillis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAxMDE4MQ=="}, "originalCommit": {"oid": "aef5512fc4d6c2be0effcd0db8f7ae4ad3e1588c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2NDA0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LocaleCacheItem getRegionsByLocale(String locale){\n          \n          \n            \n                public LocaleCacheItem getRegionsFromCache(String locale){", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495664047", "createdAt": "2020-09-28T02:50:23Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2NDU2OQ==", "bodyText": "Here supported means supported by CLDR rather than product, right?\nThis will need the CLDR data to support this.\nAt last, we should make sure the locale of translation matches the locale of pattern data.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r495664569", "createdAt": "2020-09-28T02:52:57Z", "author": {"login": "Xiaochao8"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTgzMA=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdfc50320d97ed80d321816dfd1abfcb85655adb", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/fdfc50320d97ed80d321816dfd1abfcb85655adb", "committedDate": "2020-09-30T02:52:37Z", "message": "fix review comments about CacheItem related objects"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea76d3dd02d3c6a6fa4245f43282b9a39f2511da", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/ea76d3dd02d3c6a6fa4245f43282b9a39f2511da", "committedDate": "2020-09-28T10:12:13Z", "message": "fix review comments about CacheItem related objects"}, "afterCommit": {"oid": "fdfc50320d97ed80d321816dfd1abfcb85655adb", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/fdfc50320d97ed80d321816dfd1abfcb85655adb", "committedDate": "2020-09-30T02:52:37Z", "message": "fix review comments about CacheItem related objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc2c55f08844eefaeebf34afb083b418901733e1", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/fc2c55f08844eefaeebf34afb083b418901733e1", "committedDate": "2020-09-30T08:09:53Z", "message": "optimize code in RemoteLocaleOpt and RemotePatternOpt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acd7b18906f7badb4fd2818c2629afdb4f4ed71b", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/acd7b18906f7badb4fd2818c2629afdb4f4ed71b", "committedDate": "2020-10-15T06:42:19Z", "message": "fix 2 minor comments about LocalLocaleOpt:\n 1. rename method name\n 2. log an error before return sentense"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a6154a22777e96e806547b8002a8c97e54b846", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/17a6154a22777e96e806547b8002a8c97e54b846", "committedDate": "2020-10-15T08:59:10Z", "message": "fix review comments:\n 1. change Callable to Runnable when start a new thread to update cache\n 2. correct related comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1495a227b346e69ded20002a354b066b63ee75b0", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/1495a227b346e69ded20002a354b066b63ee75b0", "committedDate": "2020-10-15T14:27:25Z", "message": "fix review comment: correct some debug logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6104fe1ad5970b1fa0596632f224ca614ee248c", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/c6104fe1ad5970b1fa0596632f224ca614ee248c", "committedDate": "2020-10-15T15:02:37Z", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_L2CacheExpire"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTYyNDgx", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-509962481", "createdAt": "2020-10-16T02:01:44Z", "commit": {"oid": "c6104fe1ad5970b1fa0596632f224ca614ee248c"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA3Nzk0", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-510807794", "createdAt": "2020-10-16T21:26:59Z", "commit": {"oid": "c6104fe1ad5970b1fa0596632f224ca614ee248c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMToyNjo1OVrOHjQQwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMToyNjo1OVrOHjQQwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyODY0MA==", "bodyText": "First, local bundle will never be updated at runtime. The reason is this is against product integrity. Any updates to local bundles must be done using an official product upgrade/patch/hotfix.\nSecond, the implementation that you copied from Singleton service (caching the language names) is not optimal. You do not need to copy it. We have to remove it from here, especially because adding the languages' names to the cache is going to unnecessarily add to the memory footprint of the client application, not just in Singleton service. Removing the caching logic for language names entirely will avoid this problem. We should eventually remove this same non-optimal behavior from the Singleton service too.\nMoreover, you are incorrect when you say that the code will not be used. The expire logic in formatCacheItem.isExpired will always be applied in mixed mode, and so the formatCacheItem in cache will expire even if it previously came from the offline jar. Anyway, this is not the primary concern, but removing the caching logic for language names entirely will avoid this problem.\nHence, please remove:\n\nFormattingCacheItem.addLanguagesNames\nFormattingCacheItem.getLanguagesNames\nFormattingCacheItem.getLanguagesNamesCacheKey\nConstantsKeys.LANGUAGES_PREFIX\nOther related code", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506728640", "createdAt": "2020-10-16T21:26:59Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -37,72 +39,104 @@ public LocalLocaleOpt(LocaleDTO dto) {\n \t}\n \n \t@Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n \t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n \t\t\t\t.getSupportedLocales();\n \t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n \t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n \t\t\tif (languagesNames == null || languagesNames.isEmpty())\n-\t\t\t\treturn supportedLanguageNames;\n+\t\t\t\treturn;\n \t\t\tfor(String language : supportedLanguages){\n \t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n \t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n \t\t}\n-\t\treturn supportedLanguageNames;\n+\t\tif (!supportedLanguageNames.isEmpty()) {\n+\t\t\tcacheItem.addCachedData(supportedLanguageNames);\n+\t\t\tcacheItem.setTimestamp(System.currentTimeMillis());\n+\t\t}\n     }\n \n     private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n-\t\tMap<String, String> languagesNames = null;\n+\t\tLocaleCacheItem languagesNames = null;\n \t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n \t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n \t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n \t\tif (languagesNames != null) {\n+\t\t\tif (languagesNames.isExpired()) { // cacheItem has expired", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzMjA4NQ=="}, "originalCommit": {"oid": "4edbc4ebde1715cad60dc217259b547391f15a81"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA4ODEy", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-510808812", "createdAt": "2020-10-16T21:29:18Z", "commit": {"oid": "c6104fe1ad5970b1fa0596632f224ca614ee248c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMToyOToxOFrOHjQTzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMTozMDozMFrOHjQVaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTQyMg==", "bodyText": "_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729422", "createdAt": "2020-10-16T21:29:18Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTUyNg==", "bodyText": "Same:\n_The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please._", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729526", "createdAt": "2020-10-16T21:29:39Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);\n+                        }\n+                    } catch (Exception e) {\n+                        logger.error(\"Failed to get region data from Singleton Service!\");\n+                    }\n+                }else{\n+                    logger.debug(\"There is no update on Singleton Service for the regions of locale [{}].\\n\", locale);\n+                    cacheItem.set(etag, timestamp, maxAgeMillis);\n+                }\n             }\n         } catch (Exception e) {\n             logger.error(e.getMessage());\n         }\n-        return respMap;\n     }\n \n     @Override\n-    public Map<String, String> getSupportedLanguages(String locale) {\n+    public void getSupportedLanguages(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for supported languages from Singleton Service for product [{}], version [{}], locale [{}]!\",\n                 dto.getProductID(), dto.getVersion(), locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester()\n-                .request(\n+        try {\n+            Map<String, Object> response = (Map<String, Object>) getResponse(\n                         V2URL.getSupportedLanguageListURL(\n                                 VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL(), dto, locale),\n-                        ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> dispMap = null;\n-        try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            Object data = jsonObject.get(ConstantsKeys.DATA);\n-            if (data == null || \"\".equals(data)) {\n-                return dispMap;\n-            }\n-            JSONObject jsonData = (JSONObject) data;\n-            JSONArray jsonArray = (JSONArray) jsonData.get(ConstantsKeys.LANGUAGES);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                dispMap = new HashMap<String, String>();\n-                for (int i = 0; i < jsonArray.size(); i++) {\n-                    Map<String, Object> tmpMap = JSONUtils.getMapFromJson(jsonArray.get(i).toString());\n-                    dispMap.put(tmpMap.get(ConstantsKeys.LANGUAGE_TAG).toString(),\n-                            tmpMap.get(ConstantsKeys.DISPLAY_NAME).toString());\n+                        ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> languages = getLanguagesFromResponse(responseBody);\n+                        if (languages != null) {\n+                            logger.debug(\"Find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            languages = JSONUtils.map2SortMap(languages);\n+                            cacheItem.set(languages, etag, timestamp, maxAgeMillis);\n+                        }else{\n+                            logger.debug(\"Doesn't find the supported languages from Singleton Service for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0OTY2MQ=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTY1OA==", "bodyText": "Same reply as in RemoteLocaleOpt\n_\"The cacheItem object here was passed a parameter. It could be an object that was retrieved from the cache (not a new cacheItem), updating its timestamp here incorrectly \"un-expires\" the cacheItem. We want to keep the old timestamp if the fetch failed.\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, remove this line please.\"_", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729658", "createdAt": "2020-10-16T21:30:02Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemotePatternOpt.java", "diffHunk": "@@ -4,82 +4,88 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.HttpRequester;\n+import com.vmware.vipclient.i18n.base.cache.PatternCacheItem;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n import org.json.simple.JSONObject;\n-import org.json.simple.JSONValue;\n-import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.net.HttpURLConnection;\n+import java.util.List;\n import java.util.Map;\n \n-public class RemotePatternOpt implements PatternOpt{\n+public class RemotePatternOpt extends RemoteL2BaseOpt implements PatternOpt{\n     Logger logger = LoggerFactory.getLogger(RemotePatternOpt.class);\n \n-    public JSONObject getPatterns(String locale) {\n+    public void getPatterns(String locale, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(locale,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n-            }\n-            return msgObject;\n-        }\n+        getPatternsFromRemote(locale, V2URL.getPatternURL(locale,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n     }\n \n-    public JSONObject getPatterns(String language, String region) {\n+    public void getPatterns(String language, String region, PatternCacheItem cacheItem) {\n         logger.debug(\"Look for pattern from Singleton Service for language [{}], region [{}]!\", language, region);\n-        String responseStr = \"\";\n-        String i18nScope = VIPCfg.getInstance().getI18nScope();\n         HttpRequester httpRequester = VIPCfg.getInstance().getVipService().getHttpRequester();\n-        if (i18nScope != null && !\"\".equalsIgnoreCase(i18nScope)) {\n-        \tMap<String, Object> response = httpRequester.request(V2URL.getPatternURL(language, region,\n-                    httpRequester.getBaseURL()), ConstantsKeys.GET, null);\n-        \tresponseStr = (String) response.get(URLUtils.BODY);\n-        }\n-        if (null == responseStr || responseStr.equals(\"\")) {\n-            return null;\n-        } else {\n-            Object dataObj = this.getCategoriesFromResponse(responseStr, PatternKeys.CATEGORIES);\n-            JSONObject msgObject = null;\n-            if (dataObj != null) {\n-                msgObject = (JSONObject) dataObj;\n+        getPatternsFromRemote(language+\"-\"+region, V2URL.getPatternURL(language, region,\n+                    httpRequester.getBaseURL()), ConstantsKeys.GET, null, cacheItem);\n+    }\n+\n+    private void getPatternsFromRemote(String locale, String url, String method, Object requestData, PatternCacheItem cacheItem) {\n+\n+        Map<String, Object> response = getResponse(url, method, requestData, cacheItem);\n+\n+        Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+        if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+            long timestamp = 0;\n+            String etag = null;\n+            Long maxAgeMillis = null;\n+\n+            if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+            if (response.get(URLUtils.HEADERS) != null)\n+                etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+            if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+            if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                try {\n+                    String responseBody = (String) response.get(URLUtils.BODY);\n+                    Map<String, Object> patterns = getPatternsFromResponse(responseBody);\n+                    if (patterns != null) {\n+                        logger.debug(\"Find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(patterns, etag, timestamp, maxAgeMillis);\n+                    }else{\n+                        logger.debug(\"Doesn't find the pattern from Singleton Service for locale [{}].\\n\", locale);\n+                        cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MTUzMA=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTc3MA==", "bodyText": "Same:\nIf you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, add the if statement.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729770", "createdAt": "2020-10-16T21:30:18Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwMzk4OA=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyOTgzMg==", "bodyText": "Same reply:\n_If you noticed in my most recent PR, we have changed the design of caching empty cacheItem objects for non-supported locales. This is because this design won't help in the case of the very first request (it will still be slow). So for L3, we just use the list of supported locales to figure out the next steps.. and in the case of non-supported locale, that would be to return fallback locale messages.\nFor L2, can we do the same in next PR? For now, add the if statement._", "url": "https://github.com/vmware/singleton/pull/742#discussion_r506729832", "createdAt": "2020-10-16T21:30:30Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -31,119 +34,166 @@ public LocaleService(LocaleDTO dto) {\n     }\n \n     public Map<String, String> getRegions(String locale){\n-        Map<String, String> regionMap = getRegionsByLocale(locale);\n-        if (regionMap != null) {\n-            return regionMap;\n+        LocaleCacheItem cacheItem = getRegionsByLocale(locale);\n+        if (!cacheItem.getCachedData().isEmpty()) {\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find regions for locale [{}], look for fallback locale [{}] regions as fallback!\", locale, fallbackLocale);\n-            regionMap = getRegionsByLocale(fallbackLocale);\n-            if (regionMap != null) {\n-                new FormattingCacheService().addRegions(locale, regionMap);\n-                logger.debug(\"Fallback locale [{}] regions is cached for locale [{}]!\\n\\n\", fallbackLocale, locale);\n+            cacheItem = getRegionsByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return regionMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getRegionsByLocale(String locale){\n+    public LocaleCacheItem getRegionsByLocale(String locale){\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> regionMap = null;\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        regionMap = formattingCacheService.getRegions(locale);\n-        if (regionMap != null) {\n+        cacheItem = formattingCacheService.getRegions(locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateRegionsCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n-            return regionMap;\n-        }\n-        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (regionMap != null) {\n-            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n-            formattingCacheService.addRegions(locale, regionMap);\n-            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n-            return regionMap;\n+            return cacheItem;\n         }\n-        return regionMap;\n+        cacheItem = new LocaleCacheItem();\n+        getRegionsFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addRegions(locale, cacheItem);\n+        logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+        return cacheItem;\n     }\n \n-    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n-        Map<String, String> regions = null;\n+    private void getRegionsFromDS(String locale, LocaleCacheItem cacheItem, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL);\n-            return regions;\n+            logger.error(ConstantsMsg.GET_REGIONS_FAILED_ALL, locale);\n+            return;\n         }\n+        long timestampOld = cacheItem.getTimestamp();\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n-        if (regions == null || regions.isEmpty()) {\n-            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString());\n-            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        dataSource.createLocaleOpt(dto).getRegions(locale, cacheItem);\n+        long timestampNew = cacheItem.getTimestamp();\n+        if (timestampNew == timestampOld) {\n+            logger.debug(ConstantsMsg.GET_REGIONS_FAILED, locale, dataSource.toString());\n+        }\n+        // Skip this block if timestamp is not 0 (which means cacheItem is in the cache) regardless if cacheItem is expired or not.\n+        // Otherwise, try the next dataSource in the queue.\n+        if (timestampNew == 0) {\n+            getRegionsFromDS(locale, cacheItem, msgSourceQueueIter);\n         }\n-        return regions;\n     }\n \n     public Map<String, String> getDisplayNames(String locale) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-        dispMap = getSupportedDisplayNamesByLocale(locale);\n-        if(dispMap != null && !dispMap.isEmpty()){\n-            return dispMap;\n+        LocaleCacheItem cacheItem = getSupportedDisplayNamesByLocale(locale);\n+        if(!cacheItem.getCachedData().isEmpty()){\n+            return cacheItem.getCachedData();\n         }\n         Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n         while (fallbackLocalesIter.hasNext()) {\n             String fallbackLocale = fallbackLocalesIter.next().toLanguageTag();\n             if(fallbackLocale.equalsIgnoreCase(locale))\n                 continue;\n             logger.info(\"Can't find supported languages for locale [{}], look for fallback locale [{}] languages as fallback!\", locale, fallbackLocale);\n-            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale);\n-            if (dispMap != null && dispMap.size() > 0) {\n-                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n-                logger.debug(\"Fallback locale [{}] displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n-                        fallbackLocale, dto.getProductID(), dto.getVersion(), locale);\n+            cacheItem = getSupportedDisplayNamesByLocale(fallbackLocale);\n+            if (!cacheItem.getCachedData().isEmpty()) {\n                 break;\n             }\n         }\n-        return dispMap;\n+        return cacheItem.getCachedData();\n     }\n \n-    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+    public LocaleCacheItem getSupportedDisplayNamesByLocale(String locale) {\n         if(locale != null && !locale.isEmpty())\n             locale = locale.replace(\"_\", \"-\").toLowerCase();\n-        Map<String, String> dispMap = new HashMap<String, String>();\n+        LocaleCacheItem cacheItem = null;\n         logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n         FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n-        if (dispMap != null) {\n+        cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (cacheItem != null) {\n+            if (cacheItem.isExpired()) { // cacheItem has expired\n+                // Update the cache in a separate thread\n+                populateSupportedLanguagesCache(locale, cacheItem);\n+            }\n             logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n+            return cacheItem;\n         }\n-        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        if (dispMap != null && dispMap.size() > 0) {\n-            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n-            return dispMap;\n-        }\n-        return dispMap;\n+        cacheItem = new LocaleCacheItem();\n+        getSupportedLanguagesFromDS(locale, cacheItem, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        formattingCacheService.addSupportedLanguages(dto, locale, cacheItem);\n+        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQyMTQ3MQ=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c69fd525b204458cbedcb2616c9711241b6951a", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/7c69fd525b204458cbedcb2616c9711241b6951a", "committedDate": "2020-10-20T08:34:49Z", "message": "fix as review comment: remove expire logic for languages' names cache which is from local bundle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aad9aebb7b14b3c6653ae9779d05ea3dff5998f9", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/aad9aebb7b14b3c6653ae9779d05ea3dff5998f9", "committedDate": "2020-10-20T15:14:01Z", "message": "fix as review comment: remove cache logic for languages' names which is from local bundle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11e79660d44d53c49c310a4e96cbbb8b106284b3", "author": {"user": {"login": "huihuiw01", "name": null}}, "url": "https://github.com/vmware/singleton/commit/11e79660d44d53c49c310a4e96cbbb8b106284b3", "committedDate": "2020-10-22T15:29:40Z", "message": "Change the judgement condition to do data source fallback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MzM3ODU0", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-515337854", "createdAt": "2020-10-23T05:04:37Z", "commit": {"oid": "11e79660d44d53c49c310a4e96cbbb8b106284b3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODUzMzMz", "url": "https://github.com/vmware/singleton/pull/742#pullrequestreview-515853333", "createdAt": "2020-10-23T17:07:01Z", "commit": {"oid": "11e79660d44d53c49c310a4e96cbbb8b106284b3"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowNzowMlrOHnWTeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowNzowMlrOHnWTeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMTk0NA==", "bodyText": "Hi @huihuiw01 . It looks like you have not filed an issue regarding this yet so I did: #841\nI will now approve this Pr, and you can separately fix the new issue.", "url": "https://github.com/vmware/singleton/pull/742#discussion_r511021944", "createdAt": "2020-10-23T17:07:02Z", "author": {"login": "jessiejuachon"}, "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -30,61 +30,129 @@ public RemoteLocaleOpt(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getRegions(String locale) {\n+    public void getRegions(String locale, LocaleCacheItem cacheItem) {\n         logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", locale);\n-    \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n-                V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n-                ConstantsKeys.GET, null);\n-    \tString responseData = (String) response.get(URLUtils.BODY);\n-        if(responseData == null || responseData.isEmpty())\n-            return null;\n-        Map<String, String> respMap = null;\n         try {\n-            JSONObject jsonObject = (JSONObject) JSONValue.parseWithException(responseData);\n-            JSONArray jsonArray = (JSONArray) jsonObject.get(ConstantsKeys.DATA);\n-            if (jsonArray != null && !jsonArray.isEmpty()) {\n-                Map<String, Object> regionMap = JSONUtils.getMapFromJson(jsonArray.get(0).toString());\n-                respMap = (Map<String, String>) regionMap.get(ConstantsKeys.TERRITORIES);\n+            Map<String, Object> response = getResponse(\n+                    V2URL.getRegionListURL(locale, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n+                    ConstantsKeys.GET, null, cacheItem);\n+\n+            Integer responseCode = (Integer) response.get(URLUtils.RESPONSE_CODE);\n+\n+            if (responseCode != null && (responseCode.equals(HttpURLConnection.HTTP_OK) ||\n+                    responseCode.equals(HttpURLConnection.HTTP_NOT_MODIFIED))) {\n+                long timestamp = 0;\n+                String etag = null;\n+                Long maxAgeMillis = null;\n+                if (response.get(URLUtils.RESPONSE_TIMESTAMP) != null)\n+                    timestamp = (long) response.get(URLUtils.RESPONSE_TIMESTAMP);\n+                if (response.get(URLUtils.HEADERS) != null)\n+                    etag = URLUtils.createEtagString((Map<String, List<String>>) response.get(URLUtils.HEADERS));\n+                if (response.get(URLUtils.MAX_AGE_MILLIS) != null)\n+                    maxAgeMillis = (Long) response.get(URLUtils.MAX_AGE_MILLIS);\n+\n+                if (responseCode.equals(HttpURLConnection.HTTP_OK)) {\n+                    try {\n+                        String responseBody = (String) response.get(URLUtils.BODY);\n+                        Map<String, String> territories = getTerritoriesFromResponse(responseBody);\n+                        if (territories != null) {\n+                            logger.debug(\"Find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            territories = JSONUtils.map2SortMap(territories);\n+                            cacheItem.set(territories, etag, timestamp, maxAgeMillis);\n+                        } else {\n+                            logger.debug(\"Doesn't find the regions from Singleton Service for locale [{}].\\n\", locale);\n+                            cacheItem.set(etag, timestamp, maxAgeMillis);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0ODM1Nw=="}, "originalCommit": {"oid": "98e09fa956d7acfcedb65b34247965107188c808"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4296, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}