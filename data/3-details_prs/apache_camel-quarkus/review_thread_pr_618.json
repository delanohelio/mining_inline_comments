{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNTY2MjM2", "number": 618, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxNzoyM1rODYlK6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjowMzoyMlrODY3RnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MTAxNDE2OnYy", "diffSide": "RIGHT", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzoxNzoyM1rOFehS1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjozNjo1NlrOFepx1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ==", "bodyText": "we need to fine tune language and data-format as we can store into the registry only singleton services (this requires also some changes to the FastCamelContext as it assumes languages and dataformats are stored in the registry)", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367547095", "createdAt": "2020-01-16T17:17:23Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MzcwMg==", "bodyText": "Yes we do have this problem as today but this is a good change to fix it", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367553702", "createdAt": "2020-01-16T17:31:13Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzODcxMg==", "bodyText": "we need to fine tune language and data-format\n\nNot sure how should we tune?\n\nas we can store into the registry only singleton services\n\nYou seem to imply language and data-format are not singleton services, but could you plz. define \"singleton services\"?", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367638712", "createdAt": "2020-01-16T20:40:19Z", "author": {"login": "ppalaga"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjEwMQ==", "bodyText": "The \"tuning\" here is about to carefully select which language/dataformat can be bound to the registry.\nAs example camel creates components only once so every time you use a schema, then you'll end up using the same component instance.\nFor languages and dataformat that's not always true and this is because you can use the same dataformat multiple time in the same route with a different configuration.", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367686101", "createdAt": "2020-01-16T22:36:56Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MTA2MjA3OnYy", "diffSide": "RIGHT", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzozMzoyM1rOFehwfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOToxMDo1MVrOFeyuzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA==", "bodyText": "As future evolution, may be better not to expose such instances to the user through the registry, maybe better to try to bind them to the components at build time", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367554684", "createdAt": "2020-01-16T17:33:23Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NDM1Nw==", "bodyText": "I wonder how can we cover the case you mentioned on the chat - manually bind a second instance of a component under a different name?", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367644357", "createdAt": "2020-01-16T20:54:00Z", "author": {"login": "ppalaga"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4OTcyNg==", "bodyText": "I mean that we should not even bind them to the registry but scan the registry for components and bind related configurers through a recorder during STATIC_INIT", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367689726", "createdAt": "2020-01-16T22:47:25Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMTY1Mw==", "bodyText": "the registry for components and bind related configurers through a recorder during STATIC_INIT\n\nYes, that would be easy to do. But when a user adds a second instance of a component under a different name at runtime, our configurer setting code would not catch it.", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367831653", "createdAt": "2020-01-17T09:07:59Z", "author": {"login": "ppalaga"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjc4MQ==", "bodyText": "yep but as the second instance is probably configured at runtime, the component will fallback to the \"factory finder\" way which is reasonable", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367832781", "createdAt": "2020-01-17T09:10:51Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, "originalCommit": {"oid": "38439849e9cc41ae230af7aafda455556c010098"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mzk4MDQ1OnYy", "diffSide": "RIGHT", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjowMzoyMlrOFe9p3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNzo0NDoxNFrOFfAcWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg==", "bodyText": "not a huge issue in our case but my understanding is that invoking build() multiple time on the same builder should produce the same result", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368011742", "createdAt": "2020-01-17T16:03:22Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMTIyOQ==", "bodyText": "invoking build() multiple time on the same builder should produce the same result\n\nIf the collection is not set to null here the following sequence would be possible:\nPathFilter.Builder b = new PathFilter.Builder();\nb.include(\"foo/bar\");\nPathFilter pf1 = b.build();\nb.include(\"bar/baz\");\nPathFilter pf2 = b.build();\n\nwhere pf1 and pf2 would have set the same list instance in their includePatterns fields. That would be really unwanted. That's a true reference leak that harms the immutability of PathFilter.\nI hold re-using builders for rather unusual and so I find breaking the re-use better than copying the list in the PathFilter constructor as a way to ensure immutability.", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368031229", "createdAt": "2020-01-17T16:43:15Z", "author": {"login": "ppalaga"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, "originalCommit": {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjU1Ng==", "bodyText": "At least document it as I think no-one expect the builder to be re-set once you invoke build()", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368036556", "createdAt": "2020-01-17T16:54:00Z", "author": {"login": "lburgazzoli"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, "originalCommit": {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NDUwNQ==", "bodyText": "Done at https://github.com/apache/camel-quarkus/pull/618/files#diff-7d0dfbc8ca22f0eb14e77322fcda0902R143", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368044505", "createdAt": "2020-01-17T17:11:57Z", "author": {"login": "ppalaga"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, "originalCommit": {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzQzMg==", "bodyText": "Well another, in my opinion, cleaner option is to copy the collection in each object built making it immutable. A variation of this is used in most of the framework that generates builders, like Lombok and similars one.\nMy 2c.", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368057432", "createdAt": "2020-01-17T17:44:14Z", "author": {"login": "valdar"}, "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, "originalCommit": {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4446, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}