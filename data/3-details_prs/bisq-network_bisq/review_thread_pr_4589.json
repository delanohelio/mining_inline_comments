{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NjY2NTUy", "number": 4589, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNDozNzowNVrOEqBVBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDoyNDo0M1rOEqHrUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDk3NDEyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNDozNzowNVrOHcB5EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNDozNzowNVrOHcB5EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1MzE2OA==", "bodyText": "To reduce confusion, how about\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    openInstances.decrementAndGet();\n          \n          \n            \n                    if (openInstances.get() == 0) {\n          \n          \n            \n                    if (openInstances.decrementAndGet() == 0) {", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499153168", "createdAt": "2020-10-03T14:37:05Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbaef268ffc1ef669c8e264ef65c8beccdea1bd5"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTA2NzY1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNzoxMDo1NlrOHcCnIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNzo1MzoyN1rOHcJHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2NDk2Mg==", "bodyText": "Misspelled sourcce", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499164962", "createdAt": "2020-10-03T17:10:56Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbaef268ffc1ef669c8e264ef65c8beccdea1bd5"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTYwNQ==", "bodyText": "fixed", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271605", "createdAt": "2020-10-04T17:53:27Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2NDk2Mg=="}, "originalCommit": {"oid": "fbaef268ffc1ef669c8e264ef65c8beccdea1bd5"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTIwMjk5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QyMTowOTowNlrOHcDp_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNzo1NDo0MlrOHcJIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjA3OQ==", "bodyText": "Why use runPeriodically() instead of runAfter()? The effect would be the same but now it seems the write is intended to happen periodically, but two lines later that we see that it's not.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499182079", "createdAt": "2020-10-03T21:09:06Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    }\n+\n+    public void initialize(T persistable, String fileName, Source sourcce) {\n+        this.persistable = persistable;\n+        this.fileName = fileName;\n+        this.source = sourcce;\n+        storageFile = new File(dir, fileName);\n+        ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n+    }\n+\n+    public void shutdown() {\n+        ALL_PERSISTENCE_MANAGERS.remove(fileName);\n+\n+        if (timer != null) {\n+            timer.stop();\n+        }\n+\n+        if (writeToDiskExecutor != null) {\n+            writeToDiskExecutor.shutdown();\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Reading file\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Nullable\n+    public T getPersisted() {\n+        return getPersisted(checkNotNull(fileName));\n+    }\n+\n+    //TODO use threading here instead in the clients\n+    // We get called at startup either by readAllPersisted or readFromResources. Both are wrapped in a thread so we\n+    // are not on the user thread.\n+    @Nullable\n+    public T getPersisted(String fileName) {\n+        File storageFile = new File(dir, fileName);\n+        if (!storageFile.exists()) {\n+            return null;\n+        }\n+\n+        long ts = System.currentTimeMillis();\n+        try (FileInputStream fileInputStream = new FileInputStream(storageFile)) {\n+            protobuf.PersistableEnvelope proto = protobuf.PersistableEnvelope.parseDelimitedFrom(fileInputStream);\n+            //noinspection unchecked\n+            T persistableEnvelope = (T) persistenceProtoResolver.fromProto(proto);\n+            log.info(\"Reading {} completed in {} ms\", fileName, System.currentTimeMillis() - ts);\n+            return persistableEnvelope;\n+        } catch (Throwable t) {\n+            log.error(\"Reading {} failed with {}.\", fileName, t.getMessage());\n+            try {\n+                // We keep a backup which might be used for recovery\n+                FileUtil.removeAndBackupFile(dir, storageFile, fileName, \"backup_of_corrupted_data\");\n+                DevEnv.logErrorAndThrowIfDevMode(t.toString());\n+            } catch (IOException e1) {\n+                e1.printStackTrace();\n+                log.error(e1.getMessage());\n+                // We swallow Exception if backup fails\n+            }\n+            if (corruptedStorageFileHandler != null) {\n+                corruptedStorageFileHandler.addFile(storageFile.getName());\n+            }\n+        }\n+        return null;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Write file to disk\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void requestPersistence() {\n+        persistenceRequested = true;\n+\n+        // We write to disk with a delay to avoid frequent write operations. Depending on the priority those delays\n+        // can be rather long.\n+        if (timer == null) {\n+            timer = UserThread.runPeriodically(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTczOA==", "bodyText": "Yes was from earlier version, should be runAfter.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271738", "createdAt": "2020-10-04T17:54:42Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.persistence;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+import bisq.common.app.DevEnv;\n+import bisq.common.config.Config;\n+import bisq.common.file.CorruptedStorageFileHandler;\n+import bisq.common.file.FileUtil;\n+import bisq.common.handlers.ResultHandler;\n+import bisq.common.proto.persistable.PersistableEnvelope;\n+import bisq.common.proto.persistable.PersistenceProtoResolver;\n+import bisq.common.util.Utilities;\n+\n+import com.google.inject.Inject;\n+\n+import javax.inject.Named;\n+\n+import java.nio.file.Path;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static bisq.common.util.Preconditions.checkDir;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Responsible for reading persisted data and writing it on disk. We read usually only at start-up and keep data in RAM.\n+ * We write all data which got a request for persistence at shut down at the very last moment when all other services\n+ * are shut down, so allowing changes to the data in the very last moment. For critical data we set {@link Source}\n+ * to HIGH which causes a timer to trigger a write to disk after 1 minute. We use that for not very frequently altered\n+ * data and data which cannot be recovered from the network.\n+ *\n+ * We decided to not use threading (as it was in previous versions) as the read operation happens only at start-up and\n+ * with the modified model that data is written at shut down we eliminate frequent and expensive disk I/O. Risks of\n+ * deadlock or data inconsistency and a more complex model have been a further argument for that model. In fact\n+ * previously we wasted a lot of resources as way too many threads have been created without doing actual work as well\n+ * the write operations got triggered way too often specially for the very frequent changes at SequenceNumberMap and\n+ * the very large DaoState (at dao blockchain sync that slowed down sync).\n+ *\n+ *\n+ * @param <T>   The type of the {@link PersistableEnvelope} to be written or read from disk\n+ */\n+@Slf4j\n+public class PersistenceManager<T extends PersistableEnvelope> {\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Static\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public static final Map<String, PersistenceManager<?>> ALL_PERSISTENCE_MANAGERS = new HashMap<>();\n+\n+    // We don't know from which thread we are called so we map back to user thread\n+    public static void flushAllDataToDisk(ResultHandler completeHandler) {\n+        log.info(\"Start flushAllDataToDisk at shutdown\");\n+        AtomicInteger openInstances = new AtomicInteger(ALL_PERSISTENCE_MANAGERS.size());\n+\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+\n+        new HashSet<>(ALL_PERSISTENCE_MANAGERS.values()).forEach(persistenceManager -> {\n+            // For Priority.HIGH data we want to write to disk in any case to be on the safe side if we might have missed\n+            // a requestPersistence call after an important state update. Those are usually rather small data stores.\n+            // Otherwise we only persist if requestPersistence was called since the last persist call.\n+            if (persistenceManager.source.flushAtShutDown || persistenceManager.persistenceRequested) {\n+                // We don't know from which thread we are called so we map back to user thread when calling persistNow\n+                UserThread.execute(() -> {\n+                    // We always get our completeHandler called even if exceptions happen. In case a file write fails\n+                    // we still call our shutdown and count down routine as the completeHandler is triggered in any case.\n+                    persistenceManager.persistNow(() ->\n+                            onWriteCompleted(completeHandler, openInstances, persistenceManager));\n+                });\n+            } else {\n+                onWriteCompleted(completeHandler, openInstances, persistenceManager);\n+            }\n+        });\n+    }\n+\n+    private static void onWriteCompleted(ResultHandler completeHandler,\n+                                         AtomicInteger openInstances,\n+                                         PersistenceManager<?> persistenceManager) {\n+        persistenceManager.shutdown();\n+        openInstances.decrementAndGet();\n+        if (openInstances.get() == 0) {\n+            log.info(\"flushAllDataToDisk completed\");\n+            UserThread.execute(completeHandler::handleResult);\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Enum\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public enum Source {\n+        // For data stores we received from the network and which could be rebuilt. We store only for avoiding too much network traffic.\n+        NETWORK(1, TimeUnit.HOURS.toSeconds(1), false),\n+\n+        // For data stores which are created from private local data. This data could only be rebuilt from backup files.\n+        PRIVATE(10, TimeUnit.SECONDS.toSeconds(30), true),\n+\n+        // For data stores which are created from private local data. Loss of that data would not have any critical consequences.\n+        PRIVATE_LOW_PRIO(4, TimeUnit.HOURS.toSeconds(2), false);\n+\n+\n+        @Getter\n+        private final int numMaxBackupFiles;\n+        @Getter\n+        private final long delayInSec;\n+        @Getter\n+        private final boolean flushAtShutDown;\n+\n+        Source(int numMaxBackupFiles, long delayInSec, boolean flushAtShutDown) {\n+            this.numMaxBackupFiles = numMaxBackupFiles;\n+            this.delayInSec = delayInSec;\n+            this.flushAtShutDown = flushAtShutDown;\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Class fields\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private final File dir;\n+    private final PersistenceProtoResolver persistenceProtoResolver;\n+    private final CorruptedStorageFileHandler corruptedStorageFileHandler;\n+    private File storageFile;\n+    private T persistable;\n+    private String fileName;\n+    private Source source = Source.PRIVATE_LOW_PRIO;\n+    private Path usedTempFilePath;\n+    private volatile boolean persistenceRequested;\n+    @Nullable\n+    private Timer timer;\n+    private ExecutorService writeToDiskExecutor;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Inject\n+    public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n+                              PersistenceProtoResolver persistenceProtoResolver,\n+                              CorruptedStorageFileHandler corruptedStorageFileHandler) {\n+        this.dir = checkDir(dir);\n+        this.persistenceProtoResolver = persistenceProtoResolver;\n+        this.corruptedStorageFileHandler = corruptedStorageFileHandler;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void initialize(T persistable, Source sourcce) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    }\n+\n+    public void initialize(T persistable, String fileName, Source sourcce) {\n+        this.persistable = persistable;\n+        this.fileName = fileName;\n+        this.source = sourcce;\n+        storageFile = new File(dir, fileName);\n+        ALL_PERSISTENCE_MANAGERS.put(fileName, this);\n+    }\n+\n+    public void shutdown() {\n+        ALL_PERSISTENCE_MANAGERS.remove(fileName);\n+\n+        if (timer != null) {\n+            timer.stop();\n+        }\n+\n+        if (writeToDiskExecutor != null) {\n+            writeToDiskExecutor.shutdown();\n+        }\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Reading file\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    @Nullable\n+    public T getPersisted() {\n+        return getPersisted(checkNotNull(fileName));\n+    }\n+\n+    //TODO use threading here instead in the clients\n+    // We get called at startup either by readAllPersisted or readFromResources. Both are wrapped in a thread so we\n+    // are not on the user thread.\n+    @Nullable\n+    public T getPersisted(String fileName) {\n+        File storageFile = new File(dir, fileName);\n+        if (!storageFile.exists()) {\n+            return null;\n+        }\n+\n+        long ts = System.currentTimeMillis();\n+        try (FileInputStream fileInputStream = new FileInputStream(storageFile)) {\n+            protobuf.PersistableEnvelope proto = protobuf.PersistableEnvelope.parseDelimitedFrom(fileInputStream);\n+            //noinspection unchecked\n+            T persistableEnvelope = (T) persistenceProtoResolver.fromProto(proto);\n+            log.info(\"Reading {} completed in {} ms\", fileName, System.currentTimeMillis() - ts);\n+            return persistableEnvelope;\n+        } catch (Throwable t) {\n+            log.error(\"Reading {} failed with {}.\", fileName, t.getMessage());\n+            try {\n+                // We keep a backup which might be used for recovery\n+                FileUtil.removeAndBackupFile(dir, storageFile, fileName, \"backup_of_corrupted_data\");\n+                DevEnv.logErrorAndThrowIfDevMode(t.toString());\n+            } catch (IOException e1) {\n+                e1.printStackTrace();\n+                log.error(e1.getMessage());\n+                // We swallow Exception if backup fails\n+            }\n+            if (corruptedStorageFileHandler != null) {\n+                corruptedStorageFileHandler.addFile(storageFile.getName());\n+            }\n+        }\n+        return null;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Write file to disk\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public void requestPersistence() {\n+        persistenceRequested = true;\n+\n+        // We write to disk with a delay to avoid frequent write operations. Depending on the priority those delays\n+        // can be rather long.\n+        if (timer == null) {\n+            timer = UserThread.runPeriodically(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4MjA3OQ=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTgwODgwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNToyOToyOFrOHcIUuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNzo1OToxN1rOHcJJ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw==", "bodyText": "This does not look safe. I think list should be an ObservableList since it's required by this interface. It's first initiated to an ArrayList (line 39) but I assume all implementations of PersistableList passes an ObservableList as the constructor argument.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258553", "createdAt": "2020-10-04T15:29:28Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MTg3OA==", "bodyText": "Yes, was moving the listeners later to the base class. But I think best here is to enforce observeable list as it is used anyway by all subclasses.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499271878", "createdAt": "2020-10-04T17:56:04Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MjE4OA==", "bodyText": "After looking at subclasses its not true. many dont use ObservableList. I will move back the ObservableList methods to the classes which actually use them and remove all ObservableList casts from the base class", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272188", "createdAt": "2020-10-04T17:59:17Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODU1Mw=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTgxMTQ3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNTozMjo0MFrOHcIWAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxODowNjozMFrOHcJMWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODg4MA==", "bodyText": "Naming the generic tradable is confusing, item is more neutral", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258880", "createdAt": "2020-10-04T15:32:40Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3Mjc5NA==", "bodyText": "Yes, will fix", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272794", "createdAt": "2020-10-04T18:06:30Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODg4MA=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTgxMTc3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNTozMzowNVrOHcIWJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxODowNzoxN1rOHcJMng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODkxNw==", "bodyText": "Rather use a uniform naming for the generic, like item", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499258917", "createdAt": "2020-10-04T15:33:05Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {\n+        return list.remove(tradable);\n     }\n \n-    // this.stream() does not compile for unknown reasons, so add that manual delegate method\n     public Stream<T> stream() {\n         return list.stream();\n     }\n \n-    private interface ExcludesDelegateMethods<T> {\n-        Stream<T> stream();\n+    public int size() {\n+        return list.size();\n+    }\n+\n+    public boolean contains(T thing) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3Mjg2Mg==", "bodyText": "Agree.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272862", "createdAt": "2020-10-04T18:07:17Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableList.java", "diffHunk": "@@ -17,43 +17,85 @@\n \n package bisq.common.proto.persistable;\n \n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.function.Consumer;\n import java.util.stream.Stream;\n \n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n-import lombok.experimental.Delegate;\n \n @EqualsAndHashCode\n-public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope, Iterable<T> {\n-    @Delegate(excludes = ExcludesDelegateMethods.class)\n+public abstract class PersistableList<T extends PersistablePayload> implements PersistableEnvelope {\n+\n     @Getter\n-    @Setter\n-    private List<T> list;\n+    public final List<T> list = createList();\n+\n+    protected List<T> createList() {\n+        return new ArrayList<>();\n+    }\n \n     public PersistableList() {\n-        list = new ArrayList<>();\n     }\n \n     public PersistableList(List<T> list) {\n-        this.list = list;\n+        setAll(list);\n+    }\n+\n+    public void addListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).addListener(listener);\n+    }\n+\n+    public void removeListener(ListChangeListener<T> listener) {\n+        ((ObservableList<T>) getList()).removeListener(listener);\n+    }\n+\n+    public ObservableList<T> getObservableList() {\n+        return (ObservableList<T>) getList();\n+    }\n+\n+    public void setAll(Collection<T> collection) {\n+        this.list.clear();\n+        this.list.addAll(collection);\n+    }\n+\n+    public boolean add(T item) {\n+        if (!list.contains(item)) {\n+            list.add(item);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean remove(T tradable) {\n+        return list.remove(tradable);\n     }\n \n-    // this.stream() does not compile for unknown reasons, so add that manual delegate method\n     public Stream<T> stream() {\n         return list.stream();\n     }\n \n-    private interface ExcludesDelegateMethods<T> {\n-        Stream<T> stream();\n+    public int size() {\n+        return list.size();\n+    }\n+\n+    public boolean contains(T thing) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1ODkxNw=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTgxNjMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/app/BisqExecutable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxNTozODoyOFrOHcIYZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxODowNzo1OVrOHcJMzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1OTQ5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Subclassed might configure classes with the injector here\n          \n          \n            \n                    // Subclasses might configure classes with the injector here", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499259492", "createdAt": "2020-10-04T15:38:28Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/app/BisqExecutable.java", "diffHunk": "@@ -148,21 +153,30 @@ protected Injector getInjector() {\n     }\n \n     protected void applyInjector() {\n-        setupPersistedDataHosts(injector);\n+        // Subclassed might configure classes with the injector here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MjkxMA==", "bodyText": "Will fix in a new commit with other changes...", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499272910", "createdAt": "2020-10-04T18:07:59Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/app/BisqExecutable.java", "diffHunk": "@@ -148,21 +153,30 @@ protected Injector getInjector() {\n     }\n \n     protected void applyInjector() {\n-        setupPersistedDataHosts(injector);\n+        // Subclassed might configure classes with the injector here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI1OTQ5Mg=="}, "originalCommit": {"oid": "6693a03f96e45c3ecd98bb879d91c7274c971784"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAxMjk4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDoyMjoyMVrOHcJ8ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMTowNTo0OVrOHcKK6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTA5Mg==", "bodyText": "The typo continues...", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499285092", "createdAt": "2020-10-04T20:22:21Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -184,8 +184,8 @@ public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n     // API\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    public void initialize(T persistable, Source sourcce) {\n-        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    public void initialize(T persistable, Source source) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), source);\n     }\n \n     public void initialize(T persistable, String fileName, Source sourcce) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b31dc9ff3484204b4784f354ab1ca7cdba6a9b9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODgxMQ==", "bodyText": "ups...", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499288811", "createdAt": "2020-10-04T21:05:49Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/persistence/PersistenceManager.java", "diffHunk": "@@ -184,8 +184,8 @@ public PersistenceManager(@Named(Config.STORAGE_DIR) File dir,\n     // API\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    public void initialize(T persistable, Source sourcce) {\n-        this.initialize(persistable, persistable.getDefaultStorageFileName(), sourcce);\n+    public void initialize(T persistable, Source source) {\n+        this.initialize(persistable, persistable.getDefaultStorageFileName(), source);\n     }\n \n     public void initialize(T persistable, String fileName, Source sourcce) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTA5Mg=="}, "originalCommit": {"oid": "3b31dc9ff3484204b4784f354ab1ca7cdba6a9b9"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNjAxNDI2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDoyNDo0M1rOHcJ9IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMToxNDowNFrOHcKNjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ==", "bodyText": "Should take ObservableList<T>", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499285281", "createdAt": "2020-10-04T20:24:43Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.proto.persistable;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n+import java.util.List;\n+\n+public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n+\n+    public PersistableListAsObservable() {\n+    }\n+\n+    protected PersistableListAsObservable(List<T> list) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4ODk2Ng==", "bodyText": "No, that is called from protobug methods and there we map to a list, will be copied over to the observable in the base class. We could use a collection here as well to make it more clear that its not setting the list.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499288966", "createdAt": "2020-10-04T21:07:35Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.proto.persistable;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n+import java.util.List;\n+\n+public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n+\n+    public PersistableListAsObservable() {\n+    }\n+\n+    protected PersistableListAsObservable(List<T> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}, "originalCommit": {"oid": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTMxMQ==", "bodyText": "Right you are, since the list is created by createList(). No need to change, this is correct.", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499289311", "createdAt": "2020-10-04T21:11:43Z", "author": {"login": "sqrrm"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.proto.persistable;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n+import java.util.List;\n+\n+public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n+\n+    public PersistableListAsObservable() {\n+    }\n+\n+    protected PersistableListAsObservable(List<T> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}, "originalCommit": {"oid": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTQ4Ng==", "bodyText": "See last commit...", "url": "https://github.com/bisq-network/bisq/pull/4589#discussion_r499289486", "createdAt": "2020-10-04T21:14:04Z", "author": {"login": "chimp1984"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableListAsObservable.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.common.proto.persistable;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+\n+import java.util.List;\n+\n+public abstract class PersistableListAsObservable<T extends PersistablePayload> extends PersistableList<T> {\n+\n+    public PersistableListAsObservable() {\n+    }\n+\n+    protected PersistableListAsObservable(List<T> list) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NTI4MQ=="}, "originalCommit": {"oid": "f9f33aa16deb5c4dada2883d24dfd5d7867a4e21"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2382, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}