{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTMxMTQy", "number": 4950, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyNjo1MlrOFGJJJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTozNzoyMVrOFGJZlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTg1NTc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyNjo1M1rOIHAqVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMzoyODo1NlrOIHFSfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMTc4Mw==", "bodyText": "Shouldn't this be !openOffer.isDeactivated() since it's being republished. That was the check before this change.", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544221783", "createdAt": "2020-12-16T11:26:53Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI5NTU3Mg==", "bodyText": "No it is correct, we call our recursive method with the list where we have removed that offer. But the following lines neede to be in a else branch.\nI made a PR where I invert the if check and add a comment.", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544295572", "createdAt": "2020-12-16T13:26:02Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMTc4Mw=="}, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI5NzU5Ng==", "bodyText": "Yes, understood after the fix. Also the fix handles the recursion issue so I think it's good to merge.", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544297596", "createdAt": "2020-12-16T13:28:56Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMTc4Mw=="}, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTg5NzgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMTozNzoyMVrOIHBCRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMzozMjo1NFrOIHFdmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNzkxMA==", "bodyText": "I don't understand the reason for the delay, all offers will be prepared to republish recursively, then during the recursion unwind they will all get this call so they delay is likely less than 1ms between each offer republish, but all the calls to republish will happen 30ms later. I think this is not much different to republishing without delay.\nThe previous version had a random delay, but it was a multiple of the number of orders and 700, so 200 orders ran into 140 seconds republish time and each offer would be spaced out in that time.", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544227910", "createdAt": "2020-12-16T11:37:21Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {\n+            republishOffers(list);\n+        }\n+\n+        republishOffer(openOffer,\n+                () -> UserThread.runAfter(() -> republishOffers(list),\n+                        30, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI5ODgwMA==", "bodyText": "Ah damn, yes you are right...Wanted to avoid the way it was done before, but the delay from the callback is too short to be used as delay. I am acutally not very sure what happens if one publishes 200 offers without delay. It might be that connections to other peers get dropped due dos protection, but not sure if we hit those thresholds. To make it more smooth for the node and the network the delay was used, but could be that it makes things actually worse as it causes more messages (we use bundledEnvelope now to group msg in 1 container).\nMaybe best to leave the PR for now open and we do more tests first, just hard to test 200 offers on mainnet ;-(.", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544298800", "createdAt": "2020-12-16T13:30:38Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {\n+            republishOffers(list);\n+        }\n+\n+        republishOffer(openOffer,\n+                () -> UserThread.runAfter(() -> republishOffers(list),\n+                        30, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNzkxMA=="}, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwMDQ0Mw==", "bodyText": "Yeah, could be it's better to have no delay and get all these messages into one bundle (or just a few) rather than spreading over time", "url": "https://github.com/bisq-network/bisq/pull/4950#discussion_r544300443", "createdAt": "2020-12-16T13:32:54Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/OpenOfferManager.java", "diffHunk": "@@ -871,39 +871,46 @@ private void maybeUpdatePersistedOffers() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     private void republishOffers() {\n-        int size = openOffers.size();\n-        final ArrayList<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n-        if (!stopped) {\n-            stopPeriodicRefreshOffersTimer();\n-            for (int i = 0; i < size; i++) {\n-                // we delay to avoid reaching throttle limits\n-\n-                long delay = 700;\n-                final long minDelay = (i + 1) * delay;\n-                final long maxDelay = (i + 2) * delay;\n-                final OpenOffer openOffer = openOffersList.get(i);\n-                UserThread.runAfterRandomDelay(() -> {\n-                    if (openOffers.contains(openOffer)) {\n-                        String id = openOffer.getId();\n-                        if (id != null && !openOffer.isDeactivated())\n-                            republishOffer(openOffer);\n-                    }\n+        if (stopped) {\n+            return;\n+        }\n \n-                }, minDelay, maxDelay, TimeUnit.MILLISECONDS);\n-            }\n-        } else {\n-            log.debug(\"We have stopped already. We ignore that republishOffers call.\");\n+        List<OpenOffer> openOffersList = new ArrayList<>(openOffers.getList());\n+        republishOffers(openOffersList);\n+\n+        stopPeriodicRefreshOffersTimer();\n+    }\n+\n+    private void republishOffers(List<OpenOffer> list) {\n+        if (list.isEmpty()) {\n+            return;\n         }\n+\n+        OpenOffer openOffer = list.remove(0);\n+        if (!openOffers.contains(openOffer) || openOffer.isDeactivated()) {\n+            republishOffers(list);\n+        }\n+\n+        republishOffer(openOffer,\n+                () -> UserThread.runAfter(() -> republishOffers(list),\n+                        30, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyNzkxMA=="}, "originalCommit": {"oid": "7bfbd0fd797e03ef5261fe82e7c5572018518608"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2654, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}