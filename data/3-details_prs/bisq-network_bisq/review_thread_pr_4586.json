{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NTI3MDAw", "number": 4586, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxMjoxOVrOEpodcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMzozM1rOEpwzRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDg5OTcwOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/StoreService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxMjoxOVrOHba_Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTozMjo0NFrOHbbfGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTgxNA==", "bodyText": "log.info(\"No resource file has been copied. {} exists already.\", fileName);\nOR\nlog.info(\"No resource file was copied. {} exists already.\", fileName);\n(grammar)", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498515814", "createdAt": "2020-10-01T21:12:19Z", "author": {"login": "ghubstan"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/StoreService.java", "diffHunk": "@@ -116,21 +116,25 @@ protected void makeFileFromResourceFile(String postFix) {\n                 e.printStackTrace();\n             }\n         } else {\n-            log.debug(fileName + \" file exists already.\");\n+            log.info(\"No resource file have been copied. {} exists already.\", fileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9446f2807d0d55297e0f60e5909d2a3447ec9154"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMzkzMA==", "bodyText": "Will fix.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498523930", "createdAt": "2020-10-01T21:32:44Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/StoreService.java", "diffHunk": "@@ -116,21 +116,25 @@ protected void makeFileFromResourceFile(String postFix) {\n                 e.printStackTrace();\n             }\n         } else {\n-            log.debug(fileName + \" file exists already.\");\n+            log.info(\"No resource file have been copied. {} exists already.\", fileName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTgxNA=="}, "originalCommit": {"oid": "9446f2807d0d55297e0f60e5909d2a3447ec9154"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDkyODQ3OnYy", "diffSide": "RIGHT", "path": "proto/src/main/proto/pb.proto", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToyMzo1NFrOHbbRzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTozMzo0MlrOHbbgkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMDUyNg==", "bodyText": "Shouldn't the proto msg field number be 1, not 21?\nint32 nonce = 1;", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498520526", "createdAt": "2020-10-01T21:23:54Z", "author": {"login": "ghubstan"}, "path": "proto/src/main/proto/pb.proto", "diffHunk": "@@ -95,6 +95,7 @@ message PreliminaryGetDataRequest {\n     int32 nonce = 21;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "384152fb6be8917c92dc825030b7355063964f18"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNDMwNw==", "bodyText": "Upps, will fix.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498524307", "createdAt": "2020-10-01T21:33:42Z", "author": {"login": "chimp1984"}, "path": "proto/src/main/proto/pb.proto", "diffHunk": "@@ -95,6 +95,7 @@ message PreliminaryGetDataRequest {\n     int32 nonce = 21;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMDUyNg=="}, "originalCommit": {"oid": "384152fb6be8917c92dc825030b7355063964f18"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDkzMjg5OnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToyNTo1OFrOHbbUvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTozNTo0N1rOHbbjzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTI3Ng==", "bodyText": "Needs license info comment?", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498521276", "createdAt": "2020-10-01T21:25:58Z", "author": {"login": "ghubstan"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNTEzMg==", "bodyText": "will add", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498525132", "createdAt": "2020-10-01T21:35:47Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTI3Ng=="}, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDkzMzIxOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/PersistableNetworkPayloadStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToyNjowNVrOHbbU8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTozNjoxOVrOHbbkmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTMzMA==", "bodyText": "Needs license info comment?", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498521330", "createdAt": "2020-10-01T21:26:05Z", "author": {"login": "ghubstan"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/PersistableNetworkPayloadStore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package bisq.network.p2p.storage.persistence;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e50e4c5d7e96790c4812c825b386761e01d48a7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNTMzNg==", "bodyText": "will add", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498525336", "createdAt": "2020-10-01T21:36:19Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/PersistableNetworkPayloadStore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package bisq.network.p2p.storage.persistence;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTMzMA=="}, "originalCommit": {"oid": "2e50e4c5d7e96790c4812c825b386761e01d48a7"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjEyNTY4OnYy", "diffSide": "RIGHT", "path": "proto/src/main/proto/pb.proto", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyNDozMFrOHbm_yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxMzo1MlrOHb3C9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMjUyMg==", "bodyText": "This is old indexing so the index has to be kept, we cannot just change the indexes since it's already in production.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498712522", "createdAt": "2020-10-02T09:24:30Z", "author": {"login": "sqrrm"}, "path": "proto/src/main/proto/pb.proto", "diffHunk": "@@ -92,7 +92,7 @@ message BundleOfEnvelopes {\n // get data\n \n message PreliminaryGetDataRequest {\n-    int32 nonce = 21;\n+    int32 nonce = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5027c861e3558014cfea5ed28e93c6de1d375e01"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3NTQ3OA==", "bodyText": "Ah true. I thought I have introduced that, but checked master and history and is indeed a old issue. Will revert it so it is 21 again. Will add a comment as well.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498975478", "createdAt": "2020-10-02T18:13:52Z", "author": {"login": "chimp1984"}, "path": "proto/src/main/proto/pb.proto", "diffHunk": "@@ -92,7 +92,7 @@ message BundleOfEnvelopes {\n // get data\n \n message PreliminaryGetDataRequest {\n-    int32 nonce = 21;\n+    int32 nonce = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMjUyMg=="}, "originalCommit": {"oid": "5027c861e3558014cfea5ed28e93c6de1d375e01"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjE1ODA0OnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTozNTozM1rOHbnUEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTozNTozM1rOHbnUEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNzcxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Otherwise we only add data if the requesters version is older then\n          \n          \n            \n                                // Otherwise we only add data if the requesters version is older than", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498717714", "createdAt": "2020-10-02T09:35:33Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjE2MzI2OnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTozNzozMVrOHbnXdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTozNzozMVrOHbnXdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxODU4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        \"As the requester version is not older as our historical store we do not \" +\n          \n          \n            \n                                        \"As the requester version is not older than our historical store we do not \" +", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498718583", "createdAt": "2020-10-02T09:37:31Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjIxMTkxOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOTo1NDoxNVrOHbn2Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoxOTowM1rOHb3T4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNjQzNA==", "bodyText": "I don't understand why this is done. First there is a check if the key exists in any map, then if if doesn't we add it and return what was there. Nothing should be there since we checked nothing was there.\nOnly thing I can think of is some handling some concurrency issue. I think a comment would be helpful here.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498726434", "createdAt": "2020-10-02T09:54:15Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +\n+                                    \"add the data to the result map.\";\n+                    log.info(\"The requester had version {}. Our historical data store has version {}.\\n{}\",\n+                            requestersVersion, storeVersion, details);\n+                    return newVersion;\n+                })\n+                .map(e -> e.getValue().getMap())\n+                .forEach(result::putAll);\n+\n+        log.info(\"We found {} entries since requesters version {}\",\n+                result.size(), requestersVersion);\n+        return result;\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfLiveData() {\n+        return store.getMap();\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfAllData() {\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(getMapOfLiveData());\n+        result.putAll(allHistoricalPayloads);\n+        return result;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // MapStoreService\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // TODO optimize so that callers to AppendOnlyDataStoreService are not invoking that often getMap\n+    // ProposalService is one of the main callers and could avoid it by using the ProposalStoreService directly\n+    // instead of AppendOnlyDataStoreService\n+\n+    // By default we return the live data only. This method should not be used by domain clients but rather the\n+    // custom methods getMapOfAllData, getMapOfLiveData or getMapSinceVersion\n+    @Override\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMap() {\n+        return store.getMap();\n+    }\n+\n+    @Override\n+    protected void put(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return;\n+        }\n+\n+        getMapOfLiveData().put(hash, payload);\n+        persist();\n+    }\n+\n+    @Override\n+    protected PersistableNetworkPayload putIfAbsent(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return null;\n+        }\n+\n+        PersistableNetworkPayload previous = getMapOfLiveData().put(hash, payload);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTgwOQ==", "bodyText": "Yes it will be always null, but we override the method signature from MapStoreService and follow the putIfAbsent signature from Map. In our special case it wil be always null. I can change it to make it more clear and add a comment.", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498979809", "createdAt": "2020-10-02T18:19:03Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +\n+                                    \"add the data to the result map.\";\n+                    log.info(\"The requester had version {}. Our historical data store has version {}.\\n{}\",\n+                            requestersVersion, storeVersion, details);\n+                    return newVersion;\n+                })\n+                .map(e -> e.getValue().getMap())\n+                .forEach(result::putAll);\n+\n+        log.info(\"We found {} entries since requesters version {}\",\n+                result.size(), requestersVersion);\n+        return result;\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfLiveData() {\n+        return store.getMap();\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfAllData() {\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(getMapOfLiveData());\n+        result.putAll(allHistoricalPayloads);\n+        return result;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // MapStoreService\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // TODO optimize so that callers to AppendOnlyDataStoreService are not invoking that often getMap\n+    // ProposalService is one of the main callers and could avoid it by using the ProposalStoreService directly\n+    // instead of AppendOnlyDataStoreService\n+\n+    // By default we return the live data only. This method should not be used by domain clients but rather the\n+    // custom methods getMapOfAllData, getMapOfLiveData or getMapSinceVersion\n+    @Override\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMap() {\n+        return store.getMap();\n+    }\n+\n+    @Override\n+    protected void put(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return;\n+        }\n+\n+        getMapOfLiveData().put(hash, payload);\n+        persist();\n+    }\n+\n+    @Override\n+    protected PersistableNetworkPayload putIfAbsent(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return null;\n+        }\n+\n+        PersistableNetworkPayload previous = getMapOfLiveData().put(hash, payload);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNjQzNA=="}, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjIzOTQ4OnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowMzo1N1rOHboHHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowMzo1N1rOHboHHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMDc4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int preLive = getMapOfLiveData().keySet().size();\n          \n          \n            \n                    int preLive = getMapOfLiveData().size();", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498730780", "createdAt": "2020-10-02T10:03:57Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +\n+                                    \"add the data to the result map.\";\n+                    log.info(\"The requester had version {}. Our historical data store has version {}.\\n{}\",\n+                            requestersVersion, storeVersion, details);\n+                    return newVersion;\n+                })\n+                .map(e -> e.getValue().getMap())\n+                .forEach(result::putAll);\n+\n+        log.info(\"We found {} entries since requesters version {}\",\n+                result.size(), requestersVersion);\n+        return result;\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfLiveData() {\n+        return store.getMap();\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfAllData() {\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(getMapOfLiveData());\n+        result.putAll(allHistoricalPayloads);\n+        return result;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // MapStoreService\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // TODO optimize so that callers to AppendOnlyDataStoreService are not invoking that often getMap\n+    // ProposalService is one of the main callers and could avoid it by using the ProposalStoreService directly\n+    // instead of AppendOnlyDataStoreService\n+\n+    // By default we return the live data only. This method should not be used by domain clients but rather the\n+    // custom methods getMapOfAllData, getMapOfLiveData or getMapSinceVersion\n+    @Override\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMap() {\n+        return store.getMap();\n+    }\n+\n+    @Override\n+    protected void put(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return;\n+        }\n+\n+        getMapOfLiveData().put(hash, payload);\n+        persist();\n+    }\n+\n+    @Override\n+    protected PersistableNetworkPayload putIfAbsent(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return null;\n+        }\n+\n+        PersistableNetworkPayload previous = getMapOfLiveData().put(hash, payload);\n+        persist();\n+        return previous;\n+    }\n+\n+\n+    @Override\n+    protected void readFromResources(String postFix) {\n+        readStore();\n+        log.info(\"We have created the {} store for the live data and filled it with {} entries from the persisted data.\",\n+                getFileName(), getMapOfLiveData().size());\n+\n+        // Now we add our historical data stores. As they are immutable after created we use an ImmutableMap\n+        ImmutableMap.Builder<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloadsBuilder = ImmutableMap.builder();\n+        ImmutableMap.Builder<String, PersistableNetworkPayloadStore> storesByVersionBuilder = ImmutableMap.builder();\n+\n+        Version.HISTORY.forEach(version -> readHistoricalStoreFromResources(version, postFix, allHistoricalPayloadsBuilder, storesByVersionBuilder));\n+\n+        allHistoricalPayloads = allHistoricalPayloadsBuilder.build();\n+        storesByVersion = storesByVersionBuilder.build();\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Private\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private void readHistoricalStoreFromResources(String version,\n+                                                  String postFix,\n+                                                  ImmutableMap.Builder<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalDataBuilder,\n+                                                  ImmutableMap.Builder<String, PersistableNetworkPayloadStore> storesByVersionBuilder) {\n+        String fileName = getFileName() + \"_\" + version;\n+        boolean wasCreatedFromResources = makeFileFromResourceFile(fileName, postFix);\n+\n+        // If resource file does not exist we return null. We do not create a new store as it would never get filled.\n+        PersistableNetworkPayloadStore historicalStore = storage.getPersisted(fileName);\n+        if (historicalStore == null) {\n+            log.warn(\"Resource file with file name {} does not exits.\", fileName);\n+            return;\n+        }\n+\n+        storesByVersionBuilder.put(version, historicalStore);\n+        allHistoricalDataBuilder.putAll(historicalStore.getMap());\n+\n+        if (wasCreatedFromResources) {\n+            pruneStore(historicalStore, version);\n+        }\n+    }\n+\n+    private void pruneStore(PersistableNetworkPayloadStore historicalStore, String version) {\n+        int preLive = getMapOfLiveData().keySet().size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI2MzgzOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMjo0NFrOHboWMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMjo0NFrOHboWMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNDY0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                }\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                }\n          \n          \n            \n                                map.putAll(serviceMap);", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498734643", "createdAt": "2020-10-02T10:12:44Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "diffHunk": "@@ -293,6 +300,57 @@ public GetDataResponse buildGetDataResponse(\n                 getDataRequest instanceof GetUpdatedDataRequest);\n     }\n \n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Utils for collecting the exclude hashes\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataRequest() {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        // As we add the version to our request we only use the live data. Eventually missing data will be\n+                        // derived from the version.\n+                        serviceMap = historicalDataStoreService.getMapOfLiveData();\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62836d79f5e6b15c14546069106abaf57e813abf"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI2NjMwOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMzozM1rOHboXug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMzozM1rOHboXug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNTAzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                }\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                }\n          \n          \n            \n                                map.putAll(serviceMap);", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498735034", "createdAt": "2020-10-02T10:13:33Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "diffHunk": "@@ -293,6 +300,57 @@ public GetDataResponse buildGetDataResponse(\n                 getDataRequest instanceof GetUpdatedDataRequest);\n     }\n \n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Utils for collecting the exclude hashes\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataRequest() {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        // As we add the version to our request we only use the live data. Eventually missing data will be\n+                        // derived from the version.\n+                        serviceMap = historicalDataStoreService.getMapOfLiveData();\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }\n+                    log.info(\"We added {} entries from {} to the excluded key set of our request\",\n+                            serviceMap.size(), service.getClass().getSimpleName());\n+                });\n+        return map;\n+    }\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataResponse(String requestersVersion) {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        serviceMap = historicalDataStoreService.getMapSinceVersion(requestersVersion);\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62836d79f5e6b15c14546069106abaf57e813abf"}, "originalPosition": 170}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2374, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}