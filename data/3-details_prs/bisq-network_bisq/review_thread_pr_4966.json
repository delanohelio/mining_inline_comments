{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMDE4ODI1", "number": 4966, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyMTo1MlrOFII2_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMjowNjo1M1rOFIjnZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc4MDc4OnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/CallRateMeteringInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyMTo1MlrOIJ5UFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOToyOToyNVrOIKGxgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzEyNQ==", "bodyText": "This should probably be a log.warn as it's not an error but rather expected when the rate limit is exceeded. Might consider changing the method name as well for the same reason.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547247125", "createdAt": "2020-12-22T12:21:52Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/CallRateMeteringInterceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.StatusRuntimeException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.grpc.Status.FAILED_PRECONDITION;\n+import static io.grpc.Status.PERMISSION_DENIED;\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class CallRateMeteringInterceptor implements ServerInterceptor {\n+\n+    // Maps the gRPC server method names to rate meters.  This allows one interceptor\n+    // instance to handle rate metering for any or all the methods in a Grpc*Service.\n+    protected final Map<String, GrpcCallRateMeter> serviceCallRateMeters;\n+\n+    public CallRateMeteringInterceptor(Map<String, GrpcCallRateMeter> serviceCallRateMeters) {\n+        this.serviceCallRateMeters = serviceCallRateMeters;\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> serverCall,\n+                                                                 Metadata headers,\n+                                                                 ServerCallHandler<ReqT, RespT> serverCallHandler) {\n+        Optional<Map.Entry<String, GrpcCallRateMeter>> rateMeterKV = getRateMeterKV(serverCall);\n+        rateMeterKV.ifPresentOrElse(\n+                (kv) -> checkRateMeterAndMaybeCloseCall(kv, serverCall),\n+                () -> handleInterceptorConfigErrorAndCloseCall(serverCall));\n+\n+        // We leave it to the gRPC framework to clean up if the server call was closed\n+        // above.  But we still have to invoke startCall here because the method must\n+        // return a ServerCall.Listener<RequestT>.\n+        return serverCallHandler.startCall(serverCall, headers);\n+    }\n+\n+    private void checkRateMeterAndMaybeCloseCall(Map.Entry<String, GrpcCallRateMeter> rateMeterKV,\n+                                                 ServerCall<?, ?> serverCall) {\n+        String methodName = rateMeterKV.getKey();\n+        GrpcCallRateMeter rateMeter = rateMeterKV.getValue();\n+\n+        // The service method's rate meter doesn't start running until the 1st call.\n+        if (!rateMeter.isRunning())\n+            rateMeter.start();\n+\n+        rateMeter.incrementCallsCount();\n+\n+        if (rateMeter.isCallRateExceeded())\n+            handlePermissionDeniedErrorAndCloseCall(methodName, rateMeter, serverCall);\n+        else\n+            log.info(rateMeter.getCallsCountProgress(methodName));\n+    }\n+\n+    private void handleInterceptorConfigErrorAndCloseCall(ServerCall<?, ?> serverCall)\n+            throws StatusRuntimeException {\n+        String methodName = getRateMeterKey(serverCall);\n+        String msg = format(\"%s's rate metering interceptor is incorrectly configured;\"\n+                        + \"  its rate meter cannot be found \",\n+                methodName);\n+        log.error(StringUtils.capitalize(msg) + \".\");\n+        serverCall.close(FAILED_PRECONDITION.withDescription(msg), new Metadata());\n+    }\n+\n+    private void handlePermissionDeniedErrorAndCloseCall(String methodName,\n+                                                         GrpcCallRateMeter rateMeter,\n+                                                         ServerCall<?, ?> serverCall)\n+            throws StatusRuntimeException {\n+        String msg = getDefaultRateExceededError(methodName, rateMeter);\n+        log.error(StringUtils.capitalize(msg) + \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ2NzY0OQ==", "bodyText": "Fixed in commit 01546ad.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547467649", "createdAt": "2020-12-22T19:29:25Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/CallRateMeteringInterceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.StatusRuntimeException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.grpc.Status.FAILED_PRECONDITION;\n+import static io.grpc.Status.PERMISSION_DENIED;\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class CallRateMeteringInterceptor implements ServerInterceptor {\n+\n+    // Maps the gRPC server method names to rate meters.  This allows one interceptor\n+    // instance to handle rate metering for any or all the methods in a Grpc*Service.\n+    protected final Map<String, GrpcCallRateMeter> serviceCallRateMeters;\n+\n+    public CallRateMeteringInterceptor(Map<String, GrpcCallRateMeter> serviceCallRateMeters) {\n+        this.serviceCallRateMeters = serviceCallRateMeters;\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> serverCall,\n+                                                                 Metadata headers,\n+                                                                 ServerCallHandler<ReqT, RespT> serverCallHandler) {\n+        Optional<Map.Entry<String, GrpcCallRateMeter>> rateMeterKV = getRateMeterKV(serverCall);\n+        rateMeterKV.ifPresentOrElse(\n+                (kv) -> checkRateMeterAndMaybeCloseCall(kv, serverCall),\n+                () -> handleInterceptorConfigErrorAndCloseCall(serverCall));\n+\n+        // We leave it to the gRPC framework to clean up if the server call was closed\n+        // above.  But we still have to invoke startCall here because the method must\n+        // return a ServerCall.Listener<RequestT>.\n+        return serverCallHandler.startCall(serverCall, headers);\n+    }\n+\n+    private void checkRateMeterAndMaybeCloseCall(Map.Entry<String, GrpcCallRateMeter> rateMeterKV,\n+                                                 ServerCall<?, ?> serverCall) {\n+        String methodName = rateMeterKV.getKey();\n+        GrpcCallRateMeter rateMeter = rateMeterKV.getValue();\n+\n+        // The service method's rate meter doesn't start running until the 1st call.\n+        if (!rateMeter.isRunning())\n+            rateMeter.start();\n+\n+        rateMeter.incrementCallsCount();\n+\n+        if (rateMeter.isCallRateExceeded())\n+            handlePermissionDeniedErrorAndCloseCall(methodName, rateMeter, serverCall);\n+        else\n+            log.info(rateMeter.getCallsCountProgress(methodName));\n+    }\n+\n+    private void handleInterceptorConfigErrorAndCloseCall(ServerCall<?, ?> serverCall)\n+            throws StatusRuntimeException {\n+        String methodName = getRateMeterKey(serverCall);\n+        String msg = format(\"%s's rate metering interceptor is incorrectly configured;\"\n+                        + \"  its rate meter cannot be found \",\n+                methodName);\n+        log.error(StringUtils.capitalize(msg) + \".\");\n+        serverCall.close(FAILED_PRECONDITION.withDescription(msg), new Metadata());\n+    }\n+\n+    private void handlePermissionDeniedErrorAndCloseCall(String methodName,\n+                                                         GrpcCallRateMeter rateMeter,\n+                                                         ServerCall<?, ?> serverCall)\n+            throws StatusRuntimeException {\n+        String msg = getDefaultRateExceededError(methodName, rateMeter);\n+        log.error(StringUtils.capitalize(msg) + \".\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzEyNQ=="}, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg3MzYyOnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo1Mjo1NVrOIJ6KKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOToyNzo0MlrOIKGt9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MDk2OQ==", "bodyText": "I find this a bit odd. I think it makes more sense to set the time window in seconds and just have a int with number of seconds in the time window.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547260969", "createdAt": "2020-12-22T12:52:55Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class GrpcCallRateMeter {\n+\n+    @Getter\n+    private final long allowedCallsPerTimeUnit;\n+    @Getter\n+    private final TimeUnit timeUnit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ2Njc0MQ==", "bodyText": "Fixed in commit 01546ad.  The rate meter can still use a DAYS and HOURS TimeUnit, though I supposed most method rate meters will restrict calls on a per second basis.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547466741", "createdAt": "2020-12-22T19:27:42Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class GrpcCallRateMeter {\n+\n+    @Getter\n+    private final long allowedCallsPerTimeUnit;\n+    @Getter\n+    private final TimeUnit timeUnit;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MDk2OQ=="}, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg4NDAyOnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo1NjowNlrOIJ6QMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOToyNDo1MVrOIKGlNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjUxMw==", "bodyText": "My expectation is to have a moving time window with the rate limit. The way it's done now I can send double the max amount if I send all at the end of the first period and then continues at the beginning of the second period.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547262513", "createdAt": "2020-12-22T12:56:06Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class GrpcCallRateMeter {\n+\n+    @Getter\n+    private final long allowedCallsPerTimeUnit;\n+    @Getter\n+    private final TimeUnit timeUnit;\n+\n+    @Getter\n+    private long callsCount = 0;\n+\n+    @Getter\n+    private boolean isRunning;\n+\n+    @Nullable\n+    private Timer timer;\n+\n+    public GrpcCallRateMeter(long allowedCallsPerTimeUnit, TimeUnit timeUnit) {\n+        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n+        this.timeUnit = timeUnit;\n+    }\n+\n+    public void start() {\n+        if (timer != null)\n+            timer.stop();\n+\n+        timer = UserThread.runPeriodically(() -> callsCount = 0, 1, timeUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ2NDUwMw==", "bodyText": "I rewrote the rate meter class in commit 01546ad.  There is a running call count over the current time window, instead of using this timer (oops).", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547464503", "createdAt": "2020-12-22T19:24:51Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package bisq.daemon.grpc.interceptor;\n+\n+import bisq.common.Timer;\n+import bisq.common.UserThread;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nullable;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+public final class GrpcCallRateMeter {\n+\n+    @Getter\n+    private final long allowedCallsPerTimeUnit;\n+    @Getter\n+    private final TimeUnit timeUnit;\n+\n+    @Getter\n+    private long callsCount = 0;\n+\n+    @Getter\n+    private boolean isRunning;\n+\n+    @Nullable\n+    private Timer timer;\n+\n+    public GrpcCallRateMeter(long allowedCallsPerTimeUnit, TimeUnit timeUnit) {\n+        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n+        this.timeUnit = timeUnit;\n+    }\n+\n+    public void start() {\n+        if (timer != null)\n+            timer.stop();\n+\n+        timer = UserThread.runPeriodically(() -> callsCount = 0, 1, timeUnit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjUxMw=="}, "originalCommit": {"oid": "2148a4d9587f5da8e2d965182c5b4a86c6bc34fa"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDk2NTYyOnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcServiceRateMeteringConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzoyMjoxMlrOIJ6_jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOToyMDowN1rOIKGVIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3NDYzNw==", "bodyText": "Not sure this is right unless it's only supposed to work on *nix.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547274637", "createdAt": "2020-12-22T13:22:12Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcServiceRateMeteringConfig.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.daemon.grpc.interceptor;\n+\n+import io.grpc.ServerInterceptor;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.nio.file.Paths;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static bisq.common.file.FileUtil.deleteFileIfExists;\n+import static bisq.common.file.FileUtil.renameFile;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.lang.String.format;\n+import static java.lang.System.getProperty;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.Files.readAllBytes;\n+\n+@VisibleForTesting\n+@Slf4j\n+public class GrpcServiceRateMeteringConfig {\n+\n+    public static final String RATE_METERS_CONFIG_FILENAME = \"ratemeters.json\";\n+\n+    private static final String KEY_GRPC_SERVICE_CLASS_NAME = \"grpcServiceClassName\";\n+    private static final String KEY_METHOD_RATE_METERS = \"methodRateMeters\";\n+    private static final String KEY_ALLOWED_CALL_PER_TIME_UNIT = \"allowedCallsPerTimeUnit\";\n+    private static final String KEY_TIME_UNIT = \"timeUnit\";\n+\n+    private static final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+\n+    private final List<Map<String, GrpcCallRateMeter>> methodRateMeters;\n+    private final String grpcServiceClassName;\n+\n+    public GrpcServiceRateMeteringConfig(String grpcServiceClassName) {\n+        this(grpcServiceClassName, new ArrayList<>());\n+    }\n+\n+    public GrpcServiceRateMeteringConfig(String grpcServiceClassName,\n+                                         List<Map<String, GrpcCallRateMeter>> methodRateMeters) {\n+        this.grpcServiceClassName = grpcServiceClassName;\n+        this.methodRateMeters = methodRateMeters;\n+    }\n+\n+    public GrpcServiceRateMeteringConfig addMethodCallRateMeter(String methodName,\n+                                                                int maxCalls,\n+                                                                TimeUnit timeUnit) {\n+        methodRateMeters.add(new LinkedHashMap<>() {{\n+            put(methodName, new GrpcCallRateMeter(maxCalls, timeUnit));\n+        }});\n+        return this;\n+    }\n+\n+    public boolean isConfigForGrpcService(Class<?> clazz) {\n+        return isConfigForGrpcService(clazz.getSimpleName());\n+    }\n+\n+    public boolean isConfigForGrpcService(String grpcServiceClassSimpleName) {\n+        return this.grpcServiceClassName.equals(grpcServiceClassSimpleName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"GrpcServiceRateMeteringConfig{\" + \"\\n\" +\n+                \"  grpcServiceClassName='\" + grpcServiceClassName + '\\'' + \"\\n\" +\n+                \", methodRateMeters=\" + methodRateMeters + \"\\n\" +\n+                '}';\n+    }\n+\n+    public static Optional<ServerInterceptor> getCustomRateMeteringInterceptor(File installationDir,\n+                                                                               Class<?> grpcServiceClass) {\n+        File configFile = new File(installationDir, RATE_METERS_CONFIG_FILENAME);\n+        return configFile.exists()\n+                ? toServerInterceptor(configFile, grpcServiceClass)\n+                : Optional.empty();\n+    }\n+\n+    public static Optional<ServerInterceptor> toServerInterceptor(File configFile, Class<?> grpcServiceClass) {\n+        // From a global rate metering config file, create a specific gRPC service\n+        // interceptor configuration in the form of an interceptor constructor argument,\n+        // a map<method-name, rate-meter>.\n+        // Transforming json into the List<Map<String, GrpcCallRateMeter>> is a bit\n+        // convoluted due to Gson's loss of generic type information during deserialization.\n+        Optional<GrpcServiceRateMeteringConfig> grpcServiceConfig = getAllDeserializedConfigs(configFile)\n+                .stream().filter(x -> x.isConfigForGrpcService(grpcServiceClass)).findFirst();\n+        if (grpcServiceConfig.isPresent()) {\n+            Map<String, GrpcCallRateMeter> serviceCallRateMeters = new HashMap<>();\n+            for (Map<String, GrpcCallRateMeter> methodToRateMeterMap : grpcServiceConfig.get().methodRateMeters) {\n+                Map.Entry<String, GrpcCallRateMeter> entry = methodToRateMeterMap.entrySet().stream().findFirst().orElseThrow(()\n+                        -> new IllegalStateException(\"Gson deserialized a method rate meter configuration into an empty map.\"));\n+                serviceCallRateMeters.put(entry.getKey(), entry.getValue());\n+            }\n+            return Optional.of(new CallRateMeteringInterceptor(serviceCallRateMeters));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static List<Map<String, GrpcCallRateMeter>> getMethodRateMetersMap(Map<String, Object> gsonMap) {\n+        List<Map<String, GrpcCallRateMeter>> rateMeters = new ArrayList<>();\n+        // Each gsonMap is a Map<String, Object> with a single entry:\n+        // {getVersion={allowedCallsPerTimeUnit=8.0, timeUnit=SECONDS, callsCount=0.0, isRunning=false}}\n+        // Convert it to a multiple entry Map<String, GrpcCallRateMeter>, where the key\n+        // is a method name.\n+        for (Map<String, Object> singleEntryRateMeterMap : (List<Map<String, Object>>) gsonMap.get(KEY_METHOD_RATE_METERS)) {\n+            log.debug(\"Gson's single entry {} {}<String, Object> = {}\",\n+                    gsonMap.get(KEY_GRPC_SERVICE_CLASS_NAME),\n+                    singleEntryRateMeterMap.getClass().getSimpleName(),\n+                    singleEntryRateMeterMap);\n+            Map.Entry<String, Object> entry = singleEntryRateMeterMap.entrySet().stream().findFirst().orElseThrow(()\n+                    -> new IllegalStateException(\"Gson deserialized a method rate meter configuration into an empty map.\"));\n+            String methodName = entry.getKey();\n+            GrpcCallRateMeter rateMeter = getGrpcCallRateMeter(entry);\n+            rateMeters.add(new LinkedHashMap<>() {{\n+                put(methodName, rateMeter);\n+            }});\n+        }\n+        return rateMeters;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static List<GrpcServiceRateMeteringConfig> deserialize(File configFile) {\n+        verifyConfigFile(configFile);\n+        List<GrpcServiceRateMeteringConfig> serviceMethodConfigurations = new ArrayList<>();\n+        // Gson cannot deserialize a json string to List<GrpcServiceRateMeteringConfig>\n+        // so easily for us, so we do it here before returning the list of configurations.\n+        List rawConfigList = gson.fromJson(toJson(configFile), ArrayList.class);\n+        // Gson gave us a list of maps with keys grpcServiceClassName, methodRateMeters:\n+        //          String grpcServiceClassName\n+        //          List<Map> methodRateMeters\n+        for (Object rawConfig : rawConfigList) {\n+            Map<String, Object> gsonMap = (Map<String, Object>) rawConfig;\n+            String grpcServiceClassName = (String) gsonMap.get(KEY_GRPC_SERVICE_CLASS_NAME);\n+            List<Map<String, GrpcCallRateMeter>> rateMeters = getMethodRateMetersMap(gsonMap);\n+            serviceMethodConfigurations.add(new GrpcServiceRateMeteringConfig(grpcServiceClassName, rateMeters));\n+        }\n+        return serviceMethodConfigurations;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static GrpcCallRateMeter getGrpcCallRateMeter(Map.Entry<String, Object> gsonEntry) {\n+        Map<String, Object> valueMap = (Map<String, Object>) gsonEntry.getValue();\n+        int allowedCallsPerTimeUnit = ((Number) valueMap.get(KEY_ALLOWED_CALL_PER_TIME_UNIT)).intValue();\n+        TimeUnit timeUnit = TimeUnit.valueOf((String) valueMap.get(KEY_TIME_UNIT));\n+        return new GrpcCallRateMeter(allowedCallsPerTimeUnit, timeUnit);\n+    }\n+\n+    private static void verifyConfigFile(File configFile) {\n+        if (configFile == null)\n+            throw new IllegalStateException(\"Cannot read null json config file.\");\n+\n+        if (!configFile.exists())\n+            throw new IllegalStateException(format(\"cannot find json config file %s\", configFile.getAbsolutePath()));\n+    }\n+\n+    private static String toJson(File configFile) {\n+        try {\n+            return new String(readAllBytes(Paths.get(configFile.getAbsolutePath())));\n+        } catch (IOException ex) {\n+            throw new IllegalStateException(format(\"Cannot read json string from file %s.\",\n+                    configFile.getAbsolutePath()));\n+        }\n+    }\n+\n+    private static List<GrpcServiceRateMeteringConfig> allDeserializedConfigs;\n+\n+    private static List<GrpcServiceRateMeteringConfig> getAllDeserializedConfigs(File configFile) {\n+        // We deserialize once, not for each gRPC service wanting an interceptor.\n+        if (allDeserializedConfigs == null)\n+            allDeserializedConfigs = deserialize(configFile);\n+\n+        return allDeserializedConfigs;\n+    }\n+\n+    @VisibleForTesting\n+    public static class Builder {\n+        private final List<GrpcServiceRateMeteringConfig> rateMeterConfigs = new ArrayList<>();\n+\n+        public void addCallRateMeter(String grpcServiceClassName,\n+                                     String methodName,\n+                                     int maxCalls,\n+                                     TimeUnit timeUnit) {\n+            log.info(\"Adding call rate metering definition {}.{} ({}/{}).\",\n+                    grpcServiceClassName,\n+                    methodName,\n+                    maxCalls,\n+                    StringUtils.chop(timeUnit.name().toLowerCase()));\n+            rateMeterConfigs.stream().filter(c -> c.isConfigForGrpcService(grpcServiceClassName))\n+                    .findFirst().ifPresentOrElse(\n+                    (config) -> config.addMethodCallRateMeter(methodName, maxCalls, timeUnit),\n+                    () -> rateMeterConfigs.add(new GrpcServiceRateMeteringConfig(grpcServiceClassName)\n+                            .addMethodCallRateMeter(methodName, maxCalls, timeUnit)));\n+        }\n+\n+        public File build() {\n+            File tmpFile = serializeRateMeterDefinitions();\n+            File configFile = new File(\"/tmp/ratemeters.json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307593c82a86c047b9b3c21551af5ed59c088c1"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ2MDM4Nw==", "bodyText": "It is only supposed to work on *nix but I changed line 233 to\nFile configFile = Paths.get(getProperty(\"java.io.tmpdir\"), \"ratemeters.json\").toFile();\n(Commit 01546ad)", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547460387", "createdAt": "2020-12-22T19:20:07Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcServiceRateMeteringConfig.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.daemon.grpc.interceptor;\n+\n+import io.grpc.ServerInterceptor;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.nio.file.Paths;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static bisq.common.file.FileUtil.deleteFileIfExists;\n+import static bisq.common.file.FileUtil.renameFile;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static java.lang.String.format;\n+import static java.lang.System.getProperty;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.Files.readAllBytes;\n+\n+@VisibleForTesting\n+@Slf4j\n+public class GrpcServiceRateMeteringConfig {\n+\n+    public static final String RATE_METERS_CONFIG_FILENAME = \"ratemeters.json\";\n+\n+    private static final String KEY_GRPC_SERVICE_CLASS_NAME = \"grpcServiceClassName\";\n+    private static final String KEY_METHOD_RATE_METERS = \"methodRateMeters\";\n+    private static final String KEY_ALLOWED_CALL_PER_TIME_UNIT = \"allowedCallsPerTimeUnit\";\n+    private static final String KEY_TIME_UNIT = \"timeUnit\";\n+\n+    private static final Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+\n+    private final List<Map<String, GrpcCallRateMeter>> methodRateMeters;\n+    private final String grpcServiceClassName;\n+\n+    public GrpcServiceRateMeteringConfig(String grpcServiceClassName) {\n+        this(grpcServiceClassName, new ArrayList<>());\n+    }\n+\n+    public GrpcServiceRateMeteringConfig(String grpcServiceClassName,\n+                                         List<Map<String, GrpcCallRateMeter>> methodRateMeters) {\n+        this.grpcServiceClassName = grpcServiceClassName;\n+        this.methodRateMeters = methodRateMeters;\n+    }\n+\n+    public GrpcServiceRateMeteringConfig addMethodCallRateMeter(String methodName,\n+                                                                int maxCalls,\n+                                                                TimeUnit timeUnit) {\n+        methodRateMeters.add(new LinkedHashMap<>() {{\n+            put(methodName, new GrpcCallRateMeter(maxCalls, timeUnit));\n+        }});\n+        return this;\n+    }\n+\n+    public boolean isConfigForGrpcService(Class<?> clazz) {\n+        return isConfigForGrpcService(clazz.getSimpleName());\n+    }\n+\n+    public boolean isConfigForGrpcService(String grpcServiceClassSimpleName) {\n+        return this.grpcServiceClassName.equals(grpcServiceClassSimpleName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"GrpcServiceRateMeteringConfig{\" + \"\\n\" +\n+                \"  grpcServiceClassName='\" + grpcServiceClassName + '\\'' + \"\\n\" +\n+                \", methodRateMeters=\" + methodRateMeters + \"\\n\" +\n+                '}';\n+    }\n+\n+    public static Optional<ServerInterceptor> getCustomRateMeteringInterceptor(File installationDir,\n+                                                                               Class<?> grpcServiceClass) {\n+        File configFile = new File(installationDir, RATE_METERS_CONFIG_FILENAME);\n+        return configFile.exists()\n+                ? toServerInterceptor(configFile, grpcServiceClass)\n+                : Optional.empty();\n+    }\n+\n+    public static Optional<ServerInterceptor> toServerInterceptor(File configFile, Class<?> grpcServiceClass) {\n+        // From a global rate metering config file, create a specific gRPC service\n+        // interceptor configuration in the form of an interceptor constructor argument,\n+        // a map<method-name, rate-meter>.\n+        // Transforming json into the List<Map<String, GrpcCallRateMeter>> is a bit\n+        // convoluted due to Gson's loss of generic type information during deserialization.\n+        Optional<GrpcServiceRateMeteringConfig> grpcServiceConfig = getAllDeserializedConfigs(configFile)\n+                .stream().filter(x -> x.isConfigForGrpcService(grpcServiceClass)).findFirst();\n+        if (grpcServiceConfig.isPresent()) {\n+            Map<String, GrpcCallRateMeter> serviceCallRateMeters = new HashMap<>();\n+            for (Map<String, GrpcCallRateMeter> methodToRateMeterMap : grpcServiceConfig.get().methodRateMeters) {\n+                Map.Entry<String, GrpcCallRateMeter> entry = methodToRateMeterMap.entrySet().stream().findFirst().orElseThrow(()\n+                        -> new IllegalStateException(\"Gson deserialized a method rate meter configuration into an empty map.\"));\n+                serviceCallRateMeters.put(entry.getKey(), entry.getValue());\n+            }\n+            return Optional.of(new CallRateMeteringInterceptor(serviceCallRateMeters));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static List<Map<String, GrpcCallRateMeter>> getMethodRateMetersMap(Map<String, Object> gsonMap) {\n+        List<Map<String, GrpcCallRateMeter>> rateMeters = new ArrayList<>();\n+        // Each gsonMap is a Map<String, Object> with a single entry:\n+        // {getVersion={allowedCallsPerTimeUnit=8.0, timeUnit=SECONDS, callsCount=0.0, isRunning=false}}\n+        // Convert it to a multiple entry Map<String, GrpcCallRateMeter>, where the key\n+        // is a method name.\n+        for (Map<String, Object> singleEntryRateMeterMap : (List<Map<String, Object>>) gsonMap.get(KEY_METHOD_RATE_METERS)) {\n+            log.debug(\"Gson's single entry {} {}<String, Object> = {}\",\n+                    gsonMap.get(KEY_GRPC_SERVICE_CLASS_NAME),\n+                    singleEntryRateMeterMap.getClass().getSimpleName(),\n+                    singleEntryRateMeterMap);\n+            Map.Entry<String, Object> entry = singleEntryRateMeterMap.entrySet().stream().findFirst().orElseThrow(()\n+                    -> new IllegalStateException(\"Gson deserialized a method rate meter configuration into an empty map.\"));\n+            String methodName = entry.getKey();\n+            GrpcCallRateMeter rateMeter = getGrpcCallRateMeter(entry);\n+            rateMeters.add(new LinkedHashMap<>() {{\n+                put(methodName, rateMeter);\n+            }});\n+        }\n+        return rateMeters;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static List<GrpcServiceRateMeteringConfig> deserialize(File configFile) {\n+        verifyConfigFile(configFile);\n+        List<GrpcServiceRateMeteringConfig> serviceMethodConfigurations = new ArrayList<>();\n+        // Gson cannot deserialize a json string to List<GrpcServiceRateMeteringConfig>\n+        // so easily for us, so we do it here before returning the list of configurations.\n+        List rawConfigList = gson.fromJson(toJson(configFile), ArrayList.class);\n+        // Gson gave us a list of maps with keys grpcServiceClassName, methodRateMeters:\n+        //          String grpcServiceClassName\n+        //          List<Map> methodRateMeters\n+        for (Object rawConfig : rawConfigList) {\n+            Map<String, Object> gsonMap = (Map<String, Object>) rawConfig;\n+            String grpcServiceClassName = (String) gsonMap.get(KEY_GRPC_SERVICE_CLASS_NAME);\n+            List<Map<String, GrpcCallRateMeter>> rateMeters = getMethodRateMetersMap(gsonMap);\n+            serviceMethodConfigurations.add(new GrpcServiceRateMeteringConfig(grpcServiceClassName, rateMeters));\n+        }\n+        return serviceMethodConfigurations;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static GrpcCallRateMeter getGrpcCallRateMeter(Map.Entry<String, Object> gsonEntry) {\n+        Map<String, Object> valueMap = (Map<String, Object>) gsonEntry.getValue();\n+        int allowedCallsPerTimeUnit = ((Number) valueMap.get(KEY_ALLOWED_CALL_PER_TIME_UNIT)).intValue();\n+        TimeUnit timeUnit = TimeUnit.valueOf((String) valueMap.get(KEY_TIME_UNIT));\n+        return new GrpcCallRateMeter(allowedCallsPerTimeUnit, timeUnit);\n+    }\n+\n+    private static void verifyConfigFile(File configFile) {\n+        if (configFile == null)\n+            throw new IllegalStateException(\"Cannot read null json config file.\");\n+\n+        if (!configFile.exists())\n+            throw new IllegalStateException(format(\"cannot find json config file %s\", configFile.getAbsolutePath()));\n+    }\n+\n+    private static String toJson(File configFile) {\n+        try {\n+            return new String(readAllBytes(Paths.get(configFile.getAbsolutePath())));\n+        } catch (IOException ex) {\n+            throw new IllegalStateException(format(\"Cannot read json string from file %s.\",\n+                    configFile.getAbsolutePath()));\n+        }\n+    }\n+\n+    private static List<GrpcServiceRateMeteringConfig> allDeserializedConfigs;\n+\n+    private static List<GrpcServiceRateMeteringConfig> getAllDeserializedConfigs(File configFile) {\n+        // We deserialize once, not for each gRPC service wanting an interceptor.\n+        if (allDeserializedConfigs == null)\n+            allDeserializedConfigs = deserialize(configFile);\n+\n+        return allDeserializedConfigs;\n+    }\n+\n+    @VisibleForTesting\n+    public static class Builder {\n+        private final List<GrpcServiceRateMeteringConfig> rateMeterConfigs = new ArrayList<>();\n+\n+        public void addCallRateMeter(String grpcServiceClassName,\n+                                     String methodName,\n+                                     int maxCalls,\n+                                     TimeUnit timeUnit) {\n+            log.info(\"Adding call rate metering definition {}.{} ({}/{}).\",\n+                    grpcServiceClassName,\n+                    methodName,\n+                    maxCalls,\n+                    StringUtils.chop(timeUnit.name().toLowerCase()));\n+            rateMeterConfigs.stream().filter(c -> c.isConfigForGrpcService(grpcServiceClassName))\n+                    .findFirst().ifPresentOrElse(\n+                    (config) -> config.addMethodCallRateMeter(methodName, maxCalls, timeUnit),\n+                    () -> rateMeterConfigs.add(new GrpcServiceRateMeteringConfig(grpcServiceClassName)\n+                            .addMethodCallRateMeter(methodName, maxCalls, timeUnit)));\n+        }\n+\n+        public File build() {\n+            File tmpFile = serializeRateMeterDefinitions();\n+            File configFile = new File(\"/tmp/ratemeters.json\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3NDYzNw=="}, "originalCommit": {"oid": "b307593c82a86c047b9b3c21551af5ed59c088c1"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTE1NTE3OnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMjowMzo0M1rOIKiuig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNDozMTo0OFrOIKmcAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNTY0Mg==", "bodyText": "allowedCallsPerTimeUnit is a bit misleading as it's really allowedCallsPerTimeWindow.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547925642", "createdAt": "2020-12-23T12:03:43Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -1,95 +1,92 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package bisq.daemon.grpc.interceptor;\n \n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-\n import org.apache.commons.lang3.StringUtils;\n \n+import java.util.ArrayDeque;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n \n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n \n-import javax.annotation.Nullable;\n-\n import static java.lang.String.format;\n+import static java.lang.System.currentTimeMillis;\n \n @Slf4j\n-public final class GrpcCallRateMeter {\n+public class GrpcCallRateMeter {\n \n     @Getter\n     private final int allowedCallsPerTimeUnit;\n     @Getter\n     private final TimeUnit timeUnit;\n     @Getter\n-    private int callsCount = 0;\n+    private final int numTimeUnits;\n+\n     @Getter\n-    private transient boolean isRunning;\n+    private transient final long timeUnitIntervalInMilliseconds;\n \n-    @Nullable\n-    private Timer timer;\n+    private transient final ArrayDeque<Long> callTimestamps;\n \n     public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c5a2965938096dd25cca64457e4528f3e3d92c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4NjQzNA==", "bodyText": "Fixed in commit 10727fc.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547986434", "createdAt": "2020-12-23T14:31:48Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -1,95 +1,92 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package bisq.daemon.grpc.interceptor;\n \n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-\n import org.apache.commons.lang3.StringUtils;\n \n+import java.util.ArrayDeque;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n \n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n \n-import javax.annotation.Nullable;\n-\n import static java.lang.String.format;\n+import static java.lang.System.currentTimeMillis;\n \n @Slf4j\n-public final class GrpcCallRateMeter {\n+public class GrpcCallRateMeter {\n \n     @Getter\n     private final int allowedCallsPerTimeUnit;\n     @Getter\n     private final TimeUnit timeUnit;\n     @Getter\n-    private int callsCount = 0;\n+    private final int numTimeUnits;\n+\n     @Getter\n-    private transient boolean isRunning;\n+    private transient final long timeUnitIntervalInMilliseconds;\n \n-    @Nullable\n-    private Timer timer;\n+    private transient final ArrayDeque<Long> callTimestamps;\n \n     public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNTY0Mg=="}, "originalCommit": {"oid": "b8c5a2965938096dd25cca64457e4528f3e3d92c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTE2NDUzOnYy", "diffSide": "RIGHT", "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMjowNjo1M1rOIKizpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNDozMTo1M1rOIKmcNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjk0OA==", "bodyText": "isAllowed() indicates it's just checking if something is allowed, this method i changing the state of the class. I would prefer something call(successCallback, failCallback) or checkAndIncrement()", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547926948", "createdAt": "2020-12-23T12:06:53Z", "author": {"login": "sqrrm"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -1,95 +1,92 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package bisq.daemon.grpc.interceptor;\n \n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-\n import org.apache.commons.lang3.StringUtils;\n \n+import java.util.ArrayDeque;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n \n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n \n-import javax.annotation.Nullable;\n-\n import static java.lang.String.format;\n+import static java.lang.System.currentTimeMillis;\n \n @Slf4j\n-public final class GrpcCallRateMeter {\n+public class GrpcCallRateMeter {\n \n     @Getter\n     private final int allowedCallsPerTimeUnit;\n     @Getter\n     private final TimeUnit timeUnit;\n     @Getter\n-    private int callsCount = 0;\n+    private final int numTimeUnits;\n+\n     @Getter\n-    private transient boolean isRunning;\n+    private transient final long timeUnitIntervalInMilliseconds;\n \n-    @Nullable\n-    private Timer timer;\n+    private transient final ArrayDeque<Long> callTimestamps;\n \n     public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit) {\n-        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n-        this.timeUnit = timeUnit;\n-    }\n-\n-    public void start() {\n-        stop();\n-        timer = UserThread.runPeriodically(() -> callsCount = 0, 1, timeUnit);\n-        isRunning = true;\n+        this(allowedCallsPerTimeUnit, timeUnit, 1);\n     }\n \n-    public void stop() {\n-        if (timer != null)\n-            timer.stop();\n-\n-        isRunning = false;\n+    public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit, int numTimeUnits) {\n+        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n+        this.timeUnit = timeUnit;\n+        this.numTimeUnits = numTimeUnits;\n+        this.timeUnitIntervalInMilliseconds = timeUnit.toMillis(1) * numTimeUnits;\n+        this.callTimestamps = new ArrayDeque<>();\n     }\n \n-    public void incrementCallsCount() {\n-        callsCount++;\n+    public boolean isAllowed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c5a2965938096dd25cca64457e4528f3e3d92c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4NjQ4NQ==", "bodyText": "Fixed in commit 10727fc.", "url": "https://github.com/bisq-network/bisq/pull/4966#discussion_r547986485", "createdAt": "2020-12-23T14:31:53Z", "author": {"login": "ghubstan"}, "path": "daemon/src/main/java/bisq/daemon/grpc/interceptor/GrpcCallRateMeter.java", "diffHunk": "@@ -1,95 +1,92 @@\n-/*\n- * This file is part of Bisq.\n- *\n- * Bisq is free software: you can redistribute it and/or modify it\n- * under the terms of the GNU Affero General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or (at\n- * your option) any later version.\n- *\n- * Bisq is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n- * License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n package bisq.daemon.grpc.interceptor;\n \n-import bisq.common.Timer;\n-import bisq.common.UserThread;\n-\n import org.apache.commons.lang3.StringUtils;\n \n+import java.util.ArrayDeque;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n \n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n \n-import javax.annotation.Nullable;\n-\n import static java.lang.String.format;\n+import static java.lang.System.currentTimeMillis;\n \n @Slf4j\n-public final class GrpcCallRateMeter {\n+public class GrpcCallRateMeter {\n \n     @Getter\n     private final int allowedCallsPerTimeUnit;\n     @Getter\n     private final TimeUnit timeUnit;\n     @Getter\n-    private int callsCount = 0;\n+    private final int numTimeUnits;\n+\n     @Getter\n-    private transient boolean isRunning;\n+    private transient final long timeUnitIntervalInMilliseconds;\n \n-    @Nullable\n-    private Timer timer;\n+    private transient final ArrayDeque<Long> callTimestamps;\n \n     public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit) {\n-        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n-        this.timeUnit = timeUnit;\n-    }\n-\n-    public void start() {\n-        stop();\n-        timer = UserThread.runPeriodically(() -> callsCount = 0, 1, timeUnit);\n-        isRunning = true;\n+        this(allowedCallsPerTimeUnit, timeUnit, 1);\n     }\n \n-    public void stop() {\n-        if (timer != null)\n-            timer.stop();\n-\n-        isRunning = false;\n+    public GrpcCallRateMeter(int allowedCallsPerTimeUnit, TimeUnit timeUnit, int numTimeUnits) {\n+        this.allowedCallsPerTimeUnit = allowedCallsPerTimeUnit;\n+        this.timeUnit = timeUnit;\n+        this.numTimeUnits = numTimeUnits;\n+        this.timeUnitIntervalInMilliseconds = timeUnit.toMillis(1) * numTimeUnits;\n+        this.callTimestamps = new ArrayDeque<>();\n     }\n \n-    public void incrementCallsCount() {\n-        callsCount++;\n+    public boolean isAllowed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjk0OA=="}, "originalCommit": {"oid": "b8c5a2965938096dd25cca64457e4528f3e3d92c"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2665, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}