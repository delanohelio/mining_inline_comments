{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNTEwNjE4", "number": 4025, "title": "Make serialisation in FileManager::saveToFile thread-safe", "bodyText": "Add toProtoMessageSynchronized() default method to PersistableEnvelope, which performs (blocking) protobuf serialisation in the user thread, regardless of the calling thread. This should prevent data races like the ConcurrentModificationException observed in #3752, under the reasonable assumption that shared persistable objects are only mutated in the user thread.\nAlso add a ThreadedPersistableEnvelope sub-interface overriding the default method above, to let objects which are expensive to serialise (like DaoStateStore) be selectively serialised in the save-file-task-X thread as before, but directly synchronised with each mutating operation. As most objects are cheap to serialise, this avoids a noticeable performance drop without having to track down every mutating method for each store.\nIn all cases but one, classes implementing ThreadedPersistableEnvelope are stores like TradeStatistic2Store, with a single ConcurrentHashMap field. These require no further synchronisation, since the map entries are immutable, so the only mutating operations are map.put(..) calls which are already synchronised with map reads. (Even if map.values().stream() sees updates at different keys happen out-of-order, it should be benign, e.g. trade statistics might be persisted out-of-order if two trades come along at almost exactly the same time.)\nThe remaining case is DaoStateStore, which is only ever reset or modified via a single persist(..) call with a cloned DaoState instance and hash chain from DaoStateSnapshotService, so there is no aliasing risk from the various DAO state mutations done in DaoStateService and elsewhere.\nThis should fix #3752.\n--\nAdding some temporary benchmark logging to PersistableEnvelope shows the time spent in each saveToFile protobuf conversion forced to run on the user thread with the PR changes, from my Bisq node (running on mainnet) from startup to shutdown:\nSerialisation_Benchmarks.txt\nAs can be seen in the filtered log, the serialisation of PreferencesPayload, UserPayload and TradableList took 100-140ms (which might cause noticeable jitter on the user thread) the first time they were persisted upon application startup. However, subsequent serialisations of the same objects seem to occur much faster (presumably after the protobuf code has had a chance to warm up), with no (single-threaded) PersistableEnvelope object taking longer than around 20ms to serialise once the application has started.\nThe assumed expensive-to-serialise objects like DaoStateStore and those managed by MapStoreService all implement ThreadedPersistableEnvelope, so don't appear in the above benchmark and are converted directly on each save-file-task-X thread as before.", "createdAt": "2020-03-04T12:00:16Z", "url": "https://github.com/bisq-network/bisq/pull/4025", "merged": true, "mergeCommit": {"oid": "557ec7f4499f886db9c65de991de6e5bdcc27b85"}, "closed": true, "closedAt": "2020-03-23T12:49:28Z", "author": {"login": "stejbac"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKFSQ8AH2gAyMzgzNTEwNjE4OjE4Zjc1ODY5YTJjZmE0YTY2ZWUyNDM2NDhlODg4MTU5MWY0YWZmMzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQdwqOAFqTM3OTM5NjExNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "18f75869a2cfa4a66ee243648e8881591f4aff36", "author": {"user": {"login": "stejbac", "name": "Steven Barclay"}}, "url": "https://github.com/bisq-network/bisq/commit/18f75869a2cfa4a66ee243648e8881591f4aff36", "committedDate": "2020-03-03T16:54:48Z", "message": "Make 'fromProto' static methods return most specific type\n\nMinor change for consistency: narrow the signature of some remaining\nsuch methods, which have return type 'PersistableEnvelope'.\n\n(This excludes some other cases with return type 'NetworkEnvelope'.)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6487f92d84257d80b4b6795c53ab7380378f7e18", "author": {"user": {"login": "stejbac", "name": "Steven Barclay"}}, "url": "https://github.com/bisq-network/bisq/commit/6487f92d84257d80b4b6795c53ab7380378f7e18", "committedDate": "2020-03-04T07:10:20Z", "message": "Make serialisation in FileManager::saveToFile thread-safe\n\nAdd toProtoMessageSynchronized() default method to PersistableEnvelope,\nwhich performs (blocking) protobuf serialisation in the user thread,\nregardless of the calling thread. This should prevent data races like\nthe ConcurrentModificationException observed in #3752, under the\nreasonable assumption that shared persistable objects are only mutated\nin the user thread.\n\nAlso add a ThreadedPersistableEnvelope sub-interface overriding the\ndefault method above, to let objects which are expensive to serialise\n(like DaoStateStore) be selectively serialised in the 'save-file-task-X'\nthread as before, but directly synchronised with each mutating op. As\nmost objects are cheap to serialise, this avoids a noticeable perf drop\nwithout having to track down every mutating method for each store.\n\nIn all cases but one, classes implementing ThreadedPersistableEnvelope\nare stores like TradeStatistic2Store, with a single ConcurrentHashMap\nfield. These require no further serialisation, since the map entries are\nimmutable, so the only mutating operations are map.put(..) calls which\nare already synchronised with map reads. (Even if map.values().stream()\nsees updates @ different keys happen out-of-order, it should be benign.)\n\nThe remaining case is DaoStateStore, which is only ever reset or\nmodified via a single persist(..) call with a cloned DaoState instance\nand hash chain from DaoStateSnapshotService, so there is no aliasing\nrisk from the various DAO state mutations done in DaoStateService and\nelsewhere.\n\nThis should fix #3752."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODcxMjk2", "url": "https://github.com/bisq-network/bisq/pull/4025#pullrequestreview-370871296", "createdAt": "2020-03-09T00:24:20Z", "commit": {"oid": "6487f92d84257d80b4b6795c53ab7380378f7e18"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDoyNDoyMVrOFzYeVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDoyNzozN1rOFzYfbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMjY3OQ==", "bodyText": "I find the method name a bit confusing as it is only synchronized in ThreadedPersistableEnvelope but here we use mapping to userThread. I would recommend using toPersistableMessage as stated above.", "url": "https://github.com/bisq-network/bisq/pull/4025#discussion_r389422679", "createdAt": "2020-03-09T00:24:21Z", "author": {"login": "ManfredKarrer"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableEnvelope.java", "diffHunk": "@@ -18,9 +18,23 @@\n package bisq.common.proto.persistable;\n \n import bisq.common.Envelope;\n+import bisq.common.UserThread;\n+\n+import com.google.protobuf.Message;\n+\n+import com.google.common.util.concurrent.Futures;\n+\n+import java.util.concurrent.FutureTask;\n \n /**\n  * Interface for the outside envelope object persisted to disk.\n  */\n public interface PersistableEnvelope extends Envelope {\n+\n+    default Message toProtoMessageSynchronized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6487f92d84257d80b4b6795c53ab7380378f7e18"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMjk1Ng==", "bodyText": "Maybe its better to use a specific interface here as well like in ThreadedPersistableEnvelope? Might make it more explicit that we alter the basic non-thread-safe but fast behaviour. We could use then toPersistableMessage as method name for all 3 cases and the interface marks which style is actually used. Would make it also a bit more distinct from the generic toProtoMessage method and shows its only relevant for persisting an envelope.", "url": "https://github.com/bisq-network/bisq/pull/4025#discussion_r389422956", "createdAt": "2020-03-09T00:27:37Z", "author": {"login": "ManfredKarrer"}, "path": "common/src/main/java/bisq/common/proto/persistable/PersistableEnvelope.java", "diffHunk": "@@ -18,9 +18,23 @@\n package bisq.common.proto.persistable;\n \n import bisq.common.Envelope;\n+import bisq.common.UserThread;\n+\n+import com.google.protobuf.Message;\n+\n+import com.google.common.util.concurrent.Futures;\n+\n+import java.util.concurrent.FutureTask;\n \n /**\n  * Interface for the outside envelope object persisted to disk.\n  */\n public interface PersistableEnvelope extends Envelope {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6487f92d84257d80b4b6795c53ab7380378f7e18"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e9fc6ab5723a3bbce66ebba9670dc0b76b00991", "author": {"user": {"login": "stejbac", "name": "Steven Barclay"}}, "url": "https://github.com/bisq-network/bisq/commit/9e9fc6ab5723a3bbce66ebba9670dc0b76b00991", "committedDate": "2020-03-10T02:36:52Z", "message": "Rename toProtoMessageSynchronized to toPersistableMessage\n\nMake PersistableEnvelope method name less confusing, as it is only\nsynchronised in ThreadedPersistableEnvelope."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91fa07343c1f23cba16937a58f0f67f7cebe2bd5", "author": {"user": {"login": "stejbac", "name": "Steven Barclay"}}, "url": "https://github.com/bisq-network/bisq/commit/91fa07343c1f23cba16937a58f0f67f7cebe2bd5", "committedDate": "2020-03-10T04:05:33Z", "message": "Add UserThreadMappedPersistableEnvelope for greater explicitness\n\nMake the default toPersistableMessage() method of PersistableEnvelope\nsimply delegate to Proto.toProtoMessage for speed, so that stores can\nexplicitly implement (Threaded|UserThreadMapped)PersistableEnvelope if\nthey actually need concurrency control.\n\nAs part of this, make PeerList implement PersistableEnvelope directly\ninstead of extending PersistableList, as it is non-critical & cloned on\nthe user thread prior to storage anyway, so doesn't need be thread-safe.\nIn this way, only PaymentAccountList & small DAO-related stores extend\nPersistableList, so they can all be made user-thread-mapped.\n\nAfter this change, the only concrete store classes not implementing\n(Threaded|UserThreadMapped)PersistableEnvelope are:\n\n  AccountAgeWitness, BlindVotePayload, ProposalPayload, SignedWitness,\n  TradeStatistics2, NavigationPath & PeerList\n\nThe first five appear to erroneously implement PersistableEnvelope and\ncan be cleaned up in a separate commit. The last two are non-critical.\n\n(Make NavigationPath.path an immutable list, for slightly better thread\nsafety anyway - that way it will never be observed half-constructed.)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ab649ec058b4d621a2db0923bb46c70a41df70c", "author": {"user": {"login": "stejbac", "name": "Steven Barclay"}}, "url": "https://github.com/bisq-network/bisq/commit/9ab649ec058b4d621a2db0923bb46c70a41df70c", "committedDate": "2020-03-22T06:12:57Z", "message": "Restore type hierarchy of MeritList & VoteWithProposalTxIdList\n\nProvide UserThreadMappedPersistableList subclass for persistable lists\nwhich need to implement UserThreadMappedPersistableEnvelope, instead of\nputting the interface on the base class.\n\nMake the (non-storage) classes MeritList and VoteWithProposalTxIdList\nkeep the original PersistableList superclass, deriving the remaining\nsubclasses of PersistableList from the new class instead. In this way,\nfurther persistence-related changes are less likely to inadvertently\nalter the behaviour of those two consensus-critical classes.\n\nRemoving the superfluous PersistableEnvelope interface from the two\nclasses (via the base class) will be done in a separate PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Mzk2MTE0", "url": "https://github.com/bisq-network/bisq/pull/4025#pullrequestreview-379396114", "createdAt": "2020-03-23T12:49:16Z", "commit": {"oid": "9ab649ec058b4d621a2db0923bb46c70a41df70c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3339, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}