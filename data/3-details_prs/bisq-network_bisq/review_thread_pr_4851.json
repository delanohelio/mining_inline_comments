{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MTc1NTkx", "number": 4851, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDoyNjoxNFrOFA0wyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTowNjo0N1rOFA15lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDA4Nzc5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDoyNjoxNFrOH_TK_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0Nzo0OVrOH_WsJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNjQ0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                        if (blockDownloadListener == null) {\n          \n          \n            \n                            blockDownloadListener = (observable, oldValue, newValue) -> {\n          \n          \n            \n                                if ((double) newValue == 1) {\n          \n          \n            \n                                    setupWalletBestBlockListener();\n          \n          \n            \n                                    UserThread.execute(() -> walletsSetup.downloadPercentageProperty().removeListener(blockDownloadListener));\n          \n          \n            \n                                }\n          \n          \n            \n                            };\n          \n          \n            \n                            walletsSetup.downloadPercentageProperty().addListener(blockDownloadListener);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    } else if (blockDownloadListener == null) {\n          \n          \n            \n                        blockDownloadListener = (observable, oldValue, newValue) -> {\n          \n          \n            \n                            if ((double) newValue == 1) {\n          \n          \n            \n                                setupWalletBestBlockListener();\n          \n          \n            \n                                UserThread.execute(() -> walletsSetup.downloadPercentageProperty().removeListener(blockDownloadListener));\n          \n          \n            \n                            }\n          \n          \n            \n                        };\n          \n          \n            \n                        walletsSetup.downloadPercentageProperty().addListener(blockDownloadListener);\n          \n          \n            \n                    }", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536136447", "createdAt": "2020-12-04T14:26:14Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -87,7 +95,24 @@ public void start() {\n \n         liteNodeNetworkService.start();\n \n-        bsqWalletService.addNewBestBlockListener(block -> {\n+        // We wait until the wallet is synced before using it trigger requests\n+        if (walletsSetup.isDownloadComplete()) {\n+            setupWalletBestBlockListener();\n+        } else {\n+            if (blockDownloadListener == null) {\n+                blockDownloadListener = (observable, oldValue, newValue) -> {\n+                    if ((double) newValue == 1) {\n+                        setupWalletBestBlockListener();\n+                        UserThread.execute(() -> walletsSetup.downloadPercentageProperty().removeListener(blockDownloadListener));\n+                    }\n+                };\n+                walletsSetup.downloadPercentageProperty().addListener(blockDownloadListener);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5MDg1Ng==", "bodyText": "I will make a commit with the suggestion. Have better control if I do it in the IDE...", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536190856", "createdAt": "2020-12-04T15:43:16Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -87,7 +95,24 @@ public void start() {\n \n         liteNodeNetworkService.start();\n \n-        bsqWalletService.addNewBestBlockListener(block -> {\n+        // We wait until the wallet is synced before using it trigger requests\n+        if (walletsSetup.isDownloadComplete()) {\n+            setupWalletBestBlockListener();\n+        } else {\n+            if (blockDownloadListener == null) {\n+                blockDownloadListener = (observable, oldValue, newValue) -> {\n+                    if ((double) newValue == 1) {\n+                        setupWalletBestBlockListener();\n+                        UserThread.execute(() -> walletsSetup.downloadPercentageProperty().removeListener(blockDownloadListener));\n+                    }\n+                };\n+                walletsSetup.downloadPercentageProperty().addListener(blockDownloadListener);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNjQ0Nw=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDA4NA==", "bodyText": "Yes, I only make the code suggestion here as a way to explain more precisely what I mean. Best do it on your own to be sure it's correct.", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536194084", "createdAt": "2020-12-04T15:47:49Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -87,7 +95,24 @@ public void start() {\n \n         liteNodeNetworkService.start();\n \n-        bsqWalletService.addNewBestBlockListener(block -> {\n+        // We wait until the wallet is synced before using it trigger requests\n+        if (walletsSetup.isDownloadComplete()) {\n+            setupWalletBestBlockListener();\n+        } else {\n+            if (blockDownloadListener == null) {\n+                blockDownloadListener = (observable, oldValue, newValue) -> {\n+                    if ((double) newValue == 1) {\n+                        setupWalletBestBlockListener();\n+                        UserThread.execute(() -> walletsSetup.downloadPercentageProperty().removeListener(blockDownloadListener));\n+                    }\n+                };\n+                walletsSetup.downloadPercentageProperty().addListener(blockDownloadListener);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNjQ0Nw=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDA5NDIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDoyNzozM1rOH_TOqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0NDowN1rOH_WhuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNzM4Nw==", "bodyText": "Why error log level?", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536137387", "createdAt": "2020-12-04T14:27:33Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -97,20 +122,20 @@ public void start() {\n                 checkForBlockReceivedTimer.stop();\n             }\n \n-            int height = block.getHeight();\n-            log.info(\"New block at height {} from bsqWalletService\", height);\n+            int btcWalletHeight = btcBlock.getHeight();\n+            log.error(\"New block at height {} from bsqWalletService\", btcWalletHeight);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5MTQxNg==", "bodyText": "Ups was from dev testing", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536191416", "createdAt": "2020-12-04T15:44:07Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -97,20 +122,20 @@ public void start() {\n                 checkForBlockReceivedTimer.stop();\n             }\n \n-            int height = block.getHeight();\n-            log.info(\"New block at height {} from bsqWalletService\", height);\n+            int btcWalletHeight = btcBlock.getHeight();\n+            log.error(\"New block at height {} from bsqWalletService\", btcWalletHeight);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzNzM4Nw=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDEwMjY0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDoyOToxNFrOH_TTew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0NTowMlrOH_WkIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzODYxOQ==", "bodyText": "Timeout unit should be sec, is this a test artefact together with the error log level?", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536138619", "createdAt": "2020-12-04T14:29:14Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -97,20 +122,20 @@ public void start() {\n                 checkForBlockReceivedTimer.stop();\n             }\n \n-            int height = block.getHeight();\n-            log.info(\"New block at height {} from bsqWalletService\", height);\n+            int btcWalletHeight = btcBlock.getHeight();\n+            log.error(\"New block at height {} from bsqWalletService\", btcWalletHeight);\n \n             // We expect to receive the new BSQ block from the network shortly after BitcoinJ has been aware of it.\n             // If we don't receive it we request it manually from seed nodes\n             checkForBlockReceivedTimer = UserThread.runAfter(() -> {\n-                int chainHeight = daoStateService.getChainHeight();\n-                if (chainHeight < height) {\n+                int daoChainHeight = daoStateService.getChainHeight();\n+                if (daoChainHeight < btcWalletHeight) {\n                     log.warn(\"We did not receive a block from the network {} seconds after we saw the new block in BicoinJ. \" +\n                                     \"We request from our seed nodes missing blocks from block height {}.\",\n-                            CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, chainHeight + 1);\n-                    liteNodeNetworkService.requestBlocks(chainHeight + 1);\n+                            CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, daoChainHeight + 1);\n+                    liteNodeNetworkService.requestBlocks(daoChainHeight + 1);\n                 }\n-            }, CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC);\n+            }, CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5MjAzNA==", "bodyText": "Ups, another dev setup leftover ;-(", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536192034", "createdAt": "2020-12-04T15:45:02Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -97,20 +122,20 @@ public void start() {\n                 checkForBlockReceivedTimer.stop();\n             }\n \n-            int height = block.getHeight();\n-            log.info(\"New block at height {} from bsqWalletService\", height);\n+            int btcWalletHeight = btcBlock.getHeight();\n+            log.error(\"New block at height {} from bsqWalletService\", btcWalletHeight);\n \n             // We expect to receive the new BSQ block from the network shortly after BitcoinJ has been aware of it.\n             // If we don't receive it we request it manually from seed nodes\n             checkForBlockReceivedTimer = UserThread.runAfter(() -> {\n-                int chainHeight = daoStateService.getChainHeight();\n-                if (chainHeight < height) {\n+                int daoChainHeight = daoStateService.getChainHeight();\n+                if (daoChainHeight < btcWalletHeight) {\n                     log.warn(\"We did not receive a block from the network {} seconds after we saw the new block in BicoinJ. \" +\n                                     \"We request from our seed nodes missing blocks from block height {}.\",\n-                            CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, chainHeight + 1);\n-                    liteNodeNetworkService.requestBlocks(chainHeight + 1);\n+                            CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, daoChainHeight + 1);\n+                    liteNodeNetworkService.requestBlocks(daoChainHeight + 1);\n                 }\n-            }, CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC);\n+            }, CHECK_FOR_BLOCK_RECEIVED_DELAY_SEC, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzODYxOQ=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDExNzczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDozMjoyOVrOH_TcZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0NjoxNFrOH_WnaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MDkwMQ==", "bodyText": "That's quite a bit of logging but perhaps ok since it's once per received block", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536140901", "createdAt": "2020-12-04T14:32:29Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -229,11 +257,12 @@ private void runDelayedBatchProcessing(List<RawBlock> blocks, Runnable resultHan\n     // We received a new block\n     private void onNewBlockReceived(RawBlock block) {\n         int blockHeight = block.getHeight();\n-        log.debug(\"onNewBlockReceived: block at height {}, hash={}\", blockHeight, block.getHash());\n+        log.info(\"onNewBlockReceived: block at height {}, hash={}. Our DAO chainHeight={}\", blockHeight, block.getHash(), chainTipHeight);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5Mjg3Mg==", "bodyText": "We can lower loglevel once we see that the feature works more reliable. Prefer to keep it now.", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536192872", "createdAt": "2020-12-04T15:46:14Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/LiteNode.java", "diffHunk": "@@ -229,11 +257,12 @@ private void runDelayedBatchProcessing(List<RawBlock> blocks, Runnable resultHan\n     // We received a new block\n     private void onNewBlockReceived(RawBlock block) {\n         int blockHeight = block.getHeight();\n-        log.debug(\"onNewBlockReceived: block at height {}, hash={}\", blockHeight, block.getHash());\n+        log.info(\"onNewBlockReceived: block at height {}, hash={}. Our DAO chainHeight={}\", blockHeight, block.getHash(), chainTipHeight);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MDkwMQ=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDIyMjcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDo1NToyM1rOH_UbEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0NzoyOVrOH_WrPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1Njk0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            \"Might be caused by an previous networkNode.sendMessage.onFailure.\");\n          \n          \n            \n                                            \"Might be caused by a previous networkNode.sendMessage.onFailure.\");", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536156944", "createdAt": "2020-12-04T14:55:23Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -108,56 +108,55 @@ public void cancel() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     public void requestBlocks() {\n-        if (!stopped) {\n-            GetBlocksRequest getBlocksRequest = new GetBlocksRequest(startBlockHeight, nonce, networkNode.getNodeAddress());\n-            log.debug(\"getBlocksRequest \" + getBlocksRequest);\n-            if (timeoutTimer == null) {\n-                timeoutTimer = UserThread.runAfter(() -> {  // setup before sending to avoid race conditions\n-                            if (!stopped) {\n-                                String errorMessage = \"A timeout occurred when sending getBlocksRequest:\" + getBlocksRequest +\n-                                        \" on peersNodeAddress:\" + nodeAddress;\n-                                log.debug(errorMessage + \" / RequestDataHandler=\" + RequestBlocksHandler.this);\n-                                handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_TIMEOUT);\n-                            } else {\n-                                log.trace(\"We have stopped already. We ignore that timeoutTimer.run call. \" +\n-                                        \"Might be caused by an previous networkNode.sendMessage.onFailure.\");\n-                            }\n-                        },\n-                        TIMEOUT);\n-            }\n+        if (stopped) {\n+            log.warn(\"We have stopped already. We ignore that requestData call.\");\n+            return;\n+        }\n \n-            log.info(\"We request blocks from peer {} from block height {}.\", nodeAddress, getBlocksRequest.getFromBlockHeight());\n-            networkNode.addMessageListener(this);\n-            SettableFuture<Connection> future = networkNode.sendMessage(nodeAddress, getBlocksRequest);\n-            Futures.addCallback(future, new FutureCallback<>() {\n-                @Override\n-                public void onSuccess(Connection connection) {\n-                    if (!stopped) {\n-                        log.info(\"Sending of GetBlocksRequest message to peer {} succeeded.\", nodeAddress.getFullAddress());\n-                    } else {\n-                        log.trace(\"We have stopped already. We ignore that networkNode.sendMessage.onSuccess call.\" +\n-                                \"Might be caused by a previous timeout.\");\n-                    }\n-                }\n+        GetBlocksRequest getBlocksRequest = new GetBlocksRequest(startBlockHeight, nonce, networkNode.getNodeAddress());\n \n-                @Override\n-                public void onFailure(@NotNull Throwable throwable) {\n+        if (timeoutTimer != null) {\n+            log.warn(\"We had a timer already running and stop it.\");\n+            timeoutTimer.stop();\n+        }\n+        timeoutTimer = UserThread.runAfter(() -> {  // setup before sending to avoid race conditions\n                     if (!stopped) {\n-                        String errorMessage = \"Sending getBlocksRequest to \" + nodeAddress +\n-                                \" failed. That is expected if the peer is offline.\\n\\t\" +\n-                                \"getBlocksRequest=\" + getBlocksRequest + \".\" +\n-                                \"\\n\\tException=\" + throwable.getMessage();\n-                        log.error(errorMessage);\n-                        handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_FAILURE);\n+                        String errorMessage = \"A timeout occurred when sending getBlocksRequest:\" + getBlocksRequest +\n+                                \" on peersNodeAddress:\" + nodeAddress;\n+                        log.debug(\"{} / RequestDataHandler={}\", errorMessage, RequestBlocksHandler.this);\n+                        handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_TIMEOUT);\n                     } else {\n-                        log.trace(\"We have stopped already. We ignore that networkNode.sendMessage.onFailure call. \" +\n-                                \"Might be caused by a previous timeout.\");\n+                        log.warn(\"We have stopped already. We ignore that timeoutTimer.run call. \" +\n+                                \"Might be caused by an previous networkNode.sendMessage.onFailure.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5Mzg1NA==", "bodyText": "Found more like that. Will fix in new commit.", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536193854", "createdAt": "2020-12-04T15:47:29Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -108,56 +108,55 @@ public void cancel() {\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n     public void requestBlocks() {\n-        if (!stopped) {\n-            GetBlocksRequest getBlocksRequest = new GetBlocksRequest(startBlockHeight, nonce, networkNode.getNodeAddress());\n-            log.debug(\"getBlocksRequest \" + getBlocksRequest);\n-            if (timeoutTimer == null) {\n-                timeoutTimer = UserThread.runAfter(() -> {  // setup before sending to avoid race conditions\n-                            if (!stopped) {\n-                                String errorMessage = \"A timeout occurred when sending getBlocksRequest:\" + getBlocksRequest +\n-                                        \" on peersNodeAddress:\" + nodeAddress;\n-                                log.debug(errorMessage + \" / RequestDataHandler=\" + RequestBlocksHandler.this);\n-                                handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_TIMEOUT);\n-                            } else {\n-                                log.trace(\"We have stopped already. We ignore that timeoutTimer.run call. \" +\n-                                        \"Might be caused by an previous networkNode.sendMessage.onFailure.\");\n-                            }\n-                        },\n-                        TIMEOUT);\n-            }\n+        if (stopped) {\n+            log.warn(\"We have stopped already. We ignore that requestData call.\");\n+            return;\n+        }\n \n-            log.info(\"We request blocks from peer {} from block height {}.\", nodeAddress, getBlocksRequest.getFromBlockHeight());\n-            networkNode.addMessageListener(this);\n-            SettableFuture<Connection> future = networkNode.sendMessage(nodeAddress, getBlocksRequest);\n-            Futures.addCallback(future, new FutureCallback<>() {\n-                @Override\n-                public void onSuccess(Connection connection) {\n-                    if (!stopped) {\n-                        log.info(\"Sending of GetBlocksRequest message to peer {} succeeded.\", nodeAddress.getFullAddress());\n-                    } else {\n-                        log.trace(\"We have stopped already. We ignore that networkNode.sendMessage.onSuccess call.\" +\n-                                \"Might be caused by a previous timeout.\");\n-                    }\n-                }\n+        GetBlocksRequest getBlocksRequest = new GetBlocksRequest(startBlockHeight, nonce, networkNode.getNodeAddress());\n \n-                @Override\n-                public void onFailure(@NotNull Throwable throwable) {\n+        if (timeoutTimer != null) {\n+            log.warn(\"We had a timer already running and stop it.\");\n+            timeoutTimer.stop();\n+        }\n+        timeoutTimer = UserThread.runAfter(() -> {  // setup before sending to avoid race conditions\n                     if (!stopped) {\n-                        String errorMessage = \"Sending getBlocksRequest to \" + nodeAddress +\n-                                \" failed. That is expected if the peer is offline.\\n\\t\" +\n-                                \"getBlocksRequest=\" + getBlocksRequest + \".\" +\n-                                \"\\n\\tException=\" + throwable.getMessage();\n-                        log.error(errorMessage);\n-                        handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_FAILURE);\n+                        String errorMessage = \"A timeout occurred when sending getBlocksRequest:\" + getBlocksRequest +\n+                                \" on peersNodeAddress:\" + nodeAddress;\n+                        log.debug(\"{} / RequestDataHandler={}\", errorMessage, RequestBlocksHandler.this);\n+                        handleFault(errorMessage, nodeAddress, CloseConnectionReason.SEND_MSG_TIMEOUT);\n                     } else {\n-                        log.trace(\"We have stopped already. We ignore that networkNode.sendMessage.onFailure call. \" +\n-                                \"Might be caused by a previous timeout.\");\n+                        log.warn(\"We have stopped already. We ignore that timeoutTimer.run call. \" +\n+                                \"Might be caused by an previous networkNode.sendMessage.onFailure.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1Njk0NA=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDI0MDQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDo1OToxMlrOH_Ul1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjowNTowM1rOH_j6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1OTcwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (networkEnvelope instanceof GetBlocksResponse) {\n          \n          \n            \n                    if (!(networkEnvelope instanceof GetBlocksResponse)) return; // Also need to remove other brace", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536159701", "createdAt": "2020-12-04T14:59:12Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -168,31 +167,36 @@ public void onFailure(@NotNull Throwable throwable) {\n     @Override\n     public void onMessage(NetworkEnvelope networkEnvelope, Connection connection) {\n         if (networkEnvelope instanceof GetBlocksResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5ODg1MQ==", "bodyText": "I prefer to not return early here as this style is commonly used in many places and often there are several if else branches. It is more like a dispatcher or switch case style (if switch would be more flexible in java). I prefer to use the early return for validation use cases but here its more to select the msg we are interested in.", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536198851", "createdAt": "2020-12-04T15:54:22Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -168,31 +167,36 @@ public void onFailure(@NotNull Throwable throwable) {\n     @Override\n     public void onMessage(NetworkEnvelope networkEnvelope, Connection connection) {\n         if (networkEnvelope instanceof GetBlocksResponse) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1OTcwMQ=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMDc1OQ==", "bodyText": "That's a good point. Might be cleaner to make a handleGetBlocksResponse(GetBlocksResponse r) and other respective dispatch handlers like is done in the trade protocol for these cases.", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536410759", "createdAt": "2020-12-04T22:05:03Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -168,31 +167,36 @@ public void onFailure(@NotNull Throwable throwable) {\n     @Override\n     public void onMessage(NetworkEnvelope networkEnvelope, Connection connection) {\n         if (networkEnvelope instanceof GetBlocksResponse) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE1OTcwMQ=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDI3NDE0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTowNjo0N1rOH_U6Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNTo0OTo0NVrOH_WxYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NDg4Mg==", "bodyText": "Doesn't timeoutTimer need to be stopped here like before?\n        stopTimeoutTimer();", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536164882", "createdAt": "2020-12-04T15:06:47Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -168,31 +167,36 @@ public void onFailure(@NotNull Throwable throwable) {\n     @Override\n     public void onMessage(NetworkEnvelope networkEnvelope, Connection connection) {\n         if (networkEnvelope instanceof GetBlocksResponse) {\n-            if (connection.getPeersNodeAddressOptional().isPresent() && connection.getPeersNodeAddressOptional().get().equals(nodeAddress)) {\n-                if (!stopped) {\n-                    GetBlocksResponse getBlocksResponse = (GetBlocksResponse) networkEnvelope;\n-                    if (getBlocksResponse.getRequestNonce() == nonce) {\n-                        stopTimeoutTimer();\n-                        checkArgument(connection.getPeersNodeAddressOptional().isPresent(),\n-                                \"RequestDataHandler.onMessage: connection.getPeersNodeAddressOptional() must be present \" +\n-                                        \"at that moment\");\n-                        cleanup();\n-                        log.info(\"We received from peer {} a BlocksResponse with {} blocks\",\n-                                nodeAddress.getFullAddress(), getBlocksResponse.getBlocks().size());\n-                        listener.onComplete(getBlocksResponse);\n-                    } else {\n-                        log.warn(\"Nonce not matching. That can happen rarely if we get a response after a canceled \" +\n-                                        \"handshake (timeout causes connection close but peer might have sent a msg before \" +\n-                                        \"connection was closed).\\n\\t\" +\n-                                        \"We drop that message. nonce={} / requestNonce={}\",\n-                                nonce, getBlocksResponse.getRequestNonce());\n-                    }\n-                } else {\n-                    log.warn(\"We have stopped already. We ignore that onDataRequest call.\");\n-                }\n-            } else {\n-                log.warn(\"We got a message from ourselves. That should never happen.\");\n+            if (stopped) {\n+                log.warn(\"We have stopped already. We ignore that onDataRequest call.\");\n+                return;\n+            }\n+\n+            Optional<NodeAddress> optionalNodeAddress = connection.getPeersNodeAddressOptional();\n+            if (!optionalNodeAddress.isPresent()) {\n+                log.warn(\"Peers node address is not present, that is not expected.\");\n+                // We do not return here as in case the connection has been created from the peers side we might not\n+                // have the address set. As we check the nonce later we do not care that much for the check if the\n+                // connection address is the same as the one we used.\n+            } else if (!optionalNodeAddress.get().equals(nodeAddress)) {\n+                log.warn(\"Peers node address is the same we requested. We ignore that message.\");\n+                return;\n             }\n+\n+            GetBlocksResponse getBlocksResponse = (GetBlocksResponse) networkEnvelope;\n+            if (getBlocksResponse.getRequestNonce() != nonce) {\n+                log.warn(\"Nonce not matching. That can happen rarely if we get a response after a canceled \" +\n+                                \"handshake (timeout causes connection close but peer might have sent a msg before \" +\n+                                \"connection was closed).\\n\\t\" +\n+                                \"We drop that message. nonce={} / requestNonce={}\",\n+                        nonce, getBlocksResponse.getRequestNonce());\n+                return;\n+            }\n+\n+            cleanup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NTQyNA==", "bodyText": "cleanup calls stopTimeoutTimer. But will consolidate cancel/stop/cleanup", "url": "https://github.com/bisq-network/bisq/pull/4851#discussion_r536195424", "createdAt": "2020-12-04T15:49:45Z", "author": {"login": "chimp1984"}, "path": "core/src/main/java/bisq/core/dao/node/lite/network/RequestBlocksHandler.java", "diffHunk": "@@ -168,31 +167,36 @@ public void onFailure(@NotNull Throwable throwable) {\n     @Override\n     public void onMessage(NetworkEnvelope networkEnvelope, Connection connection) {\n         if (networkEnvelope instanceof GetBlocksResponse) {\n-            if (connection.getPeersNodeAddressOptional().isPresent() && connection.getPeersNodeAddressOptional().get().equals(nodeAddress)) {\n-                if (!stopped) {\n-                    GetBlocksResponse getBlocksResponse = (GetBlocksResponse) networkEnvelope;\n-                    if (getBlocksResponse.getRequestNonce() == nonce) {\n-                        stopTimeoutTimer();\n-                        checkArgument(connection.getPeersNodeAddressOptional().isPresent(),\n-                                \"RequestDataHandler.onMessage: connection.getPeersNodeAddressOptional() must be present \" +\n-                                        \"at that moment\");\n-                        cleanup();\n-                        log.info(\"We received from peer {} a BlocksResponse with {} blocks\",\n-                                nodeAddress.getFullAddress(), getBlocksResponse.getBlocks().size());\n-                        listener.onComplete(getBlocksResponse);\n-                    } else {\n-                        log.warn(\"Nonce not matching. That can happen rarely if we get a response after a canceled \" +\n-                                        \"handshake (timeout causes connection close but peer might have sent a msg before \" +\n-                                        \"connection was closed).\\n\\t\" +\n-                                        \"We drop that message. nonce={} / requestNonce={}\",\n-                                nonce, getBlocksResponse.getRequestNonce());\n-                    }\n-                } else {\n-                    log.warn(\"We have stopped already. We ignore that onDataRequest call.\");\n-                }\n-            } else {\n-                log.warn(\"We got a message from ourselves. That should never happen.\");\n+            if (stopped) {\n+                log.warn(\"We have stopped already. We ignore that onDataRequest call.\");\n+                return;\n+            }\n+\n+            Optional<NodeAddress> optionalNodeAddress = connection.getPeersNodeAddressOptional();\n+            if (!optionalNodeAddress.isPresent()) {\n+                log.warn(\"Peers node address is not present, that is not expected.\");\n+                // We do not return here as in case the connection has been created from the peers side we might not\n+                // have the address set. As we check the nonce later we do not care that much for the check if the\n+                // connection address is the same as the one we used.\n+            } else if (!optionalNodeAddress.get().equals(nodeAddress)) {\n+                log.warn(\"Peers node address is the same we requested. We ignore that message.\");\n+                return;\n             }\n+\n+            GetBlocksResponse getBlocksResponse = (GetBlocksResponse) networkEnvelope;\n+            if (getBlocksResponse.getRequestNonce() != nonce) {\n+                log.warn(\"Nonce not matching. That can happen rarely if we get a response after a canceled \" +\n+                                \"handshake (timeout causes connection close but peer might have sent a msg before \" +\n+                                \"connection was closed).\\n\\t\" +\n+                                \"We drop that message. nonce={} / requestNonce={}\",\n+                        nonce, getBlocksResponse.getRequestNonce());\n+                return;\n+            }\n+\n+            cleanup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE2NDg4Mg=="}, "originalCommit": {"oid": "3babce8a9f4ba401e33fc331c0a34c821c13d361"}, "originalPosition": 180}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2636, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}