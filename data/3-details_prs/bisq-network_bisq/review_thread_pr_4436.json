{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNjUyODQ5", "number": 4436, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxMjozODo0MVrOEeEKoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxNjoxMDowNlrOEeFRrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5OTYwOTkzOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/peers/Broadcaster.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxMjozODo0MVrOHJihQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToyNjoyMFrOHJ9bLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc2NDgwMA==", "bodyText": "This is rather verbose, not sure it's a good idea to keep level at info.\nAfter running a mainnet client for a while this log is 40% of the total log lines.", "url": "https://github.com/bisq-network/bisq/pull/4436#discussion_r479764800", "createdAt": "2020-08-30T12:38:41Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/peers/Broadcaster.java", "diffHunk": "@@ -45,21 +61,63 @@ public Broadcaster(NetworkNode networkNode, PeerManager peerManager) {\n         this.peerManager = peerManager;\n     }\n \n-    public void shutDown() {\n-        broadcastHandlers.stream().forEach(BroadcastHandler::cancel);\n-        broadcastHandlers.clear();\n+    public void shutDown(Runnable resultHandler) {\n+        shutDownRequested = true;\n+        shutDownResultHandler = resultHandler;\n+        if (broadcastRequests.isEmpty()) {\n+            doShutDown();\n+        } else {\n+            // We set delay of broadcasts and timeout to very low values,\n+            // so we can expect that we get onCompleted called very fast and trigger the doShutDown from there.\n+            maybeBroadcastBundle();\n+        }\n+    }\n+\n+    private void doShutDown() {\n+        broadcastHandlers.forEach(BroadcastHandler::cancel);\n+        if (timer != null) {\n+            timer.stop();\n+        }\n+        shutDownResultHandler.run();\n     }\n \n \n     ///////////////////////////////////////////////////////////////////////////////////////////\n     // API\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    public void broadcast(BroadcastMessage message, @Nullable NodeAddress sender,\n+    public void broadcast(BroadcastMessage message,\n+                          @Nullable NodeAddress sender) {\n+        broadcast(message, sender, null);\n+    }\n+\n+\n+    public void broadcast(BroadcastMessage message,\n+                          @Nullable NodeAddress sender,\n                           @Nullable BroadcastHandler.Listener listener) {\n-        BroadcastHandler broadcastHandler = new BroadcastHandler(networkNode, peerManager);\n-        broadcastHandler.broadcast(message, sender, this, listener);\n-        broadcastHandlers.add(broadcastHandler);\n+        broadcastRequests.add(new BroadcastRequest(message, sender, listener));\n+        // Keep that log on INFO for better debugging if the feature works as expected. Later it can\n+        // be remove or set to DEBUG\n+        log.info(\"Broadcast requested for {}. We queue it up for next bundled broadcast.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aa97d39ab35d197dbf722c2efc339183fcf5ef2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwNTYxMg==", "bodyText": "I will set those to debug", "url": "https://github.com/bisq-network/bisq/pull/4436#discussion_r480205612", "createdAt": "2020-08-31T15:26:20Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/peers/Broadcaster.java", "diffHunk": "@@ -45,21 +61,63 @@ public Broadcaster(NetworkNode networkNode, PeerManager peerManager) {\n         this.peerManager = peerManager;\n     }\n \n-    public void shutDown() {\n-        broadcastHandlers.stream().forEach(BroadcastHandler::cancel);\n-        broadcastHandlers.clear();\n+    public void shutDown(Runnable resultHandler) {\n+        shutDownRequested = true;\n+        shutDownResultHandler = resultHandler;\n+        if (broadcastRequests.isEmpty()) {\n+            doShutDown();\n+        } else {\n+            // We set delay of broadcasts and timeout to very low values,\n+            // so we can expect that we get onCompleted called very fast and trigger the doShutDown from there.\n+            maybeBroadcastBundle();\n+        }\n+    }\n+\n+    private void doShutDown() {\n+        broadcastHandlers.forEach(BroadcastHandler::cancel);\n+        if (timer != null) {\n+            timer.stop();\n+        }\n+        shutDownResultHandler.run();\n     }\n \n \n     ///////////////////////////////////////////////////////////////////////////////////////////\n     // API\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    public void broadcast(BroadcastMessage message, @Nullable NodeAddress sender,\n+    public void broadcast(BroadcastMessage message,\n+                          @Nullable NodeAddress sender) {\n+        broadcast(message, sender, null);\n+    }\n+\n+\n+    public void broadcast(BroadcastMessage message,\n+                          @Nullable NodeAddress sender,\n                           @Nullable BroadcastHandler.Listener listener) {\n-        BroadcastHandler broadcastHandler = new BroadcastHandler(networkNode, peerManager);\n-        broadcastHandler.broadcast(message, sender, this, listener);\n-        broadcastHandlers.add(broadcastHandler);\n+        broadcastRequests.add(new BroadcastRequest(message, sender, listener));\n+        // Keep that log on INFO for better debugging if the feature works as expected. Later it can\n+        // be remove or set to DEBUG\n+        log.info(\"Broadcast requested for {}. We queue it up for next bundled broadcast.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc2NDgwMA=="}, "originalCommit": {"oid": "0aa97d39ab35d197dbf722c2efc339183fcf5ef2"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5OTc5MTgwOnYy", "diffSide": "RIGHT", "path": "p2p/src/main/java/bisq/network/p2p/peers/BroadcastHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxNjoxMDowNlrOHJj5lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToyNzozOFrOHJ9eTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4NzQxMw==", "bodyText": "These two cases could be combined to one block", "url": "https://github.com/bisq-network/bisq/pull/4436#discussion_r479787413", "createdAt": "2020-08-30T16:10:06Z", "author": {"login": "sqrrm"}, "path": "p2p/src/main/java/bisq/network/p2p/peers/BroadcastHandler.java", "diffHunk": "@@ -239,36 +185,145 @@ public void onAwakeFromStandby() {\n     // Private\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    private void cleanup() {\n-        stopped = true;\n-        peerManager.removeListener(this);\n-        if (timeoutTimer != null) {\n-            timeoutTimer.stop();\n-            timeoutTimer = null;\n-        }\n+    // Check if we have at least one message originated by ourselves\n+    private boolean requestsContainOwnMessage(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        NodeAddress myAddress = networkNode.getNodeAddress();\n+        if (myAddress == null)\n+            return false;\n+\n+        return broadcastRequests.stream().anyMatch(e -> myAddress.equals(e.getSender()));\n     }\n \n-    private void onFault(String errorMessage) {\n-        onFault(errorMessage, true);\n+    private void setupTimeoutHandler(List<Broadcaster.BroadcastRequest> broadcastRequests,\n+                                     int delay,\n+                                     boolean shutDownRequested) {\n+        // In case of shutdown we try to complete fast and set a short 1 second timeout\n+        long baseTimeoutMs = shutDownRequested ? TimeUnit.SECONDS.toMillis(1) : BASE_TIMEOUT_MS;\n+        long timeoutDelay = baseTimeoutMs + delay * (numPeersForBroadcast + 1); // We added 1 in the loop\n+        timeoutTimer = UserThread.runAfter(() -> {\n+            if (stopped) {\n+                return;\n+            }\n+\n+            timeoutTriggered = true;\n+\n+            log.warn(\"Broadcast did not complete after {} sec.\\n\" +\n+                            \"numPeersForBroadcast={}\\n\" +\n+                            \"numOfCompletedBroadcasts={}\\n\" +\n+                            \"numOfFailedBroadcasts={}\",\n+                    timeoutDelay / 1000d,\n+                    numPeersForBroadcast,\n+                    numOfCompletedBroadcasts,\n+                    numOfFailedBroadcasts);\n+\n+            maybeNotifyListeners(broadcastRequests);\n+\n+            cleanup();\n+\n+        }, timeoutDelay, TimeUnit.MILLISECONDS);\n     }\n \n-    private void onFault(String errorMessage, boolean logWarning) {\n-        cleanup();\n+    // We exclude the requests containing a message we received from that connection\n+    // Also we filter out messages which requires a capability but peer does not support it.\n+    private List<Broadcaster.BroadcastRequest> getBroadcastRequestsForConnection(Connection connection,\n+                                                                                 List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        return broadcastRequests.stream()\n+                .filter(broadcastRequest -> !connection.getPeersNodeAddressOptional().isPresent() ||\n+                        !connection.getPeersNodeAddressOptional().get().equals(broadcastRequest.getSender()))\n+                .filter(broadcastRequest -> connection.noCapabilityRequiredOrCapabilityIsSupported(broadcastRequest.getMessage()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void sendToPeer(Connection connection, List<Broadcaster.BroadcastRequest> broadcastRequestsForConnection) {\n+        // Can be BundleOfEnvelopes or a single BroadcastMessage\n+        BroadcastMessage broadcastMessage = getMessage(broadcastRequestsForConnection);\n+        SettableFuture<Connection> future = networkNode.sendMessage(connection, broadcastMessage);\n+\n+        Futures.addCallback(future, new FutureCallback<>() {\n+            @Override\n+            public void onSuccess(Connection connection) {\n+                numOfCompletedBroadcasts++;\n+\n+                if (stopped) {\n+                    return;\n+                }\n+\n+                maybeNotifyListeners(broadcastRequestsForConnection);\n+                checkForCompletion();\n+            }\n+\n+            @Override\n+            public void onFailure(@NotNull Throwable throwable) {\n+                log.warn(\"Broadcast to {} failed. ErrorMessage={}\", connection.getPeersNodeAddressOptional(),\n+                        throwable.getMessage());\n+                numOfFailedBroadcasts++;\n+\n+                if (stopped) {\n+                    return;\n+                }\n \n-        if (logWarning)\n-            log.warn(errorMessage);\n-        else\n-            log.debug(errorMessage);\n+                maybeNotifyListeners(broadcastRequestsForConnection);\n+                checkForCompletion();\n+            }\n+        });\n+    }\n \n-        if (listener != null)\n-            listener.onBroadcastFailed(errorMessage);\n+    private BroadcastMessage getMessage(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        if (broadcastRequests.size() == 1) {\n+            // If we only have 1 message we avoid the overhead of the BundleOfEnvelopes and send the message directly\n+            return broadcastRequests.get(0).getMessage();\n+        } else {\n+            return new BundleOfEnvelopes(broadcastRequests.stream()\n+                    .map(Broadcaster.BroadcastRequest::getMessage)\n+                    .collect(Collectors.toList()));\n+        }\n+    }\n \n-        if (listener != null && (numOfCompletedBroadcasts + numOfFailedBroadcasts == numPeers || stopped))\n-            listener.onBroadcastCompleted(message, numOfCompletedBroadcasts, numOfFailedBroadcasts);\n+    private void maybeNotifyListeners(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        int numOfCompletedBroadcastsTarget = Math.max(1, Math.min(numPeersForBroadcast, 3));\n+        // We use equal checks to avoid duplicated listener calls as it would be the case with >= checks.\n+        if (numOfCompletedBroadcasts == numOfCompletedBroadcastsTarget) {\n+            // We have heard back from 3 peers (or all peers if numPeers is lower) so we consider the message was sufficiently broadcast.\n+            broadcastRequests.stream()\n+                    .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                    .map(Broadcaster.BroadcastRequest::getListener)\n+                    .forEach(listener -> listener.onSufficientlyBroadcast(broadcastRequests));\n+        } else {\n+            // Number of open requests to peers is less than we need to reach numOfCompletedBroadcastsTarget.\n+            // Thus we never can reach required resilience as too many numOfFailedBroadcasts occurred.\n+            int openRequests = numPeersForBroadcast - numOfCompletedBroadcasts - numOfFailedBroadcasts;\n+            int maxPossibleSuccessCases = openRequests + numOfCompletedBroadcasts;\n+            // We subtract 1 as we want to have it called only once, with a < comparision we would trigger repeatedly.\n+            if (maxPossibleSuccessCases == numOfCompletedBroadcastsTarget - 1) {\n+                broadcastRequests.stream()\n+                        .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                        .map(Broadcaster.BroadcastRequest::getListener)\n+                        .forEach(listener -> listener.onNotSufficientlyBroadcast(numOfCompletedBroadcasts, numOfFailedBroadcasts));\n+            } else if (timeoutTriggered && numOfCompletedBroadcasts < numOfCompletedBroadcastsTarget) {\n+                // We did not reach resilience level and timeout prevents to reach it later\n+                broadcastRequests.stream()\n+                        .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                        .map(Broadcaster.BroadcastRequest::getListener)\n+                        .forEach(listener -> listener.onNotSufficientlyBroadcast(numOfCompletedBroadcasts, numOfFailedBroadcasts));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d212e654c70394820d6dba04671c16b33b87d4"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwNjQxNA==", "bodyText": "Will do...", "url": "https://github.com/bisq-network/bisq/pull/4436#discussion_r480206414", "createdAt": "2020-08-31T15:27:38Z", "author": {"login": "chimp1984"}, "path": "p2p/src/main/java/bisq/network/p2p/peers/BroadcastHandler.java", "diffHunk": "@@ -239,36 +185,145 @@ public void onAwakeFromStandby() {\n     // Private\n     ///////////////////////////////////////////////////////////////////////////////////////////\n \n-    private void cleanup() {\n-        stopped = true;\n-        peerManager.removeListener(this);\n-        if (timeoutTimer != null) {\n-            timeoutTimer.stop();\n-            timeoutTimer = null;\n-        }\n+    // Check if we have at least one message originated by ourselves\n+    private boolean requestsContainOwnMessage(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        NodeAddress myAddress = networkNode.getNodeAddress();\n+        if (myAddress == null)\n+            return false;\n+\n+        return broadcastRequests.stream().anyMatch(e -> myAddress.equals(e.getSender()));\n     }\n \n-    private void onFault(String errorMessage) {\n-        onFault(errorMessage, true);\n+    private void setupTimeoutHandler(List<Broadcaster.BroadcastRequest> broadcastRequests,\n+                                     int delay,\n+                                     boolean shutDownRequested) {\n+        // In case of shutdown we try to complete fast and set a short 1 second timeout\n+        long baseTimeoutMs = shutDownRequested ? TimeUnit.SECONDS.toMillis(1) : BASE_TIMEOUT_MS;\n+        long timeoutDelay = baseTimeoutMs + delay * (numPeersForBroadcast + 1); // We added 1 in the loop\n+        timeoutTimer = UserThread.runAfter(() -> {\n+            if (stopped) {\n+                return;\n+            }\n+\n+            timeoutTriggered = true;\n+\n+            log.warn(\"Broadcast did not complete after {} sec.\\n\" +\n+                            \"numPeersForBroadcast={}\\n\" +\n+                            \"numOfCompletedBroadcasts={}\\n\" +\n+                            \"numOfFailedBroadcasts={}\",\n+                    timeoutDelay / 1000d,\n+                    numPeersForBroadcast,\n+                    numOfCompletedBroadcasts,\n+                    numOfFailedBroadcasts);\n+\n+            maybeNotifyListeners(broadcastRequests);\n+\n+            cleanup();\n+\n+        }, timeoutDelay, TimeUnit.MILLISECONDS);\n     }\n \n-    private void onFault(String errorMessage, boolean logWarning) {\n-        cleanup();\n+    // We exclude the requests containing a message we received from that connection\n+    // Also we filter out messages which requires a capability but peer does not support it.\n+    private List<Broadcaster.BroadcastRequest> getBroadcastRequestsForConnection(Connection connection,\n+                                                                                 List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        return broadcastRequests.stream()\n+                .filter(broadcastRequest -> !connection.getPeersNodeAddressOptional().isPresent() ||\n+                        !connection.getPeersNodeAddressOptional().get().equals(broadcastRequest.getSender()))\n+                .filter(broadcastRequest -> connection.noCapabilityRequiredOrCapabilityIsSupported(broadcastRequest.getMessage()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private void sendToPeer(Connection connection, List<Broadcaster.BroadcastRequest> broadcastRequestsForConnection) {\n+        // Can be BundleOfEnvelopes or a single BroadcastMessage\n+        BroadcastMessage broadcastMessage = getMessage(broadcastRequestsForConnection);\n+        SettableFuture<Connection> future = networkNode.sendMessage(connection, broadcastMessage);\n+\n+        Futures.addCallback(future, new FutureCallback<>() {\n+            @Override\n+            public void onSuccess(Connection connection) {\n+                numOfCompletedBroadcasts++;\n+\n+                if (stopped) {\n+                    return;\n+                }\n+\n+                maybeNotifyListeners(broadcastRequestsForConnection);\n+                checkForCompletion();\n+            }\n+\n+            @Override\n+            public void onFailure(@NotNull Throwable throwable) {\n+                log.warn(\"Broadcast to {} failed. ErrorMessage={}\", connection.getPeersNodeAddressOptional(),\n+                        throwable.getMessage());\n+                numOfFailedBroadcasts++;\n+\n+                if (stopped) {\n+                    return;\n+                }\n \n-        if (logWarning)\n-            log.warn(errorMessage);\n-        else\n-            log.debug(errorMessage);\n+                maybeNotifyListeners(broadcastRequestsForConnection);\n+                checkForCompletion();\n+            }\n+        });\n+    }\n \n-        if (listener != null)\n-            listener.onBroadcastFailed(errorMessage);\n+    private BroadcastMessage getMessage(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        if (broadcastRequests.size() == 1) {\n+            // If we only have 1 message we avoid the overhead of the BundleOfEnvelopes and send the message directly\n+            return broadcastRequests.get(0).getMessage();\n+        } else {\n+            return new BundleOfEnvelopes(broadcastRequests.stream()\n+                    .map(Broadcaster.BroadcastRequest::getMessage)\n+                    .collect(Collectors.toList()));\n+        }\n+    }\n \n-        if (listener != null && (numOfCompletedBroadcasts + numOfFailedBroadcasts == numPeers || stopped))\n-            listener.onBroadcastCompleted(message, numOfCompletedBroadcasts, numOfFailedBroadcasts);\n+    private void maybeNotifyListeners(List<Broadcaster.BroadcastRequest> broadcastRequests) {\n+        int numOfCompletedBroadcastsTarget = Math.max(1, Math.min(numPeersForBroadcast, 3));\n+        // We use equal checks to avoid duplicated listener calls as it would be the case with >= checks.\n+        if (numOfCompletedBroadcasts == numOfCompletedBroadcastsTarget) {\n+            // We have heard back from 3 peers (or all peers if numPeers is lower) so we consider the message was sufficiently broadcast.\n+            broadcastRequests.stream()\n+                    .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                    .map(Broadcaster.BroadcastRequest::getListener)\n+                    .forEach(listener -> listener.onSufficientlyBroadcast(broadcastRequests));\n+        } else {\n+            // Number of open requests to peers is less than we need to reach numOfCompletedBroadcastsTarget.\n+            // Thus we never can reach required resilience as too many numOfFailedBroadcasts occurred.\n+            int openRequests = numPeersForBroadcast - numOfCompletedBroadcasts - numOfFailedBroadcasts;\n+            int maxPossibleSuccessCases = openRequests + numOfCompletedBroadcasts;\n+            // We subtract 1 as we want to have it called only once, with a < comparision we would trigger repeatedly.\n+            if (maxPossibleSuccessCases == numOfCompletedBroadcastsTarget - 1) {\n+                broadcastRequests.stream()\n+                        .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                        .map(Broadcaster.BroadcastRequest::getListener)\n+                        .forEach(listener -> listener.onNotSufficientlyBroadcast(numOfCompletedBroadcasts, numOfFailedBroadcasts));\n+            } else if (timeoutTriggered && numOfCompletedBroadcasts < numOfCompletedBroadcastsTarget) {\n+                // We did not reach resilience level and timeout prevents to reach it later\n+                broadcastRequests.stream()\n+                        .filter(broadcastRequest -> broadcastRequest.getListener() != null)\n+                        .map(Broadcaster.BroadcastRequest::getListener)\n+                        .forEach(listener -> listener.onNotSufficientlyBroadcast(numOfCompletedBroadcasts, numOfFailedBroadcasts));\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4NzQxMw=="}, "originalCommit": {"oid": "49d212e654c70394820d6dba04671c16b33b87d4"}, "originalPosition": 428}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2415, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}