{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MDMyMTcy", "number": 4673, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTowNzo1OVrOEwtw3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMjoyNjozM1rOEwvcdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTE2ODk0OnYy", "diffSide": "RIGHT", "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTowNzo1OVrOHmcfqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzowNjoyM1rOHmgy4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3NDc5NQ==", "bodyText": "All these wait times in the test will make the test very slow eventually. I don't really have a solution to it, more of a general observation.\nMaybe grouping all the tasks that need waiting on and then run the tests, but that would also group the tests, making them less independent and thus less useful.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510074795", "createdAt": "2020-10-22T11:07:59Z", "author": {"login": "sqrrm"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzMDgzMw==", "bodyText": "I think it's reach 6m already...\nI don't see a way around it now, but over time, old, stable 'method' (or 'unit') test cases can be consolidated in 'scenario', then 'e2e' test cases, which would run them all in one test case.  That will help.   I was thinking of a dev/test cycle like this: a new feature/bug is tested in a method/unit test, then gradually moved to older scenario/e2e test cases.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510130833", "createdAt": "2020-10-22T12:46:00Z", "author": {"login": "ghubstan"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3NDc5NQ=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NTI0OA==", "bodyText": "Sounds like a plan. If the tests never run they're useless, so it's important that they can be run within a reasonable time frame. Might also be good with a consolidated scenario to find interdependency issues.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510145248", "createdAt": "2020-10-22T13:06:23Z", "author": {"login": "sqrrm"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA3NDc5NQ=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTIwMTc2OnYy", "diffSide": "RIGHT", "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToxODowOFrOHmc0Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzowNjo1OVrOHmg0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4MDAwMw==", "bodyText": "I suspect it's keeping the last state after the offer was taken, although I haven't looked into it before. There is no TAKEN state either. I think it's used to handle the state of the offer during its life cycle, which ends once the offer is taken and everything is then handled by the Trade.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510080003", "createdAt": "2020-10-22T11:18:08Z", "author": {"login": "sqrrm"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);\n+            assertEquals(1, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            var trade = takeAlicesOffer(offerId, bobsAccount.getId());\n+            assertNotNull(trade);\n+            assertEquals(offerId, trade.getTradeId());\n+            // Cache the trade id for the other tests.\n+            tradeId = trade.getTradeId();\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            assertEquals(0, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, SELLER_PUBLISHED_DEPOSIT_TX, DEPOSIT_PUBLISHED);\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN, DEPOSIT_CONFIRMED);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(2)\n+    public void testAlicesConfirmPaymentStarted() {\n+        try {\n+            var trade = getTrade(alicedaemon, tradeId);\n+            assertNotNull(trade);\n+\n+            confirmPaymentStarted(alicedaemon, trade.getTradeId());\n+            sleep(3000);\n+\n+            trade = getTrade(alicedaemon, tradeId);\n+            assertEquals(OFFER_FEE_PAID.name(), trade.getOffer().getState());\n+            verifyExpectedTradeStateAndPhase(trade, BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG, FIAT_SENT);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(3)\n+    public void testBobsConfirmPaymentReceived() {\n+        var trade = getTrade(bobdaemon, tradeId);\n+        assertNotNull(trade);\n+\n+        confirmPaymentReceived(bobdaemon, trade.getTradeId());\n+        sleep(3000);\n+\n+        trade = getTrade(bobdaemon, tradeId);\n+        // TODO is this a bug?  Why is offer.state == available?\n+        assertEquals(AVAILABLE.name(), trade.getOffer().getState());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzMjA1Nw==", "bodyText": "I looked odd, but I don't see any bad side effects yet.  Should I leave those comments?  Reword them?", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510132057", "createdAt": "2020-10-22T12:47:59Z", "author": {"login": "ghubstan"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);\n+            assertEquals(1, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            var trade = takeAlicesOffer(offerId, bobsAccount.getId());\n+            assertNotNull(trade);\n+            assertEquals(offerId, trade.getTradeId());\n+            // Cache the trade id for the other tests.\n+            tradeId = trade.getTradeId();\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            assertEquals(0, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, SELLER_PUBLISHED_DEPOSIT_TX, DEPOSIT_PUBLISHED);\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN, DEPOSIT_CONFIRMED);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(2)\n+    public void testAlicesConfirmPaymentStarted() {\n+        try {\n+            var trade = getTrade(alicedaemon, tradeId);\n+            assertNotNull(trade);\n+\n+            confirmPaymentStarted(alicedaemon, trade.getTradeId());\n+            sleep(3000);\n+\n+            trade = getTrade(alicedaemon, tradeId);\n+            assertEquals(OFFER_FEE_PAID.name(), trade.getOffer().getState());\n+            verifyExpectedTradeStateAndPhase(trade, BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG, FIAT_SENT);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(3)\n+    public void testBobsConfirmPaymentReceived() {\n+        var trade = getTrade(bobdaemon, tradeId);\n+        assertNotNull(trade);\n+\n+        confirmPaymentReceived(bobdaemon, trade.getTradeId());\n+        sleep(3000);\n+\n+        trade = getTrade(bobdaemon, tradeId);\n+        // TODO is this a bug?  Why is offer.state == available?\n+        assertEquals(AVAILABLE.name(), trade.getOffer().getState());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4MDAwMw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE0NTY5MA==", "bodyText": "Best remove the TODO but leave a comment if you feel it's warranted.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510145690", "createdAt": "2020-10-22T13:06:59Z", "author": {"login": "sqrrm"}, "path": "apitest/src/test/java/bisq/apitest/method/trade/TakeBuyBTCOfferTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.apitest.method.trade;\n+\n+import protobuf.PaymentAccount;\n+\n+import io.grpc.StatusRuntimeException;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+\n+import static bisq.apitest.config.BisqAppConfig.alicedaemon;\n+import static bisq.apitest.config.BisqAppConfig.bobdaemon;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_CONFIRMED;\n+import static bisq.core.trade.Trade.Phase.DEPOSIT_PUBLISHED;\n+import static bisq.core.trade.Trade.Phase.FIAT_SENT;\n+import static bisq.core.trade.Trade.Phase.PAYOUT_PUBLISHED;\n+import static bisq.core.trade.Trade.State.BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG;\n+import static bisq.core.trade.Trade.State.DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN;\n+import static bisq.core.trade.Trade.State.SELLER_PUBLISHED_DEPOSIT_TX;\n+import static bisq.core.trade.Trade.State.SELLER_SAW_ARRIVED_PAYOUT_TX_PUBLISHED_MSG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static protobuf.Offer.State.OFFER_FEE_PAID;\n+import static protobuf.OpenOffer.State.AVAILABLE;\n+\n+@Slf4j\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n+public class TakeBuyBTCOfferTest extends AbstractTradeTest {\n+\n+    // Alice is buyer, Bob is seller.\n+\n+    private static String tradeId;\n+\n+    private PaymentAccount alicesAccount;\n+    private PaymentAccount bobsAccount;\n+\n+    @BeforeEach\n+    public void init() {\n+        alicesAccount = getDefaultPerfectDummyPaymentAccount(alicedaemon);\n+        bobsAccount = getDefaultPerfectDummyPaymentAccount(bobdaemon);\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void testTakeAlicesBuyOffer() {\n+        try {\n+            var alicesOffer = createAliceOffer(alicesAccount, \"buy\", \"usd\", 12500000);\n+            var offerId = alicesOffer.getId();\n+\n+            // Wait for Alice's AddToOfferBook task.\n+            // Wait times vary;  my logs show >= 2 second delay.\n+            sleep(3000);\n+            assertEquals(1, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            var trade = takeAlicesOffer(offerId, bobsAccount.getId());\n+            assertNotNull(trade);\n+            assertEquals(offerId, trade.getTradeId());\n+            // Cache the trade id for the other tests.\n+            tradeId = trade.getTradeId();\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            assertEquals(0, getOpenOffersCount(aliceStubs, \"buy\", \"usd\"));\n+\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, SELLER_PUBLISHED_DEPOSIT_TX, DEPOSIT_PUBLISHED);\n+\n+            genBtcBlocksThenWait(1, 2250);\n+            trade = getTrade(bobdaemon, trade.getTradeId());\n+            verifyExpectedTradeStateAndPhase(trade, DEPOSIT_CONFIRMED_IN_BLOCK_CHAIN, DEPOSIT_CONFIRMED);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(2)\n+    public void testAlicesConfirmPaymentStarted() {\n+        try {\n+            var trade = getTrade(alicedaemon, tradeId);\n+            assertNotNull(trade);\n+\n+            confirmPaymentStarted(alicedaemon, trade.getTradeId());\n+            sleep(3000);\n+\n+            trade = getTrade(alicedaemon, tradeId);\n+            assertEquals(OFFER_FEE_PAID.name(), trade.getOffer().getState());\n+            verifyExpectedTradeStateAndPhase(trade, BUYER_SAW_ARRIVED_FIAT_PAYMENT_INITIATED_MSG, FIAT_SENT);\n+        } catch (StatusRuntimeException e) {\n+            fail(e);\n+        }\n+    }\n+\n+    @Disabled\n+    @Test\n+    @Order(3)\n+    public void testBobsConfirmPaymentReceived() {\n+        var trade = getTrade(bobdaemon, tradeId);\n+        assertNotNull(trade);\n+\n+        confirmPaymentReceived(bobdaemon, trade.getTradeId());\n+        sleep(3000);\n+\n+        trade = getTrade(bobdaemon, tradeId);\n+        // TODO is this a bug?  Why is offer.state == available?\n+        assertEquals(AVAILABLE.name(), trade.getOffer().getState());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4MDAwMw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTI2MTUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTozNjoxM1rOHmdZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzoxOToxNFrOHmhWjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4OTYwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            trade -> {\n          \n          \n            \n                                resultHandler.accept(trade);\n          \n          \n            \n                            },\n          \n          \n            \n                            resultHandler::accept,", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510089605", "createdAt": "2020-10-22T11:36:13Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzMjY4Nw==", "bodyText": "I will add this change to #4679 (the tip of the PR/branch chain).  OK?", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510132687", "createdAt": "2020-10-22T12:48:56Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4OTYwNQ=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NDM4MA==", "bodyText": "Resolved in commit 31a3119, for PR #4679", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510154380", "createdAt": "2020-10-22T13:19:14Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4OTYwNQ=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTI2NTM3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTozNzoyM1rOHmdcEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzoxNDozM1rOHmhJWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDI1Nw==", "bodyText": "I don't understand why this has to be split in two methods, plans for future PRs?", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510090257", "createdAt": "2020-10-22T11:37:23Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },\n+                errorMessage -> {\n+                    log.error(errorMessage);\n+                    throw new IllegalStateException(errorMessage);\n+                }\n+        );\n+    }\n+\n+\n+    Trade getTrade(String tradeId) {\n+        return getTradeWithId(tradeId);\n+    }\n+\n+    private Trade getTradeWithId(String tradeId) {\n+        return tradeManager.getTradeById(tradeId).orElseThrow(() ->\n+                new IllegalArgumentException(format(\"trade with id '%s' not found\", tradeId)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzNDU4OA==", "bodyText": "There's no need to split it, not sure why I did that.  I will change in #4679 (the tip of the PR/branch chain).", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510134588", "createdAt": "2020-10-22T12:51:35Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },\n+                errorMessage -> {\n+                    log.error(errorMessage);\n+                    throw new IllegalStateException(errorMessage);\n+                }\n+        );\n+    }\n+\n+\n+    Trade getTrade(String tradeId) {\n+        return getTradeWithId(tradeId);\n+    }\n+\n+    private Trade getTradeWithId(String tradeId) {\n+        return tradeManager.getTradeById(tradeId).orElseThrow(() ->\n+                new IllegalArgumentException(format(\"trade with id '%s' not found\", tradeId)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDI1Nw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1MTAwMw==", "bodyText": "Resolved in commit fa0e05a, PR #4679.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510151003", "createdAt": "2020-10-22T13:14:33Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/api/CoreTradesService.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * This file is part of Bisq.\n+ *\n+ * Bisq is free software: you can redistribute it and/or modify it\n+ * under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * Bisq is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public\n+ * License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with Bisq. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package bisq.core.api;\n+\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.takeoffer.TakeOfferModel;\n+import bisq.core.trade.Trade;\n+import bisq.core.trade.TradeManager;\n+import bisq.core.user.User;\n+\n+import javax.inject.Inject;\n+\n+import java.util.function.Consumer;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.lang.String.format;\n+\n+@Slf4j\n+class CoreTradesService {\n+\n+    private final TakeOfferModel takeOfferModel;\n+    private final TradeManager tradeManager;\n+    private final User user;\n+\n+    @Inject\n+    public CoreTradesService(TakeOfferModel takeOfferModel,\n+                             TradeManager tradeManager,\n+                             User user) {\n+        this.takeOfferModel = takeOfferModel;\n+        this.tradeManager = tradeManager;\n+        this.user = user;\n+    }\n+\n+    void takeOffer(Offer offer,\n+                   String paymentAccountId,\n+                   Consumer<Trade> resultHandler) {\n+        var paymentAccount = user.getPaymentAccount(paymentAccountId);\n+        if (paymentAccount == null)\n+            throw new IllegalArgumentException(format(\"payment account with id '%s' not found\", paymentAccountId));\n+\n+        var useSavingsWallet = true;\n+        takeOfferModel.initModel(offer, paymentAccount, useSavingsWallet);\n+        log.info(\"Initiating take {} offer, {}\",\n+                offer.isBuyOffer() ? \"buy\" : \"sell\",\n+                takeOfferModel);\n+        //noinspection ConstantConditions\n+        tradeManager.onTakeOffer(offer.getAmount(),\n+                takeOfferModel.getTxFeeFromFeeService(),\n+                takeOfferModel.getTakerFee(),\n+                takeOfferModel.isCurrencyForTakerFeeBtc(),\n+                offer.getPrice().getValue(),\n+                takeOfferModel.getFundsNeededForTrade(),\n+                offer,\n+                paymentAccountId,\n+                useSavingsWallet,\n+                trade -> {\n+                    resultHandler.accept(trade);\n+                },\n+                errorMessage -> {\n+                    log.error(errorMessage);\n+                    throw new IllegalStateException(errorMessage);\n+                }\n+        );\n+    }\n+\n+\n+    Trade getTrade(String tradeId) {\n+        return getTradeWithId(tradeId);\n+    }\n+\n+    private Trade getTradeWithId(String tradeId) {\n+        return tradeManager.getTradeById(tradeId).orElseThrow(() ->\n+                new IllegalArgumentException(format(\"trade with id '%s' not found\", tradeId)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDI1Nw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTM5NDQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMjoxMzo1MFrOHmer2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzo0MjozNFrOHmiaHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMDY4Mg==", "bodyText": "Is this really necessary for the api? We probably want to wait for the fee to be calculated properly as an atomic part of initModel.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510110682", "createdAt": "2020-10-22T12:13:50Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();\n+        offer.resetState();\n+\n+        priceFeedService.setCurrencyCode(offer.getCurrencyCode());\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        // empty\n+    }\n+\n+    private void calculateTxFees() {\n+        // Taker pays 3 times the tx fee (taker fee, deposit, payout) because the mining fee might be different when maker created the offer\n+        // and reserved his funds. Taker creates at least taker fee and deposit tx at nearly the same moment. Just the payout will\n+        // be later and still could lead to issues if the required fee changed a lot in the meantime. using RBF and/or\n+        // multiple batch-signed payout tx with different fees might be an option but RBF is not supported yet in BitcoinJ\n+        // and batched txs would add more complexity to the trade protocol.\n+\n+        // A typical trade fee tx has about 260 bytes (if one input). The trade txs has about 336-414 bytes.\n+        // We use 320 as a average value.\n+\n+        // trade fee tx: 260 bytes (1 input)\n+        // deposit tx: 336 bytes (1 MS output+ OP_RETURN) - 414 bytes (1 MS output + OP_RETURN + change in case of smaller trade amount)\n+        // payout tx: 371 bytes\n+        // disputed payout tx: 408 bytes\n+\n+        // Set the default values (in rare cases if the fee request was not done yet we get the hard coded default values)\n+        // But the \"take offer\" happens usually after that so we should have already the value from the estimation service.\n+        txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+        txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MTY3OA==", "bodyText": "Resolved by commit d463dd1, in PR #4679.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510171678", "createdAt": "2020-10-22T13:42:34Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();\n+        offer.resetState();\n+\n+        priceFeedService.setCurrencyCode(offer.getCurrencyCode());\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        // empty\n+    }\n+\n+    private void calculateTxFees() {\n+        // Taker pays 3 times the tx fee (taker fee, deposit, payout) because the mining fee might be different when maker created the offer\n+        // and reserved his funds. Taker creates at least taker fee and deposit tx at nearly the same moment. Just the payout will\n+        // be later and still could lead to issues if the required fee changed a lot in the meantime. using RBF and/or\n+        // multiple batch-signed payout tx with different fees might be an option but RBF is not supported yet in BitcoinJ\n+        // and batched txs would add more complexity to the trade protocol.\n+\n+        // A typical trade fee tx has about 260 bytes (if one input). The trade txs has about 336-414 bytes.\n+        // We use 320 as a average value.\n+\n+        // trade fee tx: 260 bytes (1 input)\n+        // deposit tx: 336 bytes (1 MS output+ OP_RETURN) - 414 bytes (1 MS output + OP_RETURN + change in case of smaller trade amount)\n+        // payout tx: 371 bytes\n+        // disputed payout tx: 408 bytes\n+\n+        // Set the default values (in rare cases if the fee request was not done yet we get the hard coded default values)\n+        // But the \"take offer\" happens usually after that so we should have already the value from the estimation service.\n+        txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+        txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMDY4Mg=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTM5ODU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMjoxNDo1N1rOHmeubA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzo0Mzo1MVrOHmid5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMTM0MA==", "bodyText": "Fees are calculated here, after getting the reply from feeService.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510111340", "createdAt": "2020-10-22T12:14:57Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();\n+        offer.resetState();\n+\n+        priceFeedService.setCurrencyCode(offer.getCurrencyCode());\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        // empty\n+    }\n+\n+    private void calculateTxFees() {\n+        // Taker pays 3 times the tx fee (taker fee, deposit, payout) because the mining fee might be different when maker created the offer\n+        // and reserved his funds. Taker creates at least taker fee and deposit tx at nearly the same moment. Just the payout will\n+        // be later and still could lead to issues if the required fee changed a lot in the meantime. using RBF and/or\n+        // multiple batch-signed payout tx with different fees might be an option but RBF is not supported yet in BitcoinJ\n+        // and batched txs would add more complexity to the trade protocol.\n+\n+        // A typical trade fee tx has about 260 bytes (if one input). The trade txs has about 336-414 bytes.\n+        // We use 320 as a average value.\n+\n+        // trade fee tx: 260 bytes (1 input)\n+        // deposit tx: 336 bytes (1 MS output+ OP_RETURN) - 414 bytes (1 MS output + OP_RETURN + change in case of smaller trade amount)\n+        // payout tx: 371 bytes\n+        // disputed payout tx: 408 bytes\n+\n+        // Set the default values (in rare cases if the fee request was not done yet we get the hard coded default values)\n+        // But the \"take offer\" happens usually after that so we should have already the value from the estimation service.\n+        txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+        txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);\n+\n+        // We request to get the actual estimated fee\n+        log.info(\"Start requestTxFee: txFeeFromFeeService={}\", txFeeFromFeeService);\n+        feeService.requestFees(() -> {\n+            txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+            txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);\n+            calculateTotalToPay();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MjY0NA==", "bodyText": "Resolved by commit d463dd1, in PR #4679.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510172644", "createdAt": "2020-10-22T13:43:51Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();\n+        offer.resetState();\n+\n+        priceFeedService.setCurrencyCode(offer.getCurrencyCode());\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        // empty\n+    }\n+\n+    private void calculateTxFees() {\n+        // Taker pays 3 times the tx fee (taker fee, deposit, payout) because the mining fee might be different when maker created the offer\n+        // and reserved his funds. Taker creates at least taker fee and deposit tx at nearly the same moment. Just the payout will\n+        // be later and still could lead to issues if the required fee changed a lot in the meantime. using RBF and/or\n+        // multiple batch-signed payout tx with different fees might be an option but RBF is not supported yet in BitcoinJ\n+        // and batched txs would add more complexity to the trade protocol.\n+\n+        // A typical trade fee tx has about 260 bytes (if one input). The trade txs has about 336-414 bytes.\n+        // We use 320 as a average value.\n+\n+        // trade fee tx: 260 bytes (1 input)\n+        // deposit tx: 336 bytes (1 MS output+ OP_RETURN) - 414 bytes (1 MS output + OP_RETURN + change in case of smaller trade amount)\n+        // payout tx: 371 bytes\n+        // disputed payout tx: 408 bytes\n+\n+        // Set the default values (in rare cases if the fee request was not done yet we get the hard coded default values)\n+        // But the \"take offer\" happens usually after that so we should have already the value from the estimation service.\n+        txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+        txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);\n+\n+        // We request to get the actual estimated fee\n+        log.info(\"Start requestTxFee: txFeeFromFeeService={}\", txFeeFromFeeService);\n+        feeService.requestFees(() -> {\n+            txFeePerByteFromFeeService = feeService.getTxFeePerByte();\n+            txFeeFromFeeService = offerUtil.getTxFeeBySize(txFeePerByteFromFeeService, feeTxSize);\n+            calculateTotalToPay();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMTM0MA=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTQwMDcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMjoxNToyNFrOHmevrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzo1Nzo0MlrOHmjH5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMTY2Mg==", "bodyText": "This is already done in calculateTxFees", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510111662", "createdAt": "2020-10-22T12:15:24Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MzM5OQ==", "bodyText": "Resolved by commit 1f3554e in PR #4679.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510183399", "createdAt": "2020-10-22T13:57:42Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,\n+                          BtcWalletService btcWalletService,\n+                          FeeService feeService,\n+                          OfferUtil offerUtil,\n+                          PriceFeedService priceFeedService) {\n+        this.accountAgeWitnessService = accountAgeWitnessService;\n+        this.btcWalletService = btcWalletService;\n+        this.feeService = feeService;\n+        this.offerUtil = offerUtil;\n+        this.priceFeedService = priceFeedService;\n+    }\n+\n+    public void initModel(Offer offer,\n+                          PaymentAccount paymentAccount,\n+                          boolean useSavingsWallet) {\n+        this.clearModel();\n+        this.offer = offer;\n+        this.paymentAccount = paymentAccount;\n+        this.addressEntry = btcWalletService.getOrCreateAddressEntry(offer.getId(), OFFER_FUNDING);\n+        validateModelInputs();\n+\n+        this.useSavingsWallet = useSavingsWallet;\n+        this.amount = valueOf(Math.min(offer.getAmount().value, getMaxTradeLimit()));\n+        this.securityDeposit = offer.getDirection() == SELL\n+                ? offer.getBuyerSecurityDeposit()\n+                : offer.getSellerSecurityDeposit();\n+        this.isCurrencyForTakerFeeBtc = offerUtil.isCurrencyForTakerFeeBtc(amount);\n+        this.takerFee = offerUtil.getTakerFee(isCurrencyForTakerFeeBtc, amount);\n+\n+        calculateTxFees();\n+        calculateVolume();\n+        calculateTotalToPay();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExMTY2Mg=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NTQ0NDM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMjoyNjozM1rOHmfLFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMzozMDo0MFrOHmh3pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExODY3Nw==", "bodyText": "There's a lot of code that would be nice to reuse from TakeOfferDataModel here. Can be done later though in some pure refactor commit.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510118677", "createdAt": "2020-10-22T12:26:33Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1Njk3MA==", "bodyText": "I mentioned that I wanted to move more from TakeOfferDataModel into core TakeOfferModel`, but I could not pass JFX property values into the new core model.   If you or @chimp1984 know how, do tell.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510156970", "createdAt": "2020-10-22T13:22:42Z", "author": {"login": "ghubstan"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExODY3Nw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2Mjg1NA==", "bodyText": "Don't think we want to have any jfx dependency in core, rather some stuff could probably be rewritten in TakeOfferDataModel to utilize the new class.", "url": "https://github.com/bisq-network/bisq/pull/4673#discussion_r510162854", "createdAt": "2020-10-22T13:30:40Z", "author": {"login": "sqrrm"}, "path": "core/src/main/java/bisq/core/offer/takeoffer/TakeOfferModel.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package bisq.core.offer.takeoffer;\n+\n+import bisq.core.account.witness.AccountAgeWitnessService;\n+import bisq.core.btc.model.AddressEntry;\n+import bisq.core.btc.wallet.BtcWalletService;\n+import bisq.core.locale.CurrencyUtil;\n+import bisq.core.monetary.Price;\n+import bisq.core.monetary.Volume;\n+import bisq.core.offer.Offer;\n+import bisq.core.offer.OfferUtil;\n+import bisq.core.payment.PaymentAccount;\n+import bisq.core.payment.payload.PaymentMethod;\n+import bisq.core.provider.fee.FeeService;\n+import bisq.core.provider.price.PriceFeedService;\n+\n+import bisq.common.taskrunner.Model;\n+\n+import org.bitcoinj.core.Coin;\n+\n+import javax.inject.Inject;\n+\n+import java.util.Objects;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import static bisq.core.btc.model.AddressEntry.Context.OFFER_FUNDING;\n+import static bisq.core.offer.OfferPayload.Direction.SELL;\n+import static bisq.core.util.VolumeUtil.getAdjustedVolumeForHalCash;\n+import static bisq.core.util.VolumeUtil.getRoundedFiatVolume;\n+import static bisq.core.util.coin.CoinUtil.minCoin;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static org.bitcoinj.core.Coin.ZERO;\n+import static org.bitcoinj.core.Coin.valueOf;\n+\n+@Slf4j\n+public class TakeOfferModel implements Model {\n+    // Immutable\n+    private final AccountAgeWitnessService accountAgeWitnessService;\n+    private final BtcWalletService btcWalletService;\n+    private final FeeService feeService;\n+    private final OfferUtil offerUtil;\n+    private final PriceFeedService priceFeedService;\n+\n+    // Mutable\n+    @Getter\n+    private AddressEntry addressEntry;\n+    @Getter\n+    private Coin amount;\n+    @Getter\n+    private boolean isCurrencyForTakerFeeBtc;\n+    private Offer offer;\n+    private PaymentAccount paymentAccount;\n+    @Getter\n+    private Coin securityDeposit;\n+    private boolean useSavingsWallet;\n+\n+    // 260 kb is typical trade fee tx size with 1 input, but trade tx (deposit + payout)\n+    // are larger so we adjust to 320.\n+    private final int feeTxSize = 320;\n+    private Coin txFeePerByteFromFeeService;\n+    @Getter\n+    private Coin txFeeFromFeeService;\n+    @Getter\n+    private Coin takerFee;\n+    @Getter\n+    private Coin totalToPayAsCoin;\n+    @Getter\n+    private Coin missingCoin = ZERO;\n+    @Getter\n+    private Coin totalAvailableBalance;\n+    @Getter\n+    private Coin balance;\n+    @Getter\n+    private boolean isBtcWalletFunded;\n+    @Getter\n+    private Volume volume;\n+\n+    @Inject\n+    public TakeOfferModel(AccountAgeWitnessService accountAgeWitnessService,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDExODY3Nw=="}, "originalCommit": {"oid": "e809af37ccea81b89b832d87be37827c00ac0a02"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2407, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}