{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4Nzg2ODQ2", "number": 740, "title": "Add PaginationEvaluator to simplify the pagination processing", "bodyText": "", "createdAt": "2020-01-02T20:38:50Z", "url": "https://github.com/Netflix/titus-control-plane/pull/740", "merged": true, "mergeCommit": {"oid": "665187fa171e2b032be3d942228a677de6170e35"}, "closed": true, "closedAt": "2020-01-03T18:28:21Z", "author": {"login": "tbak"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2fsluAH2gAyMzU4Nzg2ODQ2OjE4NmFlOWZiNjc0MDRkNzQ1MDY3MDUxYWE2ZGIzOTY5YjA5NTc2OGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb2zEKugFqTMzODIyMzc0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "186ae9fb67404d745067051aa6db3969b095768d", "author": {"user": {"login": "tbak", "name": null}}, "url": "https://github.com/Netflix/titus-control-plane/commit/186ae9fb67404d745067051aa6db3969b095768d", "committedDate": "2020-01-02T20:22:36Z", "message": "Add PaginationEvaluator to simplify the pagination processing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTI4MTg3", "url": "https://github.com/Netflix/titus-control-plane/pull/740#pullrequestreview-337928187", "createdAt": "2020-01-03T01:46:35Z", "commit": {"oid": "186ae9fb67404d745067051aa6db3969b095768d"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwMTo0NjozNVrOFZ4uiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwMTo0OTozOFrOFZ4vxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg==", "bodyText": "Do we validate somewhere that the user hasn't set pageSize to 0?", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688136", "createdAt": "2020-01-03T01:46:35Z", "author": {"login": "andrew-leung"}, "path": "titus-common-api/src/main/java/com/netflix/titus/api/model/PaginationEvaluator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.api.model;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.titus.common.util.CollectionsExt;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.tuple.Pair;\n+\n+public class PaginationEvaluator<T> {\n+\n+    private static final Pattern CURSOR_RE = Pattern.compile(\"(.*)@(\\\\d+)\");\n+\n+    private final Function<T, String> idExtractor;\n+    private final Function<T, Long> timestampExtractor;\n+\n+    private final Comparator<T> dataComparator;\n+\n+    public PaginationEvaluator(Function<T, String> idExtractor, Function<T, Long> timestampExtractor) {\n+        this.idExtractor = idExtractor;\n+        this.timestampExtractor = timestampExtractor;\n+\n+        this.dataComparator = (first, second) -> {\n+            long firstTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(first), 0L);\n+            long secondTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(second), 0L);\n+            int timestampCmp = Long.compare(firstTimestamp, secondTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String firstId = idExtractor.apply(first);\n+            String secondId = idExtractor.apply(second);\n+            return firstId.compareTo(secondId);\n+        };\n+    }\n+\n+    public PageResult<T> takePage(Page page, List<T> items) {\n+        List<T> itemsCopy = new ArrayList<>(items);\n+        itemsCopy.sort(dataComparator);\n+\n+        if (StringExt.isEmpty(page.getCursor())) {\n+            return takePageWithoutCursor(page, itemsCopy);\n+        }\n+\n+        Pair<String, Long> decodedCursor = decode(page.getCursor());\n+        return takePageWithCursor(page, itemsCopy, decodedCursor.getLeft(), decodedCursor.getRight());\n+    }\n+\n+    /**\n+     * {@link Page#getPageNumber() Number} (index) based pagination.\n+     * <p>\n+     * Please consider using {@link PaginationUtil#takePageWithCursor(Page, List, Comparator, PaginationUtil.CursorIndexOf, Function) cursor-based}\n+     * pagination instead. This mode will be deprecated soon.\n+     */\n+    private PageResult<T> takePageWithoutCursor(Page page, List<T> items) {\n+        int totalItems = items.size();\n+        if (totalItems <= 0 || page.getPageSize() <= 0) {\n+            return PageResult.pageOf(Collections.emptyList(), new Pagination(page, false, 0, 0, \"\", 0));\n+        }\n+\n+        int firstItem = page.getPageNumber() * page.getPageSize();\n+        int lastItem = Math.min(totalItems, firstItem + page.getPageSize());\n+        boolean more = totalItems > lastItem;\n+        int totalPages = numberOfPages(page, totalItems);\n+\n+        List<T> pageItems = firstItem < lastItem\n+                ? items.subList(firstItem, lastItem)\n+                : Collections.emptyList();\n+\n+        int cursorPosition = pageItems.isEmpty() ? 0 : lastItem - 1;\n+\n+        return PageResult.pageOf(pageItems, new Pagination(page, more, totalPages, totalItems, encode(pageItems.get(cursorPosition)), cursorPosition));\n+    }\n+\n+    private PageResult<T> takePageWithCursor(Page page, List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        int offset = getOffset(itemsCopy, cursorId, cursorTimestamp);\n+\n+        int totalItems = itemsCopy.size();\n+        boolean isEmptyResult = offset >= totalItems;\n+        boolean hasMore = totalItems > (offset + page.getPageSize());\n+        int endOffset = Math.min(totalItems, offset + page.getPageSize());\n+        int cursorPosition = endOffset - 1;\n+        int numberOfPages = numberOfPages(page, totalItems);\n+        int pageNumber = Math.min(numberOfPages, offset / page.getPageSize());\n+\n+        Pagination pagination = new Pagination(\n+                page.toBuilder().withPageNumber(pageNumber).build(),\n+                hasMore,\n+                numberOfPages,\n+                totalItems,\n+                totalItems == 0 ? \"\" : encode(itemsCopy.get(cursorPosition)),\n+                totalItems == 0 ? 0 : cursorPosition\n+        );\n+\n+        List<T> pageItems = isEmptyResult ? Collections.emptyList() : itemsCopy.subList(offset, endOffset);\n+        return PageResult.pageOf(pageItems, pagination);\n+    }\n+\n+    /**\n+     * Offset is a position of an element after the one pointed by the cursor. If cursor does not point to any\n+     * existing element, the offset points to the smallest element larger than cursor.\n+     */\n+    private int getOffset(List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        if (itemsCopy.isEmpty()) {\n+            return 0;\n+        }\n+\n+        Function<T, Integer> comparator = item -> {\n+            long itemTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(item), 0L);\n+            int timestampCmp = Long.compare(cursorTimestamp, itemTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String itemId = idExtractor.apply(item);\n+            return cursorId.compareTo(itemId);\n+        };\n+\n+        int pos = CollectionsExt.binarySearchLeftMost(itemsCopy, comparator);\n+        return pos >= 0 ? (pos + 1) : -(pos + 1);\n+    }\n+\n+    @VisibleForTesting\n+    String encode(T value) {\n+        String id = idExtractor.apply(value);\n+        long timeStamp = Evaluators.getOrDefault(timestampExtractor.apply(value), 0L);\n+        return Base64.getEncoder().encodeToString((id + '@' + timeStamp).getBytes());\n+    }\n+\n+    private static Pair<String, Long> decode(String encoded) {\n+        String decoded = new String(Base64.getDecoder().decode(encoded.getBytes()));\n+\n+        Matcher matcher = CURSOR_RE.matcher(decoded);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Not a valid cursor value: encoded=%s, decoded=%s\", encoded, decoded)\n+            );\n+        }\n+\n+        String jobId = matcher.group(1);\n+        long timestamp = Long.parseLong(matcher.group(2));\n+\n+        return Pair.of(jobId, timestamp);\n+    }\n+\n+    private static int numberOfPages(Page page, int totalItems) {\n+        return (totalItems + page.getPageSize() - 1) / page.getPageSize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "186ae9fb67404d745067051aa6db3969b095768d"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODQwMg==", "bodyText": "Also, I'm a little confused about the calculation here. If totalItems is 10 and pageSize is 4, I would expect there to be 3 pages. Seems like this would return 4.", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688402", "createdAt": "2020-01-03T01:49:08Z", "author": {"login": "andrew-leung"}, "path": "titus-common-api/src/main/java/com/netflix/titus/api/model/PaginationEvaluator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.api.model;\n+\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.titus.common.util.CollectionsExt;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.tuple.Pair;\n+\n+public class PaginationEvaluator<T> {\n+\n+    private static final Pattern CURSOR_RE = Pattern.compile(\"(.*)@(\\\\d+)\");\n+\n+    private final Function<T, String> idExtractor;\n+    private final Function<T, Long> timestampExtractor;\n+\n+    private final Comparator<T> dataComparator;\n+\n+    public PaginationEvaluator(Function<T, String> idExtractor, Function<T, Long> timestampExtractor) {\n+        this.idExtractor = idExtractor;\n+        this.timestampExtractor = timestampExtractor;\n+\n+        this.dataComparator = (first, second) -> {\n+            long firstTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(first), 0L);\n+            long secondTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(second), 0L);\n+            int timestampCmp = Long.compare(firstTimestamp, secondTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String firstId = idExtractor.apply(first);\n+            String secondId = idExtractor.apply(second);\n+            return firstId.compareTo(secondId);\n+        };\n+    }\n+\n+    public PageResult<T> takePage(Page page, List<T> items) {\n+        List<T> itemsCopy = new ArrayList<>(items);\n+        itemsCopy.sort(dataComparator);\n+\n+        if (StringExt.isEmpty(page.getCursor())) {\n+            return takePageWithoutCursor(page, itemsCopy);\n+        }\n+\n+        Pair<String, Long> decodedCursor = decode(page.getCursor());\n+        return takePageWithCursor(page, itemsCopy, decodedCursor.getLeft(), decodedCursor.getRight());\n+    }\n+\n+    /**\n+     * {@link Page#getPageNumber() Number} (index) based pagination.\n+     * <p>\n+     * Please consider using {@link PaginationUtil#takePageWithCursor(Page, List, Comparator, PaginationUtil.CursorIndexOf, Function) cursor-based}\n+     * pagination instead. This mode will be deprecated soon.\n+     */\n+    private PageResult<T> takePageWithoutCursor(Page page, List<T> items) {\n+        int totalItems = items.size();\n+        if (totalItems <= 0 || page.getPageSize() <= 0) {\n+            return PageResult.pageOf(Collections.emptyList(), new Pagination(page, false, 0, 0, \"\", 0));\n+        }\n+\n+        int firstItem = page.getPageNumber() * page.getPageSize();\n+        int lastItem = Math.min(totalItems, firstItem + page.getPageSize());\n+        boolean more = totalItems > lastItem;\n+        int totalPages = numberOfPages(page, totalItems);\n+\n+        List<T> pageItems = firstItem < lastItem\n+                ? items.subList(firstItem, lastItem)\n+                : Collections.emptyList();\n+\n+        int cursorPosition = pageItems.isEmpty() ? 0 : lastItem - 1;\n+\n+        return PageResult.pageOf(pageItems, new Pagination(page, more, totalPages, totalItems, encode(pageItems.get(cursorPosition)), cursorPosition));\n+    }\n+\n+    private PageResult<T> takePageWithCursor(Page page, List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        int offset = getOffset(itemsCopy, cursorId, cursorTimestamp);\n+\n+        int totalItems = itemsCopy.size();\n+        boolean isEmptyResult = offset >= totalItems;\n+        boolean hasMore = totalItems > (offset + page.getPageSize());\n+        int endOffset = Math.min(totalItems, offset + page.getPageSize());\n+        int cursorPosition = endOffset - 1;\n+        int numberOfPages = numberOfPages(page, totalItems);\n+        int pageNumber = Math.min(numberOfPages, offset / page.getPageSize());\n+\n+        Pagination pagination = new Pagination(\n+                page.toBuilder().withPageNumber(pageNumber).build(),\n+                hasMore,\n+                numberOfPages,\n+                totalItems,\n+                totalItems == 0 ? \"\" : encode(itemsCopy.get(cursorPosition)),\n+                totalItems == 0 ? 0 : cursorPosition\n+        );\n+\n+        List<T> pageItems = isEmptyResult ? Collections.emptyList() : itemsCopy.subList(offset, endOffset);\n+        return PageResult.pageOf(pageItems, pagination);\n+    }\n+\n+    /**\n+     * Offset is a position of an element after the one pointed by the cursor. If cursor does not point to any\n+     * existing element, the offset points to the smallest element larger than cursor.\n+     */\n+    private int getOffset(List<T> itemsCopy, String cursorId, long cursorTimestamp) {\n+        if (itemsCopy.isEmpty()) {\n+            return 0;\n+        }\n+\n+        Function<T, Integer> comparator = item -> {\n+            long itemTimestamp = Evaluators.getOrDefault(timestampExtractor.apply(item), 0L);\n+            int timestampCmp = Long.compare(cursorTimestamp, itemTimestamp);\n+            if (timestampCmp != 0) {\n+                return timestampCmp;\n+            }\n+\n+            String itemId = idExtractor.apply(item);\n+            return cursorId.compareTo(itemId);\n+        };\n+\n+        int pos = CollectionsExt.binarySearchLeftMost(itemsCopy, comparator);\n+        return pos >= 0 ? (pos + 1) : -(pos + 1);\n+    }\n+\n+    @VisibleForTesting\n+    String encode(T value) {\n+        String id = idExtractor.apply(value);\n+        long timeStamp = Evaluators.getOrDefault(timestampExtractor.apply(value), 0L);\n+        return Base64.getEncoder().encodeToString((id + '@' + timeStamp).getBytes());\n+    }\n+\n+    private static Pair<String, Long> decode(String encoded) {\n+        String decoded = new String(Base64.getDecoder().decode(encoded.getBytes()));\n+\n+        Matcher matcher = CURSOR_RE.matcher(decoded);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Not a valid cursor value: encoded=%s, decoded=%s\", encoded, decoded)\n+            );\n+        }\n+\n+        String jobId = matcher.group(1);\n+        long timestamp = Long.parseLong(matcher.group(2));\n+\n+        return Pair.of(jobId, timestamp);\n+    }\n+\n+    private static int numberOfPages(Page page, int totalItems) {\n+        return (totalItems + page.getPageSize() - 1) / page.getPageSize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODEzNg=="}, "originalCommit": {"oid": "186ae9fb67404d745067051aa6db3969b095768d"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjY4ODQ1Mw==", "bodyText": "2020?", "url": "https://github.com/Netflix/titus-control-plane/pull/740#discussion_r362688453", "createdAt": "2020-01-03T01:49:38Z", "author": {"login": "andrew-leung"}, "path": "titus-common-api/src/main/java/com/netflix/titus/api/model/PaginationEvaluator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "186ae9fb67404d745067051aa6db3969b095768d"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37c45fd2a871619c18a45eccdbb44e865d084e60", "author": {"user": {"login": "tbak", "name": null}}, "url": "https://github.com/Netflix/titus-control-plane/commit/37c45fd2a871619c18a45eccdbb44e865d084e60", "committedDate": "2020-01-03T04:38:19Z", "message": "Code review updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MjIzNzQy", "url": "https://github.com/Netflix/titus-control-plane/pull/740#pullrequestreview-338223742", "createdAt": "2020-01-03T18:56:33Z", "commit": {"oid": "37c45fd2a871619c18a45eccdbb44e865d084e60"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 599, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}