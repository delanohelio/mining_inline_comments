{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzI1ODQ4", "number": 868, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzo0NToxNlrOEEfqWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDozNjo0NlrOEEgOMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ4NTA3OnYy", "diffSide": "RIGHT", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzo0NToxNlrOGiJ2dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozNzowOVrOGinudw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA==", "bodyText": "please add some documentation here (and consider renaming the method) since now it will also always returns active tasks for the job. It seems to be handled correctly by the only current caller, but it may cause confusion in the future", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438466164", "createdAt": "2020-06-10T23:45:16Z", "author": {"login": "fabiokung"}, "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTYzOQ==", "bodyText": "Active state should never be read like that (all of it is read on startup). But technically you are right that we could read active data with this method. I will add a comment documenting this.", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955639", "createdAt": "2020-06-11T17:37:09Z", "author": {"login": "tbak"}, "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA=="}, "originalCommit": {"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTU3NjgwOnYy", "diffSide": "RIGHT", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDozNjo0NlrOGiKt_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNzozNzo0NlrOGinvoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw==", "bodyText": "Is the variable name correct? Seems like these could be active or archived depending on the statement provided.", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438480383", "createdAt": "2020-06-11T00:36:46Z", "author": {"login": "andrew-leung"}, "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {\n-        return Observable.fromCallable(() -> retrieveArchivedTaskIdsForJobStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n-                .flatMap(retrieveActiveTaskIdsForJob -> execute(retrieveActiveTaskIdsForJob).flatMap(taskIdsResultSet -> {\n-                    List<String> taskIds = taskIdsResultSet.all().stream().map(row -> row.getString(0)).collect(Collectors.toList());\n-                    List<Observable<ResultSet>> observables = taskIds.stream().map(retrieveArchivedTaskStatement::bind).map(this::execute).collect(Collectors.toList());\n-                    return Observable.merge(observables, getConcurrencyLimit()).flatMapIterable(tasksResultSet -> tasksResultSet.all().stream()\n-                            .map(row -> row.getString(0))\n-                            .map(value -> deserializeTask(value))\n-                            .collect(Collectors.toList()));\n-                }));\n+        return retrieveArchivedTasksForJob(jobId, retrieveArchivedTaskIdsForJobStatement, retrieveArchivedTaskStatement)\n+                .switchIfEmpty(retrieveArchivedTasksForJob(jobId, retrieveActiveTaskIdsForJobStatement, retrieveActiveTaskStatement));\n+    }\n+\n+    private Observable<Task> retrieveArchivedTasksForJob(String jobId, PreparedStatement taskIdStatement, PreparedStatement taskStatement) {\n+        return Observable.fromCallable(() -> taskIdStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n+                .flatMap(retrieveActiveTaskIdsForJob ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTkzNw==", "bodyText": "I will change this, and add a comment.", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955937", "createdAt": "2020-06-11T17:37:46Z", "author": {"login": "tbak"}, "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {\n-        return Observable.fromCallable(() -> retrieveArchivedTaskIdsForJobStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n-                .flatMap(retrieveActiveTaskIdsForJob -> execute(retrieveActiveTaskIdsForJob).flatMap(taskIdsResultSet -> {\n-                    List<String> taskIds = taskIdsResultSet.all().stream().map(row -> row.getString(0)).collect(Collectors.toList());\n-                    List<Observable<ResultSet>> observables = taskIds.stream().map(retrieveArchivedTaskStatement::bind).map(this::execute).collect(Collectors.toList());\n-                    return Observable.merge(observables, getConcurrencyLimit()).flatMapIterable(tasksResultSet -> tasksResultSet.all().stream()\n-                            .map(row -> row.getString(0))\n-                            .map(value -> deserializeTask(value))\n-                            .collect(Collectors.toList()));\n-                }));\n+        return retrieveArchivedTasksForJob(jobId, retrieveArchivedTaskIdsForJobStatement, retrieveArchivedTaskStatement)\n+                .switchIfEmpty(retrieveArchivedTasksForJob(jobId, retrieveActiveTaskIdsForJobStatement, retrieveActiveTaskStatement));\n+    }\n+\n+    private Observable<Task> retrieveArchivedTasksForJob(String jobId, PreparedStatement taskIdStatement, PreparedStatement taskStatement) {\n+        return Observable.fromCallable(() -> taskIdStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n+                .flatMap(retrieveActiveTaskIdsForJob ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw=="}, "originalCommit": {"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3975, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}