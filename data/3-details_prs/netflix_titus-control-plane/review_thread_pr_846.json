{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NTY1ODM1", "number": 846, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNDo0N1rOD8OKXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyNDoxMlrOD8OWlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDczMTgzOnYy", "diffSide": "RIGHT", "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/CallMetadataAuthentication.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNDo0N1rOGVB6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozNDozN1rOGVCiiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDU4Mw==", "bodyText": "what does an original Authentication object mean? Are you wanting to convey that it is a standard concept from the Spring framework?", "url": "https://github.com/Netflix/titus-control-plane/pull/846#discussion_r424704583", "createdAt": "2020-05-13T20:14:47Z", "author": {"login": "corindwyer"}, "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/CallMetadataAuthentication.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.runtime.endpoint.metadata.spring;\n+\n+import java.util.Collection;\n+\n+import com.netflix.titus.api.model.callmetadata.CallMetadata;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.GrantedAuthority;\n+\n+/**\n+ * A decorator for an original {@link Authentication} object, which adds resolved request {@link CallMetadata}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0899ae11985bf2299487136e05ef7d652dcb529d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNDg4OQ==", "bodyText": "I am referring here to the authenticated principal object that we are wrapping. Authentication interface is part of Spring security API.", "url": "https://github.com/Netflix/titus-control-plane/pull/846#discussion_r424714889", "createdAt": "2020-05-13T20:34:37Z", "author": {"login": "tbak"}, "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/CallMetadataAuthentication.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.runtime.endpoint.metadata.spring;\n+\n+import java.util.Collection;\n+\n+import com.netflix.titus.api.model.callmetadata.CallMetadata;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.GrantedAuthority;\n+\n+/**\n+ * A decorator for an original {@link Authentication} object, which adds resolved request {@link CallMetadata}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDU4Mw=="}, "originalCommit": {"oid": "0899ae11985bf2299487136e05ef7d652dcb529d"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDczOTQyOnYy", "diffSide": "RIGHT", "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/SpringCallMetadataInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNjo1OVrOGVB-5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoxNjo1OVrOGVB-5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNTc2Ng==", "bodyText": "could reuse httpServletRequest.getParameter(DEBUG_QUERY_PARAM)", "url": "https://github.com/Netflix/titus-control-plane/pull/846#discussion_r424705766", "createdAt": "2020-05-13T20:16:59Z", "author": {"login": "corindwyer"}, "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/SpringCallMetadataInterceptor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.runtime.endpoint.metadata.spring;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.netflix.titus.api.model.callmetadata.CallMetadata;\n+import com.netflix.titus.api.model.callmetadata.Caller;\n+import com.netflix.titus.api.model.callmetadata.CallerType;\n+import com.netflix.titus.runtime.endpoint.metadata.CallMetadataHeaders;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Spring interceptor to decorate a request {@link Authentication} object with {@link CallMetadata}.\n+ */\n+public class SpringCallMetadataInterceptor extends HandlerInterceptorAdapter {\n+\n+    private static final String DEBUG_QUERY_PARAM = \"debug\";\n+\n+    @Override\n+    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {\n+        String callReason = httpServletRequest.getHeader(CallMetadataHeaders.CALL_REASON_HEADER);\n+        boolean debug;\n+        if (httpServletRequest.getParameter(DEBUG_QUERY_PARAM) == null) {\n+            debug = Boolean.parseBoolean(httpServletRequest.getHeader(CallMetadataHeaders.DEBUG_HEADER));\n+        } else {\n+            debug = Boolean.parseBoolean(httpServletRequest.getParameter(DEBUG_QUERY_PARAM));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0899ae11985bf2299487136e05ef7d652dcb529d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc2MzA4OnYy", "diffSide": "RIGHT", "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/SpringCallMetadataInterceptor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyNDoxMlrOGVCNqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDo0MToyMVrOGVCvzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwOTU0Nw==", "bodyText": "could use httpServletRequest.isSecure() to switch between HTTP and HTTPS here.", "url": "https://github.com/Netflix/titus-control-plane/pull/846#discussion_r424709547", "createdAt": "2020-05-13T20:24:12Z", "author": {"login": "corindwyer"}, "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/SpringCallMetadataInterceptor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.runtime.endpoint.metadata.spring;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.netflix.titus.api.model.callmetadata.CallMetadata;\n+import com.netflix.titus.api.model.callmetadata.Caller;\n+import com.netflix.titus.api.model.callmetadata.CallerType;\n+import com.netflix.titus.runtime.endpoint.metadata.CallMetadataHeaders;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Spring interceptor to decorate a request {@link Authentication} object with {@link CallMetadata}.\n+ */\n+public class SpringCallMetadataInterceptor extends HandlerInterceptorAdapter {\n+\n+    private static final String DEBUG_QUERY_PARAM = \"debug\";\n+\n+    @Override\n+    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {\n+        String callReason = httpServletRequest.getHeader(CallMetadataHeaders.CALL_REASON_HEADER);\n+        boolean debug;\n+        if (httpServletRequest.getParameter(DEBUG_QUERY_PARAM) == null) {\n+            debug = Boolean.parseBoolean(httpServletRequest.getHeader(CallMetadataHeaders.DEBUG_HEADER));\n+        } else {\n+            debug = Boolean.parseBoolean(httpServletRequest.getParameter(DEBUG_QUERY_PARAM));\n+        }\n+\n+        String originalCallerId = httpServletRequest.getHeader(CallMetadataHeaders.CALLER_ID_HEADER);\n+        Authentication delegate = SecurityContextHolder.getContext().getAuthentication();\n+\n+        Caller directCaller = getDirectCaller(httpServletRequest, delegate);\n+\n+        CallMetadata.Builder callMetadataBuilder = CallMetadata.newBuilder()\n+                .withCallReason(callReason)\n+                .withDebug(debug);\n+\n+        if (originalCallerId == null) {\n+            callMetadataBuilder.withCallers(Collections.singletonList(directCaller));\n+        } else {\n+            CallerType originalCallerType = CallerType.parseCallerType(\n+                    originalCallerId,\n+                    httpServletRequest.getHeader(CallMetadataHeaders.CALLER_TYPE_HEADER)\n+            );\n+            Caller originalCaller = Caller.newBuilder()\n+                    .withId(originalCallerId)\n+                    .withCallerType(originalCallerType)\n+                    .build();\n+\n+            callMetadataBuilder.withCallers(asList(originalCaller, directCaller));\n+        }\n+\n+        CallMetadataAuthentication authentication = new CallMetadataAuthentication(callMetadataBuilder.build(), delegate);\n+        SecurityContextHolder.getContext().setAuthentication(authentication);\n+\n+        return super.preHandle(httpServletRequest, httpServletResponse, handler);\n+    }\n+\n+    protected Caller getDirectCaller(HttpServletRequest httpServletRequest, Authentication delegate) {\n+        // If there is an original caller, we know the direct caller must be an application.\n+        CallerType callerType = httpServletRequest.getHeader(CallMetadataHeaders.CALLER_ID_HEADER) == null\n+                ? CallerType.Unknown\n+                : CallerType.Application;\n+\n+        return Caller.newBuilder()\n+                .withId(delegate.getName())\n+                .withCallerType(callerType)\n+                .withContext(getContextFromServletRequest(httpServletRequest))\n+                .build();\n+    }\n+\n+    protected Map<String, String> getContextFromServletRequest(HttpServletRequest httpServletRequest) {\n+        Map<String, String> context = new HashMap<>();\n+\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_SERVICE_NAME, httpServletRequest.getRequestURI());\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_SERVICE_METHOD, httpServletRequest.getMethod());\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_TRANSPORT_TYPE, \"HTTP\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0899ae11985bf2299487136e05ef7d652dcb529d"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxODI4NA==", "bodyText": "Transport type is HTTP or GRPC. Plain/TLS distinction has separate attribute. This code is copy-pasted from the previous (jersey) implementation. I want to keep it the same for compatibility reason.", "url": "https://github.com/Netflix/titus-control-plane/pull/846#discussion_r424718284", "createdAt": "2020-05-13T20:41:21Z", "author": {"login": "tbak"}, "path": "titus-common-server/src/main/java/com/netflix/titus/runtime/endpoint/metadata/spring/SpringCallMetadataInterceptor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.runtime.endpoint.metadata.spring;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.netflix.titus.api.model.callmetadata.CallMetadata;\n+import com.netflix.titus.api.model.callmetadata.Caller;\n+import com.netflix.titus.api.model.callmetadata.CallerType;\n+import com.netflix.titus.runtime.endpoint.metadata.CallMetadataHeaders;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Spring interceptor to decorate a request {@link Authentication} object with {@link CallMetadata}.\n+ */\n+public class SpringCallMetadataInterceptor extends HandlerInterceptorAdapter {\n+\n+    private static final String DEBUG_QUERY_PARAM = \"debug\";\n+\n+    @Override\n+    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {\n+        String callReason = httpServletRequest.getHeader(CallMetadataHeaders.CALL_REASON_HEADER);\n+        boolean debug;\n+        if (httpServletRequest.getParameter(DEBUG_QUERY_PARAM) == null) {\n+            debug = Boolean.parseBoolean(httpServletRequest.getHeader(CallMetadataHeaders.DEBUG_HEADER));\n+        } else {\n+            debug = Boolean.parseBoolean(httpServletRequest.getParameter(DEBUG_QUERY_PARAM));\n+        }\n+\n+        String originalCallerId = httpServletRequest.getHeader(CallMetadataHeaders.CALLER_ID_HEADER);\n+        Authentication delegate = SecurityContextHolder.getContext().getAuthentication();\n+\n+        Caller directCaller = getDirectCaller(httpServletRequest, delegate);\n+\n+        CallMetadata.Builder callMetadataBuilder = CallMetadata.newBuilder()\n+                .withCallReason(callReason)\n+                .withDebug(debug);\n+\n+        if (originalCallerId == null) {\n+            callMetadataBuilder.withCallers(Collections.singletonList(directCaller));\n+        } else {\n+            CallerType originalCallerType = CallerType.parseCallerType(\n+                    originalCallerId,\n+                    httpServletRequest.getHeader(CallMetadataHeaders.CALLER_TYPE_HEADER)\n+            );\n+            Caller originalCaller = Caller.newBuilder()\n+                    .withId(originalCallerId)\n+                    .withCallerType(originalCallerType)\n+                    .build();\n+\n+            callMetadataBuilder.withCallers(asList(originalCaller, directCaller));\n+        }\n+\n+        CallMetadataAuthentication authentication = new CallMetadataAuthentication(callMetadataBuilder.build(), delegate);\n+        SecurityContextHolder.getContext().setAuthentication(authentication);\n+\n+        return super.preHandle(httpServletRequest, httpServletResponse, handler);\n+    }\n+\n+    protected Caller getDirectCaller(HttpServletRequest httpServletRequest, Authentication delegate) {\n+        // If there is an original caller, we know the direct caller must be an application.\n+        CallerType callerType = httpServletRequest.getHeader(CallMetadataHeaders.CALLER_ID_HEADER) == null\n+                ? CallerType.Unknown\n+                : CallerType.Application;\n+\n+        return Caller.newBuilder()\n+                .withId(delegate.getName())\n+                .withCallerType(callerType)\n+                .withContext(getContextFromServletRequest(httpServletRequest))\n+                .build();\n+    }\n+\n+    protected Map<String, String> getContextFromServletRequest(HttpServletRequest httpServletRequest) {\n+        Map<String, String> context = new HashMap<>();\n+\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_SERVICE_NAME, httpServletRequest.getRequestURI());\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_SERVICE_METHOD, httpServletRequest.getMethod());\n+        context.put(CallMetadataHeaders.DIRECT_CALLER_CONTEXT_TRANSPORT_TYPE, \"HTTP\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwOTU0Nw=="}, "originalCommit": {"oid": "0899ae11985bf2299487136e05ef7d652dcb529d"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3955, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}