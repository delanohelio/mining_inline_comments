{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MjMwOTM4", "number": 894, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDowOToxOVrOEWVxIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDowOToxOVrOEWVxIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODYwNzcwOnYy", "diffSide": "RIGHT", "path": "titus-server-runtime/src/main/java/com/netflix/titus/runtime/endpoint/admission/JobRuntimePredictionUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDowOToxOVrOG9mdjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDozMDozMFrOG9m-Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NjQ3Nw==", "bodyText": "minor: I'm always a bit worried about comparing floating point numbers with ==. Might be good to compare against a tiny epsilon range here to make it less brittle to floating point math in the future", "url": "https://github.com/Netflix/titus-control-plane/pull/894#discussion_r467246477", "createdAt": "2020-08-07T20:09:19Z", "author": {"login": "fabiokung"}, "path": "titus-server-runtime/src/main/java/com/netflix/titus/runtime/endpoint/admission/JobRuntimePredictionUtil.java", "diffHunk": "@@ -16,21 +16,31 @@\n \n package com.netflix.titus.runtime.endpoint.admission;\n \n+import java.util.Optional;\n+import java.util.SortedSet;\n+\n import com.netflix.titus.runtime.connector.prediction.JobRuntimePrediction;\n import org.apache.commons.math3.distribution.NormalDistribution;\n \n-final class JobRuntimePredictionUtil {\n+public final class JobRuntimePredictionUtil {\n \n     private static final double LOW_QUANTILE = 0.05;\n-    private static final double HIGH_QUANTILE = 0.95;\n+    public static final double HIGH_QUANTILE = 0.95;\n \n     static final double NORM_SIGMA = computeNormSigma();\n \n     private JobRuntimePredictionUtil() {\n     }\n \n-    static boolean expectedQuantiles(JobRuntimePrediction low, JobRuntimePrediction high) {\n-        return low.getConfidence() == LOW_QUANTILE && high.getConfidence() == HIGH_QUANTILE;\n+    static boolean expectedLowest(JobRuntimePrediction low) {\n+        return low.getConfidence() == LOW_QUANTILE;\n+    }\n+\n+    static Optional<JobRuntimePrediction> findRequested(SortedSet<JobRuntimePrediction> predictions, double quantile) {\n+        if (predictions.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        return predictions.stream().filter(p -> p.getConfidence() == quantile).findFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d047144aac221b8cc3b2bde78ac10ee1ce100a4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NDg2Nw==", "bodyText": "I agree in general. In this case however exact match is what we want, as we compare two configured values.", "url": "https://github.com/Netflix/titus-control-plane/pull/894#discussion_r467254867", "createdAt": "2020-08-07T20:30:30Z", "author": {"login": "tbak"}, "path": "titus-server-runtime/src/main/java/com/netflix/titus/runtime/endpoint/admission/JobRuntimePredictionUtil.java", "diffHunk": "@@ -16,21 +16,31 @@\n \n package com.netflix.titus.runtime.endpoint.admission;\n \n+import java.util.Optional;\n+import java.util.SortedSet;\n+\n import com.netflix.titus.runtime.connector.prediction.JobRuntimePrediction;\n import org.apache.commons.math3.distribution.NormalDistribution;\n \n-final class JobRuntimePredictionUtil {\n+public final class JobRuntimePredictionUtil {\n \n     private static final double LOW_QUANTILE = 0.05;\n-    private static final double HIGH_QUANTILE = 0.95;\n+    public static final double HIGH_QUANTILE = 0.95;\n \n     static final double NORM_SIGMA = computeNormSigma();\n \n     private JobRuntimePredictionUtil() {\n     }\n \n-    static boolean expectedQuantiles(JobRuntimePrediction low, JobRuntimePrediction high) {\n-        return low.getConfidence() == LOW_QUANTILE && high.getConfidence() == HIGH_QUANTILE;\n+    static boolean expectedLowest(JobRuntimePrediction low) {\n+        return low.getConfidence() == LOW_QUANTILE;\n+    }\n+\n+    static Optional<JobRuntimePrediction> findRequested(SortedSet<JobRuntimePrediction> predictions, double quantile) {\n+        if (predictions.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        return predictions.stream().filter(p -> p.getConfidence() == quantile).findFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI0NjQ3Nw=="}, "originalCommit": {"oid": "2d047144aac221b8cc3b2bde78ac10ee1ce100a4"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4000, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}