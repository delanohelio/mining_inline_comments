{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMjEyNzQz", "number": 961, "title": "Align KubeScheduler pod -> task state mapping with KubeApiServerIntegrator", "bodyText": "", "createdAt": "2020-12-02T18:38:45Z", "url": "https://github.com/Netflix/titus-control-plane/pull/961", "merged": true, "mergeCommit": {"oid": "bc8747660eb6c1e72031d69ffd30d375eacb9de4"}, "closed": true, "closedAt": "2020-12-02T19:30:48Z", "author": {"login": "tbak"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiS-zcgH2gAyNTMxMjEyNzQzOjI5Zjk0ZDE1Y2NlOTVkNmIzYmUwNDM2YTA1ZDY2NTlkZTU3MzVjNjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdiTv4EgFqTU0MzE3MDE3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67", "author": {"user": {"login": "tbak", "name": null}}, "url": "https://github.com/Netflix/titus-control-plane/commit/29f94d15cce95d6b3be0436a05d6659de5735c67", "committedDate": "2020-12-02T18:37:33Z", "message": "Align KubeScheduler pod -> task state mapping with KubeApiServerIntegrator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTU3NTk3", "url": "https://github.com/Netflix/titus-control-plane/pull/961#pullrequestreview-543157597", "createdAt": "2020-12-02T19:14:14Z", "commit": {"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOToxNDoxNFrOH9qRMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxOToyNzoyNFrOH9qvnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxNzcxNA==", "bodyText": "There is KubeUtil.getMetadataName.", "url": "https://github.com/Netflix/titus-control-plane/pull/961#discussion_r534417714", "createdAt": "2020-12-02T19:14:14Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/direct/model/PodWrapper.java", "diffHunk": "@@ -41,6 +43,10 @@ public V1Pod getV1Pod() {\n         return v1Pod;\n     }\n \n+    public String getName() {\n+        return v1Pod.getMetadata() == null ? \"\" : StringExt.nonNull(v1Pod.getMetadata().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTUwMA==", "bodyText": "I think we can use V1ContainerStateRunning.getStartedAt here in the future as these special reasons are going away.", "url": "https://github.com/Netflix/titus-control-plane/pull/961#discussion_r534425500", "createdAt": "2020-12-02T19:27:24Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/PodToTaskMapper.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.util.Optional;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.tuple.Either;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodPhase;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodWrapper;\n+import io.kubernetes.client.openapi.models.V1Node;\n+\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Finished;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.KillInitiated;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Launched;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.StartInitiated;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Started;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.isBefore;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_FAILED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_NORMAL;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_POD_SCHEDULED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_STUCK_IN_STATE;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_TASK_KILLED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_TRANSIENT_SYSTEM_ERROR;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_UNKNOWN;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LOST;\n+\n+/**\n+ * Evaluates pod phase, pod condition and container state to determine best fitting Titus task state.\n+ */\n+public class PodToTaskMapper {\n+\n+    @VisibleForTesting\n+    static final String TASK_STARTING = \"TASK_STARTING\";\n+\n+    private final PodWrapper podWrapper;\n+    private final Optional<V1Node> node;\n+    private final Task task;\n+    private final ContainerResultCodeResolver containerResultCodeResolver;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final Either<TaskStatus, String> newTaskStatus;\n+\n+    public PodToTaskMapper(PodWrapper podWrapper,\n+                           Optional<V1Node> node,\n+                           Task task,\n+                           boolean podDeleted,\n+                           ContainerResultCodeResolver containerResultCodeResolver,\n+                           TitusRuntime titusRuntime) {\n+        this.podWrapper = podWrapper;\n+        this.node = node;\n+        this.task = task;\n+        this.containerResultCodeResolver = containerResultCodeResolver;\n+        this.titusRuntime = titusRuntime;\n+\n+        if (TaskState.isTerminalState(task.getStatus().getState())) {\n+            this.newTaskStatus = irrelevant(\"task already marked as finished\");\n+        } else if (podDeleted) {\n+            this.newTaskStatus = handlePodDeleted();\n+        } else {\n+            switch (podWrapper.getPodPhase()) {\n+                case PENDING:\n+                    this.newTaskStatus = handlePodPending();\n+                    break;\n+                case RUNNING:\n+                    this.newTaskStatus = handlePodRunning();\n+                    break;\n+                case SUCCEEDED:\n+                case FAILED:\n+                    this.newTaskStatus = handlePodFinished();\n+                    break;\n+                case UNKNOWN:\n+                default:\n+                    this.newTaskStatus = unexpected(\"unknown pod phase\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle pod object deleted event.\n+     */\n+    private Either<TaskStatus, String> handlePodDeleted() {\n+        TaskState taskState = task.getStatus().getState();\n+        boolean hasKillInitiatedState = JobFunctions.findTaskStatus(task, KillInitiated).isPresent();\n+        String reason = podWrapper.getReason();\n+        long now = titusRuntime.getClock().wallTime();\n+\n+        if (!hasKillInitiatedState) {\n+            if (NODE_LOST.equals(reason)) {\n+                return Either.ofValue(TaskStatus.newBuilder()\n+                        .withState(Finished)\n+                        .withReasonCode(effectiveFinalReasonCode(REASON_TASK_KILLED))\n+                        .withReasonMessage(\"The host running the container was unexpectedly terminated\")\n+                        .withTimestamp(now)\n+                        .build()\n+                );\n+            } else {\n+                return Either.ofValue(TaskStatus.newBuilder()\n+                        .withState(Finished)\n+                        .withReasonCode(effectiveFinalReasonCode(REASON_TASK_KILLED))\n+                        .withReasonMessage(\"Container was terminated without going through the Titus API\")\n+                        .withTimestamp(now)\n+                        .build()\n+                );\n+            }\n+        }\n+\n+        String reasonCode;\n+        if (podWrapper.getPodPhase() == PodPhase.PENDING || podWrapper.getPodPhase() == PodPhase.RUNNING) {\n+            // Pod in pending phase which is being deleted must have been terminated, as it was never run.\n+            // Pod in running state that did not complete must have been terminated as well.\n+            if (taskState == KillInitiated && task.getStatus().getReasonCode().equals(REASON_STUCK_IN_STATE)) {\n+                reasonCode = REASON_TRANSIENT_SYSTEM_ERROR;\n+            } else {\n+                reasonCode = REASON_TASK_KILLED;\n+            }\n+        } else if (podWrapper.getPodPhase() == PodPhase.SUCCEEDED) {\n+            if (taskState == KillInitiated && task.getStatus().getReasonCode().equals(REASON_STUCK_IN_STATE)) {\n+                reasonCode = REASON_TRANSIENT_SYSTEM_ERROR;\n+            } else {\n+                if (podWrapper.hasDeletionTimestamp() || taskState == KillInitiated) {\n+                    reasonCode = REASON_TASK_KILLED;\n+                } else {\n+                    reasonCode = REASON_NORMAL;\n+                }\n+            }\n+        } else if (podWrapper.getPodPhase() == PodPhase.FAILED) {\n+            reasonCode = REASON_FAILED;\n+        } else {\n+            titusRuntime.getCodeInvariants().inconsistent(\"Pod: %s has unknown phase mapping: %s\", podWrapper.getName(), podWrapper.getPodPhase());\n+            reasonCode = REASON_UNKNOWN;\n+        }\n+\n+        return Either.ofValue(TaskStatus.newBuilder()\n+                .withState(Finished)\n+                .withReasonCode(effectiveFinalReasonCode(reasonCode))\n+                .withReasonMessage(\"Container was terminated without going through the Titus API\")\n+                .withTimestamp(now)\n+                .build()\n+        );\n+    }\n+\n+    /**\n+     * Handle pod 'Pending' phase. In this phase we have to distinguish cases:\n+     * <ul>\n+     *     <li>pod is waiting in the queue</li>\n+     *     <li>pod is assigned to a node but not running yet</li>\n+     * </ul>\n+     */\n+    private Either<TaskStatus, String> handlePodPending() {\n+        if (!podWrapper.isScheduled()) {\n+            return handlePodPendingQueued();\n+        }\n+        return handlePodPendingInitializingInContainerWaitingState(podWrapper);\n+    }\n+\n+    /**\n+     * Handle pod is waiting in the queue (is not scheduled yet). This event does not cause any task state\n+     * transition. We only verify consistency.\n+     */\n+    private Either<TaskStatus, String> handlePodPendingQueued() {\n+        if (task.getStatus().getState() != TaskState.Accepted) {\n+            return unexpected(\"expected queued task in the Accepted state\");\n+        }\n+        return irrelevant(\"pod is waiting in the queue to be scheduled\");\n+    }\n+\n+    /**\n+     * Handle pod is assigned to a node but not running yet. The following pre-conditions must exist:\n+     * <ul>\n+     *     <li>pod condition 'PodScheduled' is set</li>\n+     *     <li>nodeName is not empty</li>\n+     * </ul>\n+     * Based on container state and reason message the state is classified as 'Launched' or 'StartInitiated':\n+     * <ul>\n+     *     <li>if reason != 'TASK_STARTING' set 'Launched'</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTcwMTcx", "url": "https://github.com/Netflix/titus-control-plane/pull/961#pullrequestreview-543170171", "createdAt": "2020-12-02T19:31:09Z", "commit": {"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 477, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}