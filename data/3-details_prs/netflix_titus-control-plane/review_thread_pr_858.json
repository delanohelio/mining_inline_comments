{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3OTgxMzQ4", "number": 858, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozMDoxNVrOECqWLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozNDo1M1rOECqcuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjI2NDEzOnYy", "diffSide": "LEFT", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeApiServerIntegrator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozMDoxNVrOGfQaSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozOTozOVrOGfQwmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyNzkxMg==", "bodyText": "Do we depend on GC process here to do the cleanup?", "url": "https://github.com/Netflix/titus-control-plane/pull/858#discussion_r435427912", "createdAt": "2020-06-04T17:30:15Z", "author": {"login": "tbak"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeApiServerIntegrator.java", "diffHunk": "@@ -329,18 +329,10 @@ public void onDelete(V1Node node, boolean deletedFinalStateUnknown) {\n \n     private void nodeUpdated(V1Node node) {\n         try {\n-            boolean removeStopped = node.getStatus().getConditions().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b728837de9f9b1a4acbddf14e0fdd2c6f9fbf8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzMzYyNA==", "bodyText": "Yes.", "url": "https://github.com/Netflix/titus-control-plane/pull/858#discussion_r435433624", "createdAt": "2020-06-04T17:39:39Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeApiServerIntegrator.java", "diffHunk": "@@ -329,18 +329,10 @@ public void onDelete(V1Node node, boolean deletedFinalStateUnknown) {\n \n     private void nodeUpdated(V1Node node) {\n         try {\n-            boolean removeStopped = node.getStatus().getConditions().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyNzkxMg=="}, "originalCommit": {"oid": "4b728837de9f9b1a4acbddf14e0fdd2c6f9fbf8e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjI4MDg4OnYy", "diffSide": "RIGHT", "path": "titus-server-master/src/main/java/com/netflix/titus/master/scheduler/constraint/KubeConstraint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozNDo1M1rOGfQlLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzo0NjozNVrOGfRAog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzMDcwMg==", "bodyText": "What if node is not there? We should check for null at least + double check that an exception is not thrown if a node is missing or due to other problems.", "url": "https://github.com/Netflix/titus-control-plane/pull/858#discussion_r435430702", "createdAt": "2020-06-04T17:34:53Z", "author": {"login": "tbak"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/scheduler/constraint/KubeConstraint.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2018 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.scheduler.constraint;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.fenzo.TaskRequest;\n+import com.netflix.fenzo.TaskTrackerState;\n+import com.netflix.fenzo.VirtualMachineCurrentState;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import com.netflix.titus.master.scheduler.SchedulerConfiguration;\n+import com.netflix.titus.master.scheduler.SchedulerUtils;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import io.kubernetes.client.openapi.models.V1Taint;\n+\n+/**\n+ * A system constraint that prevents launching a task on Kubernetes nodes based on conditions and taints.\n+ */\n+@Singleton\n+public class KubeConstraint implements SystemConstraint {\n+\n+    public static final String NAME = \"KubeConstraint\";\n+    public static final String INSTANCE_NOT_FOUND_REASON = \"Instance for node not found\";\n+    public static final String NOT_NOT_READY_REASON = \"Node's ready node condition is not true\";\n+    public static final String TAINT_NOT_TOLERATED_IN_CONFIGURATION_REASON = \"Node has a taint that is not configured to be tolerated\";\n+    public static final String READY = \"Ready\";\n+\n+    private static final Result VALID = new Result(true, null);\n+\n+    private enum Failure {\n+        INSTANCE_NOT_FOUND(INSTANCE_NOT_FOUND_REASON),\n+        NODE_NOT_READY(NOT_NOT_READY_REASON),\n+        TAINT_NOT_TOLERATED_IN_CONFIGURATION(TAINT_NOT_TOLERATED_IN_CONFIGURATION_REASON);\n+\n+        private final Result result;\n+\n+        Failure(String reason) {\n+            this.result = new Result(false, reason);\n+        }\n+\n+        public Result toResult() {\n+            return result;\n+        }\n+    }\n+\n+    private static final Set<String> FAILURE_REASONS = Stream.of(KubeConstraint.Failure.values())\n+            .map(f -> f.toResult().getFailureReason())\n+            .collect(Collectors.toSet());\n+\n+    public static boolean isKubeConstraintReason(String reason) {\n+        return reason != null && FAILURE_REASONS.contains(reason);\n+    }\n+\n+    private final SchedulerConfiguration schedulerConfiguration;\n+    private final MesosConfiguration mesosConfiguration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+\n+\n+    @Inject\n+    public KubeConstraint(SchedulerConfiguration schedulerConfiguration,\n+                          MesosConfiguration mesosConfiguration,\n+                          AgentManagementService agentManagementService,\n+                          KubeApiFacade kubeApiFacade) {\n+        this.schedulerConfiguration = schedulerConfiguration;\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public void prepare() {\n+    }\n+\n+    @Override\n+    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {\n+        if (!mesosConfiguration.isKubeApiServerIntegrationEnabled()) {\n+            return VALID;\n+        }\n+\n+        Optional<AgentInstance> instanceOpt = SchedulerUtils.findInstance(agentManagementService, schedulerConfiguration.getInstanceAttributeName(), targetVM);\n+        if (!instanceOpt.isPresent()) {\n+            return Failure.INSTANCE_NOT_FOUND.toResult();\n+        }\n+\n+        String instanceId = instanceOpt.get().getId();\n+        V1Node node = kubeApiFacade.getNodeInformer().getIndexer().getByKey(instanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b728837de9f9b1a4acbddf14e0fdd2c6f9fbf8e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNzczMA==", "bodyText": "good catch. updated", "url": "https://github.com/Netflix/titus-control-plane/pull/858#discussion_r435437730", "createdAt": "2020-06-04T17:46:35Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/scheduler/constraint/KubeConstraint.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2018 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.scheduler.constraint;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.fenzo.TaskRequest;\n+import com.netflix.fenzo.TaskTrackerState;\n+import com.netflix.fenzo.VirtualMachineCurrentState;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import com.netflix.titus.master.scheduler.SchedulerConfiguration;\n+import com.netflix.titus.master.scheduler.SchedulerUtils;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import io.kubernetes.client.openapi.models.V1Taint;\n+\n+/**\n+ * A system constraint that prevents launching a task on Kubernetes nodes based on conditions and taints.\n+ */\n+@Singleton\n+public class KubeConstraint implements SystemConstraint {\n+\n+    public static final String NAME = \"KubeConstraint\";\n+    public static final String INSTANCE_NOT_FOUND_REASON = \"Instance for node not found\";\n+    public static final String NOT_NOT_READY_REASON = \"Node's ready node condition is not true\";\n+    public static final String TAINT_NOT_TOLERATED_IN_CONFIGURATION_REASON = \"Node has a taint that is not configured to be tolerated\";\n+    public static final String READY = \"Ready\";\n+\n+    private static final Result VALID = new Result(true, null);\n+\n+    private enum Failure {\n+        INSTANCE_NOT_FOUND(INSTANCE_NOT_FOUND_REASON),\n+        NODE_NOT_READY(NOT_NOT_READY_REASON),\n+        TAINT_NOT_TOLERATED_IN_CONFIGURATION(TAINT_NOT_TOLERATED_IN_CONFIGURATION_REASON);\n+\n+        private final Result result;\n+\n+        Failure(String reason) {\n+            this.result = new Result(false, reason);\n+        }\n+\n+        public Result toResult() {\n+            return result;\n+        }\n+    }\n+\n+    private static final Set<String> FAILURE_REASONS = Stream.of(KubeConstraint.Failure.values())\n+            .map(f -> f.toResult().getFailureReason())\n+            .collect(Collectors.toSet());\n+\n+    public static boolean isKubeConstraintReason(String reason) {\n+        return reason != null && FAILURE_REASONS.contains(reason);\n+    }\n+\n+    private final SchedulerConfiguration schedulerConfiguration;\n+    private final MesosConfiguration mesosConfiguration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+\n+\n+    @Inject\n+    public KubeConstraint(SchedulerConfiguration schedulerConfiguration,\n+                          MesosConfiguration mesosConfiguration,\n+                          AgentManagementService agentManagementService,\n+                          KubeApiFacade kubeApiFacade) {\n+        this.schedulerConfiguration = schedulerConfiguration;\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public void prepare() {\n+    }\n+\n+    @Override\n+    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {\n+        if (!mesosConfiguration.isKubeApiServerIntegrationEnabled()) {\n+            return VALID;\n+        }\n+\n+        Optional<AgentInstance> instanceOpt = SchedulerUtils.findInstance(agentManagementService, schedulerConfiguration.getInstanceAttributeName(), targetVM);\n+        if (!instanceOpt.isPresent()) {\n+            return Failure.INSTANCE_NOT_FOUND.toResult();\n+        }\n+\n+        String instanceId = instanceOpt.get().getId();\n+        V1Node node = kubeApiFacade.getNodeInformer().getIndexer().getByKey(instanceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzMDcwMg=="}, "originalCommit": {"oid": "4b728837de9f9b1a4acbddf14e0fdd2c6f9fbf8e"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3967, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}